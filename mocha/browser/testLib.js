(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var io = {}

io.worker = new Worker(window.URL.createObjectURL(new Blob([';(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module \'"+n+"\'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){\nself.window = ""\n\nvar channelTransport = require(\'ndn-messageChannelTransport\')\n  , io = require("./ndn-io.js");\n\nvar fetchResponder = function(uri, success, thingOrObj, firstCo) {\n  if (success == true) {\n    self.postMessage({responseTo: "fetch", success: true, uri: uri, thing: thingOrObj, firstCo: firstCo})\n  } else {\n    self.postMessage({responseTo: "fetch", success: false, uri: uri});\n  }\n}\n\nonmessage = function(e){\n  console.log(e.data)\n  if (e.data.cert){\n    io.importPKI(e.data.cert,  e.data.priPem, e.data.pubPem)\n  } else if (e.data.command) {\n    if (e.data.command == "fetch") {\n      io.fetch(e.data, fetchResponder)\n    } else if (e.data.command == "publish") {\n      io.publish(e.data)\n    } else if (e.data.command == "mirror") {    \n      io.mirror(e.data.uri)\n    } else if (e.data.command == "makeEncoded"){\n      io.makeEncoded(e.data, function(id, encoded) {self.postMessage({responseTo: "makeEncoded", id: id, encoded: encoded})})\n    } else if (e.data.command == "getHashName") {\n      self.postMessage({\n        responseTo: "getHashName",\n        hashName: io.getHashname()\n      })\n    } else if (e.data.command == "tangle") {\n      function ack() {\n        self.postMessage({\n          responseTo: "tangle",\n          success: true\n        })\n      }\n      if (e.data.transport == "local"){\n        io.initFace(channelTransport, e.ports[0], ack)\n      } else if (e.data.transport == "websocket"){\n        io.initFace("websocket", {host: e.data.host, port: e.data.port}, ack)\n      }\n    }\n\n  }\n}\n\n\n\n\n\n},{"./ndn-io.js":2,"ndn-messageChannelTransport":3}],2:[function(require,module,exports){\nvar io = {}\n  , ndn = require("ndn-lib")\n  , utils = require(\'ndn-utils\')\n\n\nvar keyManager = function() {\n\n  this.certificate = null\n  this.publicKey = null\n  this.privateKey = null\n\n  this.key = null;\n};\nkeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new ndn.Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n\n  return this.key;\n}\n\nndn.globalKeyMangager =  new keyManager()\n\nio.initFace = function(transportClass, portStreamOrWebSocket, ack){\n  if (transportClass == "websocket"){\n    io.face = new ndn.Face({host:portStreamOrWebSocket.host, port: portStreamOrWebSocket.port})\n  } else {\n    io.face = new ndn.Face({host:1,port:1,getTransport: function(){return new transportClass.transport(portStreamOrWebSocket)}})\n  }\n  io.face.transport.connect(io.face, function(){ack()})\n}\n\nio.importPKI = function(cert, priPem, pubPem) {\n  ndn.globalKeyManager.certificate = e.data.cert\n  ndn.globalKeyManager.publicKey = e.data.pubPem\n  ndn.globalKeyManager.privateKey = e.data.priPem\n}\n\nio.getHashname = function() {\n  return ndn.globalKeyManager.getKey().publicKeyDigest.toString(\'hex\');\n}\n\nio.mirror = function(uri){\n    var onTimeout = function (interest) {\n      console.log("timeout", interest);\n    };\n    var onData = function(data) {\n      console.log(data)\n    };\n    //console.log(name.toUri())\n    var command = new ndn.Name(uri)\n    command.append(new ndn.Name.Component([0xc1, 0x2e, 0x52, 0x2e, 0x73, 0x77]))\n    var interest = new ndn.Interest(command)\n    interest.interestLifetime = 4000\n    utils.setNonce(interest)\n    //console.log("did this time correctly?", command.toUri())\n    io.face.expressInterest(interest, onData, onTimeout);\n}\n\nio.makeEncoded = function(data, responder) {\n  var d = new ndn.Data(new ndn.Name(data.uri), new ndn.SignedInfo(), data.bytes)\n  d.signedInfo.setFields()\n  d.sign()\n  var encoded = d.encode()\n  responder(data.id, encoded)\n  \n}\nio.fetch = function(opts, responder) {\n  console.log(opts)\n  var interestsInFlight = 0;\n  var windowSize = 4;\n  var t0 = new Date().getTime()\n  var segmentRequested = [];\n  var whenNotGottenTriggered = false\n\n  var name = new ndn.Name(opts.uri).appendSegment(0)\n\n  if (opts.version) {\n    utils.appendVersion(name, opts.version);\n  }\n\n\n  var contentArray = [];\n\n  var recievedSegments = 0;\n\n  segmentRequested[interestsInFlight] = 0;\n\n  var masterInterest = new ndn.Interest(name)\n\n\n  if (opts.selectors != undefined) {\n    if (opts.selectors.publisherPublicKeyDigest != undefined) {\n      masterInterest.publisherPublicKeyDigest = new ndn.PublisherPublicKeyDigest(opts.selectors.publisherPublicKeyDigest);\n    }\n    if (opts.selectors.exclude != undefined) {\n      var comps = []\n      for (var i = 0; i < opts.selectors.exclude.length; i++) {\n        comps[i] = new ndn.Name.Component(opts.selectors.exclude[i])\n      }\n      masterInterest.exclude = new ndn.Exclude(comps)\n    }\n    if (opts.selectors.interestLifetime != undefined) {\n      masterInterest.interestLifetime = opts.selectors.interestLifetime;\n    } else {\n      masterInterest.interestLifetime = 4000;\n    }\n\n  } else {\n    masterInterest.interestLifetime = 4000;\n  }\n\n  var interest = new ndn.Interest(masterInterest);\n\n  var firstCo;\n  var onData = function(interest, co) {\n    interestsInFlight--;\n    console.log(interest)\n\n    var segmentNumber = utils.getSegmentInteger(co.name)\n    if (segmentNumber == 0) {\n      firstCo = co\n    }\n    var finalSegmentNumber = 1 + ndn.DataUtils.bigEndianToUnsignedInt(co.signedInfo.finalBlockID);\n    //console.log(segmentNumber, co.name.toUri());\n    if (contentArray[segmentNumber] == undefined) {\n      if (opts.type == \'object\') {\n        contentArray[segmentNumber] = (ndn.DataUtils.toString(co.content));\n      } else if (opts.type == \'blob\' || \'file\'){\n        contentArray[segmentNumber] = co.content;\n      }\n\n      recievedSegments++;\n    }\n\n    //console.log(recievedSegments, finalSegmentNumber, interestsInFlight);\n    if (recievedSegments == finalSegmentNumber) {\n        console.log(\'got all segment\', contentArray.length);\n        var t1 = new Date().getTime()\n        console.log(t1 - t0)\n        if (opts.type == "object") {\n          assembleObject(name);\n        } else if (opts.type == "blob" || "file") {\n          assembleBlob(name)\n        };\n\n    } else {\n      if (interestsInFlight < windowSize) {\n        for (var i = 0; i < finalSegmentNumber; i++) {\n          if ((contentArray[i] == undefined) && (segmentRequested[i] == undefined)) {\n            var newInterest = new ndn.Interest(masterInterest)\n            newInterest.name = new ndn.Name(co.name.getPrefix(-1).appendSegment(i))\n            utils.setNonce(newInterest)\n            io.face.expressInterest(newInterest, onData, onTimeout)\n            segmentRequested[i] = 0;\n            interestsInFlight++\n            if (interestsInFlight == windowSize) {\n              //stop iterating\n              i = finalSegmentNumber;\n            };\n          };\n        };\n      };\n    };\n  };\n  var onTimeout = function(interest) {\n    var seg = utils.getSegmentInteger(interest.name)\n    if (segmentRequested[seg] < 4) {\n      segmentRequested[seg]++\n      var newInterest = new ndn.Interest(interest);\n      utils.setNonce(newInterest)\n      io.face.expressInterest(newInterest, onData, onTimeout)\n\n    } else if ((whenNotGottenTriggered == false)) {\n      whenNotGottenTriggered = true;\n      console.log(segmentRequested)\n      responder(opts.uri, false)\n    }\n  };\n\n  var assembleBlob = function(name) {\n    var mime = name.components[2].toEscapedString() + \'/\' + name.components[3].toEscapedString()\n    var blob = new Blob(contentArray, {type: mime})\n    responder(opts.uri, true, blob, firstCo)\n  };\n\n  var assembleObject = function(name) {\n    var string = "";\n    for (var i = 0; i < contentArray.length; i++) {\n      string += contentArray[i];\n    };\n    var obj = JSON.parse(string);\n    responder(opts.uri, true, obj, firstCo)\n  };\n\n  \n\n  //console.log(interest.name.toUri())\n\n  io.face.expressInterest(interest, onData, onTimeout);\n\n\n};\n\nio.publishFile = function(opts) {\n  //console.log( opts.thing)\n  var chunkSize = 7000,\n      fileSize = (opts.thing.size - 1),\n      totalSegments = Math.ceil(opts.thing.size / chunkSize),\n      name = new ndn.Name(opts.uri)\n\n\n  function getSlice(file, segment, transport) {\n    //console.log(file)\n    var fr = new FileReader(),\n        chunks = totalSegments,\n        start = segment * chunkSize,\n        end = start + chunkSize >= file.size ? file.size : start + chunkSize,\n        blob = file.slice(start,end);\n\n    fr.onloadend = function(e) {\n      var buff = new ndn.ndnbuf(e.target.result),\n          segmentName = (new ndn.Name(name)).appendSegment(segment),\n          data = new ndn.Data(segmentName, new ndn.SignedInfo(), buff),\n          encodedData;\n\n        data.signedInfo.setFields();\n        data.signedInfo.finalBlockID = utils.initSegment(totalSegments - 1);\n        data.sign();\n        encodedData = data.encode();\n\n        transport.send(encodedData);\n        var ms = new MessageChannel()\n        ms.port1.postMessage(e.target.result, [e.target.result])\n        //ms.port1.postMessage(buff.buffer, [buff.buffer])\n        if (segment == totalSegments -1) {\n          //remove closure from registeredPrefixTable\n          for (var i = 0; i < ndn.Face.registeredPrefixTable.length; i++) {\n            if (ndn.Face.registeredPrefixTable[i].prefix.match(new ndn.Name(name))) {\n              ndn.Face.registeredPrefixTable.splice(i,1);\n            }\n          }\n        }\n    };\n    //console.log("about to read as array buffer")\n    fr.readAsArrayBuffer(blob, (end - start))\n\n\n  };\n  //console.log(\'y u crashing?\')\n  function onInterest(prefix, interest, transport) {\n    //console.log("onInterest called.", opts);\n    if (!utils.endsWithSegmentNumber(interest.name)) {\n      interest.name.appendSegment(0);\n    };\n    var segment = ndn.DataUtils.bigEndianToUnsignedInt(interest.name.components[interest.name.components.length - 1].value);\n\n    getSlice(opts.thing, segment, transport)\n\n  };\n  //console.log(\'when u crashing?\')\n  function sendWriteCommand() {\n    var onTimeout = function (interest) {\n      console.log("timeout", interest);\n    };\n    var onData = function(data) {\n      console.log(data)\n    };\n    //console.log(name.toUri())\n    var command = name.getPrefix(- 1).append(new ndn.Name.Component([0xc1, 0x2e, 0x52, 0x2e, 0x73, 0x77])).append(utils.getSuffix(name, name.components.length - 1 ))\n    var interest = new ndn.Interest(command)\n    interest.interestLifetime = 4000\n    utils.setNonce(interest)\n    //console.log("did this time correctly?", command.toUri())\n    io.face.expressInterest(interest, onData, onTimeout);\n\n  };\n  var prefix = name\n  //console.log(name.toUri())\n  var closure = new ndn.Face.CallbackClosure(null, null, onInterest, prefix, io.face.transport);\n  ndn.Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n  console.log("publish defined")\n  setTimeout(sendWriteCommand, 0)\n\n};\n\nio.publishObject = function(opts) {\n  var returns = utils.chunkArbitraryData(opts)\n  var name = returns.name\n  var ndnArray = returns.array\n\n  var onInterest = function(prefix, interest, transport) {\n    var requestedSegment = utils.getSegmentInteger(interest.name)\n    console.log("got object interest", interest)\n    transport.send(ndnArray[requestedSegment])\n  };\n  var prefix = name\n\n  function sendWriteCommand() {\n    var onTimeout = function (interest) {\n      console.log("timeout", interest);\n    };\n    var onData = function(data) {\n      console.log(data)\n    };\n    var closure = new ndn.Face.CallbackClosure(null, null, onInterest, prefix, self.face.transport);\n    ndn.Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n    var command = name.getPrefix(- 1).append(new ndn.Name.Component([0xc1, 0x2e, 0x52, 0x2e, 0x73, 0x77])).append(utils.getSuffix(name, name.components.length - 1 ))\n    var interest = new ndn.Interest(command)\n    utils.setNonce(interest)\n    //console.log("did this time correctly?", command.toUri())\n    io.face.expressInterest(interest, onData, onTimeout);\n\n  };\n  setTimeout(sendWriteCommand, 0)\n};\n\nio.publish = function (opts) {\n  if (opts.type== "object") {\n    io.publishObject(opts)\n  } else if (opts.type == "file" || "blob" ) {\n    io.publishFile(opts)\n  }\n}\n\nfunction cb() {\n  var keyName = new ndn.Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\')\n  var inst = new ndn.Interest(keyName)\n\n}\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n\nmodule.exports = io;\n\n},{"ndn-lib":4,"ndn-utils":5}],3:[function(require,module,exports){\nvar ndn = require(\'ndn-lib\');\nvar ElementReader = ndn.ElementReader;\nvar ndnbuf = ndn.customBuffer;\nvar Name = ndn.Name\nvar Data = ndn.Data\nvar local = {}\n\nlocal.transport = function (port) {\n  this.port = port\n};\n\nconsole.log(ndnbuf)\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nlocal.transport.prototype.connect = function(face, onopenCallback)\n{\n  console.log(ndn, ElementReader)\n  this.elementReader = new ElementReader(face);\n  var self = this;\n  this.port.onmessage = function(ev) {\n    console.log(\'RecvHandle called on local face\', ev);\n\n    if (ev.data == null || ev.data == undefined || ev.data == "") {\n      console.log(\'INVALID ANSWER\');\n    }\n    else if (ev.data instanceof ArrayBuffer) {\n      var bytearray = new ndnbuf(ev.data);\n\n\n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n      // garbage collect arraybuffer\n      //var ms = new MessageChannel()\n      //ms.port1.postMessage(ev.data, [ev.data])\n    }\n  };\n\n  onopenCallback();\n\n};\n\n/**\n * Send the Uint8Array data.\n */\nlocal.transport.prototype.send = function(data)\n{\n  if (true) {\n        // If we directly use data.buffer to feed ws.send(),\n        // WebSocket may end up sending a packet with 10000 bytes of data.\n        // That is, WebSocket will flush the entire buffer\n        // regardless of the offset of the Uint8Array. So we have to create\n        // a new Uint8Array buffer with just the right size and copy the\n        // content from binaryInterest to the new buffer.\n        //    ---Wentao\n        var bytearray = new Uint8Array(data.length);\n        bytearray.set(data);\n        this.port.postMessage(bytearray.buffer);\n\n        //garbage collect\n        //var ms = new MessageChannel();\n        //ms.port1.postMessage(bytearray.buffer, [bytearray.buffer])\n        //ms.port1.postMessage(data.buffer, [data.buffer])\n    console.log(\'local.send() returned.\');\n  }\n  else\n    console.log(\'local connection is not established.\');\n};\n\nmodule.exports = local;\n\n},{"ndn-lib":6}],4:[function(require,module,exports){\n(function(){exports.Face = require(\'./js/face.js\').Face;\nexports.NDN = require(\'./js/face.js\').NDN; // deprecated\nexports.Closure = require(\'./js/closure.js\').Closure;\nexports.Name = require(\'./js/name.js\').Name;\nexports.ForwardingFlags = require(\'./js/forwarding-flags.js\').ForwardingFlags;\nexports.Interest = require(\'./js/interest.js\').Interest;\nexports.Exclude = require(\'./js/exclude.js\').Exclude;\nexports.Data = require(\'./js/data.js\').Data;\nexports.ContentObject = require(\'./js/data.js\').ContentObject; // deprecated\nexports.ContentType = require(\'./js/meta-info.js\').ContentType;\nexports.MetaInfo = require(\'./js/meta-info.js\').MetaInfo;\nexports.SignedInfo = require(\'./js/meta-info.js\').SignedInfo; // deprecated\nexports.Key = require(\'./js/key.js\').Key;\nexports.KeyLocator = require(\'./js/key-locator.js\').KeyLocator;\nexports.KeyName = require(\'./js/key-locator.js\').KeyName;\nexports.KeyLocatorType = require(\'./js/key-locator.js\').KeyLocatorType;\nexports.PublisherPublicKeyDigest = require(\'./js/publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nexports.WireFormat = require(\'./js/encoding/wire-format.js\').WireFormat;\nexports.BinaryXmlWireFormat = require(\'./js/encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nexports.TlvWireFormat = require(\'./js/encoding/tlv-wire-format.js\').TlvWireFormat;\nexports.DataUtils = require(\'./js/encoding/data-utils.js\').DataUtils;\nexports.EncodingUtils = require(\'./js/encoding/encoding-utils.js\').EncodingUtils;\nexports.Blob = require(\'./js/util/blob.js\').Blob;\nexports.NameEnumeration = require(\'./js/util/name-enumeration.js\').NameEnumeration;\nexports.NDNTime = require(\'./js/util/ndn-time.js\').NDNTime;\nexports.globalKeyManager = require(\'./js/security/key-manager.js\').globalKeyManager;\nexports.ElementReader = require(\'./js/encoding/element-reader.js\').ElementReader;\nexports.customBuffer = require(\'./js/browserify.js\').Buffer\n\n})()\n},{"./js/browserify.js":28,"./js/closure.js":8,"./js/data.js":13,"./js/encoding/binary-xml-wire-format.js":19,"./js/encoding/data-utils.js":21,"./js/encoding/element-reader.js":27,"./js/encoding/encoding-utils.js":22,"./js/encoding/tlv-wire-format.js":20,"./js/encoding/wire-format.js":18,"./js/exclude.js":12,"./js/face.js":7,"./js/forwarding-flags.js":10,"./js/interest.js":11,"./js/key-locator.js":16,"./js/key.js":15,"./js/meta-info.js":14,"./js/name.js":9,"./js/publisher-public-key-digest.js":17,"./js/security/key-manager.js":26,"./js/util/blob.js":23,"./js/util/name-enumeration.js":24,"./js/util/ndn-time.js":25}],8:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Provide the callback closure for the async communication methods in the Face class.\n * This is a port of Closure.py from PyNDN, written by: \n * Derek Kulinski <takeda@takeda.tk>\n * Jeff Burke <jburke@ucla.edu>\n */\n\n/**\n * A subclass of Closure is passed to expressInterest and registerPrefix.\n * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.\n * @constructor\n */\nvar Closure = function Closure() \n{\n  // I don\'t think storing Face\'s closure is needed\n  // and it creates a reference loop, as of now both\n  // of those variables are never set -- Derek\n  //\n  // Use instance variables to return data to callback\n  this.ndn_data = null;  // this holds the ndn_closure\n  this.ndn_data_dirty = false; \n};\n\nexports.Closure = Closure;\n\n// Upcall result\nClosure.RESULT_ERR               = -1; // upcall detected an error\nClosure.RESULT_OK                =  0; // normal upcall return\nClosure.RESULT_REEXPRESS         =  1; // reexpress the same interest again\nClosure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest\nClosure.RESULT_VERIFY            =  3; // force an unverified result to be verified\nClosure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest\n                                       //   with the key available in the local storage\n\n// Upcall kind\nClosure.UPCALL_FINAL              = 0; // handler is about to be deregistered\nClosure.UPCALL_INTEREST           = 1; // incoming interest\nClosure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered\nClosure.UPCALL_CONTENT            = 3; // incoming verified content\nClosure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out\nClosure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified\nClosure.UPCALL_CONTENT_BAD        = 6; // verification failed\n\n/**\n * Override this in your subclass.\n * If you\'re getting strange errors in upcall()\n * check your code whether you\'re returning a value.\n */\nClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  //dump(\'upcall \' + this + " " + kind + " " + upcallInfo + "\\n");\n  return Closure.RESULT_OK;\n};\n\n/**\n * An UpcallInfo is passed to Closure.upcall.\n * @constructor\n */\nvar UpcallInfo = function UpcallInfo(face, interest, matchedComps, data) \n{\n  this.face = face;  // Face object (not used)\n  this.ndn = face;   // deprecated\n  this.interest = interest;  // Interest object\n  this.matchedComps = matchedComps;  // int\n  this.data = data;  // Data\n  this.contentObject = data; // deprecated.  Include for backward compatibility.\n};\n\nUpcallInfo.prototype.toString = function() \n{\n  var ret = "face = " + this.face;\n  ret += "\\nInterest = " + this.interest;\n  ret += "\\nmatchedComps = " + this.matchedComps;\n  ret += "\\nData: " + this.data;\n  return ret;\n};\n\nexports.UpcallInfo = UpcallInfo;\n\n},{}],6:[function(require,module,exports){\n(function(){exports.Face = require(\'./js/face.js\').Face;\nexports.NDN = require(\'./js/face.js\').NDN; // deprecated\nexports.Closure = require(\'./js/closure.js\').Closure;\nexports.Name = require(\'./js/name.js\').Name;\nexports.ForwardingFlags = require(\'./js/forwarding-flags.js\').ForwardingFlags;\nexports.Interest = require(\'./js/interest.js\').Interest;\nexports.Exclude = require(\'./js/exclude.js\').Exclude;\nexports.Data = require(\'./js/data.js\').Data;\nexports.ContentObject = require(\'./js/data.js\').ContentObject; // deprecated\nexports.ContentType = require(\'./js/meta-info.js\').ContentType;\nexports.MetaInfo = require(\'./js/meta-info.js\').MetaInfo;\nexports.SignedInfo = require(\'./js/meta-info.js\').SignedInfo; // deprecated\nexports.Key = require(\'./js/key.js\').Key;\nexports.KeyLocator = require(\'./js/key-locator.js\').KeyLocator;\nexports.KeyName = require(\'./js/key-locator.js\').KeyName;\nexports.KeyLocatorType = require(\'./js/key-locator.js\').KeyLocatorType;\nexports.PublisherPublicKeyDigest = require(\'./js/publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nexports.WireFormat = require(\'./js/encoding/wire-format.js\').WireFormat;\nexports.BinaryXmlWireFormat = require(\'./js/encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nexports.TlvWireFormat = require(\'./js/encoding/tlv-wire-format.js\').TlvWireFormat;\nexports.DataUtils = require(\'./js/encoding/data-utils.js\').DataUtils;\nexports.EncodingUtils = require(\'./js/encoding/encoding-utils.js\').EncodingUtils;\nexports.Blob = require(\'./js/util/blob.js\').Blob;\nexports.NameEnumeration = require(\'./js/util/name-enumeration.js\').NameEnumeration;\nexports.NDNTime = require(\'./js/util/ndn-time.js\').NDNTime;\nexports.globalKeyManager = require(\'./js/security/key-manager.js\').globalKeyManager;\nexports.ElementReader = require(\'./js/encoding/element-reader.js\').ElementReader;\nexports.customBuffer = require(\'./js/browserify.js\').Buffer\n\n})()\n},{"./js/browserify.js":50,"./js/closure.js":30,"./js/data.js":35,"./js/encoding/binary-xml-wire-format.js":41,"./js/encoding/data-utils.js":43,"./js/encoding/element-reader.js":49,"./js/encoding/encoding-utils.js":44,"./js/encoding/tlv-wire-format.js":42,"./js/encoding/wire-format.js":40,"./js/exclude.js":34,"./js/face.js":29,"./js/forwarding-flags.js":33,"./js/interest.js":32,"./js/key-locator.js":38,"./js/key.js":37,"./js/meta-info.js":36,"./js/name.js":31,"./js/publisher-public-key-digest.js":39,"./js/security/key-manager.js":48,"./js/util/blob.js":45,"./js/util/name-enumeration.js":46,"./js/util/ndn-time.js":47}],7:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang\n * See COPYING for copyright and distribution information.\n * This class represents the top-level object for communicating with an NDN host.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar crypto = require(\'./crypto.js\');\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Interest = require(\'./interest.js\').Interest;\nvar Data = require(\'./data.js\').Data;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\nvar TlvWireFormat = require(\'./encoding/tlv-wire-format.js\').TlvWireFormat;\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nvar Tlv = require(\'./encoding/tlv/tlv.js\').Tlv;\nvar TlvDecoder = require(\'./encoding/tlv/tlv-decoder.js\').TlvDecoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Key = require(\'./key.js\').Key;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar ForwardingFlags = require(\'./forwarding-flags.js\').ForwardingFlags;\nvar Closure = require(\'./closure.js\').Closure;\nvar UpcallInfo = require(\'./closure.js\').UpcallInfo;\nvar TcpTransport = require(\'./transport/tcp-transport.js\').TcpTransport;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Face with the given settings.\n * This throws an exception if Face.supported is false.\n * @constructor\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.\n *              OR function() { return new TcpTransport(); },       // If in Node.js.\n *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.\n *   host: null, // If null, use getHostAndPort when connecting.\n *   port: 9696, // If in the browser.\n *      OR 6363, // If in Node.js.\n *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },\n *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },\n *   verify: false // If false, don\'t verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.\n * }\n */\nvar Face = function Face(settings) \n{\n  if (!Face.supported)\n    throw new Error("The necessary JavaScript support is not available on this platform.");\n    \n  settings = (settings || {});\n  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.\n  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });\n  this.transport = getTransport();\n  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);\n  this.host = (settings.host !== undefined ? settings.host : null);\n  this.port = (settings.port || (typeof WebSocketTransport != \'undefined\' ? 9696 : 6363));\n  this.readyStatus = Face.UNOPEN;\n  this.verify = (settings.verify !== undefined ? settings.verify : false);\n  // Event handler\n  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });\n  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });\n  this.ndndid = null;\n};\n\nexports.Face = Face;\n\nFace.UNOPEN = 0;  // created but not opened yet\nFace.OPENED = 1;  // connection to ndnd opened\nFace.CLOSED = 2;  // connection to ndnd closed\n\n/**\n * Return true if necessary JavaScript support is available, else log an error and return false.\n */\nFace.getSupported = function() \n{\n  try {\n    var dummy = new customBuf(1).slice(0, 1);\n  } \n  catch (ex) {\n    console.log("NDN not available: customBuf not supported. " + ex);\n    return false;\n  }\n    \n  return true;\n};\n\nFace.supported = Face.getSupported();\n\nFace.ndndIdFetcher = new Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\');\n\nFace.prototype.createRoute = function(host, port) \n{\n  this.host=host;\n  this.port=port;\n};\n\nFace.KeyStore = new Array();\n\nvar KeyStoreEntry = function KeyStoreEntry(name, rsa, time) \n{\n  this.keyName = name;  // KeyName\n  this.rsaKey = rsa;    // RSA key\n  this.timeStamp = time;  // Time Stamp\n};\n\nFace.addKeyEntry = function(/* KeyStoreEntry */ keyEntry) \n{\n  var result = Face.getKeyByName(keyEntry.keyName);\n  if (result == null) \n    Face.KeyStore.push(keyEntry);\n  else\n    result = keyEntry;\n};\n\nFace.getKeyByName = function(/* KeyName */ name) \n{\n  var result = null;\n  \n  for (var i = 0; i < Face.KeyStore.length; i++) {\n    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {\n      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)\n        result = Face.KeyStore[i];\n    }\n  }\n    \n  return result;\n};\n\nFace.prototype.close = function() \n{\n  if (this.readyStatus != Face.OPENED)\n    throw new Error(\'Cannot close because Face connection is not opened.\');\n\n  this.readyStatus = Face.CLOSED;\n  this.transport.close();\n};\n\n// For fetching data\nFace.PITTable = new Array();\n\n/**\n * @constructor\n */\nvar PITEntry = function PITEntry(interest, closure) \n{\n  this.interest = interest;  // Interest\n  this.closure = closure;    // Closure\n  this.timerID = -1;  // Timer ID\n};\n\n/**\n * Return the entry from Face.PITTable where the name conforms to the interest selectors, and\n * the interest name is the longest that matches name.\n */\n\n/**\n * Find all entries from Face.PITTable where the name conforms to the entry\'s \n * interest selectors, remove the entries from the table, cancel their timeout\n * timers and return them.\n * @param {Name} name The name to find the interest for (from the incoming data\n * packet).\n * @returns {Array<PITEntry>} The matching entries from Face.PITTable, or [] if \n * none are found.\n */\nFace.extractEntriesForExpressedInterest = function(name) \n{\n  var result = [];\n    \n  // Go backwards through the list so we can erase entries.\n  for (var i = Face.PITTable.length - 1; i >= 0; --i) {\n    var entry = Face.PITTable[i];\n    if (entry.interest.matchesName(name)) {\n      // Cancel the timeout timer.\n      clearTimeout(entry.timerID);\n\n      result.push(entry);\n      Face.PITTable.splice(i, 1);\n    }\n  }\n\n  return result;\n};\n\n// For publishing data\nFace.registeredPrefixTable = new Array();\n\n/**\n * @constructor\n */\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure) \n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n/**\n * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.\n * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).\n * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.\n */\nfunction getEntryForRegisteredPrefix(name) \n{\n  var iResult = -1;\n  \n  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {\n    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " , Face.registeredPrefixTable[i].prefix , " matches " , name);\n    if (Face.registeredPrefixTable[i].prefix.match(name)) {\n      if (iResult < 0 || \n          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())\n        // Update to the longer match.\n        iResult = i;\n    }\n  }\n  \n  if (iResult >= 0)\n    return Face.registeredPrefixTable[iResult];\n  else\n    return null;\n}\n\n/**\n * Return a function that selects a host at random from hostList and returns { host: host, port: port }.\n * If no more hosts remain, return null.\n */\nFace.makeShuffledGetHostAndPort = function(hostList, port) \n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n      \n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n/**\n * Send the interest through the transport, read the entire response and call onData. \n * If the interest times out according to interest lifetime, call onTimeout (if not omitted).\n * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):\n * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from\n * a name and optional interest template:\n * expressInterest(name [, template], onData [, onTimeout]).\n * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.\n * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.\n * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:\n *   interest is the interest given to expressInterest,\n *   data is the received Data object.\n * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime, \n *   this calls onTimeout(interest) where:\n *   interest is the interest given to expressInterest.\n * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).\n * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest. \n * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).\n */\nFace.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4) \n{\n  // There are several overloaded versions of expressInterest, each shown inline below.\n\n  // expressInterest(Name name, Closure closure);                      // deprecated\n  // expressInterest(Name name, Closure closure,   Interest template); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.expressInterestWithClosure(interestOrName, arg2, arg3);\n    else\n      this.expressInterestWithClosure(interestOrName, arg2);\n    return;\n  }\n  \n  var interest;\n  var onData;\n  var onTimeout;\n  // expressInterest(Interest interest, function onData);\n  // expressInterest(Interest interest, function onData, function onTimeout);\n  if (typeof interestOrName == \'object\' && interestOrName instanceof Interest) {\n    // Just use a copy of the interest.\n    interest = new Interest(interestOrName);\n    onData = arg2;\n    onTimeout = (arg3 ? arg3 : function() {});\n  }\n  else {\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    // expressInterest(Name name, Interest template, function onData); \n    // expressInterest(Name name, Interest template, function onData, function onTimeout); \n    if (arg2 && typeof arg2 == \'object\' && arg2 instanceof Interest) {\n      var template = arg2;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n\n      onData = arg3;\n      onTimeout = (arg4 ? arg4 : function() {});\n    }\n    // expressInterest(Name name, function onData); \n    // expressInterest(Name name, function onData,   function onTimeout); \n    else {\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n      onData = arg2;\n      onTimeout = (arg3 ? arg3 : function() {});\n    }\n  }\n  \n  // Make a Closure from the callbacks so we can use expressInterestWithClosure.\n  // TODO: Convert the PIT to use callbacks, not a closure.\n  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout));\n}\n\nFace.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {\n  // Inherit from Closure.\n  Closure.call(this);\n  \n  this.onData = onData;\n  this.onTimeout = onTimeout;\n  this.onInterest = onInterest;\n  this.prefix = prefix;\n  this.transport = transport;\n};\n\nFace.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {\n  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)\n    this.onData(upcallInfo.interest, upcallInfo.data);\n  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)\n    this.onTimeout(upcallInfo.interest);\n  else if (kind == Closure.UPCALL_INTEREST)\n    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.\n    this.onInterest(this.prefix, upcallInfo.interest, this.transport)\n  \n  return Closure.RESULT_OK;\n};\n\n/**\n * A private method to encode name as an Interest and send the it to host:port, read the entire response and call\n * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),\n *                 new UpcallInfo(this, interest, 0, data)). \n * @deprecated Use expressInterest with callback functions, not Closure.\n * @param {Name} name Encode name as an Interest using the template (if supplied).\n * @param {Closure} closure\n * @param {Interest} template If not null, use its attributes.\n */\nFace.prototype.expressInterestWithClosure = function(name, closure, template) \n{\n  var interest = new Interest(name);\n  if (template != null) {\n    interest.minSuffixComponents = template.minSuffixComponents;\n    interest.maxSuffixComponents = template.maxSuffixComponents;\n    interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n    interest.exclude = template.exclude;\n    interest.childSelector = template.childSelector;\n    interest.answerOriginKind = template.answerOriginKind;\n    interest.scope = template.scope;\n    interest.interestLifetime = template.interestLifetime;\n  }\n  else\n    interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n  \n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else {\n      var thisNDN = this;\n      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });\n    }\n  }\n  else\n    this.reconnectAndExpressInterest(interest, closure);\n};\n\n/**\n * If the host and port are different than the ones in this.transport, then call\n *   this.transport.connect to change the connection (or connect for the first time).\n * Then call expressInterestHelper.\n */\nFace.prototype.reconnectAndExpressInterest = function(interest, closure) \n{\n  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {\n    var thisNDN = this;\n    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });\n    this.readyStatus = Face.OPENED;\n  }\n  else\n    this.expressInterestHelper(interest, closure);\n};\n\n/**\n * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call\n *   this.transport.send to send the interest.\n */\nFace.prototype.expressInterestHelper = function(interest, closure) \n{\n  var binaryInterest = interest.wireEncode();\n  var thisNDN = this;    \n  //TODO: check local content store first\n  if (closure != null) {\n    var pitEntry = new PITEntry(interest, closure);\n    // TODO: This needs to be a single thread-safe transaction on a global object.\n    Face.PITTable.push(pitEntry);\n    closure.pitEntry = pitEntry;\n\n    // Set interest timer.\n    var timeoutMilliseconds = (interest.interestLifetime || 4000);\n    var timeoutCallback = function() {\n      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());\n        \n      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express\n      //   the interest because we don\'t want to match it in the mean time.\n      // TODO: Make this a thread-safe operation on the global PITTable.\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0) \n        Face.PITTable.splice(index, 1);\n        \n      // Raise closure callback\n      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {\n        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());\n        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n        Face.PITTable.push(pitEntry);\n        thisNDN.transport.send(binaryInterest.buf());\n      }\n    };\n  \n    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n  }\n\n  this.transport.send(binaryInterest.buf());\n};\n\n/**\n * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.\n * This uses the form:\n * registerPrefix(name, onInterest, onRegisterFailed [, flags]).\n * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.\n * @param {Name} prefix The Name prefix.\n * @param {function} onInterest When an interest is received which matches the name prefix, this calls \n * onInterest(prefix, interest, transport) where:\n *   prefix is the prefix given to registerPrefix.\n *   interest is the received interest.\n *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().\n * @param {function} onRegisterFailed If failed to retrieve the connected hub\'s ID or failed to register the prefix, \n * this calls onRegisterFailed(prefix) where:\n *   prefix is the prefix given to registerPrefix.\n * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.  \n * If omitted, use the default flags defined by the default ForwardingFlags constructor.\n */\nFace.prototype.registerPrefix = function(prefix, arg2, arg3, arg4) \n{\n  // There are several overloaded versions of registerPrefix, each shown inline below.\n\n  // registerPrefix(Name prefix, Closure closure);            // deprecated\n  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.registerPrefixWithClosure(prefix, arg2, arg3);\n    else\n      this.registerPrefixWithClosure(prefix, arg2);\n    return;\n  }\n\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);\n  var onInterest = arg2;\n  var onRegisterFailed = (arg3 ? arg3 : function() {});\n  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());\n  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport), \n                                 intFlags, onRegisterFailed);\n}\n\n/**\n * A private method to register the prefix with the host, receive the data and call\n * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)). \n * @deprecated Use registerPrefix with callback functions, not Closure.\n * @param {Name} prefix\n * @param {Closure} closure\n * @param {number} intFlags\n * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix) \n * if registration fails.\n */\nFace.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed) \n{\n  intFlags = intFlags | 3;\n  var thisNDN = this;\n  var onConnected = function() {\n    if (thisNDN.ndndid == null) {\n      // Fetch ndndid first, then register.\n      var interest = new Interest(Face.ndndIdFetcher);\n      interest.interestLifetime = 4000; // milliseconds\n      if (LOG > 3) console.log(\'Expressing interest for ndndid from ndnd.\');\n      thisNDN.reconnectAndExpressInterest\n        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));\n    }\n    else  \n      thisNDN.registerPrefixHelper(prefix, closure, flags, onRegisterFailed);\n  };\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else\n      this.connectAndExecute(onConnected);\n  }\n  else\n    onConnected();\n};\n\n/**\n * This is a closure to receive the Data for Face.ndndIdFetcher and call\n *   registerPrefixHelper(prefix, callerClosure, flags).\n */\nFace.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed) \n{\n  // Inherit from Closure.\n  Closure.call(this);\n    \n  this.face = face;\n  this.prefix = prefix;\n  this.callerClosure = callerClosure;\n  this.flags = flags;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n       \n  if (LOG > 3) console.log(\'Got ndndid from ndnd.\');\n  // Get the digest of the public key in the data packet content.\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(upcallInfo.data.getContent());\n  this.face.ndndid = new customBuf(hash.digest());\n  if (LOG > 3) console.log(this.face.ndndid);\n  \n  this.face.registerPrefixHelper\n    (this.prefix, this.callerClosure, this.flags, this.onRegisterFailed);\n    \n  return Closure.RESULT_OK;\n};\n/**\n * This is a closure to receive the response Data packet from the register \n * prefix interest sent to the connected NDN hub. If this gets a bad response\n * or a timeout, call onRegisterFailed.\n */\nFace.RegisterResponseClosure = function RegisterResponseClosure\n  (prefix, onRegisterFailed) \n{\n  // Inherit from Closure.\n  Closure.call(this);\n    \n  this.prefix = prefix;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.RegisterResponseClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n       \n  var expectedName = new Name("/ndnx/.../selfreg");\n  // Got a response. Do a quick check of expected name components.\n  if (upcallInfo.data.getName().size() < 4 ||\n      !upcallInfo.data.getName().get(0).equals(expectedName.get(0)) ||\n      !upcallInfo.data.getName().get(2).equals(expectedName.get(2))) {\n    this.onRegisterFailed(this.prefix);\n    return;\n  }\n  \n  // Otherwise, silently succeed.  \n  return Closure.RESULT_OK;\n};\n\n/**\n * Do the work of registerPrefix once we know we are connected with a ndndid.\n */\nFace.prototype.registerPrefixHelper = function\n  (prefix, closure, flags, onRegisterFailed) \n{\n  var fe = new ForwardingEntry(\'selfreg\', prefix, null, null, flags, null);\n    \n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  var encoder = new BinaryXMLEncoder();\n  fe.to_ndnb(encoder);\n  var bytes = encoder.getReducedOstream();\n    \n  var si = new MetaInfo();\n  si.setFields();\n    \n  // Set the name to a random value so that each request is unique.\n  var data = new Data(new Name().append(require("crypto").randomBytes(4)), si, bytes); \n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  data.sign(BinaryXmlWireFormat.get());\n  var coBinary = data.wireEncode(BinaryXmlWireFormat.get());;\n    \n  var nodename = this.ndndid;\n  var interestName = new Name([\'ndnx\', nodename, \'selfreg\', coBinary]);\n\n  var interest = new Interest(interestName);\n  interest.setInterestLifetimeMilliseconds(4000.0);\n  interest.setScope(1);\n  if (LOG > 3) console.log(\'Send Interest registration packet.\');\n      \n  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n    \n  this.reconnectAndExpressInterest\n    (interest, new Face.RegisterResponseClosure(prefix, onRegisterFailed));\n};\n\n/**\n * This is called when an entire binary XML element is received, such as a Data or Interest.\n * Look up in the PITTable and call the closure callback.\n */\nFace.prototype.onReceivedElement = function(element) \n{\n  if (LOG > 3) console.log(\'Complete element received. Length \' + element.length + \'. Start decoding.\');\n  // First, decode as Interest or Data.\n  var interest = null;\n  var data = null;\n  // The type codes for TLV Interest and Data packets are chosen to not\n  //   conflict with the first byte of a binary XML packet, so we can\n  //   just look at the first byte.\n  if (element[0] == Tlv.Interest || element[0] == Tlv.Data) {\n    if (LOG > 3) console.log(\'Detected Tlv element\', element, TlvWireFormat.get())\n    var decoder = new TlvDecoder(element);  \n    if (decoder.peekType(Tlv.Interest, element.length)) {\n      interest = new Interest();\n      interest.wireDecode(element, TlvWireFormat.get());\n    }\n    else if (decoder.peekType(Tlv.Data, element.length)) {\n      data = new Data();\n      data.wireDecode(element, TlvWireFormat.get());\n    }\n  }\n  else {\n    if (LOG > 3) console.log(\'assumed BinaryXML\')\n    // Binary XML.\n    var decoder = new BinaryXMLDecoder(element);\n    if (decoder.peekDTag(NDNProtocolDTags.Interest)) {\n      interest = new Interest();\n      interest.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Data)) {\n      data = new Data();\n      data.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n  }\n\n  // Now process as Interest or Data.\n  if (interest !== null) {\n    if (LOG > 3) console.log(\'Interest packet received.\', interest);\n        setTimeout(function(){console.log(interest)}, 300)\n    var entry = getEntryForRegisteredPrefix(interest.name);\n    if (entry != null) {\n      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());\n      var info = new UpcallInfo(this, interest, 0, null);\n      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);\n      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null) \n        this.transport.send(info.data.wireEncode().buf());\n    }        \n  } \n  else if (data !== null) {\n    if (LOG > 3) console.log(\'Data packet received.\');\n        \n    var pendingInterests = Face.extractEntriesForExpressedInterest(data.name);\n    // Process each matching PIT entry (if any).\n    for (var i = 0; i < pendingInterests.length; ++i) {\n      var pitEntry = pendingInterests[i];\n      var currentClosure = pitEntry.closure;\n                    \n      if (this.verify == false) {\n        // Pass content up without verifying the signature\n        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));\n        continue;\n      }\n        \n      // Key verification\n            \n      // Recursive key fetching & verification closure\n      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {\n        this.data = content;  // unverified data packet object\n        this.closure = closure;  // closure corresponding to the data\n        this.keyName = key;  // name of current key to be fetched\n            \n        Closure.call(this);\n      };\n            \n      var thisNDN = this;\n      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {\n        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n          console.log("In KeyFetchClosure.upcall: interest time out.");\n          console.log(this.keyName.contentName.toUri());\n        } \n        else if (kind == Closure.UPCALL_CONTENT) {\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(upcallInfo.data.content);\n          var verified = data.verify(rsakey);\n                \n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));\n                \n          // Store key in cache\n          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());\n          Face.addKeyEntry(keyEntry);\n        } \n        else if (kind == Closure.UPCALL_CONTENT_BAD)\n          console.log("In KeyFetchClosure.upcall: signature verification failed");\n      };\n            \n      if (data.signedInfo && data.signedInfo.locator && data.signature) {\n        if (LOG > 3) console.log("Key verification...");\n        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();\n              \n        var wit = null;\n        if (data.signature.witness != null)\n            //SWT: deprecate support for Witness decoding and Merkle hash tree verification\n            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));\n          \n        var keylocator = data.signedInfo.locator;\n        if (keylocator.type == KeyLocatorType.KEYNAME) {\n          if (LOG > 3) console.log("KeyLocator contains KEYNAME");\n                \n          if (keylocator.keyName.contentName.match(data.name)) {\n            if (LOG > 3) console.log("Content is key itself");\n                  \n            var rsakey = new Key();\n            rsakey.readDerPublicKey(data.content);\n            var verified = data.verify(rsakey);\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n              \n            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n            // SWT: We don\'t need to store key here since the same key will be stored again in the closure.\n          } \n          else {\n            // Check local key store\n            var keyEntry = Face.getKeyByName(keylocator.keyName);\n            if (keyEntry) {\n              // Key found, verify now\n              if (LOG > 3) console.log("Local key cache hit");\n              var rsakey = keyEntry.rsaKey;\n              var verified = data.verify(rsakey);\n              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n              // Raise callback\n              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n            } \n            else {\n              // Not found, fetch now\n              if (LOG > 3) console.log("Fetch key according to keylocator");\n              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);\n              // TODO: Use expressInterest with callbacks, not Closure.\n              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);\n            }\n          }\n        } \n        else if (keylocator.type == KeyLocatorType.KEY) {\n          if (LOG > 3) console.log("Keylocator contains KEY");\n                \n          var rsakey = new Key();\n          rsakey.readDerPublicKey(keylocator.publicKey);\n          var verified = data.verify(rsakey);\n              \n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          // Raise callback\n          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n          // Since KeyLocator does not contain key name for this key,\n          // we have no way to store it as a key entry in KeyStore.\n        } \n        else {\n          var cert = keylocator.certificate;\n          console.log("KeyLocator contains CERT");\n          console.log(cert);                \n          // TODO: verify certificate\n        }\n      }\n    }\n  } \n};\n\n/**\n * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host\n *   is not alive.  Get a host and port, connect, then execute onConnected().\n */\nFace.prototype.connectAndExecute = function(onConnected) \n{\n  var hostAndPort = this.getHostAndPort();\n  if (hostAndPort == null) {\n    console.log(\'ERROR: No more hosts from getHostAndPort\');\n    this.host = null;\n    return;\n  }\n\n  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {\n    console.log(\'ERROR: The host returned by getHostAndPort is not alive: \' + this.host + ":" + this.port);\n    return;\n  }\n        \n  this.host = hostAndPort.host;\n  this.port = hostAndPort.port;   \n  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);\n    \n  // Fetch any content.\n  var interest = new Interest(new Name("/"));\n  interest.interestLifetime = 4000; // milliseconds    \n\n  var thisNDN = this;\n  var timerID = setTimeout(function() {\n    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);\n      // Try again.\n      thisNDN.connectAndExecute(onConnected);\n  }, 3000);\n  \n  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));\n};\n\n/**\n * This is called by the Transport when the connection is closed by the remote host.\n */\nFace.prototype.closeByTransport = function() \n{\n  this.readyStatus = Face.CLOSED;\n  this.onclose();\n};\n\nFace.ConnectClosure = function ConnectClosure(face, onConnected, timerID) \n{\n  // Inherit from Closure.\n  Closure.call(this);\n    \n  this.face = face;\n  this.onConnected = onConnected;\n  this.timerID = timerID;\n};\n\nFace.ConnectClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.\n    return Closure.RESULT_ERR;\n        \n  // The host is alive, so cancel the timeout and continue with onConnected().\n  clearTimeout(this.timerID);\n\n    // Call Face.onopen after success\n  this.face.readyStatus = Face.OPENED;\n  this.face.onopen();\n\n  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);\n  this.onConnected();\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * @deprecated Use new Face.\n */\nvar NDN = function NDN(settings) \n{\n  // Call the base constructor.\n  Face.call(this, settings); \n}\n\n// Use dummy functions so that the Face constructor will not try to set its own defaults.                                      \nNDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });\n\nexports.NDN = NDN;\n\nNDN.supported = Face.supported;\nNDN.UNOPEN = Face.UNOPEN;\nNDN.OPENED = Face.OPENED;\nNDN.CLOSED = Face.CLOSED;\n\n})()\n},{"./buffer.js":28,"./closure.js":8,"./crypto.js":28,"./data.js":13,"./encoding/binary-xml-decoder.js":55,"./encoding/binary-xml-encoder.js":56,"./encoding/binary-xml-wire-format.js":19,"./encoding/data-utils.js":21,"./encoding/tlv-wire-format.js":20,"./encoding/tlv/tlv-decoder.js":54,"./encoding/tlv/tlv.js":53,"./forwarding-entry.js":52,"./forwarding-flags.js":10,"./interest.js":11,"./key-locator.js":16,"./key.js":15,"./log.js":59,"./meta-info.js":14,"./name.js":9,"./transport/tcp-transport.js":58,"./util/ndn-protoco-id-tags.js":57,"crypto":51}],9:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents a Name as an array of components where each is a byte array.\n */\n \nvar Blob = require(\'./util/blob.js\').Blob;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Name from components.\n * \n * @constructor\n * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.  \n * Otherwise it is an array of components which are appended according to Name.append, so\n * convert each and store it as an array of customBuf.  If a component is a string, encode as utf8.\n */\nvar Name = function Name(components) \n{\n  if (typeof components == \'string\') {    \n    if (LOG > 3) console.log(\'Content Name String \' + components);\n    this.components = Name.createNameArray(components);\n  }\n  else if (typeof components === \'object\') {    \n    this.components = [];\n    if (components instanceof Name)\n      this.append(components);\n    else {\n      for (var i = 0; i < components.length; ++i)\n        this.append(components[i]);\n    }\n  }\n  else if (components == null)\n    this.components = [];\n  else\n    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");\n};\n\nexports.Name = Name;\n\n/**\n * \n * @constructor\n * Create a new Name.Component with a copy of the given value.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don\'t unescape).\n */\nName.Component = function NameComponent(value) \n{\n  if (typeof value === \'string\')\n    this.value = DataUtils.stringToUtf8Array(value);\n  else if (typeof value === \'object\' && value instanceof Name.Component)\n    this.value = new customBuf(value.value);\n  else if (typeof value === \'object\' && value instanceof Blob)\n    this.value = new customBuf(value.buf());\n  else if (typeof value === \'object\' && value instanceof customBuf)\n    this.value = new customBuf(value);\n  else if (typeof value === \'object\' && typeof ArrayBuffer !== \'undefined\' &&  value instanceof ArrayBuffer) {\n    // Make a copy.  Don\'t use ArrayBuffer.slice since it isn\'t always supported.                                                      \n    this.value = new customBuf(new ArrayBuffer(value.byteLength));\n    this.value.set(new customBuf(value));\n  }\n  else if (typeof value === \'object\')\n    // Assume value is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    this.value = new customBuf(value);\n  else \n    throw new Error("Name.Component constructor: Invalid type");\n}\n\n/**\n * Get the component value.\n * @returns {Buffer} The component value.\n */\nName.Component.prototype.getValue = function() \n{\n  return this.value;\n}\n\n/**\n * Convert this component value to a string by escaping characters according to the NDN URI Scheme.\n * This also adds "..." to a value with zero or more ".".\n * @returns {string} The escaped string.\n */\nName.Component.prototype.toEscapedString = function() \n{\n  return Name.toEscapedString(this.value);\n}\n\n/**\n * Check if this is the same component as other.\n * @param {Name.Component} other The other Component to compare with.\n * @returns {Boolean} true if the components are equal, otherwise false.\n */\nName.Component.prototype.equals = function(other) \n{\n  return DataUtils.arraysEqual(this.value, other.value);\n}\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.getName = function() \n{\n  return this.toUri();\n};\n\n/** Parse uri as a URI and return an array of customBuf components.\n */\nName.createNameArray = function(uri) \n{\n  uri = uri.trim();\n  if (uri.length <= 0)\n    return [];\n\n  var iColon = uri.indexOf(\':\');\n  if (iColon >= 0) {\n    // Make sure the colon came before a \'/\'.\n    var iFirstSlash = uri.indexOf(\'/\');\n    if (iFirstSlash < 0 || iColon < iFirstSlash)\n      // Omit the leading protocol such as ndn:\n      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();\n  }\n    \n  if (uri[0] == \'/\') {\n    if (uri.length >= 2 && uri[1] == \'/\') {\n      // Strip the authority following "//".\n      var iAfterAuthority = uri.indexOf(\'/\', 2);\n      if (iAfterAuthority < 0)\n        // Unusual case: there was only an authority.\n        return [];\n      else\n        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();\n    }\n    else\n      uri = uri.substr(1, uri.length - 1).trim();\n  }\n\n  var array = uri.split(\'/\');\n    \n  // Unescape the components.\n  for (var i = 0; i < array.length; ++i) {\n    var value = Name.fromEscapedString(array[i]);\n        \n    if (value == null) {\n      // Ignore the illegal componenent.  This also gets rid of a trailing \'/\'.\n      array.splice(i, 1);\n      --i;  \n      continue;\n    }\n    else\n      array[i] = new Name.Component(value);\n  }\n\n  return array;\n};\n\nName.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)  \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  this.components = [];\n\n  while (decoder.peekDTag(NDNProtocolDTags.Component))\n    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    \n  decoder.readElementClose();\n};\n\nName.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{    \n  if (this.components == null) \n    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  var count = this.size();\n  for (var i=0; i < count; i++)\n    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());\n  \n  encoder.writeElementClose();\n};\n\nName.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.Name;\n};\n\n/**\n * Convert the component to a customBuf and append to this Name.\n * Return this Name object to allow chaining calls to add.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don\'t unescape).\n * @returns {Name}\n */\nName.prototype.append = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name) {\n    var components;\n    if (component == this)\n      // special case, when we need to create a copy\n      components = this.components.slice(0, this.components.length);\n    else\n      components = component.components;\n      \n    for (var i = 0; i < components.length; ++i)\n      this.components.push(new Name.Component(components[i]));\n  }\n  else\n    // Just use the Name.Component constructor.\n    this.components.push(new Name.Component(component));\n\n  return this;\n};\n\n/**\n * @deprecated Use append.\n */\nName.prototype.add = function(component)\n{\n  return this.append(component);\n};\n\n/**\n * Clear all the components.\n */\nName.prototype.clear = function()\n{\n  this.components = [];  \n};\n\n/**\n * Return the escaped name string according to "NDNx URI Scheme".\n * @returns {String}\n */\nName.prototype.toUri = function() \n{  \n  if (this.size() == 0)\n    return "/";\n    \n  var result = "";\n  \n  for (var i = 0; i < this.size(); ++i)\n    result += "/"+ Name.toEscapedString(this.components[i].getValue());\n  \n  return result;  \n};\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.to_uri = function() \n{\n  return this.toUri();\n};\n\n/**\n * Append a component with the encoded segment number.\n * @param {number} segment The segment number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendSegment = function(segment) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(segment);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * Append a component with the encoded version number.\n * Note that this encodes the exact value of version without converting from a \n * time representation.\n * @param {number} version The version number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendVersion = function(version) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(version);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0xfD;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * @deprecated Use appendSegment.\n */\nName.prototype.addSegment = function(number) \n{\n  return this.appendSegment(number);\n};\n\n/**\n * Get a new name, constructed as a subset of components.\n * @param {number} iStartComponent The index if the first component to get.\n * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,\n * return components starting at iStartComponent until the end of the name.\n * @returns {Name} A new name.\n */\nName.prototype.getSubName = function(iStartComponent, nComponents)\n{\n  if (nComponents == undefined)\n    nComponents = this.components.length - iStartComponent;\n  \n  var result = new Name();\n\n  var iEnd = iStartComponent + nComponents;\n  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)\n    result.components.push(this.components[i]);\n\n  return result;  \n};\n\n/**\n * Return a new Name with the first nComponents components of this Name.\n * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up\n * to name.size() - N. For example getPrefix(-1) returns the name without the final component.\n * @returns {Name} A new name.\n */\nName.prototype.getPrefix = function(nComponents) \n{\n  if (nComponents < 0)\n    return this.getSubName(0, this.components.length + nComponents);\n  else\n    return this.getSubName(0, nComponents);\n};\n\n/**\n * @brief Get prefix of the name, containing less minusComponents right components\n * @param minusComponents number of components to cut from the back\n */\nName.prototype.cut = function(minusComponents) \n{\n  return new Name(this.components.slice(0, this.components.length - minusComponents));\n};\n\n/**\n * Return the number of name components.\n * @returns {number}\n */\nName.prototype.size = function() \n{\n  return this.components.length;\n};\n\n/**\n * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().\n * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component\n * at size() - (-i).\n * @returns {Name.Component}\n */\nName.prototype.get = function(i) \n{\n  if (i >= 0) {\n    if (i >= this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[i]);\n  }\n  else {\n    // Negative index.\n    if (i < -this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[this.components.length - (-i)]);\n  }\n};\n\n/**\n * @deprecated Use size().\n */\nName.prototype.getComponentCount = function() \n{\n  return this.components.length;\n};\n\n/**\n * @deprecated To get just the component value, use get(i).getValue().\n */\nName.prototype.getComponent = function(i) \n{\n  return new customBuf(this.components[i].getValue());\n};\n\n/**\n * The "file name" in a name is the last component that isn\'t blank and doesn\'t start with one of the\n *   special marker octets (for version, etc.).  Return the index in this.components of\n *   the file name, or -1 if not found.\n */\nName.prototype.indexOfFileName = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var component = this.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n        \n    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 || \n        (component[0] >= 0xF5 && component[0] <= 0xFF))\n      continue;\n        \n    return i;\n  }\n    \n  return -1;\n};\n\n/**\n * Return true if this Name has the same components as name.\n */\nName.prototype.equals = function(name) \n{\n  if (this.components.length != name.components.length)\n    return false;\n    \n  // Start from the last component because they are more likely to differ.\n  for (var i = this.components.length - 1; i >= 0; --i) {\n    if (!this.components[i].equals(name.components[i]))\n      return false;\n  }\n    \n  return true;\n};\n\n/**\n * @deprecated Use equals.\n */\nName.prototype.equalsName = function(name)\n{\n  return this.equals(name);\n};\n\n/**\n * Find the last component in name that has a ContentDigest and return the digest value as customBuf, \n *   or null if not found.  See Name.getComponentContentDigestValue.\n */\nName.prototype.getContentDigestValue = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var digestValue = Name.getComponentContentDigestValue(this.components[i]);\n    if (digestValue != null)\n      return digestValue;\n  }\n    \n  return null;\n};\n\n/**\n * If component is a ContentDigest, return the digest value as a customBuf slice (don\'t modify!).\n * If not a ContentDigest, return null.\n * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.\n */\nName.getComponentContentDigestValue = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length; \n  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.\n  if (component.length == digestComponentLength &&\n      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length), \n                            Name.ContentDigestPrefix) &&\n      DataUtils.arraysEqual(component.slice\n         (component.length - Name.ContentDigestSuffix.length, component.length),\n                            Name.ContentDigestSuffix))\n   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);\n else\n   return null;\n};\n\n// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB. \nName.ContentDigestPrefix = new customBuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);\nName.ContentDigestSuffix = new customBuf([0x00]);\n\n\n/**\n * Return value as an escaped string according to "NDNx URI Scheme".\n * We can\'t use encodeURIComponent because that doesn\'t encode all the characters we want to.\n * @param {Buffer|Name.Component} component The value or Name.Component to escape.\n * @returns {string} The escaped string.\n */\nName.toEscapedString = function(value) \n{\n  if (typeof value == \'object\' && value instanceof Name.Component)\n    value = value.getValue();\n  \n  var result = "";\n  var gotNonDot = false;\n  for (var i = 0; i < value.length; ++i) {\n    if (value[i] != 0x2e) {\n      gotNonDot = true;\n      break;\n    }\n  }\n  if (!gotNonDot) {\n    // Special case for component of zero or more periods.  Add 3 periods.\n    result = "...";\n    for (var i = 0; i < value.length; ++i)\n      result += ".";\n  }\n  else {\n    for (var i = 0; i < value.length; ++i) {\n      var x = value[i];\n      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)\n      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||\n          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d || \n          x == 0x2e || x == 0x5f)\n        result += String.fromCharCode(x);\n      else\n        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();\n    }\n  }\n  return result;\n};\n\n/**\n * Return a customBuf byte array by decoding the escapedString according to "NDNx URI Scheme".\n * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.\n * @param {string} escapedString The escaped string to decode.\n * @returns {Buffer} The byte array, or null which means to skip the component in the name.\n */\nName.fromEscapedString = function(escapedString) \n{\n  var value = unescape(escapedString.trim());\n        \n  if (value.match(/[^.]/) == null) {\n    // Special case for value of only periods.  \n    if (value.length <= 2)\n      // Zero, one or two periods is illegal.  Ignore this componenent to be\n      //   consistent with the C implementation.\n      return null;\n    else\n      // Remove 3 periods.\n      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));\n  }\n  else\n    return DataUtils.toNumbersFromString(value);\n};\n\n/**\n * Return true if the N components of this name are the same as the first N components of the given name.\n * @param {Name} name The name to check.\n * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.\n */\nName.prototype.match = function(name) \n{\n  var i_name = this.components;\n  var o_name = name.components;\n\n  // This name is longer than the name we are checking it against.\n  if (i_name.length > o_name.length)\n    return false;\n\n  // Check if at least one of given components doesn\'t match.\n  for (var i = 0; i < i_name.length; ++i) {\n    if (!i_name[i].equals(o_name[i]))\n      return false;\n  }\n\n  return true;\n};\n\n})()\n},{"./buffer.js":28,"./encoding/binary-xml-decoder.js":55,"./encoding/binary-xml-encoder.js":56,"./encoding/data-utils.js":21,"./log.js":59,"./util/blob.js":23,"./util/ndn-protoco-id-tags.js":57}],10:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\n\n/**\n * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for\n * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding\n * bits are changed, amended or deprecated.\n * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.\n */\nvar ForwardingFlags = function ForwardingFlags() \n{\n  this.active = true;\n  this.childInherit = true;\n  this.advertise = false;\n  this.last = false;\n  this.capture = false;\n  this.local = false;\n  this.tap = false;\n  this.captureOk = false;\n}\n\nexports.ForwardingFlags = ForwardingFlags;\n\n/**\n * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.\n * @returns {number} An integer with the bits set.\n */\nForwardingFlags.prototype.getForwardingEntryFlags = function()\n{\n  var result = 0;\n  \n  if (this.active)\n    result |= ForwardingEntry.ACTIVE;\n  if (this.childInherit)\n    result |= ForwardingEntry.CHILD_INHERIT;\n  if (this.advertise)\n    result |= ForwardingEntry.ADVERTISE;\n  if (this.last)\n    result |= ForwardingEntry.LAST;\n  if (this.capture)\n    result |= ForwardingEntry.CAPTURE;\n  if (this.local)\n    result |= ForwardingEntry.LOCAL;\n  if (this.tap)\n    result |= ForwardingEntry.TAP;\n  if (this.captureOk)\n    result |= ForwardingEntry.CAPTURE_OK;\n  \n  return result;\n};\n\n/**\n * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.\n * @param {number} forwardingEntryFlags An integer with the bits set.\n */\nForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)\n{\n  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);\n  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);\n  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);\n  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);\n  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);\n  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);\n  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);\n  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);\n};\n\n/**\n * Get the value of the "active" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getActive = function() { return this.active; };\n\n/**\n * Get the value of the "childInherit" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };\n\n/**\n * Get the value of the "advertise" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };\n\n/**\n * Get the value of the "last" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLast = function() { return this.last; };\n\n/**\n * Get the value of the "capture" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCapture = function() { return this.capture; };\n\n/**\n * Get the value of the "local" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLocal = function() { return this.local; };\n\n/**\n * Get the value of the "tap" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getTap = function() { return this.tap; };\n\n/**\n * Get the value of the "captureOk" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };\n\n/**\n * Set the value of the "active" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setActive = function(value) { this.active = value; };\n\n/**\n * Set the value of the "childInherit" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };\n\n/**\n * Set the value of the "advertise" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };\n\n/**\n * Set the value of the "last" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLast = function(value) { this.last = value; };\n\n/**\n * Set the value of the "capture" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };\n\n/**\n * Set the value of the "local" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLocal = function(value) { this.local = value; };\n\n/**\n * Set the value of the "tap" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setTap = function(value) { this.tap = value; };\n\n/**\n * Set the value of the "captureOk" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };\n\n},{"./forwarding-entry.js":52}],11:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar Name = require(\'./name.js\').Name;\nvar Exclude = require(\'./exclude.js\').Exclude;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').LOG\n/**\n * Create a new Interest with the optional values.\n * \n * @constructor\n * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the\n * other arguments.  Otherwise this is the optional name for the new Interest.\n * @param {number} minSuffixComponents\n * @param {number} maxSuffixComponents\n * @param {Buffer} publisherPublicKeyDigest\n * @param {Exclude} exclude\n * @param {number} childSelector\n * @param {number} answerOriginKind\n * @param {number} scope\n * @param {number} interestLifetimeMilliseconds in milliseconds\n * @param {Buffer} nonce\n */\nvar Interest = function Interest\n   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude, \n    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce) \n{\n  if (typeof nameOrInterest === \'object\' && nameOrInterest instanceof Interest) {\n    // Special case: this is a copy constructor.  Ignore all but the first argument.\n    var interest = nameOrInterest;\n    if (interest.name)\n      // Copy the name.\n      this.name = new Name(interest.name);\n    this.maxSuffixComponents = interest.maxSuffixComponents;\n    this.minSuffixComponents = interest.minSuffixComponents;\n\n    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator(interest.keyLocator);\n    this.exclude = new Exclude(interest.exclude);\n    this.childSelector = interest.childSelector;\n    this.answerOriginKind = interest.answerOriginKind;\n    this.scope = interest.scope;\n    this.interestLifetime = interest.interestLifetime;\n    if (interest.nonce)\n      // Copy.\n      this.nonce = new customBuf(interest.nonce);    \n  }  \n  else {\n    this.name = typeof nameOrInterest === \'object\' && nameOrInterest instanceof Name ?\n                new Name(nameOrInterest) : new Name();\n    this.maxSuffixComponents = maxSuffixComponents;\n    this.minSuffixComponents = minSuffixComponents;\n\n    this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator();\n    this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                   new Exclude(exclude) : new Exclude();\n    this.childSelector = childSelector;\n    this.answerOriginKind = answerOriginKind;\n    this.scope = scope;\n    this.interestLifetime = interestLifetimeMilliseconds;\n    if (nonce)\n      // Copy and make sure it is a customBuf.\n      this.nonce = new customBuf(nonce);\n  }\n};\n\nexports.Interest = Interest;\n\nInterest.RECURSIVE_POSTFIX = "*";\n\nInterest.CHILD_SELECTOR_LEFT = 0;\nInterest.CHILD_SELECTOR_RIGHT = 1;\n\nInterest.ANSWER_NO_CONTENT_STORE = 0;\nInterest.ANSWER_CONTENT_STORE = 1;\nInterest.ANSWER_GENERATED = 2;\nInterest.ANSWER_STALE = 4;    // Stale answer OK\nInterest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"\n\nInterest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;\n\n/**\n * Return true if this.name.match(name) and the name conforms to the interest selectors.\n * @param {Name} name\n * @returns {boolean}\n */\nInterest.prototype.matchesName = function(/*Name*/ name) \n{\n  if (!this.name.match(name))\n    return false;\n    \n  if (this.minSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))\n    return false;\n  if (this.maxSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))\n    return false;\n  if (this.exclude != null && name.size() > this.name.size() &&\n      this.exclude.matches(name.components[this.name.size()]))\n    return false;\n    \n  return true;\n};\n\n/**\n * @deprecated Use matchesName.\n */\nInterest.prototype.matches_name = function(/*Name*/ name) \n{\n  return this.matchesName(name);\n};\n\n/**\n * Return a new Interest with the same fields as this Interest.  \n */\nInterest.prototype.clone = function() \n{\n  return new Interest\n     (this.name, this.minSuffixComponents, this.maxSuffixComponents, \n      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind, \n      this.scope, this.interestLifetime, this.nonce);\n};\n\n/**\n * Get the interest Name.\n * @returns {Name} The name.  The name size() may be 0 if not specified.\n */\nInterest.prototype.getName = function() { return this.name; };\n\n/**\n * Get the min suffix components.\n * @returns number} The min suffix components, or null if not specified.\n */\nInterest.prototype.getMinSuffixComponents = function() \n{ \n  return this.minSuffixComponents; \n};\n\n/**\n * Get the max suffix components.\n * @returns {number} The max suffix components, or null if not specified.\n */\nInterest.prototype.getMaxSuffixComponents = function() \n{ \n  return this.maxSuffixComponents; \n};\n\n/**\n * Get the interest key locator.\n * @returns {KeyLocator} The key locator. If its getType() is null, \n * then the key locator is not specified.\n */\nInterest.prototype.getKeyLocator = function() \n{ \n  return this.keyLocator; \n};\n\n/**\n * Get the exclude object.\n * @returns {Exclude} The exclude object. If the exclude size() is zero, then\n * the exclude is not specified.\n */\nInterest.prototype.getExclude = function() { return this.exclude; };\n\n/**\n * Get the child selector.\n * @returns {number} The child selector, or null if not specified.\n */\nInterest.prototype.getChildSelector = function() \n{ \n  return this.childSelector; \n};\n\n/**\n * @deprecated Use getMustBeFresh.\n */\nInterest.prototype.getAnswerOriginKind = function() \n{ \n  return this.answerOriginKind; \n};\n  \n  /**\n   * Return true if the content must be fresh.\n   * @return true if must be fresh, otherwise false.\n   */\n  \n/**\n * Get the must be fresh flag. If not specified, the default is true.\n * @returns {boolean} The must be fresh flag.\n */\nInterest.prototype.getMustBeFresh = function() \n{\n  if (this.answerOriginKind == null || this.answerOriginKind < 0)\n    return true;\n  else\n    return (this.answerOriginKind & Interest.ANSWER_STALE) == 0;\n};\n\n/**\n * Return the nonce value from the incoming interest.  If you change any of the \n * fields in this Interest object, then the nonce value is cleared.\n * @returns {Buffer} The nonce, or null if not specified.\n */\nInterest.prototype.getNonce = function() { return this.nonce; };\n\n/**\n * Get the interest scope.\n * @returns {number} The scope, or null if not specified.\n */\nInterest.prototype.getScope = function() { return this.scope; };\n\n/**\n * Get the interest lifetime.\n * @returns {number} The interest lifetime in milliseconds, or null if not \n * specified.\n */\nInterest.prototype.getInterestLifetimeMilliseconds = function() \n{ \n  return this.interestLifetime; \n};\n\nInterest.prototype.setName = function(name)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.name = typeof name === \'object\' && name instanceof Interest ?\n              new Name(name) : new Name();\n};\n                \nInterest.prototype.setMinSuffixComponents = function(minSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.minSuffixComponents = minSuffixComponents;\n};\n\nInterest.prototype.setMaxSuffixComponents = function(maxSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.maxSuffixComponents = maxSuffixComponents;\n};\n\n/**\n * Set this interest to use a copy of the given exclude object. Note: You can \n * also change this interest\'s exclude object modifying the object from \n * getExclude().\n * @param {Exclude} exclude The exlcude object that is copied.\n */\nInterest.prototype.setExclude = function(exclude)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                 new Exclude(exclude) : new Exclude();\n};\n\nInterest.prototype.setChildSelector = function(childSelector)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.childSelector = childSelector;\n};\n\n/**\n * @deprecated Use setMustBeFresh.\n */\nInterest.prototype.setAnswerOriginKind = function(answerOriginKind)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.answerOriginKind = answerOriginKind;\n};\n\n/**\n * Set the MustBeFresh flag.\n * @param {boolean} mustBeFresh True if the content must be fresh, otherwise false.\n */\nInterest.prototype.setMustBeFresh = function(mustBeFresh)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  if (this.answerOriginKind == null || this.answerOriginKind < 0) {\n    // It is is already the default where MustBeFresh is true. \n    if (!mustBeFresh)\n      // Set answerOriginKind_ so that getMustBeFresh returns false.\n      this.answerOriginKind = Interest.ANSWER_STALE; \n  }\n  else {\n    if (mustBeFresh)\n      // Clear the stale bit.\n      this.answerOriginKind &= ~Interest.ANSWER_STALE;\n    else\n      // Set the stale bit.\n      this.answerOriginKind |= Interest.ANSWER_STALE;\n  }\n};\n\nInterest.prototype.setScope = function(scope)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.scope = scope;\n};\n\nInterest.prototype.setInterestLifetimeMilliseconds = function(interestLifetimeMilliseconds)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.interestLifetime = interestLifetimeMilliseconds;\n};\n\n/**\n * @deprecated You should let the wire encoder generate a random nonce \n * internally before sending the interest.\n */\nInterest.prototype.setNonce = function(nonce)\n{\n  if (nonce)\n    // Copy and make sure it is a customBuf.\n    this.nonce = new customBuf(nonce);\n  else\n    this.nonce = null;\n};\n\n/**\n * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and\n * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".\n * @returns {string} The URI string.\n * @note This is an experimental feature.  See the API docs for more detail at\n * http://named-data.net/doc/ndn-ccl-api/interest.html#interest-touri-method .\n */\nInterest.prototype.toUri = function() \n{  \n  var selectors = "";\n  \n  if (this.minSuffixComponents != null)\n    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;\n  if (this.maxSuffixComponents != null)\n    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;\n  if (this.childSelector != null)\n    selectors += "&ndn.ChildSelector=" + this.childSelector;\n  if (this.answerOriginKind != null)\n    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;\n  if (this.scope != null)\n    selectors += "&ndn.Scope=" + this.scope;\n  if (this.interestLifetime != null)\n    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;\n  if (this.publisherPublicKeyDigest != null)\n    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  if (this.nonce != null)\n    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);\n  if (this.exclude != null && this.exclude.size() > 0)\n    selectors += "&ndn.Exclude=" + this.exclude.toUri();\n\n  var result = this.name.toUri();\n  if (selectors != "")\n    // Replace the first & with ?.\n    result += "?" + selectors.substr(1);\n  \n  return result;\n};\n\n/**\n * Encode this Interest for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {Blob} The encoded buffer in a Blob object.\n */\nInterest.prototype.wireEncode = function(wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return wireFormat.encodeInterest(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Interest.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nInterest.prototype.wireDecode = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  if (LOG > 3 ) console.log(\'decoding input to interes\', input)\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ? \n                     input.buf() : input;\n  wireFormat.decodeInterest(this, decodeBuffer);\n};\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom \n// to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  BinaryXmlWireFormat.decodeInterest(this, decoder);\n};\n\n/**\n * @deprecated Use wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder) \n{\n  BinaryXmlWireFormat.encodeInterest(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.encode = function(wireFormat) \n{\n  return this.wireEncode(BinaryXmlWireFormat.get()).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.decode = function(input, wireFormat) \n{\n  this.wireDecode(input, BinaryXmlWireFormat.get())\n};\n\n})()\n},{"./buffer.js":28,"./encoding/binary-xml-wire-format.js":19,"./encoding/wire-format.js":18,"./exclude.js":12,"./key-locator.js":16,"./log.js":59,"./name.js":9,"./publisher-public-key-digest.js":17,"./util/blob.js":23}],12:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an Interest Exclude.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\n\n/**\n * Create a new Exclude.\n * @constructor\n * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, customBuf component or Exclude.ANY.\n */\nvar Exclude = function Exclude(values) \n{ \n  this.values = [];\n  \n  if (typeof values === \'object\' && values instanceof Exclude)\n    // Copy the exclude.\n    this.values = values.values.slice(0);\n  else if (values) {\n    for (var i = 0; i < values.length; ++i) {\n      if (values[i] == Exclude.ANY)\n        this.appendAny();\n      else\n        this.appendComponent(values[i]);\n    }\n  }\n};\n\nexports.Exclude = Exclude;\n\nExclude.ANY = "*";\n\n/**\n * Get the number of entries.\n * @returns {number} The number of entries.\n */\nExclude.prototype.size = function() { return this.values.length; };\n\n/**\n * Get the entry at the given index.\n * @param {number} i The index of the entry, starting from 0.\n * @returns {Exclude.ANY|Name.Component} Exclude.ANY or a Name.Component.\n */\nExclude.prototype.get = function(i) { return this.values[i]; };\n\n/**\n * Append an Exclude.ANY element.\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendAny = function() \n{\n  this.values.push(Exclude.ANY);\n  return this;\n};\n\n/**\n * Append a component entry, copying from component.\n * @param {Name.Component|Buffer} component\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendComponent = function(component) \n{\n  this.values.push(new Name.Component(component));\n  return this;\n};\n\n/**\n * Clear all the entries.\n */\nExclude.prototype.clear = function() \n{\n  this.values = [];\n};\n\nExclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);\n\n  while (true) {\n    if (decoder.peekDTag(NDNProtocolDTags.Component))\n      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {\n      decoder.readElementStartDTag(NDNProtocolDTags.Any);\n      decoder.readElementClose();\n      this.appendAny();\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {\n      // Skip the Bloom and treat it as Any.\n      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);\n      this.appendAny();\n    }\n    else\n      break;\n  }\n    \n  decoder.readElementClose();\n};\n\nExclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{\n  if (this.values == null || this.values.length == 0)\n    return;\n\n  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);\n    \n  // TODO: Do we want to order the components (except for ANY)?\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      encoder.writeElementStartDTag(NDNProtocolDTags.Any);\n      encoder.writeElementClose();\n    }\n    else\n      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());\n  }\n\n  encoder.writeElementClose();\n};\n\n/**\n * Return a string with elements separated by "," and Exclude.ANY shown as "*". \n */\nExclude.prototype.toUri = function() \n{\n  if (this.values == null || this.values.length == 0)\n    return "";\n\n  var result = "";\n  for (var i = 0; i < this.values.length; ++i) {\n    if (i > 0)\n      result += ",";\n        \n    if (this.values[i] == Exclude.ANY)\n      result += "*";\n    else\n      result += Name.toEscapedString(this.values[i].getValue());\n  }\n  return result;\n};\n\n/**\n * Return true if the component matches any of the exclude criteria.\n */\nExclude.prototype.matches = function(/*Buffer*/ component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      var lowerBound = null;\n      if (i > 0)\n        lowerBound = this.values[i - 1];\n      \n      // Find the upper bound, possibly skipping over multiple ANY in a row.\n      var iUpperBound;\n      var upperBound = null;\n      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {\n        if (this.values[iUpperBound] != Exclude.ANY) {\n          upperBound = this.values[iUpperBound];\n          break;\n        }\n      }\n      \n      // If lowerBound != null, we already checked component equals lowerBound on the last pass.\n      // If upperBound != null, we will check component equals upperBound on the next pass.\n      if (upperBound != null) {\n        if (lowerBound != null) {\n          if (Exclude.compareComponents(component, lowerBound) > 0 &&\n              Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n        else {\n          if (Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n          \n        // Make i equal iUpperBound on the next pass.\n        i = iUpperBound - 1;\n      }\n      else {\n        if (lowerBound != null) {\n            if (Exclude.compareComponents(component, lowerBound) > 0)\n              return true;\n        }\n        else\n          // this.values has only ANY.\n          return true;\n      }\n    }\n    else {\n      if (DataUtils.arraysEqual(component, this.values[i].getValue()))\n        return true;\n    }\n  }\n  \n  return false;\n};\n\n/**\n * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.\n * A component is less if it is shorter, otherwise if equal length do a byte comparison.\n */\nExclude.compareComponents = function(component1, component2) \n{\n  if (typeof component1 == \'object\' && component1 instanceof Name.Component)\n    component1 = component1.getValue();\n  if (typeof component2 == \'object\' && component2 instanceof Name.Component)\n    component2 = component2.getValue();\n\n  if (component1.length < component2.length)\n    return -1;\n  if (component1.length > component2.length)\n    return 1;\n  \n  for (var i = 0; i < component1.length; ++i) {\n    if (component1[i] < component2[i])\n      return -1;\n    if (component1[i] > component2[i])\n      return 1;\n  }\n\n  return 0;\n};\n\n})()\n},{"./buffer.js":28,"./encoding/binary-xml-decoder.js":55,"./encoding/binary-xml-encoder.js":56,"./encoding/data-utils.js":21,"./name.js":9,"./util/ndn-protoco-id-tags.js":57}],14:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data MetaInfo object.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Blob = require(\'./util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar Name = require(\'./name.js\').Name;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar NDNTime = require(\'./util/ndn-time.js\').NDNTime;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar LOG = require(\'./log.js\').Log.LOG;\n\nvar ContentType = {\n  BLOB:0,\n  // ContentType DATA is deprecated.  Use ContentType.BLOB .\n  DATA:0, \n  LINK:1, \n  KEY: 2, \n  // ContentType ENCR, GONE and NACK are not supported in NDN-TLV encoding and are deprecated.\n  ENCR:3, \n  GONE:4, \n  NACK:5\n};\n\nexports.ContentType = ContentType;\n\n/**\n * Create a new MetaInfo with the optional values.\n * @constructor\n */\nvar MetaInfo = function MetaInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID, skipSetFields) \n{\n  if (typeof publisherOrMetaInfo === \'object\' && \n      publisherOrMetaInfo instanceof MetaInfo) {\n    // Copy values.\n    var metaInfo = publisherOrMetaInfo;\n    this.publisher = metaInfo.publisher;\n    this.timestamp = metaInfo.timestamp;\n    this.type = metaInfo.type;\n    this.locator = metaInfo.locator == null ? \n      new KeyLocator() : new KeyLocator(metaInfo.locator);\n    this.freshnessSeconds = metaInfo.freshnessSeconds;\n    this.finalBlockID = metaInfo.finalBlockID;\n  }\n  else {\n    this.publisher = publisherOrMetaInfo; //publisherPublicKeyDigest\n    this.timestamp = timestamp; // NDN Time\n    this.type = type; // ContentType\n    this.locator = locator == null ? new KeyLocator() : new KeyLocator(locator);\n    this.freshnessSeconds = freshnessSeconds; // Integer\n    this.finalBlockID = finalBlockID; //byte array\n\n    if (!skipSetFields)\n      this.setFields();\n  }\n};\n\nexports.MetaInfo = MetaInfo;\n\n/**\n * Get the content type.\n * @returns {an int from ContentType} The content type.\n */\nMetaInfo.prototype.getType = function()\n{\n  return this.type;\n};\n\n/**\n * Get the freshness period.\n * @returns {number} The freshness period in milliseconds, or null if not \n * specified.\n */\nMetaInfo.prototype.getFreshnessPeriod = function()\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (this.freshnessSeconds == null || this.freshnessSeconds < 0)\n    return null;\n  else\n    // Convert to milliseconds.\n    return this.freshnessSeconds * 1000.0;\n};\n\n/**\n * Get the final block ID.\n * @returns {Buffer} The final block ID or null if not specified.\n */\nMetaInfo.prototype.getFinalBlockID = function()\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  return this.finalBlockID;\n};\n\n/**\n * Set the content type.\n * @param {an int from ContentType} type The content type.  If null, this \n * uses ContentType.BLOB.\n */\nMetaInfo.prototype.setType = function(type)\n{\n  this.type = type == null || type < 0 ? ContentType.BLOB : type;\n};\n\n/**\n * Set the freshness period.\n * @param {type} freshnessPeriod The freshness period in milliseconds, or null\n * for not specified.\n */\nMetaInfo.prototype.setFreshnessPeriod = function(freshnessPeriod)\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (freshnessPeriod == null || freshnessPeriod < 0)\n    this.freshnessSeconds = null;\n  else\n    // Convert from milliseconds.\n    this.freshnessSeconds = freshnessPeriod / 1000.0;\n};\n\nMetaInfo.prototype.setFinalBlockID = function(finalBlockID)\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  if (finalBlockID == null)\n    this.finalBlockID = null;\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Blob)\n    this.finalBlockID = finalBlockID.buf();\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Name.Component)\n    this.finalBlockID = finalBlockID.getValue();\n  else \n    this.finalBlockID = new customBuf(finalBlockID);\n};\n\nMetaInfo.prototype.setFields = function() \n{\n  var key = globalKeyManager.getKey();\n  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());\n\n  var d = new Date();\n    \n  var time = d.getTime();  \n\n  this.timestamp = new NDNTime(time);\n    \n  if (LOG > 4) console.log(\'TIME msec is\');\n\n  if (LOG > 4) console.log(this.timestamp.msec);\n\n  //DATA\n  this.type = ContentType.BLOB;\n  \n  if (LOG > 4) console.log(\'PUBLIC KEY TO WRITE TO DATA PACKET IS \');\n  if (LOG > 4) console.log(key.publicToDER().toString(\'hex\'));\n\n  this.locator = new KeyLocator(key.getKeyID(), KeyLocatorType.KEY_LOCATOR_DIGEST);\n};\n\nMetaInfo.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    if (LOG > 4) console.log(\'DECODING PUBLISHER KEY\');\n    this.publisher = new PublisherPublicKeyDigest();\n    this.publisher.from_ndnb(decoder);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {\n    if (LOG > 4) console.log(\'DECODING TIMESTAMP\');\n    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Type)) {\n    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);\n    \n    if (LOG > 4) console.log(\'Binary Type of of Signed Info is \'+binType);\n\n    this.type = binType;\n    \n    //TODO Implement type of Key Reading\n    if (null == this.type)\n      throw new Error("Cannot parse signedInfo type: bytes.");\n  } \n  else\n    this.type = ContentType.DATA; // default\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n    if (LOG > 4) console.log(\'FRESHNESS IN SECONDS IS \'+ this.freshnessSeconds);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {\n    if (LOG > 4) console.log(\'DECODING FINAL BLOCKID\');\n    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {\n    if (LOG > 4) console.log(\'DECODING KEY LOCATOR\');\n    this.locator = new KeyLocator();\n    this.locator.from_ndnb(decoder);\n  }\n      \n  decoder.readElementClose();\n};\n\n/**\n * Encode this MetaInfo in ndnb, using the given keyLocator instead of the\n * locator in this object.\n * @param {BinaryXMLEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nMetaInfo.prototype.to_ndnb = function(encoder, keyLocator)  {\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.publisher) {\n    // We have a publisherPublicKeyDigest, so use it.\n    if (LOG > 3) console.log(\'ENCODING PUBLISHER KEY\' + this.publisher.publisherPublicKeyDigest);\n    this.publisher.to_ndnb(encoder);\n  }\n  else {\n    if (null != keyLocator &&\n        keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n        keyLocator.getKeyData() != null &&\n        keyLocator.getKeyData().length > 0)\n      // We have a TLV-style KEY_LOCATOR_DIGEST, so encode as the\n      //   publisherPublicKeyDigest.\n      encoder.writeDTagElement\n        (NDNProtocolDTags.PublisherPublicKeyDigest, keyLocator.getKeyData());\n  }\n\n  if (null != this.timestamp)\n    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);\n  \n  if (null != this.type && this.type != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);\n  \n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  if (null != this.finalBlockID)\n    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);\n\n  if (null != keyLocator)\n    keyLocator.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nMetaInfo.prototype.valueToType = function() \n{\n  return null;  \n};\n\nMetaInfo.prototype.getElementLabel = function() { \n  return NDNProtocolDTags.SignedInfo;\n};\n\nMetaInfo.prototype.validate = function() \n{\n  // We don\'t do partial matches any more, even though encoder/decoder\n  // is still pretty generous.\n  if (null == this.timestamp)\n    return false;\n  return true;\n};\n\n/**\n * @deprecated Use new MetaInfo.\n */\nvar SignedInfo = function SignedInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID) \n{\n  // Call the base constructor.\n  MetaInfo.call(this, publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID); \n}\n\n// Set skipSetFields true since we only need the prototype functions.\nSignedInfo.prototype = new MetaInfo(null, null, null, null, null, null, true);\n\nexports.SignedInfo = SignedInfo;\n\n})()\n},{"./buffer.js":28,"./encoding/binary-xml-decoder.js":55,"./encoding/binary-xml-encoder.js":56,"./key-locator.js":16,"./log.js":59,"./name.js":9,"./publisher-public-key-digest.js":17,"./security/key-manager.js":26,"./util/blob.js":23,"./util/ndn-protoco-id-tags.js":57,"./util/ndn-time.js":25}],60:[function(require,module,exports){\nrequire=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module \'"+r+"\'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],2:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require(\'util\');\nvar Buffer = require("buffer").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError\'s when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = \'AssertionError\';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return \'\' + value;\n  }\n  if (typeof value === \'number\' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === \'function\' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == \'string\') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + \':\', this.message].join(\' \');\n  } else {\n    return [\n      this.name + \':\',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(\' \');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError\'s constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, \'==\', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \'==\', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \'!=\', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'deepEqual\', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == \'object\',\n  // equivalence is determined by ==.\n  } else if (typeof actual != \'object\' && typeof expected != \'object\') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \'prototype\' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == \'[object Arguments]\';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical \'prototype\' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I\'ve managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn\'t\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'notDeepEqual\', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \'===\', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \'!==\', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === \'string\') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? \' (\' + expected.name + \').\' : \'.\') +\n            (message ? \' \' + message : \'.\');\n\n  if (shouldThrow && !actual) {\n    fail(\'Missing expected exception\' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(\'Got unwanted exception\' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){\nmodule.exports=require(\'q9TxCC\');\n},{}],"q9TxCC":[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n    case \'binary\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nSlowBuffer.prototype.fill = function(value, start, end) {\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this.parent[i + this.offset] = subject.readUInt8(i);\n        }\n        else {\n          this.parent[i + this.offset] = subject[i];\n        }\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1];\n    }\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer.parent[buffer.offset + offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){\nvar events = require(\'events\');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === \'[object Date]\'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === \'[object RegExp]\'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { \'bold\' : [1, 22],\n          \'italic\' : [3, 23],\n          \'underline\' : [4, 24],\n          \'inverse\' : [7, 27],\n          \'white\' : [37, 39],\n          \'grey\' : [90, 39],\n          \'black\' : [30, 39],\n          \'blue\' : [34, 39],\n          \'cyan\' : [36, 39],\n          \'green\' : [32, 39],\n          \'magenta\' : [35, 39],\n          \'red\' : [31, 39],\n          \'yellow\' : [33, 39] };\n\n    var style =\n        { \'special\': \'cyan\',\n          \'number\': \'blue\',\n          \'boolean\': \'yellow\',\n          \'undefined\': \'grey\',\n          \'null\': \'bold\',\n          \'string\': \'green\',\n          \'date\': \'magenta\',\n          // "name": intentionally not styling\n          \'regexp\': \'red\' }[styleType];\n\n    if (style) {\n      return \'\\033[\' + styles[style][0] + \'m\' + str +\n             \'\\033[\' + styles[style][1] + \'m\';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === \'function\' &&\n        // Filter out the util module, it\'s inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case \'undefined\':\n        return stylize(\'undefined\', \'undefined\');\n\n      case \'string\':\n        var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                                 .replace(/\'/g, "\\\\\'")\n                                                 .replace(/\\\\"/g, \'"\') + \'\\\'\';\n        return stylize(simple, \'string\');\n\n      case \'number\':\n        return stylize(\'\' + value, \'number\');\n\n      case \'boolean\':\n        return stylize(\'\' + value, \'boolean\');\n    }\n    // For some reason typeof null is "object", so special case here.\n    if (value === null) {\n      return stylize(\'null\', \'null\');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === \'function\' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        var name = value.name ? \': \' + value.name : \'\';\n        return stylize(\'[Function\' + name + \']\', \'special\');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), \'date\');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = \'Array\';\n      braces = [\'[\', \']\'];\n    } else {\n      type = \'Object\';\n      braces = [\'{\', \'}\'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === \'function\') {\n      var n = value.name ? \': \' + value.name : \'\';\n      base = (isRegExp(value)) ? \' \' + value : \' [Function\' + n + \']\';\n    } else {\n      base = \'\';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = \' \' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        return stylize(\'[Object]\', \'special\');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Getter/Setter]\', \'special\');\n          } else {\n            str = stylize(\'[Getter]\', \'special\');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Setter]\', \'special\');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = \'[\' + key + \']\';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf(\'\\n\') > -1) {\n            if (isArray(value)) {\n              str = str.split(\'\\n\').map(function(line) {\n                return \'  \' + line;\n              }).join(\'\\n\').substr(2);\n            } else {\n              str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n                return \'   \' + line;\n              }).join(\'\\n\');\n            }\n          }\n        } else {\n          str = stylize(\'[Circular]\', \'special\');\n        }\n      }\n      if (typeof name === \'undefined\') {\n        if (type === \'Array\' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\'\' + key);\n        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, \'name\');\n        } else {\n          name = name.replace(/\'/g, "\\\\\'")\n                     .replace(/\\\\"/g, \'"\')\n                     .replace(/(^"|"$)/g, "\'");\n          name = stylize(name, \'string\');\n        }\n      }\n\n      return name + \': \' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === \'\' ? \'\' : base + \'\\n \') +\n               \' \' +\n               output.join(\',\\n  \') +\n               \' \' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === \'undefined\' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === \'object\' && Object.prototype.toString.call(re) === \'[object RegExp]\');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== \'object\') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { \'__proto__\' : null };\n    }\n    else {\n        if (typeof prototype !== \'object\') {\n            throw new TypeError(\n                \'typeof prototype[\' + (typeof prototype) + \'] != \\\'object\\\'\'\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== \'undefined\' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== \'string\') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== \'object\') {\n      str += \' \' + x;\n    } else {\n      str += \' \' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{"events":6}],5:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],7:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],8:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            if (ev.source === window && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],6:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === \'function\'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === \'[object Array]\'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled \'error\' event\n      } else {\n        throw new Error("Uncaught, unspecified \'error\' event.");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == \'function\') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'addListener only takes instances of Function\');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == "newListeners"! Before\n  // adding it to the listeners, first emit "newListeners".\n  this.emit(\'newListener\', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error(\'(node) warning: possible EventEmitter memory \' +\n                      \'leak detected. %d listeners added. \' +\n                      \'Use emitter.setMaxListeners() to increase limit.\',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'removeListener only takes instances of Function\');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n})(require("__browserify_process"))\n},{"__browserify_process":8}],4:[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        this.parent[i + this.offset] = subject[i];\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    val |= buffer.parent[buffer.offset + offset + 1];\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset + 1] << 16;\n    val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    val = buffer.parent[buffer.offset + offset + 2] << 16;\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  buffer.parent[buffer.offset + offset] = value;\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;\n  } else {\n    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset] = value & 0x00ff;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset + 3] = value & 0xff;\n  } else {\n    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset] = value & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}]},{},[])\n;;module.exports=require("buffer-browserify")\n\n},{}],13:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar SignedBlob = require(\'./util/signed-blob.js\').SignedBlob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Signature = require(\'./signature.js\').Signature;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\n/**\n * Create a new Data with the optional values.  There are 2 forms of constructor:\n * new Data([name] [, content]);\n * new Data(name, metaInfo [, content]);\n * \n * @constructor\n * @param {Name} name\n * @param {MetaInfo} metaInfo\n * @param {Buffer} content\n */\nvar Data = function Data(name, metaInfoOrContent, arg3) \n{\n  if (typeof name === \'string\')\n    this.name = new Name(name);\n  else\n    this.name = typeof name === \'object\' && name instanceof Name ?\n       new Name(name) : new Name();\n\n  var metaInfo;\n  var content;\n  if (typeof metaInfoOrContent === \'object\' && \n      metaInfoOrContent instanceof MetaInfo) {\n    metaInfo = metaInfoOrContent;\n    content = arg3;\n  }\n  else {\n    metaInfo = null;\n    content = metaInfoOrContent;\n  }\n    \n  // Use signedInfo instead of metaInfo for backward compatibility.\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n       new MetaInfo(metaInfo) : new MetaInfo();\n  \n  if (typeof content === \'string\') \n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else \n    this.content = content;\n  \n  this.signature = new Signature();\n  \n  this.wireEncoding = SignedBlob();\n};\n\nexports.Data = Data;\n\n/**\n * Get the data packet\'s name.\n * @returns {Name} The name.\n */\nData.prototype.getName = function() \n{\n  return this.name;\n};\n\n/**\n * Get the data packet\'s meta info.\n * @returns {MetaInfo} The meta info.\n */\nData.prototype.getMetaInfo = function() \n{\n  return this.signedInfo;\n};\n\n/**\n * Get the data packet\'s signature object.\n * @returns {Signature} The signature object.\n */\nData.prototype.getSignature = function() \n{\n  return this.signature;\n};\n\n/**\n * Get the data packet\'s content.\n * @returns {Buffer} The content as a customBuf, which is null if unspecified.\n */\nData.prototype.getContent = function() \n{\n  return this.content;\n};\n\n/**\n * Set name to a copy of the given Name.\n * @param {Name} name The Name which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setName = function(name) \n{\n  this.name = typeof name === \'object\' && name instanceof Name ?\n    new Name(name) : new Name();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set metaInfo to a copy of the given MetaInfo.\n * @param {MetaInfo} metaInfo The MetaInfo which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setMetaInfo = function(metaInfo) \n{\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n    new MetaInfo(metaInfo) : new MetaInfo();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the signature to a copy of the given signature.\n * @param {Signature} signature The signature object which is cloned.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setSignature = function(signature) \n{\n  this.signature = typeof signature === \'object\' && signature instanceof Signature ?\n    signature.clone() : new Signature();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the content to the given value.\n * @param {type} content The array this is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setContent = function(content) \n{\n  if (typeof content === \'string\') \n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else \n    this.content = new customBuf(content);\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\nData.prototype.sign = function(wireFormat) \n{\n  var rs = require(\'buffer\')\n  var ss = require(\'./crypto.js\')\n  console.log(Buffer, ss, rs)\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n \n  if (this.getSignatureOrMetaInfoKeyLocator() == null ||\n      this.getSignatureOrMetaInfoKeyLocator().getType() == null)\n    this.getMetaInfo().setFields();\n  \n  if (this.wireEncoding == null || this.wireEncoding.isNull()) {\n    // Need to encode to set wireEncoding.\n    // Set an initial empty signature so that we can encode.\n    this.getSignature().setSignature(new customBuf(128));\n    this.wireEncode(wireFormat);\n  }\n  \n  var rsa = require("./crypto.js").createSign(\'RSA-SHA256\');\n  rsa.update(this.wireEncoding.signedBuf());\n    \n  var sig = new customBuf(rsa.sign(globalKeyManager.privateKey));\n  this.signature.signature = sig;\n};\n\nData.prototype.verify = function(/*Key*/ key) \n{\n  if (key == null || key.publicKeyPem == null)\n    throw new Error(\'Cannot verify Data without a public key.\');\n\n  if (this.wireEncoding == null || this.wireEncoding.isNull())\n    // Need to encode to set wireEncoding.\n    this.wireEncode();\n  var verifier = require(\'./crypto.js\').createVerify(\'RSA-SHA256\');\n  verifier.update(this.wireEncoding.signedBuf());\n  return verifier.verify(key.publicKeyPem, this.signature.signature);\n};\n\nData.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };\n\n/**\n * Encode this Data for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {SignedBlob} The encoded buffer in a SignedBlob object.\n */\nData.prototype.wireEncode = function(wireFormat) \n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var result = wireFormat.encodeData(this);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  this.wireEncoding = new SignedBlob\n    (result.encoding, result.signedPortionBeginOffset, \n     result.signedPortionEndOffset);\n  return this.wireEncoding;\n};\n\n/**\n * Decode the input using a particular wire format and update this Data.\n * @param {Blob|Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nData.prototype.wireDecode = function(input, wireFormat) \n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ? \n                     input.buf() : input;\n  var result = wireFormat.decodeData(this, decodeBuffer);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  // In the Blob constructor, set copy true, but if input is already a Blob, it \n  //   won\'t copy.\n  this.wireEncoding = new SignedBlob\n    (new Blob(input, true), result.signedPortionBeginOffset, \n     result.signedPortionEndOffset);\n};\n\n/**\n * If getSignature() has a key locator, return it.  Otherwise, use\n * the key locator from getMetaInfo() for backward compatibility and print\n * a warning to console.log that the key locator has moved to the Signature\n * object.  If neither has a key locator, return an empty key locator.\n * When we stop supporting the key locator in MetaInfo, this function is not\n * necessary and we will just use the key locator in the Signature.\n * @returns {KeyLocator} The key locator to use.\n */\nData.prototype.getSignatureOrMetaInfoKeyLocator = function()\n{\n  if (this.signature != null && this.signature.getKeyLocator() != null &&\n      this.signature.getKeyLocator().getType() != null &&\n      this.signature.getKeyLocator().getType() >= 0)\n    // The application is using the key locator in the correct object.\n    return this.signature.getKeyLocator();\n  \n  if (this.signedInfo != null && this.signedInfo.locator != null &&\n      this.signedInfo.locator.type != null &&\n      this.signedInfo.locator.type >= 0) {\n    //console.log("WARNING: Temporarily using the key locator found in the MetaInfo - expected it in the Signature object.");\n    //console.log("WARNING: In the future, the key locator in the Signature object will not be supported.");\n    return this.signedInfo.locator;\n  }\n  \n  // Return the empty key locator from the Signature object if possible.\n  if (this.signature != null && this.signature.getKeyLocator() != null)\n    return this.signature.getKeyLocator();\n  else\n    return new KeyLocator();\n}\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeData.\n */\nData.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  BinaryXmlWireFormat.decodeData(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeData.\n */\nData.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeData(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nData.prototype.encode = function(wireFormat) \n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  return wireFormat.encodeData(this).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nData.prototype.decode = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  wireFormat.decodeData(this, input);\n};\n\n/**\n * @deprecated Use new Data.\n */\nvar ContentObject = function ContentObject(name, signedInfo, content) \n{\n  // Call the base constructor.\n  Data.call(this, name, signedInfo, content); \n}\n\nContentObject.prototype = new Data();\n\nexports.ContentObject = ContentObject;\n\n})(require("__browserify_buffer").Buffer)\n},{"./buffer.js":28,"./crypto.js":28,"./encoding/binary-xml-encoder.js":56,"./encoding/binary-xml-wire-format.js":19,"./encoding/data-utils.js":21,"./encoding/wire-format.js":18,"./key-locator.js":16,"./meta-info.js":14,"./name.js":9,"./security/key-manager.js":26,"./signature.js":63,"./util/blob.js":23,"./util/ndn-protoco-id-tags.js":57,"./util/signed-blob.js":62,"__browserify_buffer":60,"buffer":61}],15:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Key Objects\n */\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\n/**\n * Key\n */\nvar Key = function Key() \n{\n  this.publicKeyDer = null;     // customBuf\n  this.publicKeyDigest = null;  // customBuf\n  this.publicKeyPem = null;     // String\n  this.privateKeyPem = null;    // String\n};\n\nexports.Key = Key;\n\n/**\n * Helper functions to read Key fields\n * TODO: generateRSA()\n */\n\nKey.prototype.publicToDER = function() \n{\n  return this.publicKeyDer;  // customBuf\n};\n\nKey.prototype.privateToDER = function() \n{\n  // Remove the \'-----XXX-----\' from the beginning and the end of the key\n  // and also remove any \\n in the key string\n  var lines = this.privateKeyPem.split(\'\\n\');\n  priKey = "";\n  for (var i = 1; i < lines.length - 1; i++)\n    priKey += lines[i];\n  \n  return new customBuf(priKey, \'base64\');    \n};\n\nKey.prototype.publicToPEM = function() \n{\n  return this.publicKeyPem;\n};\n\nKey.prototype.privateToPEM = function() \n{\n  return this.privateKeyPem;\n};\n\nKey.prototype.getKeyID = function() \n{\n  return this.publicKeyDigest;\n};\n\nexports.Key = Key;\n\nKey.prototype.readDerPublicKey = function(/*Buffer*/pub_der) \n{\n  if (LOG > 4) console.log("Encode DER public key:\\n" + pub_der.toString(\'hex\'));\n\n  this.publicKeyDer = pub_der;\n\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(this.publicKeyDer);\n  this.publicKeyDigest = new customBuf(hash.digest());\n    \n  var keyStr = pub_der.toString(\'base64\'); \n  var keyPem = "-----BEGIN PUBLIC KEY-----\\n";\n  for (var i = 0; i < keyStr.length; i += 64)\n  keyPem += (keyStr.substr(i, 64) + "\\n");\n  keyPem += "-----END PUBLIC KEY-----";\n  this.publicKeyPem = keyPem;\n\n  if (LOG > 4) console.log("Convert public key to PEM format:\\n" + this.publicKeyPem);\n};\n\n/**\n * Load RSA key pair from PEM-encoded strings.\n * Will throw an Error if both \'pub\' and \'pri\' are null.\n */\nKey.prototype.fromPemString = function(pub, pri) \n{\n  if (pub == null && pri == null)\n    throw new Error(\'Cannot create Key object if both public and private PEM string is empty.\');\n\n  // Read public key\n  if (pub != null) {\n    this.publicKeyPem = pub;\n    if (LOG > 4) console.log("Key.publicKeyPem: \\n" + this.publicKeyPem);\n  \n    // Remove the \'-----XXX-----\' from the beginning and the end of the public key\n    // and also remove any \\n in the public key string\n    var lines = pub.split(\'\\n\');\n    pub = "";\n    for (var i = 1; i < lines.length - 1; i++)\n      pub += lines[i];\n    this.publicKeyDer = new customBuf(pub, \'base64\');\n    if (LOG > 4) console.log("Key.publicKeyDer: \\n" + this.publicKeyDer.toString(\'hex\'));\n  \n    var hash = require("./crypto.js").createHash(\'sha256\');\n    hash.update(this.publicKeyDer);\n    this.publicKeyDigest = new customBuf(hash.digest());\n    if (LOG > 4) console.log("Key.publicKeyDigest: \\n" + this.publicKeyDigest.toString(\'hex\'));\n  }\n    \n  // Read private key\n  if (pri != null) {\n    this.privateKeyPem = pri;\n    if (LOG > 4) console.log("Key.privateKeyPem: \\n" + this.privateKeyPem);\n  }\n};\n\nKey.prototype.fromPem = Key.prototype.fromPemString;\n\n/**\n * Static method that create a Key object.\n * Parameter \'obj\' is a JSON object that has two properties:\n *   pub: the PEM string for the public key\n *   pri: the PEM string for the private key\n * Will throw an Error if both obj.pub and obj.pri are null.\n */\nKey.createFromPEM = function(obj) \n{\n    var key = new Key();\n    key.fromPemString(obj.pub, obj.pri);\n    return key;\n};\n\n})()\n},{"./buffer.js":28,"./crypto.js":28,"./log.js":59}],16:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN KeyLocator object.\n */\n\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherID = require(\'./publisher-id.js\').PublisherID;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * KeyLocator\n */\nvar KeyLocatorType = {\n  KEYNAME: 1,\n  KEY_LOCATOR_DIGEST: 2,\n  KEY: 3,\n  CERTIFICATE: 4\n};\n\nexports.KeyLocatorType = KeyLocatorType;\n\n/**\n * @constructor\n */\nvar KeyLocator = function KeyLocator(input,type) \n{ \n  if (typeof input === \'object\' && input instanceof KeyLocator) {\n    // Copy from the input KeyLocator.\n    this.type = input.type;\n    this.keyName = new KeyName();\n    if (input.keyName != null) {\n      this.keyName.contentName = input.keyName.contentName == null ? \n        null : new Name(input.keyName.contentName);\n      this.keyName.publisherID = input.keyName.publisherID;\n    }\n    this.keyData = input.keyData == null ? null : new customBuf(input.keyData);\n    this.publicKey = input.publicKey == null ? null : new customBuf(input.publicKey);\n    this.certificate = input.certificate == null ? null : new customBuf(input.certificate);\n  }\n  else {\n    this.type = type;\n    this.keyName = new KeyName();\n\n    if (type == KeyLocatorType.KEYNAME)\n      this.keyName = input;\n    else if (type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n      this.keyData = new customBuf(input);\n    else if (type == KeyLocatorType.KEY) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.publicKey = this.keyData;\n    }\n    else if (type == KeyLocatorType.CERTIFICATE) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.certificate = this.keyData;\n    }\n  }\n};\n\nexports.KeyLocator = KeyLocator;\n\n/**\n * Get the key locator type. If KeyLocatorType.KEYNAME, you may also\n * getKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you may also\n * getKeyData() to get the digest.\n * @returns {number} The key locator type, or null if not specified.\n */\nKeyLocator.prototype.getType = function() { return this.type; };\n\n/**\n * Get the key name.  This is meaningful if getType() is KeyLocatorType.KEYNAME.\n * @returns {Name} The key name. If not specified, the Name is empty.\n */\nKeyLocator.prototype.getKeyName = function() \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  if (this.keyName.contentName == null)\n    this.keyName.contentName = new Name();\n  \n  return this.keyName.contentName;\n};\n\n/**\n * Get the key data. If getType() is KeyLocatorType.KEY_LOCATOR_DIGEST, this is \n * the digest bytes. If getType() is KeyLocatorType.KEY, this is the DER \n * encoded public key. If getType() is KeyLocatorType.CERTIFICATE, this is the \n * DER encoded certificate. \n * @returns {Buffer} The key data, or null if not specified.\n */\nKeyLocator.prototype.getKeyData = function() \n{ \n  if (this.type == KeyLocatorType.KEY)\n    return this.publicKey;\n  else if (this.type == KeyLocatorType.CERTIFICATE)\n    return this.certificate;\n  else\n    return this.keyData;\n};\n\n/**\n * Set the key locator type.  If KeyLocatorType.KEYNAME, you must also\n * setKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you must also\n * setKeyData() to the digest.\n * @param {number} type The key locator type.  If null, the type is unspecified.\n */\nKeyLocator.prototype.setType = function(type) { this.type = type; }; \n\n/**\n * Set key name to a copy of the given Name.  This is the name if getType() \n * is KeyLocatorType.KEYNAME.\n * @param {Name} name The key name which is copied.\n */\nKeyLocator.prototype.setKeyName = function(name) \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  \n  this.keyName.contentName = typeof name === \'object\' && name instanceof Name ?\n                             new Name(name) : new Name(); \n}; \n\n/**\n * Set the key data to the given value. This is the digest bytes if getType() is \n * KeyLocatorType.KEY_LOCATOR_DIGEST.\n * @param {Buffer} keyData The array with the key data bytes.\n */\nKeyLocator.prototype.setKeyData = function(keyData)\n{\n  var value = keyData;\n  if (value != null)\n    // Make a copy.\n    value = new customBuf(value);\n  \n  this.keyData = value;\n  // Set for backwards compatibility.\n  this.publicKey = value;\n  this.certificate = value;\n};\n\n/**\n * Clear the keyData and set the type to none.\n */\nKeyLocator.prototype.clear = function() \n{\n  this.type = null;\n  this.keyName = null;\n  this.keyData = null;\n  this.publicKey = null;\n  this.certificate = null;\n};\n\nKeyLocator.prototype.from_ndnb = function(decoder) {\n\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Key)) \n  {\n    try {\n      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);\n      // This is a DER-encoded SubjectPublicKeyInfo.\n      \n      //TODO FIX THIS, This should create a Key Object instead of keeping bytes\n\n      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);\n      this.type = KeyLocatorType.KEY;    \n\n      if (LOG > 4) console.log(\'PUBLIC KEY FOUND: \'+ this.publicKey);\n    } \n    catch (e) {\n      throw new Error("Cannot parse key: ", e);\n    } \n\n    if (null == this.publicKey)\n      throw new Error("Cannot parse key: ");\n  } \n  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {\n    try {\n      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);\n      \n      /*\n       * Certificates not yet working\n       */\n      \n      this.certificate = encodedCert;\n      this.type = KeyLocatorType.CERTIFICATE;\n\n      if (LOG > 4) console.log(\'CERTIFICATE FOUND: \'+ this.certificate);      \n    } \n    catch (e) {\n      throw new Error("Cannot decode certificate: " +  e);\n    }\n    if (null == this.certificate)\n      throw new Error("Cannot parse certificate! ");\n  } else  {\n    this.type = KeyLocatorType.KEYNAME;\n    \n    this.keyName = new KeyName();\n    this.keyName.from_ndnb(decoder);\n  }\n  decoder.readElementClose();\n};  \n\nKeyLocator.prototype.to_ndnb = function(encoder) \n{\n  if (LOG > 4) console.log(\'type is is \' + this.type);\n\n  if (this.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n    // encodeSignedInfo already encoded this as the publisherPublicKeyDigest,\n    //   so do nothing here.\n    return;\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (this.type == KeyLocatorType.KEY) {\n    if (LOG > 5) console.log(\'About to encode a public key\' +this.publicKey);\n    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);  \n  } \n  else if (this.type == KeyLocatorType.CERTIFICATE) {  \n    try {\n      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);\n    } \n    catch (e) {\n      throw new Error("CertificateEncodingException attempting to write key locator: " + e);\n    }    \n  } \n  else if (this.type == KeyLocatorType.KEYNAME)\n    this.keyName.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyLocator.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.KeyLocator; \n};\n\n/**\n * KeyName is only used by KeyLocator.\n * @constructor\n */\nvar KeyName = function KeyName() \n{\n  this.contentName = new Name();  //contentName\n  this.publisherID = this.publisherID;  //publisherID\n};\n\nexports.KeyName = KeyName;\n\nKeyName.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.contentName = new Name();\n  this.contentName.from_ndnb(decoder);\n  \n  if (LOG > 4) console.log(\'KEY NAME FOUND: \');\n  \n  if (PublisherID.peek(decoder)) {\n    this.publisherID = new PublisherID();\n    this.publisherID.from_ndnb(decoder);\n  }\n  \n  decoder.readElementClose();\n};\n\nKeyName.prototype.to_ndnb = function(encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  this.contentName.to_ndnb(encoder);\n  if (null != this.publisherID)\n    this.publisherID.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nKeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };\n\n\n})()\n},{"./buffer.js":28,"./log.js":59,"./name.js":9,"./publisher-id.js":64,"./util/ndn-protoco-id-tags.js":57}],17:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents PublisherPublicKeyDigest Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd) \n{ \n this.PUBLISHER_ID_LEN = 512/8;\n this.publisherPublicKeyDigest = pkd;\n};\n\nexports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;\n\nPublisherPublicKeyDigest.prototype.from_ndnb = function(decoder) \n{\n  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'Publisher public key digest is \' + this.publisherPublicKeyDigest);\n\n  if (null == this.publisherPublicKeyDigest)\n    throw new Error("Cannot parse publisher key digest.");\n    \n  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)\n\n  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {\n    if (LOG > 0)\n      console.log(\'LENGTH OF PUBLISHER ID IS WRONG! Expected \' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);\n      \n    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;    \n  }\n};\n\nPublisherPublicKeyDigest.prototype.to_ndnb= function(encoder) \n{\n  //TODO Check that the ByteArray for the key is present\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  if (LOG > 3) console.log(\'PUBLISHER KEY DIGEST IS\'+this.publisherPublicKeyDigest);\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);\n};\n  \nPublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };\n\nPublisherPublicKeyDigest.prototype.validate = function() \n{\n    return null != this.publisherPublicKeyDigest;\n};\n\n},{"./log.js":59,"./util/ndn-protoco-id-tags.js":57}],28:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n// Library namespace\nvar ndn = ndn || {};\n\nvar exports = ndn;\n\nvar ASN1HEX = require(\'../contrib/securityLib/asn1hex-1.1.js\')\nvar KJUR = require(\'../contrib/securityLib/crypto-1.0.js\')\nvar RSAKey = require(\'../contrib/securityLib/rsasign-1.2.js\')\nvar b64tohex = require(\'../contrib/securityLib/base64.js\').b64tohex\n// Factory method to create node.js compatible buffer objects\nvar customBuf = function customBuf(data, format) \n{\n  var obj;\n\n  if (typeof data == \'number\')\n    obj = new Uint8Array(data);\n  else if (typeof data == \'string\') {\n    if (format == null || format == \'utf8\') {\n      var utf8 = customBuf.str2rstr_utf8(data);\n      obj = new Uint8Array(utf8.length);\n      for (var i = 0; i < utf8.length; i++)\n        obj[i] = utf8.charCodeAt(i);\n    } \n    else if (format == \'binary\') {\n      obj = new Uint8Array(data.length);\n      for (var i = 0; i < data.length; i++)\n        obj[i] = data.charCodeAt(i);\n    } \n    else if (format == \'hex\') {\n      obj = new Uint8Array(Math.floor(data.length / 2));\n      var i = 0;\n      data.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else if (format == \'base64\') {\n      var hex = b64tohex(data);\n      obj = new Uint8Array(Math.floor(hex.length / 2));\n      var i = 0;\n      hex.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else \n      throw new Error(\'Buffer: unknown encoding format \' + format);\n  } \n  else if (typeof data == \'object\' && (data instanceof Uint8Array || data instanceof customBuf)) {\n    // The second argument is a boolean for "copy", default true.\n    if (format == false)\n      obj = data.subarray(0);\n    else\n      obj = new Uint8Array(data);\n  }\n  else if (typeof data == \'object\' && data instanceof ArrayBuffer)\n    // Copy.\n    obj = new Uint8Array(data);\n  else if (typeof data == \'object\')\n    // Assume component is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    obj = new Uint8Array(data);\n  else\n    throw new Error(\'Buffer: unknown data type.\');\n\n  try {\n    obj.__proto__ = customBuf.prototype;\n  } catch(ex) {\n    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);\n  }\n\n  obj.__proto__.toString = function(encoding) {\n    if (encoding == null) {\n      var ret = "";\n      for (var i = 0; i < this.length; i++)\n        ret += String.fromCharCode(this[i]);\n      return ret;\n    }\n\n    var ret = "";\n    for (var i = 0; i < this.length; i++)\n      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);\n\n    if (encoding == \'hex\')\n      return ret;\n    else if (encoding == \'base64\')\n      return hex2b64(ret);\n    else\n      throw new Error(\'Buffer.toString: unknown encoding format \' + encoding);\n  };\n\n  obj.__proto__.slice = function(begin, end) {\n    if (end !== undefined)\n      return new customBuf(this.subarray(begin, end), false);\n    else\n      return new customBuf(this.subarray(begin), false);\n  };\n\n  obj.__proto__.copy = function(target, targetStart) {\n    if (targetStart !== undefined)\n      target.set(this, targetStart);\n    else\n      target.set(this);\n  };\n\n  return obj;\n};\n\ncustomBuf.prototype = Uint8Array.prototype;\n\ncustomBuf.concat = function(arrays) \n{\n  var totalLength = 0;\n  for (var i = 0; i < arrays.length; ++i)\n    totalLength += arrays[i].length;\n    \n  var result = new customBuf(totalLength);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; ++i) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return result;\n};\n\ncustomBuf.str2rstr_utf8 = function(input)\n{\n  var output = "";\n  var i = -1;\n  var x, y;\n\n  while (++i < input.length)\n  {\n    // Decode utf-16 surrogate pairs\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\n    {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    // Encode output as utf-8\n    if (x <= 0x7F)\n      output += String.fromCharCode(x);\n    else if (x <= 0x7FF)\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0xFFFF)\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0x1FFFFF)\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\n                                    0x80 | ((x >>> 12) & 0x3F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n  }\n  return output;\n};\n\n// Factory method to create hasher objects\nexports.createHash = function(alg) \n{\n  if (alg != \'sha256\')\n    throw new Error(\'createHash: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});\n\n  obj.update = function(buf) {\n    this.md.updateHex(buf.toString(\'hex\'));\n  };\n\n  obj.digest = function() {\n    return new customBuf(this.md.digest(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA signer objects\nexports.createSign = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  obj.sign = function(keypem) {\n    var rsa = new RSAKey();\n    rsa.readPrivateKeyFromPEMString(keypem);\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initSign(rsa);\n    for (var i = 0; i < this.arr.length; ++i)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n\n    return new customBuf(signer.sign(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA verifier objects\nexports.createVerify = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n    \n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  var getSubjectPublicKeyPosFromHex = function(hPub) {  \n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0); \n    if (a.length != 2) \n      return -1;\n    var pBitString = a[1];\n    if (hPub.substring(pBitString, pBitString + 2) != \'03\') \n      return -1;\n    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);\n    if (hPub.substring(pBitStringV, pBitStringV + 2) != \'00\') \n      return -1;\n    return pBitStringV + 2;\n  };\n\n  var readPublicDER = function(pub_der) {\n    var hex = pub_der.toString(\'hex\'); \n    var p = getSubjectPublicKeyPosFromHex(hex);\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);\n    if (a.length != 2) \n      return null;\n    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);\n    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);\n    var rsaKey = new RSAKey();\n    rsaKey.setPublic(hN, hE);\n    return rsaKey;\n  };\n\n  obj.verify = function(keypem, sig) {\n    var key = new ndn.Key();\n    key.fromPemString(keypem);\n\n    var rsa = readPublicDER(key.publicToDER());\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initVerifyByPublicKey(rsa);\n    for (var i = 0; i < this.arr.length; i++)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n    var hSig = sig.toString(\'hex\'); \n    return signer.verify(hSig);\n  };\n\n  return obj;\n};\n\nexports.randomBytes = function(size)\n{\n  // TODO: Use a cryptographic random number generator.\n  var result = new customBuf(size);\n  for (var i = 0; i < size; ++i)\n    result[i] = Math.floor(Math.random() * 256);\n  return result;\n};\n\nexports.Buffer = customBuf;\n\nmodule.exports = exports;\n\n})()\n},{"../contrib/securityLib/asn1hex-1.1.js":65,"../contrib/securityLib/base64.js":68,"../contrib/securityLib/crypto-1.0.js":67,"../contrib/securityLib/rsasign-1.2.js":66}],18:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like TlvWireFormat.\n * @constructor\n */\nvar WireFormat = function WireFormat() {\n};\n\nexports.WireFormat = WireFormat;\n\n/**\n * Encode interest and return the encoding.  Your derived class should override.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeInterest = function(interest) \n{\n  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as an interest and set the fields of the interest object. \n * Your derived class should override.\n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Encode data and return the encoding and signed offsets. Your derived class \n * should override.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeData = function(data) \n{\n  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as a data packet, set the fields in the data object, and return \n * the signed offsets.  Your derived class should override.\n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeData = function(data, input) \n{\n  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Set the static default WireFormat used by default encoding and decoding \n * methods.\n * @param wireFormat {a subclass of WireFormat} An object of a subclass of \n * WireFormat.\n */\nWireFormat.setDefaultWireFormat = function(wireFormat)\n{\n  WireFormat.defaultWireFormat = wireFormat;\n};\n\n/**\n * Return the default WireFormat used by default encoding and decoding methods \n * which was set with setDefaultWireFormat.\n * @returns {a subclass of WireFormat} The WireFormat object.\n */\nWireFormat.getDefaultWireFormat = function()\n{\n  return WireFormat.defaultWireFormat;\n};\n\n// Invoke TlvWireFormat to set the default format.\n// Since tlv-wire-format.js includes this file, put this at the bottom \n// to avoid problems with cycles of require.\nvar TlvWireFormat = require(\'./tlv-wire-format.js\').TlvWireFormat;\n\n})()\n},{"../buffer.js":28,"./tlv-wire-format.js":20}],19:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar Blob = require(\'../util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Name = require(\'../name.js\').Name;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar Signature = require(\'../signature.js\').Signature;\nvar MetaInfo = require(\'../meta-info.js\').MetaInfo;\nvar PublisherPublicKeyDigest = require(\'../publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\n\n/**\n * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.\n * @constructor\n */\nvar BinaryXmlWireFormat = function BinaryXmlWireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nexports.BinaryXmlWireFormat = BinaryXmlWireFormat;\n\n// Default object.\nBinaryXmlWireFormat.instance = null;\n\n/**\n * Encode interest as Binary XML and return the encoding.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nBinaryXmlWireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new BinaryXMLEncoder();\n  BinaryXmlWireFormat.encodeInterest(interest, encoder);  \n  return new Blob(encoder.getReducedOstream(), false);  \n};\n\n/**\n * Decode input as a Binary XML interest and set the fields of the interest object. \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nBinaryXmlWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeInterest(interest, decoder);\n};\n\n/**\n * Encode data as Binary XML and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nBinaryXmlWireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new BinaryXMLEncoder(1500);\n  var result = BinaryXmlWireFormat.encodeData(data, encoder);\n  result.encoding = new Blob(encoder.getReducedOstream(), false);\n  return result;\n};\n\n/**\n * @deprecated Use encodeData(data).\n */\nBinaryXmlWireFormat.prototype.encodeContentObject = function(data)\n{\n  return this.encodeData(data);\n};\n\n/**\n * Decode input as a Binary XML data packet, set the fields in the data object, and return \n * the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  return BinaryXmlWireFormat.decodeData(data, decoder);\n};\n\n/**\n * @deprecated Use decodeData(data, input).\n */\nBinaryXmlWireFormat.prototype.decodeContentObject = function(data, input) \n{\n  this.decodeData(data, input);\n};\n\n/**\n * Get a singleton instance of a BinaryXmlWireFormat.  Assuming that the default \n * wire format was set with \n * WireFormat.setDefaultWireFormat(BinaryXmlWireFormat.get()), you can check if \n * this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == BinaryXmlWireFormat.get().\n * @returns {BinaryXmlWireFormat} The singleton instance.\n */\nBinaryXmlWireFormat.get = function()\n{\n  if (BinaryXmlWireFormat.instance === null)\n    BinaryXmlWireFormat.instance = new BinaryXmlWireFormat();\n  return BinaryXmlWireFormat.instance;\n};\n\n/**\n * Encode the interest by calling the operations on the encoder.\n * @param {Interest} interest\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeInterest = function(interest, encoder) \n{\n  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);\n    \n  interest.name.to_ndnb(encoder);\n  \n  if (null != interest.minSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);  \n\n  if (null != interest.maxSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);\n\n  if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n      interest.getKeyLocator().getKeyData() != null &&\n      interest.getKeyLocator().getKeyData().length > 0)\n    // There is a KEY_LOCATOR_DIGEST. Use this instead of the publisherPublicKeyDigest.\n    encoder.writeDTagElement\n      (NDNProtocolDTags.PublisherPublicKeyDigest, \n       interest.getKeyLocator().getKeyData());\n  else {\n    if (null != interest.publisherPublicKeyDigest)\n      interest.publisherPublicKeyDigest.to_ndnb(encoder);\n  }\n    \n  if (null != interest.exclude)\n    interest.exclude.to_ndnb(encoder);\n    \n  if (null != interest.childSelector) \n    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);\n\n  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null) \n    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);\n    \n  if (null != interest.scope) \n    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);\n    \n  if (null != interest.interestLifetime) \n    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime, \n                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));\n    \n  if (null != interest.nonce)\n    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);\n    \n  encoder.writeElementClose();\n};\n\n/**\n * Use the decoder to place the result in interest.\n * @param {Interest} interest\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeInterest = function(interest, decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name = new Name();\n  interest.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))\n    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);\n  else\n    interest.minSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents)) \n    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);\n  else\n    interest.maxSuffixComponents = null;\n      \n  // Initially clear the keyLocator.\n  interest.getKeyLocator().clear();\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    interest.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  else\n    interest.publisherPublicKeyDigest = null;\n  if (interest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest.length > 0) {\n    // We keep the deprecated publisherPublicKeyDigest for backwards \n    //   compatibility.  Also set the key locator.\n    interest.getKeyLocator().setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    interest.getKeyLocator().setKeyData\n      (interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {\n    interest.exclude = new Exclude();\n    interest.exclude.from_ndnb(decoder);\n  }\n  else\n    interest.exclude = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))\n    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);\n  else\n    interest.childSelector = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))\n    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);\n  else\n    interest.answerOriginKind = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.Scope))\n    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);\n  else\n    interest.scope = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))\n    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt\n               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;\n  else\n    interest.interestLifetime = null;              \n    \n  if (decoder.peekDTag(NDNProtocolDTags.Nonce))\n    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);\n  else\n    interest.nonce = null;\n    \n  decoder.readElementClose();\n};\n\n/**\n * Encode the data by calling the operations on the encoder.\n * @param {Data} data\n * @param {BinaryXMLEncoder} encoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.encodeData = function(data, encoder)  \n{\n  //TODO verify name, MetaInfo and Signature is present\n  encoder.writeElementStartDTag(data.getElementLabel());\n\n  if (null != data.signature) \n    data.signature.to_ndnb(encoder);\n    \n  var signedPortionBeginOffset = encoder.offset;\n\n  if (null != data.name) \n    data.name.to_ndnb(encoder);\n  \n  if (null != data.signedInfo) \n    // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n    //   the key locator from the MetaInfo to the Signauture object.\n    data.signedInfo.to_ndnb(encoder, data.getSignatureOrMetaInfoKeyLocator());\n\n  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);\n  \n  var signedPortionEndOffset = encoder.offset;\n  \n  encoder.writeElementClose();\n  \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Use the decoder to place the result in data.\n * @param {Data} data\n * @param {BinaryXMLDecoder} decoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.decodeData = function(data, decoder) \n{\n  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT\n  decoder.readElementStartDTag(data.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {\n    data.signature = new Signature();\n    data.signature.from_ndnb(decoder);\n  }\n  else\n    data.signature = null;\n    \n  var signedPortionBeginOffset = decoder.offset;\n\n  data.name = new Name();\n  data.name.from_ndnb(decoder);\n    \n  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {\n    data.signedInfo = new MetaInfo();\n    data.signedInfo.from_ndnb(decoder);\n    if (data.signedInfo.locator != null && data.getSignature() != null)\n      // Copy the key locator pointer to the Signature object for the transition \n      //   of moving the key locator from the MetaInfo to the Signature object.\n      data.getSignature().keyLocator = data.signedInfo.locator;\n  }\n  else\n    data.signedInfo = null;\n\n  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);\n    \n  var signedPortionEndOffset = decoder.offset;\n    \n  decoder.readElementClose();\n    \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n})()\n},{"../exclude.js":12,"../key-locator.js":16,"../meta-info.js":14,"../name.js":9,"../publisher-public-key-digest.js":17,"../signature.js":63,"../util/blob.js":23,"../util/ndn-protoco-id-tags.js":57,"./binary-xml-decoder.js":55,"./binary-xml-encoder.js":56,"./data-utils.js":21,"./wire-format.js":18}],21:[function(require,module,exports){\n(function(){/**\n * This class contains utilities to help parse the data\n *\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nconsole.log(customBuf)\n \n/**\n * A DataUtils has static methods for converting data.\n * @constructor\n */\n\n\nvar DataUtils = function()\n{\n};\n\nexports.DataUtils = new DataUtils();\n\n/*\n * NOTE THIS IS CURRENTLY NOT BEING USED\n * \n */\n\nDataUtils.prototype.keyStr = "ABCDEFGHIJKLMNOP" +\n                   "QRSTUVWXYZabcdef" +\n                   "ghijklmnopqrstuv" +\n                   "wxyz0123456789+/" +\n                   "=";\n               \n/**\n * Raw String to Base 64\n */\nDataUtils.prototype.stringtoBase64 = function stringtoBase64(input) \n{\n   //input = escape(input);\n   var output = "";\n   var chr1, chr2, chr3 = "";\n   var enc1, enc2, enc3, enc4 = "";\n   var i = 0;\n\n   do {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2))\n       enc3 = enc4 = 64;\n    else if (isNaN(chr3))\n       enc4 = 64;\n\n    output = output +\n       DataUtils.keyStr.charAt(enc1) +\n       DataUtils.keyStr.charAt(enc2) +\n       DataUtils.keyStr.charAt(enc3) +\n       DataUtils.keyStr.charAt(enc4);\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n   } while (i < input.length);\n\n   return output;\n};\n\n/**\n * Base 64 to Raw String \n */\nDataUtils.prototype.base64toString = function base64toString(input) \n{\n  var output = "";\n  var chr1, chr2, chr3 = "";\n  var enc1, enc2, enc3, enc4 = "";\n  var i = 0;\n\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n  /* Test for invalid characters. */\n  if (base64test.exec(input)) {\n    alert("There were invalid base64 characters in the input text.\\n" +\n          "Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\\n" +\n          "Expect errors in decoding.");\n  }\n  \n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");\n\n  do {\n    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 != 64)\n      output = output + String.fromCharCode(chr2);\n\n    if (enc4 != 64)\n      output = output + String.fromCharCode(chr3);\n\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n  } while (i < input.length);\n\n  return output;\n};\n\n/**\n * customBuf to Hex String\n */\nDataUtils.prototype.toHex = function(buffer) \n{\n  return buffer.toString(\'hex\');\n};\n\n/**\n * Raw string to hex string.\n */\nDataUtils.prototype.stringToHex = function(args) \n{\n  var ret = "";\n  for (var i = 0; i < args.length; ++i) {\n    var value = args.charCodeAt(i);\n    ret += (value < 16 ? "0" : "") + value.toString(16);\n  }\n  return ret;\n};\n\n/**\n * customBuf to raw string.\n */\nDataUtils.prototype.toString = function(buffer) \n{\n  return buffer.toString();\n};\n\n/**\n * Hex String to customBuf.\n */\nDataUtils.prototype.toNumbers = function(str) \n{\n  return new customBuf(str, \'hex\');\n};\n\n/**\n * Hex String to raw string.\n */\nDataUtils.prototype.hexToRawString = function(str) \n{\n  if (typeof str ==\'string\') {\n  var ret = "";\n  str.replace(/(..)/g, function(s) {\n    ret += String.fromCharCode(parseInt(s, 16));\n  });\n  return ret;\n  }\n};\n\n/**\n * Raw String to customBuf.\n */\nDataUtils.prototype.toNumbersFromString = function(str) \n{\n  return new customBuf(str, \'binary\');\n};\n\n/**\n * Encode str as utf8 and return as customBuf.\n */\nDataUtils.prototype.stringToUtf8Array = function(str) \n{\n  return new customBuf(str, \'utf8\');\n};\n\n/**\n * arrays is an array of customBuf. Return a new customBuf which is the concatenation of all.\n */\nDataUtils.prototype.concatArrays = function(arrays) \n{\n  return customBuf.concat(arrays);\n};\n \n// TODO: Take customBuf and use TextDecoder when available.\nDataUtils.prototype.decodeUtf8 = function(utftext) \n{\n  var string = "";\n  var i = 0;\n  var c = 0;\n    var c1 = 0;\n    var c2 = 0;\n \n  while (i < utftext.length) {\n    c = utftext.charCodeAt(i);\n \n    if (c < 128) {\n      string += String.fromCharCode(c);\n      i++;\n    }\n    else if (c > 191 && c < 224) {\n      c2 = utftext.charCodeAt(i + 1);\n      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n      i += 2;\n    }\n    else {\n      c2 = utftext.charCodeAt(i+1);\n      var c3 = utftext.charCodeAt(i+2);\n      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n      i += 3;\n    }\n  }\n \n  return string;\n};\n\n/**\n * Return true if a1 and a2 are the same length with equal elements.\n */\nDataUtils.prototype.arraysEqual = function(a1, a2) \n{\n  // A simple sanity check that it is an array.\n  if (!a1.slice)\n    throw new Error("DataUtils.arraysEqual: a1 is not an array");\n  if (!a2.slice)\n    throw new Error("DataUtils.arraysEqual: a2 is not an array");\n    \n  if (a1.length != a2.length)\n    return false;\n  \n  for (var i = 0; i < a1.length; ++i) {\n    if (a1[i] != a2[i])\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Convert the big endian customBuf to an unsigned int.\n * Don\'t check for overflow.\n */\nDataUtils.prototype.bigEndianToUnsignedInt = function(bytes) \n{\n  var result = 0;\n  for (var i = 0; i < bytes.length; ++i) {\n    result <<= 8;\n    result += bytes[i];\n  }\n  return result;\n};\n\n/**\n * Convert the int value to a new big endian customBuf and return.\n * If value is 0 or negative, return new customBuf(0). \n */\nDataUtils.prototype.nonNegativeIntToBigEndian = function(value) \n{\n  value = Math.round(value);\n  if (value <= 0)\n    return new customBuf(0);\n  \n  // Assume value is not over 64 bits.\n  var size = 8;\n  var result = new customBuf(size);\n  var i = 0;\n  while (value != 0) {\n    ++i;\n    result[size - i] = value & 0xff;\n    value >>= 8;\n  }\n  return result.slice(size - i, size);\n};\n\n/**\n * Modify array to randomly shuffle the elements.\n */\nDataUtils.prototype.shuffle = function(array) \n{\n  for (var i = array.length - 1; i >= 1; --i) {\n    // j is from 0 to i.\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n};\n\n})()\n},{"../buffer.js":28}],20:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Tlv0_1a2WireFormat = require(\'./tlv-0_1a2-wire-format.js\').Tlv0_1a2WireFormat;\n\n/**\n * A TlvWireFormat extends Tlv0_1a2WireFormat to override its methods to \n * implement encoding and decoding using the preferred implementation of NDN-TLV.\n * @constructor\n */\nvar TlvWireFormat = function TlvWireFormat() \n{\n  // Inherit from Tlv0_1a2WireFormat.\n  Tlv0_1a2WireFormat.call(this);\n};\n\nTlvWireFormat.prototype = new Tlv0_1a2WireFormat();\nTlvWireFormat.prototype.name = "TlvWireFormat";\n\nexports.TlvWireFormat = TlvWireFormat;\n\n// Default object.\nTlvWireFormat.instance = null;\n\n/**\n * Get a singleton instance of a TlvWireFormat.  Assuming that the default \n * wire format was set with WireFormat.setDefaultWireFormat(TlvWireFormat.get()), \n * you can check if this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == TlvWireFormat.get().\n * @returns {TlvWireFormat} The singleton instance.\n */\nTlvWireFormat.get = function()\n{\n  if (TlvWireFormat.instance === null)\n    TlvWireFormat.instance = new TlvWireFormat();\n  return TlvWireFormat.instance;\n};\n\n// On loading this module, make this the default wire format.\n// This module will be loaded because WireFormat loads it.\nWireFormat.setDefaultWireFormat(TlvWireFormat.get());\n\n},{"./tlv-0_1a2-wire-format.js":69,"./wire-format.js":18}],22:[function(require,module,exports){\n(function(){/**\n * This file contains utilities to help encode and decode NDN objects.\n * Copyright (C) 2013-2014 Regents of the University of California.\n * author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Key = require(\'../key.js\').Key;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Interest = require(\'../interest.js\').Interest;\nvar Data = require(\'../data.js\').Data;\nvar FaceInstance = require(\'../face-instance.js\').FaceInstance;\nvar ForwardingEntry = require(\'../forwarding-entry.js\').ForwardingEntry;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * An EncodingUtils has static methods for encoding data.\n * @constructor\n */\nvar EncodingUtils = function EncodingUtils() \n{\n};\n\nexports.EncodingUtils = EncodingUtils;\n\nEncodingUtils.encodeToHexInterest = function(interest, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(interest.wireEncode(wireFormat).buf());\n};\n\nEncodingUtils.encodeToHexData = function(data, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(data.wireEncode(wireFormat).buf());\n};\n\n/**\n * @deprecated Use EncodingUtils.encodeToHexData(data).\n */\nEncodingUtils.encodeToHexContentObject = function(data, wireFormat) \n{\n  return EncodingUtils.encodeToHexData(data, wireFormat);\n}\n\nEncodingUtils.encodeForwardingEntry = function(data) \n{\n  var enc = new BinaryXMLEncoder();\n  data.to_ndnb(enc);\n  var bytes = enc.getReducedOstream();\n\n  return bytes;\n};\n\nEncodingUtils.decodeHexFaceInstance = function(result) \n{  \n  var numbers = DataUtils.toNumbers(result); \n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODING HEX FACE INSTANCE  \\n\'+numbers);\n\n  var faceInstance = new FaceInstance();\n  faceInstance.from_ndnb(decoder);\n  \n  return faceInstance;\n};\n\nEncodingUtils.decodeHexInterest = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var interest = new Interest();\n  interest.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return interest;\n};\n\nEncodingUtils.decodeHexData = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var data = new Data();\n  data.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return data;\n};\n\n/**\n * @deprecated Use EncodingUtils.decodeHexData(input).\n */\nEncodingUtils.decodeHexContentObject = function(input, wireFormat) \n{\n  return EncodingUtils.decodeHexData(input, wireFormat);\n}\n\nEncodingUtils.decodeHexForwardingEntry = function(result) \n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODED HEX FORWARDING ENTRY \\n\'+numbers);\n  \n  var forwardingEntry = new ForwardingEntry();\n  forwardingEntry.from_ndnb(decoder);\n  return forwardingEntry;\n};\n\n/**\n * Decode the customBuf array which holds SubjectPublicKeyInfo and return an RSAKey.\n */\nEncodingUtils.decodeSubjectPublicKeyInfo = function(array) \n{\n  var hex = DataUtils.toHex(array).toLowerCase();\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));\n  var rsaKey = new RSAKey();\n  rsaKey.setPublic(a[0], a[1]);\n  return rsaKey;\n}\n\n/**\n * Return a user friendly HTML string with the contents of data.\n * This also outputs to console.log.\n */\nEncodingUtils.dataToHtml = function(/* Data */ data) \n{\n  var output ="";\n      \n  if (data == -1)\n    output+= "NO CONTENT FOUND"\n  else if (data == -2)\n    output+= "CONTENT NAME IS EMPTY"\n  else {\n    if (data.name != null && data.name.components != null) {\n      output+= "NAME: " + data.name.toUri();\n        \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.digestAlgorithm != null) {\n      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.witness != null) {\n      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.signature != null) {\n      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {\n      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.timestamp != null) {\n      var d = new Date();\n      d.setTime(data.signedInfo.timestamp.msec);\n      \n      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];\n      \n      output += "TimeStamp: "+d;\n      output+= "<br />";\n      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;\n      \n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {\n      output += "keyLocator: ";\n      if (data.signedInfo.locator.type == KeyLocatorType.KEY)\n        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n        output += "KeyLocatorDigest: " + DataUtils.toHex(data.signedInfo.locator.getKeyData()).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)\n        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)\n        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";\n      else\n        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";      \n    }\n  }\n\n  return output;\n};\n\n/**\n * @deprecated Use return EncodingUtils.dataToHtml(data).\n */\nEncodingUtils.contentObjectToHtml = function(data) \n{\n  return EncodingUtils.dataToHtml(data);\n}\n\n//\n// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.\n//\n\nvar encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }\nvar encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }\nvar encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }\nvar decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }\nvar decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }\nvar decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }\nvar decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }\nvar decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }\nvar contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }\n\n/**\n * @deprecated Use interest.wireEncode().\n */\nfunction encodeToBinaryInterest(interest) { return interest.wireEncode().buf(); }\n/**\n * @deprecated Use data.wireEncode().\n */\nfunction encodeToBinaryContentObject(data) { return data.wireEncode().buf(); }\n\n})()\n},{"../data.js":13,"../face-instance.js":70,"../forwarding-entry.js":52,"../interest.js":11,"../key-locator.js":16,"../key.js":15,"../log.js":59,"./binary-xml-decoder.js":55,"./binary-xml-encoder.js":56,"./data-utils.js":21,"./wire-format.js":18}],23:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * A Blob holds an immutable byte array implemented as a customBuf.  This should be \n * treated like a string which is a pointer to an immutable string. (It is OK to \n * pass a pointer to the string because the new owner can\u2019t change the bytes of \n * the string.)  Blob does not inherit from customBuf. Instead you must call buf() \n * to get the byte array which reminds you that you should not change the \n * contents.  Also remember that buf() can return null.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {boolean} copy (optional) (optional) If true, copy the contents of \n * value into a new customBuf.  If false, just use the existing value without \n * copying. If omitted, then copy the contents (unless value is already a Blob).\n * IMPORTANT: If copy is false, if you keep a pointer to the value then you must\n * treat the value as immutable and promise not to change it.\n */\nvar Blob = function Blob(value, copy) \n{\n  if (copy == null)\n    copy = true;\n  \n  if (value == null)\n    this.buffer = null;\n  else if (typeof value === \'object\' && value instanceof Blob)\n    // Use the existing buffer.  Don\'t need to check for copy.\n    this.buffer = value.buffer;\n  else {\n    if (typeof value === \'string\')\n      // Convert from a string to utf-8 byte encoding.\n      this.buffer = new customBuf(value, \'utf8\');\n    else {\n      if (copy)\n        // We are copying, so just make another customBuf.\n        this.buffer = new customBuf(value);\n      else {\n        if (typeof value === \'object\' && value instanceof customBuf)\n          // We can use as-is.\n          this.buffer = value;\n        else\n          // We need a customBuf, so copy.\n          this.buffer = new customBuf(value);\n      }\n    }\n  }\n};\n\nexports.Blob = Blob;\n\n/**\n * Return the length of the immutable byte array.\n * @returns {number} The length of the array.  If buf() is null, return 0.\n */\nBlob.prototype.size = function()\n{\n  if (this.buffer != null)\n    return this.buffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return the immutable byte array.  DO NOT change the contents of the customBuf.  \n * If you need to change it, make a copy.\n * @returns {Buffer} The customBuf holding the immutable byte array, or null.\n */\nBlob.prototype.buf = function()\n{\n  return this.buffer;\n};\n\n/**\n * Return true if the array is null, otherwise false.\n * @returns {boolean} True if the array is null.\n */\nBlob.prototype.isNull = function()\n{\n  return this.buffer == null;\n};\n\n/**\n * Return the hex representation of the bytes in the byte array.\n * @returns {string} The hex string.\n */\nBlob.prototype.toHex = function() \n{  \n  if (this.buffer == null)\n    return "";\n  else\n    return this.buffer.toString(\'hex\');\n};\n\n})()\n},{"../buffer.js":28}],24:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar BinaryXMLDecoder = require(\'../encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Name = require(\'../name.js\').Name;\n\n/**\n * Create a context for getting the response from the name enumeration command, as neede by getComponents.\n * (To do name enumeration, call the static method NameEnumeration.getComponents.)\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nvar NameEnumeration = function NameEnumeration(face, onComponents) \n{\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n  \n  var self = this;\n  this.onData = function(interest, data) { self.processData(data); };\n  this.onTimeout = function(interest) { self.processTimeout(); };\n};\n\nexports.NameEnumeration = NameEnumeration;\n\n/**\n * Use the name enumeration protocol to get the child components of the name prefix.\n * @param {Face} face The Face object for using expressInterest.\n * @param {Name} name The name prefix for finding the child components.\n * @param {function} onComponents On getting the response, this calls onComponents(components) where\n * components is an array of customBuf name components.  If there is no response, this calls onComponents(null). \n */\nNameEnumeration.getComponents = function(face, prefix, onComponents)\n{\n  var command = new Name(prefix);\n  // Add %C1.E.be\n  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])\n  \n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n/**\n * Parse the response from the name enumeration command and call this.onComponents.\n * @param {Data} data\n */\nNameEnumeration.prototype.processData = function(data) \n{\n  try {\n    if (!NameEnumeration.endsWithSegmentNumber(data.name))\n      // We don\'t expect a name without a segment number.  Treat it as a bad packet.\n      this.onComponents(null);\n    else {\n      var segmentNumber = DataUtils.bigEndianToUnsignedInt\n          (data.name.get(data.name.size() - 1).getValue());\n\n      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.\n      var expectedSegmentNumber = this.contentParts.length;\n      if (segmentNumber != expectedSegmentNumber)\n        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);\n      else {\n        // Save the content and check if we are finished.\n        this.contentParts.push(data.content);\n\n        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);\n          if (segmentNumber == finalSegmentNumber) {\n            // We are finished.  Parse and return the result.\n            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));\n            return;\n          }\n        }\n\n        // Fetch the next segment.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);\n      }\n    }\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Just call onComponents(null).\n */\nNameEnumeration.prototype.processTimeout = function()\n{\n  try {\n    this.onComponents(null);\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.\n * @param {Uint8Array} content The content to parse.\n * @returns {Array<Buffer>} The array of components.\n */\nNameEnumeration.parseComponents = function(content)\n{\n  var components = [];\n  var decoder = new BinaryXMLDecoder(content);\n  \n  decoder.readElementStartDTag(NDNProtocolDTags.Collection);\n \n  while (decoder.peekDTag(NDNProtocolDTags.Link)) {\n    decoder.readElementStartDTag(NDNProtocolDTags.Link);    \n    decoder.readElementStartDTag(NDNProtocolDTags.Name);\n    \n    components.push(new customBuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));\n    \n    decoder.readElementClose();  \n    decoder.readElementClose();  \n  }\n\n  decoder.readElementClose();\n  return components;\n};\n\n/**\n * Check if the last component in the name is a segment number.\n * TODO: Move to Name class.\n * @param {Name} name\n * @returns {Boolean} True if the name ends with a segment number, otherwise false.\n */\nNameEnumeration.endsWithSegmentNumber = function(name) {\n  return name.components != null && name.size() >= 1 &&\n         name.get(name.size() - 1).getValue().length >= 1 &&\n         name.get(name.size() - 1).getValue()[0] == 0;\n};\n\n})(require("__browserify_buffer").Buffer)\n},{"../buffer.js":28,"../encoding/binary-xml-decoder.js":55,"../encoding/data-utils.js":21,"../name.js":9,"./ndn-protoco-id-tags.js":57,"__browserify_buffer":60}],25:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents NDNTime Objects\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar NDNTime = function NDNTime(input) \n{\n  this.NANOS_MAX = 999877929;\n  \n  if (typeof input ==\'number\')\n    this.msec = input;\n  else {\n    if (LOG > 1) console.log(\'UNRECOGNIZED TYPE FOR TIME\');\n  }\n};\n\nexports.NDNTime = NDNTime;\n\nNDNTime.prototype.getJavascriptDate = function() \n{\n  var d = new Date();\n  d.setTime(this.msec);\n  return d\n};  \n\n},{"../log.js":59}],26:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar Key = require(\'../key.js\').Key;\n\n/**\n * @constructor\n */\nvar KeyManager = function KeyManager()\n{\n  this.certificate = \n  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +\n  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +\n  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +\n  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +\n  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +\n  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +\n  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +\n  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +\n  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";\n\n  // Public Key\n    this.publicKey = \n  "-----BEGIN PUBLIC KEY-----\\n" +\n  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\\n" +\n  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\\n" +\n  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\\n" +\n  "WFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "-----END PUBLIC KEY-----";\n  // Private Key\n    this.privateKey = \n  "-----BEGIN RSA PRIVATE KEY-----\\n" +\n  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\\n" +\n  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\\n" +\n  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\\n" +\n  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\\n" +\n  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\\n" +\n  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\\n" +\n  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\\n" +\n  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\\n" +\n  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\\n" +\n  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\\n" +\n  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\\n" +\n  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\\n" +\n  "-----END RSA PRIVATE KEY-----";\n  \n  this.key = null;\n};\n\n/**\n * Return a Key object for the keys in this KeyManager.  This creates the Key on the first\n * call and returns a cached copy after that.\n * @returns {Key}\n */\nKeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n  \n  return this.key;\n}\n\nvar globalKeyManager = globalKeyManager || new KeyManager();\nexports.globalKeyManager = globalKeyManager;\n\n},{"../key.js":15}],27:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLStructureDecoder = require(\'./binary-xml-structure-decoder.js\').BinaryXMLStructureDecoder;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvStructureDecoder = require(\'./tlv/tlv-structure-decoder.js\').TlvStructureDecoder;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * A ElementReader lets you call onReceivedData multiple times which uses a\n * BinaryXMLStructureDecoder or TlvStructureDecoder to detect the end of a \n * binary XML or TLV element and calls elementListener.onReceivedElement(element) \n * with the element.  This handles the case where a single call to \n * onReceivedData may contain multiple elements.\n * @constructor\n * @param {{onReceivedElement:function}} elementListener\n */\nvar ElementReader = function ElementReader(elementListener) \n{\n  this.elementListener = elementListener;\n  this.dataParts = [];\n  this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n  this.tlvStructureDecoder = new TlvStructureDecoder();\n  this.useTlv = null;\n};\n\nexports.ElementReader = ElementReader;\n\nElementReader.prototype.onReceivedData = function(/* customBuf */ data) \n{\n  // Process multiple objects in the data.\n  while (true) {\n    if (this.dataParts.length == 0) {\n      // This is the beginning of an element.  Check whether it is binaryXML or TLV.\n      if (data.length <= 0)\n        // Wait for more data.\n        return;\n      \n      // The type codes for TLV Interest and Data packets are chosen to not\n      //   conflict with the first byte of a binary XML packet, so we can\n      //   just look at the first byte.\n      if (data[0] == Tlv.Interest || data[0] == Tlv.Data || data[0] == 0x80)\n        this.useTlv = true;\n      else\n        // Binary XML.\n        this.useTlv = false;\n    }\n\n    var gotElementEnd;\n    var offset;\n    if (this.useTlv) {\n      // Scan the input to check if a whole TLV object has been read.\n      this.tlvStructureDecoder.seek(0);\n      gotElementEnd = this.tlvStructureDecoder.findElementEnd(data);\n      offset = this.tlvStructureDecoder.getOffset();\n    }\n    else {\n      // Scan the input to check if a whole Binary XML object has been read.\n      this.binaryXmlStructureDecoder.seek(0);\n      gotElementEnd = this.binaryXmlStructureDecoder.findElementEnd(data);\n      offset = this.binaryXmlStructureDecoder.offset;\n    }\n    \n    if (gotElementEnd) {\n      // Got the remainder of an object.  Report to the caller.\n      this.dataParts.push(data.slice(0, offset));\n      var element = DataUtils.concatArrays(this.dataParts);\n      this.dataParts = [];\n      try {\n        this.elementListener.onReceivedElement(element);\n      } catch (ex) {\n          console.log("ElementReader: ignoring exception from onReceivedElement: " , ex);\n      }\n  \n      // Need to read a new object.\n      data = data.slice(offset, data.length);\n      this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n      this.tlvStructureDecoder = new TlvStructureDecoder();\n      if (data.length == 0)\n        // No more data in the packet.\n        return;\n      \n      // else loop back to decode.\n    }\n    else {\n      // Save for a later call to concatArrays so that we only copy data once.\n      this.dataParts.push(data);\n      if (LOG > 3) console.log(\'Incomplete packet received. Length \' + data.length + \'. Wait for more input.\');\n        return;\n    }\n  }    \n};\n\n})()\n},{"../buffer.js":28,"../log.js":59,"./binary-xml-structure-decoder.js":71,"./data-utils.js":21,"./tlv/tlv-structure-decoder.js":72,"./tlv/tlv.js":53}],30:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Provide the callback closure for the async communication methods in the Face class.\n * This is a port of Closure.py from PyNDN, written by: \n * Derek Kulinski <takeda@takeda.tk>\n * Jeff Burke <jburke@ucla.edu>\n */\n\n/**\n * A subclass of Closure is passed to expressInterest and registerPrefix.\n * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.\n * @constructor\n */\nvar Closure = function Closure() \n{\n  // I don\'t think storing Face\'s closure is needed\n  // and it creates a reference loop, as of now both\n  // of those variables are never set -- Derek\n  //\n  // Use instance variables to return data to callback\n  this.ndn_data = null;  // this holds the ndn_closure\n  this.ndn_data_dirty = false; \n};\n\nexports.Closure = Closure;\n\n// Upcall result\nClosure.RESULT_ERR               = -1; // upcall detected an error\nClosure.RESULT_OK                =  0; // normal upcall return\nClosure.RESULT_REEXPRESS         =  1; // reexpress the same interest again\nClosure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest\nClosure.RESULT_VERIFY            =  3; // force an unverified result to be verified\nClosure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest\n                                       //   with the key available in the local storage\n\n// Upcall kind\nClosure.UPCALL_FINAL              = 0; // handler is about to be deregistered\nClosure.UPCALL_INTEREST           = 1; // incoming interest\nClosure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered\nClosure.UPCALL_CONTENT            = 3; // incoming verified content\nClosure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out\nClosure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified\nClosure.UPCALL_CONTENT_BAD        = 6; // verification failed\n\n/**\n * Override this in your subclass.\n * If you\'re getting strange errors in upcall()\n * check your code whether you\'re returning a value.\n */\nClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  //dump(\'upcall \' + this + " " + kind + " " + upcallInfo + "\\n");\n  return Closure.RESULT_OK;\n};\n\n/**\n * An UpcallInfo is passed to Closure.upcall.\n * @constructor\n */\nvar UpcallInfo = function UpcallInfo(face, interest, matchedComps, data) \n{\n  this.face = face;  // Face object (not used)\n  this.ndn = face;   // deprecated\n  this.interest = interest;  // Interest object\n  this.matchedComps = matchedComps;  // int\n  this.data = data;  // Data\n  this.contentObject = data; // deprecated.  Include for backward compatibility.\n};\n\nUpcallInfo.prototype.toString = function() \n{\n  var ret = "face = " + this.face;\n  ret += "\\nInterest = " + this.interest;\n  ret += "\\nmatchedComps = " + this.matchedComps;\n  ret += "\\nData: " + this.data;\n  return ret;\n};\n\nexports.UpcallInfo = UpcallInfo;\n\n},{}],73:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require(\'util\');\nvar Buffer = require("buffer").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError\'s when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = \'AssertionError\';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return \'\' + value;\n  }\n  if (typeof value === \'number\' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === \'function\' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == \'string\') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + \':\', this.message].join(\' \');\n  } else {\n    return [\n      this.name + \':\',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(\' \');\n  }\n};\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError\'s constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, \'==\', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \'==\', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \'!=\', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'deepEqual\', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == \'object\',\n  // equivalence is determined by ==.\n  } else if (typeof actual != \'object\' && typeof expected != \'object\') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \'prototype\' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == \'[object Arguments]\';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical \'prototype\' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I\'ve managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn\'t\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'notDeepEqual\', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \'===\', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \'!==\', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === \'string\') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? \' (\' + expected.name + \').\' : \'.\') +\n            (message ? \' \' + message : \'.\');\n\n  if (shouldThrow && !actual) {\n    fail(\'Missing expected exception\' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(\'Got unwanted exception\' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{"buffer":61,"util":74}],5:[function(require,module,exports){\nvar utils = {}\n  , ndn = require(\'ndn-lib\')\nvar Data = ndn.Data\nvar Name = ndn.Name\nvar SignedInfo = ndn.SignedInfo\nvar ndnbuf = ndn.customBuffer\nvar DataUtils = ndn.DataUtils\n\nutils.chunkArbitraryData = function(opts) {\n  var ndnArray = [];\n  //console.log(name)\n  if (opts.type == \'object\') {\n    var string = JSON.stringify(opts.thing);\n  } else if (typeof opts.data == \'string\') {\n    var string = data;\n  } else if (typeof opts.data == \'file\') {\n    //console.log(\'no handlers yet for datatype: \', typeof data);\n    return;\n  };\n  var name = new ndn.Name(opts.uri)\n  if (opts.version != false) {\n    utils.appendVersion(name, opts.version)\n  }\n  var stringArray = string.match(/.{1,4000}/g);\n  var segmentNames = [];\n  for (i = 0; i < stringArray.length; i++) {\n    segmentNames[i] = new Name(name).appendSegment(i)\n    var co = new Data(segmentNames[i], new SignedInfo(), new ndnbuf(stringArray[i]));\n    co.signedInfo.setFields()\n    co.signedInfo.finalBlockID = utils.initSegment(stringArray.length - 1)\n    console.log(co.signedInfo.finalBlockID)\n    if (opts.freshness != undefined) {\n      co.signedInfo.freshnessSeconds = fresh\n    }\n    co.sign()\n    ndnArray[i] = co.wireEncode()\n  };\n\n  return {array:ndnArray, name: name};\n\n};\n\nutils.initSegment = function(seg) {\n    if (seg == null || seg == 0)\n\t  return (new ndnbuf(\'00\', \'hex\'));\n\n    var segStr = seg.toString(16);\n\n    if (segStr.length % 2 == 1)\n\tsegStr = \'0\' + segStr;\n\n    segStr = \'00\' + segStr;\n    return (new ndnbuf(segStr, \'hex\'));\n};\n\nutils.getAllPrefixes = function(name) {\n  var uriArray = [];\n  for (i = 0 ; i < name.components.length + 1 ; i++) {\n    var uri = name.getPrefix(i).toUri()\n    uriArray.push(uri);\n  };\n  return uriArray;\n};\n\nutils.isFirstSegment = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length == 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n};\n\nutils.isLastSegment = function(name, co) {\n\n    return DataUtils.arraysEqual(name.components[name.components.length - 1].value, co.signedInfo.finalBlockID);\n}\n\nutils.normalizeUri = function(name) {\n  //console.log(name)\n  if (!endsWithSegmentNumber(name)) {\n    normalizedName = name;\n    requestedSegment = 0\n  } else if (!isFirstSegment(name)) {\n    normalizedName = name.getPrefix(name.components.length - 1);\n    requestedSegment = DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value);\n  } else {\n    normalizedName = name.getPrefix(name.components.length - 1) ;\n    requestedSegment = 0;\n  };\n  var returns = [normalizedName, requestedSegment];\n  return returns;\n};\n\nutils.getSegmentInteger = function(name) {\n  if (name.components != null && name.components.length >= 1 &&\n  name.components[name.components.length - 1].value.length >= 1 &&\n  name.components[name.components.length - 1].value[0] == 0) {\n    return DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value)\n  } else {\n    return 0;\n  }\n};\n\nutils.normalizeNameToObjectStore = function(name) {\n  var throwaway = utils.getNameWithoutCommandMarker(name);\n\n  if (!utils.endsWithSegmentNumber(throwaway)) {\n    return throwaway.appendSegment(0).toUri();\n  } else if (!utils.isFirstSegment(throwaway)) {\n    return throwaway.getPrefix(name.components.length - 1).appendSegment(0).toUri();\n  } else {\n    return throwaway.toUri();\n  };\n};\n\nutils.endsWithSegmentNumber = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length >= 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n}\n\nutils.nameHasCommandMarker = function(name) {\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1) {\n      return true\n    };\n  }\n\n  return false;\n};\n\nutils.getCommandMarker = function(name) {\n  //console.log(name)\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1 && component[2] != 0x4E) {\n      return name.components[i].toEscapedString()\n    };\n  }\n};\n\nutils.getNameWithoutCommandMarker = function(name) {\n  var strippedName = new Name(\'\');\n\n  for (var i = 0 ; i < name.size(); i++) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] != 0xC1) {\n      strippedName.append(name.components[i]);\n    };\n  };\n  return strippedName;\n};\n\n\nutils.getSuffix = function(name, p) {\n    return new Name(name.components.slice(p));\n};\n\nutils.appendVersion = function(name, date) {\n    console.log(date)\n    if (date) {\n      if (date instanceof Date) {\n        var d = date.getTime()\n\n      } else if (typeof date == "number")\n        var d = new Date().setTime(date)\n    } else {\n      var d = new Date().getTime();\n    };\n\n    var time = d.toString(16);\n    if (time.length % 2 == 1) {\n\t    time = \'0\' + time;\n    };\n    time = \'fd\' + time;\n    var binTime = new ndnbuf(time, \'hex\');\n    //console.log(binTime)\n    return name.append(binTime);\n};\n\nutils.timeToVersion = function(date) {\n  if (date instanceof Date) {\n    var d = date.getTime\n  } else {\n    var d = date;\n  };\n  var time = d.toString(16);\n  if (time.length % 2 == 1) {\n    time = \'0\' + time;\n  };\n  time = \'fd\' + time;\n  var binTime = new ndnbuf(time, \'hex\');\n  return (new Name.Component(binTime).toEscapedString())\n\n};\n\nutils.versionToTime = function(version) {\n  time = 0\n  array = DataUtils.toNumbers(DataUtils.toHex(version))\n  //console.log(array)\n  for (i = 1; i < array.length ; i++) {\n    time = time + (array[i] * Math.pow(2, (7 - i)));\n    //console.log(time)\n  };\n  return time\n};\n\n\n\nutils.setNonce = function(interest) {\n  var bytes = [0xc1, 0x2e, 0x4e, 0x00];\n  for (var n = 8; n > 0; n--) {\n\t  bytes.push(Math.floor(Math.random() * 256));\n\t  //console.log(bytes)\n  }\n  var buf = new ndnbuf(bytes);\n  interest.nonce = buf;\n}\n\nmodule.exports = utils;\n\n},{"ndn-lib":4}],53:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Tlv class has static type codes for the NDN-TLV wire format.\n * @constructor\n */\nvar Tlv = function Tlv()\n{\n}\n\nexports.Tlv = Tlv;\n\nTlv.Interest =         5;\nTlv.Data =             6;\nTlv.Name =             7;\nTlv.NameComponent =    8;\nTlv.Selectors =        9;\nTlv.Nonce =            10;\nTlv.Scope =            11;\nTlv.InterestLifetime = 12;\nTlv.MinSuffixComponents = 13;\nTlv.MaxSuffixComponents = 14;\nTlv.PublisherPublicKeyLocator = 15;\nTlv.Exclude =          16;\nTlv.ChildSelector =    17;\nTlv.MustBeFresh =      18;\nTlv.Any =              19;\nTlv.MetaInfo =         20;\nTlv.Content =          21;\nTlv.SignatureInfo =    22;\nTlv.SignatureValue =   23;\nTlv.ContentType =      24;\nTlv.FreshnessPeriod =  25;\nTlv.FinalBlockId =     26;\nTlv.SignatureType =    27;\nTlv.KeyLocator =       28;\nTlv.KeyLocatorDigest = 29;\nTlv.FaceInstance =     128;\nTlv.ForwardingEntry =  129;\nTlv.StatusResponse =   130;\nTlv.Action =           131;\nTlv.FaceID =           132;\nTlv.IPProto =          133;\nTlv.Host =             134;\nTlv.Port =             135;\nTlv.MulticastInterface = 136;\nTlv.MulticastTTL =     137;\nTlv.ForwardingFlags =  138;\nTlv.StatusCode =       139;\nTlv.StatusText =       140;\n\nTlv.SignatureType_DigestSha256 = 0;\nTlv.SignatureType_SignatureSha256WithRsa = 1;\n\n},{}],57:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class contains all NDNx tags\n */\n\n\nvar NDNProtocolDTags = {\n\n  /**\n   * Note if you add one of these, add it to the reverse string map as well.\n   * Emphasize getting the work done at compile time over trying to make something\n   * flexible and developer error-proof.\n   */\n\n   Any : 13,\n   Name : 14,\n   Component : 15,\n   Certificate : 16,\n   Collection : 17,\n   CompleteName : 18,\n   Content : 19,\n   SignedInfo : 20,\n   ContentDigest : 21,\n   ContentHash : 22,\n   Count : 24,\n   Header : 25,\n   Interest : 26,  /* 20090915 */\n   Key : 27,\n   KeyLocator : 28,\n   KeyName : 29,\n   Length : 30,\n   Link : 31,\n   LinkAuthenticator : 32,\n   NameComponentCount : 33,  /* DeprecatedInInterest */\n   RootDigest : 36,\n   Signature : 37,\n   Start : 38,\n   Timestamp : 39,\n   Type : 40,\n   Nonce : 41,\n   Scope : 42,\n   Exclude : 43,\n   Bloom : 44,\n   BloomSeed : 45,\n   AnswerOriginKind : 47,\n   InterestLifetime : 48,\n   Witness : 53,\n   SignatureBits : 54,\n   DigestAlgorithm : 55,\n   BlockSize : 56,\n   FreshnessSeconds : 58,\n   FinalBlockID : 59,\n   PublisherPublicKeyDigest : 60,\n   PublisherCertificateDigest : 61,\n   PublisherIssuerKeyDigest : 62,\n   PublisherIssuerCertificateDigest : 63,\n   Data : 64,  /* 20090915 */\n   WrappedKey : 65,\n   WrappingKeyIdentifier : 66,\n   WrapAlgorithm : 67,\n   KeyAlgorithm : 68,\n   Label : 69,\n   EncryptedKey : 70,\n   EncryptedNonceKey : 71,\n   WrappingKeyName : 72,\n   Action : 73,\n   FaceID : 74,\n   IPProto : 75,\n   Host : 76,\n   Port : 77,\n   MulticastInterface : 78,\n   ForwardingFlags : 79,\n   FaceInstance : 80,\n   ForwardingEntry : 81,\n   MulticastTTL : 82,\n   MinSuffixComponents : 83,\n   MaxSuffixComponents : 84,\n   ChildSelector : 85,\n   RepositoryInfo : 86,\n   Version : 87,\n   RepositoryVersion : 88,\n   GlobalPrefix : 89,\n   LocalName : 90,\n   Policy : 91,\n   Namespace : 92,\n   GlobalPrefixName : 93,\n   PolicyVersion : 94,\n   KeyValueSet : 95,\n   KeyValuePair : 96,\n   IntegerValue : 97,\n   DecimalValue : 98,\n   StringValue : 99,\n   BinaryValue : 100,\n   NameValue : 101,\n   Entry : 102,\n   ACL : 103,\n   ParameterizedName : 104,\n   Prefix : 105,\n   Suffix : 106,\n   Root : 107,\n   ProfileName : 108,\n   Parameters : 109,\n   InfoString : 110,\n  // 111 unallocated\n   StatusResponse : 112,\n   StatusCode : 113,\n   StatusText : 114,\n\n  // Sync protocol\n   SyncNode : 115,\n   SyncNodeKind : 116,\n   SyncNodeElement : 117,\n   SyncVersion : 118,\n   SyncNodeElements : 119,\n   SyncContentHash : 120,\n   SyncLeafCount : 121,\n   SyncTreeDepth : 122,\n   SyncByteCount : 123,\n   ConfigSlice : 124,\n   ConfigSliceList : 125,\n   ConfigSliceOp : 126,\n\n  // Remember to keep in sync with schema/tagnames.csvsdict\n   NDNProtocolDataUnit : 17702112,\n   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"\n};\n\nexports.NDNProtocolDTags = NDNProtocolDTags;\n\nvar NDNProtocolDTagsStrings = [\n  null, null, null, null, null, null, null, null, null, null, null,\n  null, null,\n  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",\n  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",\n  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",\n  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",\n  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",\n  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",\n  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",\n  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",\n  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",\n  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",\n  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",\n  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",\n  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",\n  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",\n  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",\n  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",\n  "InfoString", null,\n    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",\n    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",\n    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];\n\nexports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;\n\n},{}],51:[function(require,module,exports){\n(function(){var Buffer = require(\'buffer\').Buffer\nvar sha = require(\'./sha\')\nvar sha256 = require(\'./sha256\')\nvar rng = require(\'./rng\')\nvar md5 = require(\'./md5\')\n\nvar algorithms = {\n  sha1: sha,\n  sha256: sha256,\n  md5: md5\n}\n\nvar blocksize = 64\nvar zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)\nfunction hmac(fn, key, data) {\n  if(!Buffer.isBuffer(key)) key = new Buffer(key)\n  if(!Buffer.isBuffer(data)) data = new Buffer(data)\n\n  if(key.length > blocksize) {\n    key = fn(key)\n  } else if(key.length < blocksize) {\n    key = Buffer.concat([key, zeroBuffer], blocksize)\n  }\n\n  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)\n  for(var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  var hash = fn(Buffer.concat([ipad, data]))\n  return fn(Buffer.concat([opad, hash]))\n}\n\nfunction hash(alg, key) {\n  alg = alg || \'sha1\'\n  var fn = algorithms[alg]\n  var bufs = []\n  var length = 0\n  if(!fn) error(\'algorithm:\', alg, \'is not yet supported\')\n  return {\n    update: function (data) {\n      if(!Buffer.isBuffer(data)) data = new Buffer(data)\n        \n      bufs.push(data)\n      length += data.length\n      return this\n    },\n    digest: function (enc) {\n      var buf = Buffer.concat(bufs)\n      var r = key ? hmac(fn, key, buf) : fn(buf)\n      bufs = null\n      return enc ? r.toString(enc) : r\n    }\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(\' \')\n  throw new Error([\n    m,\n    \'we accept pull requests\',\n    \'http://github.com/dominictarr/crypto-browserify\'\n    ].join(\'\\n\'))\n}\n\nexports.createHash = function (alg) { return hash(alg) }\nexports.createHmac = function (alg, key) { return hash(alg, key) }\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, new Buffer(rng(size)))\n    } catch (err) { callback(err) }\n  } else {\n    return new Buffer(rng(size))\n  }\n}\n\nfunction each(a, f) {\n  for(var i in a)\n    f(a[i], i)\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\neach([\'createCredentials\'\n, \'createCipher\'\n, \'createCipheriv\'\n, \'createDecipher\'\n, \'createDecipheriv\'\n, \'createSign\'\n, \'createVerify\'\n, \'createDiffieHellman\'\n, \'pbkdf2\'], function (name) {\n  exports[name] = function () {\n    error(\'sorry,\', name, \'is not implemented yet\')\n  }\n})\n\n})()\n},{"./md5":78,"./rng":77,"./sha":75,"./sha256":76,"buffer":61}],59:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Log class holds the global static variable LOG.\n */\nvar Log = function Log() \n{\n}\n\nexports.Log = Log;\n\n/**\n * LOG is the level for logging debugging statements.  0 means no log messages. \n * @type Number\n */\nLog.LOG = 0;\n\n})()\n},{}],68:[function(require,module,exports){\nvar b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\nvar b64pad="=";\nvar BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction hex2b64(h) {\n  var i;\n  var c;\n  var ret = "";\n  for(i = 0; i+3 <= h.length; i+=3) {\n    c = parseInt(h.substring(i,i+3),16);\n    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n  }\n  if(i+1 == h.length) {\n    c = parseInt(h.substring(i,i+1),16);\n    ret += b64map.charAt(c << 2);\n  }\n  else if(i+2 == h.length) {\n    c = parseInt(h.substring(i,i+2),16);\n    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n  }\n  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n  return ret;\n}\n\n// convert a base64 string to hex\nfunction b64tohex(s) {\n  var ret = ""\n  var i;\n  var k = 0; // b64 state, 0-3\n  var slop;\n  for(i = 0; i < s.length; ++i) {\n    if(s.charAt(i) == b64pad) break;\n    v = b64map.indexOf(s.charAt(i));\n    if(v < 0) continue;\n    if(k == 0) {\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 1;\n    }\n    else if(k == 1) {\n      ret += int2char((slop << 2) | (v >> 4));\n      slop = v & 0xf;\n      k = 2;\n    }\n    else if(k == 2) {\n      ret += int2char(slop);\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 3;\n    }\n    else {\n      ret += int2char((slop << 2) | (v >> 4));\n      ret += int2char(v & 0xf);\n      k = 0;\n    }\n  }\n  if(k == 1)\n    ret += int2char(slop << 2);\n  return ret;\n}\n\n// convert a base64 string to a byte/number array\nfunction b64toBA(s) {\n  //piggyback on b64tohex for now, optimize later\n  var h = b64tohex(s);\n  var i;\n  var a = new Array();\n  for(i = 0; 2*i < h.length; ++i) {\n    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n  }\n  return a;\n}\n\nmodule.exports = {b64tohex: b64tohex, b64toBA: b64toBA, hex2b64: hex2b64};\n\n},{}],74:[function(require,module,exports){\nvar events = require(\'events\');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === \'[object Date]\'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === \'[object RegExp]\'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { \'bold\' : [1, 22],\n          \'italic\' : [3, 23],\n          \'underline\' : [4, 24],\n          \'inverse\' : [7, 27],\n          \'white\' : [37, 39],\n          \'grey\' : [90, 39],\n          \'black\' : [30, 39],\n          \'blue\' : [34, 39],\n          \'cyan\' : [36, 39],\n          \'green\' : [32, 39],\n          \'magenta\' : [35, 39],\n          \'red\' : [31, 39],\n          \'yellow\' : [33, 39] };\n\n    var style =\n        { \'special\': \'cyan\',\n          \'number\': \'blue\',\n          \'boolean\': \'yellow\',\n          \'undefined\': \'grey\',\n          \'null\': \'bold\',\n          \'string\': \'green\',\n          \'date\': \'magenta\',\n          // "name": intentionally not styling\n          \'regexp\': \'red\' }[styleType];\n\n    if (style) {\n      return \'\\u001b[\' + styles[style][0] + \'m\' + str +\n             \'\\u001b[\' + styles[style][1] + \'m\';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === \'function\' &&\n        // Filter out the util module, it\'s inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case \'undefined\':\n        return stylize(\'undefined\', \'undefined\');\n\n      case \'string\':\n        var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                                 .replace(/\'/g, "\\\\\'")\n                                                 .replace(/\\\\"/g, \'"\') + \'\\\'\';\n        return stylize(simple, \'string\');\n\n      case \'number\':\n        return stylize(\'\' + value, \'number\');\n\n      case \'boolean\':\n        return stylize(\'\' + value, \'boolean\');\n    }\n    // For some reason typeof null is "object", so special case here.\n    if (value === null) {\n      return stylize(\'null\', \'null\');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === \'function\' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        var name = value.name ? \': \' + value.name : \'\';\n        return stylize(\'[Function\' + name + \']\', \'special\');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), \'date\');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = \'Array\';\n      braces = [\'[\', \']\'];\n    } else {\n      type = \'Object\';\n      braces = [\'{\', \'}\'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === \'function\') {\n      var n = value.name ? \': \' + value.name : \'\';\n      base = (isRegExp(value)) ? \' \' + value : \' [Function\' + n + \']\';\n    } else {\n      base = \'\';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = \' \' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        return stylize(\'[Object]\', \'special\');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Getter/Setter]\', \'special\');\n          } else {\n            str = stylize(\'[Getter]\', \'special\');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Setter]\', \'special\');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = \'[\' + key + \']\';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf(\'\\n\') > -1) {\n            if (isArray(value)) {\n              str = str.split(\'\\n\').map(function(line) {\n                return \'  \' + line;\n              }).join(\'\\n\').substr(2);\n            } else {\n              str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n                return \'   \' + line;\n              }).join(\'\\n\');\n            }\n          }\n        } else {\n          str = stylize(\'[Circular]\', \'special\');\n        }\n      }\n      if (typeof name === \'undefined\') {\n        if (type === \'Array\' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\'\' + key);\n        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, \'name\');\n        } else {\n          name = name.replace(/\'/g, "\\\\\'")\n                     .replace(/\\\\"/g, \'"\')\n                     .replace(/(^"|"$)/g, "\'");\n          name = stylize(name, \'string\');\n        }\n      }\n\n      return name + \': \' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === \'\' ? \'\' : base + \'\\n \') +\n               \' \' +\n               output.join(\',\\n  \') +\n               \' \' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === \'undefined\' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === \'object\' && Object.prototype.toString.call(ar) === \'[object Array]\');\n}\n\n\nfunction isRegExp(re) {\n  typeof re === \'object\' && Object.prototype.toString.call(re) === \'[object RegExp]\';\n}\n\n\nfunction isDate(d) {\n  return typeof d === \'object\' && Object.prototype.toString.call(d) === \'[object Date]\';\n}\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { \'__proto__\' : null };\n    }\n    else {\n        if (typeof prototype !== \'object\') {\n            throw new TypeError(\n                \'typeof prototype[\' + (typeof prototype) + \'] != \\\'object\\\'\'\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== \'undefined\' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== \'string\') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== \'object\') {\n      str += \' \' + x;\n    } else {\n      str += \' \' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{"events":79}],31:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents a Name as an array of components where each is a byte array.\n */\n \nvar Blob = require(\'./util/blob.js\').Blob;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Name from components.\n * \n * @constructor\n * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.  \n * Otherwise it is an array of components which are appended according to Name.append, so\n * convert each and store it as an array of customBuf.  If a component is a string, encode as utf8.\n */\nvar Name = function Name(components) \n{\n  if (typeof components == \'string\') {    \n    if (LOG > 3) console.log(\'Content Name String \' + components);\n    this.components = Name.createNameArray(components);\n  }\n  else if (typeof components === \'object\') {    \n    this.components = [];\n    if (components instanceof Name)\n      this.append(components);\n    else {\n      for (var i = 0; i < components.length; ++i)\n        this.append(components[i]);\n    }\n  }\n  else if (components == null)\n    this.components = [];\n  else\n    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");\n};\n\nexports.Name = Name;\n\n/**\n * \n * @constructor\n * Create a new Name.Component with a copy of the given value.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don\'t unescape).\n */\nName.Component = function NameComponent(value) \n{\n  if (typeof value === \'string\')\n    this.value = DataUtils.stringToUtf8Array(value);\n  else if (typeof value === \'object\' && value instanceof Name.Component)\n    this.value = new customBuf(value.value);\n  else if (typeof value === \'object\' && value instanceof Blob)\n    this.value = new customBuf(value.buf());\n  else if (typeof value === \'object\' && value instanceof customBuf)\n    this.value = new customBuf(value);\n  else if (typeof value === \'object\' && typeof ArrayBuffer !== \'undefined\' &&  value instanceof ArrayBuffer) {\n    // Make a copy.  Don\'t use ArrayBuffer.slice since it isn\'t always supported.                                                      \n    this.value = new customBuf(new ArrayBuffer(value.byteLength));\n    this.value.set(new customBuf(value));\n  }\n  else if (typeof value === \'object\')\n    // Assume value is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    this.value = new customBuf(value);\n  else \n    throw new Error("Name.Component constructor: Invalid type");\n}\n\n/**\n * Get the component value.\n * @returns {Buffer} The component value.\n */\nName.Component.prototype.getValue = function() \n{\n  return this.value;\n}\n\n/**\n * Convert this component value to a string by escaping characters according to the NDN URI Scheme.\n * This also adds "..." to a value with zero or more ".".\n * @returns {string} The escaped string.\n */\nName.Component.prototype.toEscapedString = function() \n{\n  return Name.toEscapedString(this.value);\n}\n\n/**\n * Check if this is the same component as other.\n * @param {Name.Component} other The other Component to compare with.\n * @returns {Boolean} true if the components are equal, otherwise false.\n */\nName.Component.prototype.equals = function(other) \n{\n  return DataUtils.arraysEqual(this.value, other.value);\n}\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.getName = function() \n{\n  return this.toUri();\n};\n\n/** Parse uri as a URI and return an array of customBuf components.\n */\nName.createNameArray = function(uri) \n{\n  uri = uri.trim();\n  if (uri.length <= 0)\n    return [];\n\n  var iColon = uri.indexOf(\':\');\n  if (iColon >= 0) {\n    // Make sure the colon came before a \'/\'.\n    var iFirstSlash = uri.indexOf(\'/\');\n    if (iFirstSlash < 0 || iColon < iFirstSlash)\n      // Omit the leading protocol such as ndn:\n      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();\n  }\n    \n  if (uri[0] == \'/\') {\n    if (uri.length >= 2 && uri[1] == \'/\') {\n      // Strip the authority following "//".\n      var iAfterAuthority = uri.indexOf(\'/\', 2);\n      if (iAfterAuthority < 0)\n        // Unusual case: there was only an authority.\n        return [];\n      else\n        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();\n    }\n    else\n      uri = uri.substr(1, uri.length - 1).trim();\n  }\n\n  var array = uri.split(\'/\');\n    \n  // Unescape the components.\n  for (var i = 0; i < array.length; ++i) {\n    var value = Name.fromEscapedString(array[i]);\n        \n    if (value == null) {\n      // Ignore the illegal componenent.  This also gets rid of a trailing \'/\'.\n      array.splice(i, 1);\n      --i;  \n      continue;\n    }\n    else\n      array[i] = new Name.Component(value);\n  }\n\n  return array;\n};\n\nName.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)  \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  this.components = [];\n\n  while (decoder.peekDTag(NDNProtocolDTags.Component))\n    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    \n  decoder.readElementClose();\n};\n\nName.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{    \n  if (this.components == null) \n    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  var count = this.size();\n  for (var i=0; i < count; i++)\n    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());\n  \n  encoder.writeElementClose();\n};\n\nName.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.Name;\n};\n\n/**\n * Convert the component to a customBuf and append to this Name.\n * Return this Name object to allow chaining calls to add.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don\'t unescape).\n * @returns {Name}\n */\nName.prototype.append = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name) {\n    var components;\n    if (component == this)\n      // special case, when we need to create a copy\n      components = this.components.slice(0, this.components.length);\n    else\n      components = component.components;\n      \n    for (var i = 0; i < components.length; ++i)\n      this.components.push(new Name.Component(components[i]));\n  }\n  else\n    // Just use the Name.Component constructor.\n    this.components.push(new Name.Component(component));\n\n  return this;\n};\n\n/**\n * @deprecated Use append.\n */\nName.prototype.add = function(component)\n{\n  return this.append(component);\n};\n\n/**\n * Clear all the components.\n */\nName.prototype.clear = function()\n{\n  this.components = [];  \n};\n\n/**\n * Return the escaped name string according to "NDNx URI Scheme".\n * @returns {String}\n */\nName.prototype.toUri = function() \n{  \n  if (this.size() == 0)\n    return "/";\n    \n  var result = "";\n  \n  for (var i = 0; i < this.size(); ++i)\n    result += "/"+ Name.toEscapedString(this.components[i].getValue());\n  \n  return result;  \n};\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.to_uri = function() \n{\n  return this.toUri();\n};\n\n/**\n * Append a component with the encoded segment number.\n * @param {number} segment The segment number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendSegment = function(segment) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(segment);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * Append a component with the encoded version number.\n * Note that this encodes the exact value of version without converting from a \n * time representation.\n * @param {number} version The version number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendVersion = function(version) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(version);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0xfD;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * @deprecated Use appendSegment.\n */\nName.prototype.addSegment = function(number) \n{\n  return this.appendSegment(number);\n};\n\n/**\n * Get a new name, constructed as a subset of components.\n * @param {number} iStartComponent The index if the first component to get.\n * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,\n * return components starting at iStartComponent until the end of the name.\n * @returns {Name} A new name.\n */\nName.prototype.getSubName = function(iStartComponent, nComponents)\n{\n  if (nComponents == undefined)\n    nComponents = this.components.length - iStartComponent;\n  \n  var result = new Name();\n\n  var iEnd = iStartComponent + nComponents;\n  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)\n    result.components.push(this.components[i]);\n\n  return result;  \n};\n\n/**\n * Return a new Name with the first nComponents components of this Name.\n * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up\n * to name.size() - N. For example getPrefix(-1) returns the name without the final component.\n * @returns {Name} A new name.\n */\nName.prototype.getPrefix = function(nComponents) \n{\n  if (nComponents < 0)\n    return this.getSubName(0, this.components.length + nComponents);\n  else\n    return this.getSubName(0, nComponents);\n};\n\n/**\n * @brief Get prefix of the name, containing less minusComponents right components\n * @param minusComponents number of components to cut from the back\n */\nName.prototype.cut = function(minusComponents) \n{\n  return new Name(this.components.slice(0, this.components.length - minusComponents));\n};\n\n/**\n * Return the number of name components.\n * @returns {number}\n */\nName.prototype.size = function() \n{\n  return this.components.length;\n};\n\n/**\n * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().\n * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component\n * at size() - (-i).\n * @returns {Name.Component}\n */\nName.prototype.get = function(i) \n{\n  if (i >= 0) {\n    if (i >= this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[i]);\n  }\n  else {\n    // Negative index.\n    if (i < -this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[this.components.length - (-i)]);\n  }\n};\n\n/**\n * @deprecated Use size().\n */\nName.prototype.getComponentCount = function() \n{\n  return this.components.length;\n};\n\n/**\n * @deprecated To get just the component value, use get(i).getValue().\n */\nName.prototype.getComponent = function(i) \n{\n  return new customBuf(this.components[i].getValue());\n};\n\n/**\n * The "file name" in a name is the last component that isn\'t blank and doesn\'t start with one of the\n *   special marker octets (for version, etc.).  Return the index in this.components of\n *   the file name, or -1 if not found.\n */\nName.prototype.indexOfFileName = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var component = this.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n        \n    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 || \n        (component[0] >= 0xF5 && component[0] <= 0xFF))\n      continue;\n        \n    return i;\n  }\n    \n  return -1;\n};\n\n/**\n * Return true if this Name has the same components as name.\n */\nName.prototype.equals = function(name) \n{\n  if (this.components.length != name.components.length)\n    return false;\n    \n  // Start from the last component because they are more likely to differ.\n  for (var i = this.components.length - 1; i >= 0; --i) {\n    if (!this.components[i].equals(name.components[i]))\n      return false;\n  }\n    \n  return true;\n};\n\n/**\n * @deprecated Use equals.\n */\nName.prototype.equalsName = function(name)\n{\n  return this.equals(name);\n};\n\n/**\n * Find the last component in name that has a ContentDigest and return the digest value as customBuf, \n *   or null if not found.  See Name.getComponentContentDigestValue.\n */\nName.prototype.getContentDigestValue = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var digestValue = Name.getComponentContentDigestValue(this.components[i]);\n    if (digestValue != null)\n      return digestValue;\n  }\n    \n  return null;\n};\n\n/**\n * If component is a ContentDigest, return the digest value as a customBuf slice (don\'t modify!).\n * If not a ContentDigest, return null.\n * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.\n */\nName.getComponentContentDigestValue = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length; \n  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.\n  if (component.length == digestComponentLength &&\n      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length), \n                            Name.ContentDigestPrefix) &&\n      DataUtils.arraysEqual(component.slice\n         (component.length - Name.ContentDigestSuffix.length, component.length),\n                            Name.ContentDigestSuffix))\n   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);\n else\n   return null;\n};\n\n// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB. \nName.ContentDigestPrefix = new customBuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);\nName.ContentDigestSuffix = new customBuf([0x00]);\n\n\n/**\n * Return value as an escaped string according to "NDNx URI Scheme".\n * We can\'t use encodeURIComponent because that doesn\'t encode all the characters we want to.\n * @param {Buffer|Name.Component} component The value or Name.Component to escape.\n * @returns {string} The escaped string.\n */\nName.toEscapedString = function(value) \n{\n  if (typeof value == \'object\' && value instanceof Name.Component)\n    value = value.getValue();\n  \n  var result = "";\n  var gotNonDot = false;\n  for (var i = 0; i < value.length; ++i) {\n    if (value[i] != 0x2e) {\n      gotNonDot = true;\n      break;\n    }\n  }\n  if (!gotNonDot) {\n    // Special case for component of zero or more periods.  Add 3 periods.\n    result = "...";\n    for (var i = 0; i < value.length; ++i)\n      result += ".";\n  }\n  else {\n    for (var i = 0; i < value.length; ++i) {\n      var x = value[i];\n      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)\n      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||\n          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d || \n          x == 0x2e || x == 0x5f)\n        result += String.fromCharCode(x);\n      else\n        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();\n    }\n  }\n  return result;\n};\n\n/**\n * Return a customBuf byte array by decoding the escapedString according to "NDNx URI Scheme".\n * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.\n * @param {string} escapedString The escaped string to decode.\n * @returns {Buffer} The byte array, or null which means to skip the component in the name.\n */\nName.fromEscapedString = function(escapedString) \n{\n  var value = unescape(escapedString.trim());\n        \n  if (value.match(/[^.]/) == null) {\n    // Special case for value of only periods.  \n    if (value.length <= 2)\n      // Zero, one or two periods is illegal.  Ignore this componenent to be\n      //   consistent with the C implementation.\n      return null;\n    else\n      // Remove 3 periods.\n      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));\n  }\n  else\n    return DataUtils.toNumbersFromString(value);\n};\n\n/**\n * Return true if the N components of this name are the same as the first N components of the given name.\n * @param {Name} name The name to check.\n * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.\n */\nName.prototype.match = function(name) \n{\n  var i_name = this.components;\n  var o_name = name.components;\n\n  // This name is longer than the name we are checking it against.\n  if (i_name.length > o_name.length)\n    return false;\n\n  // Check if at least one of given components doesn\'t match.\n  for (var i = 0; i < i_name.length; ++i) {\n    if (!i_name[i].equals(o_name[i]))\n      return false;\n  }\n\n  return true;\n};\n\n})()\n},{"./buffer.js":50,"./encoding/binary-xml-decoder.js":81,"./encoding/binary-xml-encoder.js":80,"./encoding/data-utils.js":43,"./log.js":83,"./util/blob.js":45,"./util/ndn-protoco-id-tags.js":82}],32:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar Name = require(\'./name.js\').Name;\nvar Exclude = require(\'./exclude.js\').Exclude;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').LOG\n/**\n * Create a new Interest with the optional values.\n * \n * @constructor\n * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the\n * other arguments.  Otherwise this is the optional name for the new Interest.\n * @param {number} minSuffixComponents\n * @param {number} maxSuffixComponents\n * @param {Buffer} publisherPublicKeyDigest\n * @param {Exclude} exclude\n * @param {number} childSelector\n * @param {number} answerOriginKind\n * @param {number} scope\n * @param {number} interestLifetimeMilliseconds in milliseconds\n * @param {Buffer} nonce\n */\nvar Interest = function Interest\n   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude, \n    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce) \n{\n  if (typeof nameOrInterest === \'object\' && nameOrInterest instanceof Interest) {\n    // Special case: this is a copy constructor.  Ignore all but the first argument.\n    var interest = nameOrInterest;\n    if (interest.name)\n      // Copy the name.\n      this.name = new Name(interest.name);\n    this.maxSuffixComponents = interest.maxSuffixComponents;\n    this.minSuffixComponents = interest.minSuffixComponents;\n\n    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator(interest.keyLocator);\n    this.exclude = new Exclude(interest.exclude);\n    this.childSelector = interest.childSelector;\n    this.answerOriginKind = interest.answerOriginKind;\n    this.scope = interest.scope;\n    this.interestLifetime = interest.interestLifetime;\n    if (interest.nonce)\n      // Copy.\n      this.nonce = new customBuf(interest.nonce);    \n  }  \n  else {\n    this.name = typeof nameOrInterest === \'object\' && nameOrInterest instanceof Name ?\n                new Name(nameOrInterest) : new Name();\n    this.maxSuffixComponents = maxSuffixComponents;\n    this.minSuffixComponents = minSuffixComponents;\n\n    this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator();\n    this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                   new Exclude(exclude) : new Exclude();\n    this.childSelector = childSelector;\n    this.answerOriginKind = answerOriginKind;\n    this.scope = scope;\n    this.interestLifetime = interestLifetimeMilliseconds;\n    if (nonce)\n      // Copy and make sure it is a customBuf.\n      this.nonce = new customBuf(nonce);\n  }\n};\n\nexports.Interest = Interest;\n\nInterest.RECURSIVE_POSTFIX = "*";\n\nInterest.CHILD_SELECTOR_LEFT = 0;\nInterest.CHILD_SELECTOR_RIGHT = 1;\n\nInterest.ANSWER_NO_CONTENT_STORE = 0;\nInterest.ANSWER_CONTENT_STORE = 1;\nInterest.ANSWER_GENERATED = 2;\nInterest.ANSWER_STALE = 4;    // Stale answer OK\nInterest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"\n\nInterest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;\n\n/**\n * Return true if this.name.match(name) and the name conforms to the interest selectors.\n * @param {Name} name\n * @returns {boolean}\n */\nInterest.prototype.matchesName = function(/*Name*/ name) \n{\n  if (!this.name.match(name))\n    return false;\n    \n  if (this.minSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))\n    return false;\n  if (this.maxSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))\n    return false;\n  if (this.exclude != null && name.size() > this.name.size() &&\n      this.exclude.matches(name.components[this.name.size()]))\n    return false;\n    \n  return true;\n};\n\n/**\n * @deprecated Use matchesName.\n */\nInterest.prototype.matches_name = function(/*Name*/ name) \n{\n  return this.matchesName(name);\n};\n\n/**\n * Return a new Interest with the same fields as this Interest.  \n */\nInterest.prototype.clone = function() \n{\n  return new Interest\n     (this.name, this.minSuffixComponents, this.maxSuffixComponents, \n      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind, \n      this.scope, this.interestLifetime, this.nonce);\n};\n\n/**\n * Get the interest Name.\n * @returns {Name} The name.  The name size() may be 0 if not specified.\n */\nInterest.prototype.getName = function() { return this.name; };\n\n/**\n * Get the min suffix components.\n * @returns number} The min suffix components, or null if not specified.\n */\nInterest.prototype.getMinSuffixComponents = function() \n{ \n  return this.minSuffixComponents; \n};\n\n/**\n * Get the max suffix components.\n * @returns {number} The max suffix components, or null if not specified.\n */\nInterest.prototype.getMaxSuffixComponents = function() \n{ \n  return this.maxSuffixComponents; \n};\n\n/**\n * Get the interest key locator.\n * @returns {KeyLocator} The key locator. If its getType() is null, \n * then the key locator is not specified.\n */\nInterest.prototype.getKeyLocator = function() \n{ \n  return this.keyLocator; \n};\n\n/**\n * Get the exclude object.\n * @returns {Exclude} The exclude object. If the exclude size() is zero, then\n * the exclude is not specified.\n */\nInterest.prototype.getExclude = function() { return this.exclude; };\n\n/**\n * Get the child selector.\n * @returns {number} The child selector, or null if not specified.\n */\nInterest.prototype.getChildSelector = function() \n{ \n  return this.childSelector; \n};\n\n/**\n * @deprecated Use getMustBeFresh.\n */\nInterest.prototype.getAnswerOriginKind = function() \n{ \n  return this.answerOriginKind; \n};\n  \n  /**\n   * Return true if the content must be fresh.\n   * @return true if must be fresh, otherwise false.\n   */\n  \n/**\n * Get the must be fresh flag. If not specified, the default is true.\n * @returns {boolean} The must be fresh flag.\n */\nInterest.prototype.getMustBeFresh = function() \n{\n  if (this.answerOriginKind == null || this.answerOriginKind < 0)\n    return true;\n  else\n    return (this.answerOriginKind & Interest.ANSWER_STALE) == 0;\n};\n\n/**\n * Return the nonce value from the incoming interest.  If you change any of the \n * fields in this Interest object, then the nonce value is cleared.\n * @returns {Buffer} The nonce, or null if not specified.\n */\nInterest.prototype.getNonce = function() { return this.nonce; };\n\n/**\n * Get the interest scope.\n * @returns {number} The scope, or null if not specified.\n */\nInterest.prototype.getScope = function() { return this.scope; };\n\n/**\n * Get the interest lifetime.\n * @returns {number} The interest lifetime in milliseconds, or null if not \n * specified.\n */\nInterest.prototype.getInterestLifetimeMilliseconds = function() \n{ \n  return this.interestLifetime; \n};\n\nInterest.prototype.setName = function(name)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.name = typeof name === \'object\' && name instanceof Interest ?\n              new Name(name) : new Name();\n};\n                \nInterest.prototype.setMinSuffixComponents = function(minSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.minSuffixComponents = minSuffixComponents;\n};\n\nInterest.prototype.setMaxSuffixComponents = function(maxSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.maxSuffixComponents = maxSuffixComponents;\n};\n\n/**\n * Set this interest to use a copy of the given exclude object. Note: You can \n * also change this interest\'s exclude object modifying the object from \n * getExclude().\n * @param {Exclude} exclude The exlcude object that is copied.\n */\nInterest.prototype.setExclude = function(exclude)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                 new Exclude(exclude) : new Exclude();\n};\n\nInterest.prototype.setChildSelector = function(childSelector)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.childSelector = childSelector;\n};\n\n/**\n * @deprecated Use setMustBeFresh.\n */\nInterest.prototype.setAnswerOriginKind = function(answerOriginKind)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.answerOriginKind = answerOriginKind;\n};\n\n/**\n * Set the MustBeFresh flag.\n * @param {boolean} mustBeFresh True if the content must be fresh, otherwise false.\n */\nInterest.prototype.setMustBeFresh = function(mustBeFresh)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  if (this.answerOriginKind == null || this.answerOriginKind < 0) {\n    // It is is already the default where MustBeFresh is true. \n    if (!mustBeFresh)\n      // Set answerOriginKind_ so that getMustBeFresh returns false.\n      this.answerOriginKind = Interest.ANSWER_STALE; \n  }\n  else {\n    if (mustBeFresh)\n      // Clear the stale bit.\n      this.answerOriginKind &= ~Interest.ANSWER_STALE;\n    else\n      // Set the stale bit.\n      this.answerOriginKind |= Interest.ANSWER_STALE;\n  }\n};\n\nInterest.prototype.setScope = function(scope)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.scope = scope;\n};\n\nInterest.prototype.setInterestLifetimeMilliseconds = function(interestLifetimeMilliseconds)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.interestLifetime = interestLifetimeMilliseconds;\n};\n\n/**\n * @deprecated You should let the wire encoder generate a random nonce \n * internally before sending the interest.\n */\nInterest.prototype.setNonce = function(nonce)\n{\n  if (nonce)\n    // Copy and make sure it is a customBuf.\n    this.nonce = new customBuf(nonce);\n  else\n    this.nonce = null;\n};\n\n/**\n * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and\n * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".\n * @returns {string} The URI string.\n * @note This is an experimental feature.  See the API docs for more detail at\n * http://named-data.net/doc/ndn-ccl-api/interest.html#interest-touri-method .\n */\nInterest.prototype.toUri = function() \n{  \n  var selectors = "";\n  \n  if (this.minSuffixComponents != null)\n    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;\n  if (this.maxSuffixComponents != null)\n    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;\n  if (this.childSelector != null)\n    selectors += "&ndn.ChildSelector=" + this.childSelector;\n  if (this.answerOriginKind != null)\n    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;\n  if (this.scope != null)\n    selectors += "&ndn.Scope=" + this.scope;\n  if (this.interestLifetime != null)\n    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;\n  if (this.publisherPublicKeyDigest != null)\n    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  if (this.nonce != null)\n    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);\n  if (this.exclude != null && this.exclude.size() > 0)\n    selectors += "&ndn.Exclude=" + this.exclude.toUri();\n\n  var result = this.name.toUri();\n  if (selectors != "")\n    // Replace the first & with ?.\n    result += "?" + selectors.substr(1);\n  \n  return result;\n};\n\n/**\n * Encode this Interest for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {Blob} The encoded buffer in a Blob object.\n */\nInterest.prototype.wireEncode = function(wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return wireFormat.encodeInterest(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Interest.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nInterest.prototype.wireDecode = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  if (LOG > 3 ) console.log(\'decoding input to interes\', input)\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ? \n                     input.buf() : input;\n  wireFormat.decodeInterest(this, decodeBuffer);\n};\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom \n// to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  BinaryXmlWireFormat.decodeInterest(this, decoder);\n};\n\n/**\n * @deprecated Use wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder) \n{\n  BinaryXmlWireFormat.encodeInterest(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.encode = function(wireFormat) \n{\n  return this.wireEncode(BinaryXmlWireFormat.get()).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.decode = function(input, wireFormat) \n{\n  this.wireDecode(input, BinaryXmlWireFormat.get())\n};\n\n})()\n},{"./buffer.js":50,"./encoding/binary-xml-wire-format.js":41,"./encoding/wire-format.js":40,"./exclude.js":34,"./key-locator.js":38,"./log.js":83,"./name.js":31,"./publisher-public-key-digest.js":39,"./util/blob.js":45}],33:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\n\n/**\n * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for\n * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding\n * bits are changed, amended or deprecated.\n * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.\n */\nvar ForwardingFlags = function ForwardingFlags() \n{\n  this.active = true;\n  this.childInherit = true;\n  this.advertise = false;\n  this.last = false;\n  this.capture = false;\n  this.local = false;\n  this.tap = false;\n  this.captureOk = false;\n}\n\nexports.ForwardingFlags = ForwardingFlags;\n\n/**\n * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.\n * @returns {number} An integer with the bits set.\n */\nForwardingFlags.prototype.getForwardingEntryFlags = function()\n{\n  var result = 0;\n  \n  if (this.active)\n    result |= ForwardingEntry.ACTIVE;\n  if (this.childInherit)\n    result |= ForwardingEntry.CHILD_INHERIT;\n  if (this.advertise)\n    result |= ForwardingEntry.ADVERTISE;\n  if (this.last)\n    result |= ForwardingEntry.LAST;\n  if (this.capture)\n    result |= ForwardingEntry.CAPTURE;\n  if (this.local)\n    result |= ForwardingEntry.LOCAL;\n  if (this.tap)\n    result |= ForwardingEntry.TAP;\n  if (this.captureOk)\n    result |= ForwardingEntry.CAPTURE_OK;\n  \n  return result;\n};\n\n/**\n * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.\n * @param {number} forwardingEntryFlags An integer with the bits set.\n */\nForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)\n{\n  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);\n  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);\n  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);\n  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);\n  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);\n  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);\n  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);\n  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);\n};\n\n/**\n * Get the value of the "active" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getActive = function() { return this.active; };\n\n/**\n * Get the value of the "childInherit" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };\n\n/**\n * Get the value of the "advertise" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };\n\n/**\n * Get the value of the "last" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLast = function() { return this.last; };\n\n/**\n * Get the value of the "capture" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCapture = function() { return this.capture; };\n\n/**\n * Get the value of the "local" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLocal = function() { return this.local; };\n\n/**\n * Get the value of the "tap" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getTap = function() { return this.tap; };\n\n/**\n * Get the value of the "captureOk" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };\n\n/**\n * Set the value of the "active" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setActive = function(value) { this.active = value; };\n\n/**\n * Set the value of the "childInherit" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };\n\n/**\n * Set the value of the "advertise" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };\n\n/**\n * Set the value of the "last" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLast = function(value) { this.last = value; };\n\n/**\n * Set the value of the "capture" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };\n\n/**\n * Set the value of the "local" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLocal = function(value) { this.local = value; };\n\n/**\n * Set the value of the "tap" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setTap = function(value) { this.tap = value; };\n\n/**\n * Set the value of the "captureOk" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };\n\n},{"./forwarding-entry.js":84}],34:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an Interest Exclude.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\n\n/**\n * Create a new Exclude.\n * @constructor\n * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, customBuf component or Exclude.ANY.\n */\nvar Exclude = function Exclude(values) \n{ \n  this.values = [];\n  \n  if (typeof values === \'object\' && values instanceof Exclude)\n    // Copy the exclude.\n    this.values = values.values.slice(0);\n  else if (values) {\n    for (var i = 0; i < values.length; ++i) {\n      if (values[i] == Exclude.ANY)\n        this.appendAny();\n      else\n        this.appendComponent(values[i]);\n    }\n  }\n};\n\nexports.Exclude = Exclude;\n\nExclude.ANY = "*";\n\n/**\n * Get the number of entries.\n * @returns {number} The number of entries.\n */\nExclude.prototype.size = function() { return this.values.length; };\n\n/**\n * Get the entry at the given index.\n * @param {number} i The index of the entry, starting from 0.\n * @returns {Exclude.ANY|Name.Component} Exclude.ANY or a Name.Component.\n */\nExclude.prototype.get = function(i) { return this.values[i]; };\n\n/**\n * Append an Exclude.ANY element.\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendAny = function() \n{\n  this.values.push(Exclude.ANY);\n  return this;\n};\n\n/**\n * Append a component entry, copying from component.\n * @param {Name.Component|Buffer} component\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendComponent = function(component) \n{\n  this.values.push(new Name.Component(component));\n  return this;\n};\n\n/**\n * Clear all the entries.\n */\nExclude.prototype.clear = function() \n{\n  this.values = [];\n};\n\nExclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);\n\n  while (true) {\n    if (decoder.peekDTag(NDNProtocolDTags.Component))\n      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {\n      decoder.readElementStartDTag(NDNProtocolDTags.Any);\n      decoder.readElementClose();\n      this.appendAny();\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {\n      // Skip the Bloom and treat it as Any.\n      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);\n      this.appendAny();\n    }\n    else\n      break;\n  }\n    \n  decoder.readElementClose();\n};\n\nExclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{\n  if (this.values == null || this.values.length == 0)\n    return;\n\n  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);\n    \n  // TODO: Do we want to order the components (except for ANY)?\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      encoder.writeElementStartDTag(NDNProtocolDTags.Any);\n      encoder.writeElementClose();\n    }\n    else\n      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());\n  }\n\n  encoder.writeElementClose();\n};\n\n/**\n * Return a string with elements separated by "," and Exclude.ANY shown as "*". \n */\nExclude.prototype.toUri = function() \n{\n  if (this.values == null || this.values.length == 0)\n    return "";\n\n  var result = "";\n  for (var i = 0; i < this.values.length; ++i) {\n    if (i > 0)\n      result += ",";\n        \n    if (this.values[i] == Exclude.ANY)\n      result += "*";\n    else\n      result += Name.toEscapedString(this.values[i].getValue());\n  }\n  return result;\n};\n\n/**\n * Return true if the component matches any of the exclude criteria.\n */\nExclude.prototype.matches = function(/*Buffer*/ component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      var lowerBound = null;\n      if (i > 0)\n        lowerBound = this.values[i - 1];\n      \n      // Find the upper bound, possibly skipping over multiple ANY in a row.\n      var iUpperBound;\n      var upperBound = null;\n      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {\n        if (this.values[iUpperBound] != Exclude.ANY) {\n          upperBound = this.values[iUpperBound];\n          break;\n        }\n      }\n      \n      // If lowerBound != null, we already checked component equals lowerBound on the last pass.\n      // If upperBound != null, we will check component equals upperBound on the next pass.\n      if (upperBound != null) {\n        if (lowerBound != null) {\n          if (Exclude.compareComponents(component, lowerBound) > 0 &&\n              Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n        else {\n          if (Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n          \n        // Make i equal iUpperBound on the next pass.\n        i = iUpperBound - 1;\n      }\n      else {\n        if (lowerBound != null) {\n            if (Exclude.compareComponents(component, lowerBound) > 0)\n              return true;\n        }\n        else\n          // this.values has only ANY.\n          return true;\n      }\n    }\n    else {\n      if (DataUtils.arraysEqual(component, this.values[i].getValue()))\n        return true;\n    }\n  }\n  \n  return false;\n};\n\n/**\n * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.\n * A component is less if it is shorter, otherwise if equal length do a byte comparison.\n */\nExclude.compareComponents = function(component1, component2) \n{\n  if (typeof component1 == \'object\' && component1 instanceof Name.Component)\n    component1 = component1.getValue();\n  if (typeof component2 == \'object\' && component2 instanceof Name.Component)\n    component2 = component2.getValue();\n\n  if (component1.length < component2.length)\n    return -1;\n  if (component1.length > component2.length)\n    return 1;\n  \n  for (var i = 0; i < component1.length; ++i) {\n    if (component1[i] < component2[i])\n      return -1;\n    if (component1[i] > component2[i])\n      return 1;\n  }\n\n  return 0;\n};\n\n})()\n},{"./buffer.js":50,"./encoding/binary-xml-decoder.js":81,"./encoding/binary-xml-encoder.js":80,"./encoding/data-utils.js":43,"./name.js":31,"./util/ndn-protoco-id-tags.js":82}],29:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang\n * See COPYING for copyright and distribution information.\n * This class represents the top-level object for communicating with an NDN host.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar crypto = require(\'./crypto.js\');\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Interest = require(\'./interest.js\').Interest;\nvar Data = require(\'./data.js\').Data;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\nvar TlvWireFormat = require(\'./encoding/tlv-wire-format.js\').TlvWireFormat;\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nvar Tlv = require(\'./encoding/tlv/tlv.js\').Tlv;\nvar TlvDecoder = require(\'./encoding/tlv/tlv-decoder.js\').TlvDecoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Key = require(\'./key.js\').Key;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar ForwardingFlags = require(\'./forwarding-flags.js\').ForwardingFlags;\nvar Closure = require(\'./closure.js\').Closure;\nvar UpcallInfo = require(\'./closure.js\').UpcallInfo;\nvar TcpTransport = require(\'./transport/tcp-transport.js\').TcpTransport;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Face with the given settings.\n * This throws an exception if Face.supported is false.\n * @constructor\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.\n *              OR function() { return new TcpTransport(); },       // If in Node.js.\n *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.\n *   host: null, // If null, use getHostAndPort when connecting.\n *   port: 9696, // If in the browser.\n *      OR 6363, // If in Node.js.\n *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },\n *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },\n *   verify: false // If false, don\'t verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.\n * }\n */\nvar Face = function Face(settings) \n{\n  if (!Face.supported)\n    throw new Error("The necessary JavaScript support is not available on this platform.");\n    \n  settings = (settings || {});\n  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.\n  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });\n  this.transport = getTransport();\n  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);\n  this.host = (settings.host !== undefined ? settings.host : null);\n  this.port = (settings.port || (typeof WebSocketTransport != \'undefined\' ? 9696 : 6363));\n  this.readyStatus = Face.UNOPEN;\n  this.verify = (settings.verify !== undefined ? settings.verify : false);\n  // Event handler\n  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });\n  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });\n  this.ndndid = null;\n};\n\nexports.Face = Face;\n\nFace.UNOPEN = 0;  // created but not opened yet\nFace.OPENED = 1;  // connection to ndnd opened\nFace.CLOSED = 2;  // connection to ndnd closed\n\n/**\n * Return true if necessary JavaScript support is available, else log an error and return false.\n */\nFace.getSupported = function() \n{\n  try {\n    var dummy = new customBuf(1).slice(0, 1);\n  } \n  catch (ex) {\n    console.log("NDN not available: customBuf not supported. " + ex);\n    return false;\n  }\n    \n  return true;\n};\n\nFace.supported = Face.getSupported();\n\nFace.ndndIdFetcher = new Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\');\n\nFace.prototype.createRoute = function(host, port) \n{\n  this.host=host;\n  this.port=port;\n};\n\nFace.KeyStore = new Array();\n\nvar KeyStoreEntry = function KeyStoreEntry(name, rsa, time) \n{\n  this.keyName = name;  // KeyName\n  this.rsaKey = rsa;    // RSA key\n  this.timeStamp = time;  // Time Stamp\n};\n\nFace.addKeyEntry = function(/* KeyStoreEntry */ keyEntry) \n{\n  var result = Face.getKeyByName(keyEntry.keyName);\n  if (result == null) \n    Face.KeyStore.push(keyEntry);\n  else\n    result = keyEntry;\n};\n\nFace.getKeyByName = function(/* KeyName */ name) \n{\n  var result = null;\n  \n  for (var i = 0; i < Face.KeyStore.length; i++) {\n    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {\n      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)\n        result = Face.KeyStore[i];\n    }\n  }\n    \n  return result;\n};\n\nFace.prototype.close = function() \n{\n  if (this.readyStatus != Face.OPENED)\n    throw new Error(\'Cannot close because Face connection is not opened.\');\n\n  this.readyStatus = Face.CLOSED;\n  this.transport.close();\n};\n\n// For fetching data\nFace.PITTable = new Array();\n\n/**\n * @constructor\n */\nvar PITEntry = function PITEntry(interest, closure) \n{\n  this.interest = interest;  // Interest\n  this.closure = closure;    // Closure\n  this.timerID = -1;  // Timer ID\n};\n\n/**\n * Return the entry from Face.PITTable where the name conforms to the interest selectors, and\n * the interest name is the longest that matches name.\n */\n\n/**\n * Find all entries from Face.PITTable where the name conforms to the entry\'s \n * interest selectors, remove the entries from the table, cancel their timeout\n * timers and return them.\n * @param {Name} name The name to find the interest for (from the incoming data\n * packet).\n * @returns {Array<PITEntry>} The matching entries from Face.PITTable, or [] if \n * none are found.\n */\nFace.extractEntriesForExpressedInterest = function(name) \n{\n  var result = [];\n    \n  // Go backwards through the list so we can erase entries.\n  for (var i = Face.PITTable.length - 1; i >= 0; --i) {\n    var entry = Face.PITTable[i];\n    if (entry.interest.matchesName(name)) {\n      // Cancel the timeout timer.\n      clearTimeout(entry.timerID);\n\n      result.push(entry);\n      Face.PITTable.splice(i, 1);\n    }\n  }\n\n  return result;\n};\n\n// For publishing data\nFace.registeredPrefixTable = new Array();\n\n/**\n * @constructor\n */\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure) \n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n/**\n * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.\n * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).\n * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.\n */\nfunction getEntryForRegisteredPrefix(name) \n{\n  var iResult = -1;\n  \n  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {\n    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " , Face.registeredPrefixTable[i].prefix , " matches " , name);\n    if (Face.registeredPrefixTable[i].prefix.match(name)) {\n      if (iResult < 0 || \n          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())\n        // Update to the longer match.\n        iResult = i;\n    }\n  }\n  \n  if (iResult >= 0)\n    return Face.registeredPrefixTable[iResult];\n  else\n    return null;\n}\n\n/**\n * Return a function that selects a host at random from hostList and returns { host: host, port: port }.\n * If no more hosts remain, return null.\n */\nFace.makeShuffledGetHostAndPort = function(hostList, port) \n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n      \n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n/**\n * Send the interest through the transport, read the entire response and call onData. \n * If the interest times out according to interest lifetime, call onTimeout (if not omitted).\n * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):\n * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from\n * a name and optional interest template:\n * expressInterest(name [, template], onData [, onTimeout]).\n * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.\n * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.\n * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:\n *   interest is the interest given to expressInterest,\n *   data is the received Data object.\n * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime, \n *   this calls onTimeout(interest) where:\n *   interest is the interest given to expressInterest.\n * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).\n * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest. \n * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).\n */\nFace.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4) \n{\n  // There are several overloaded versions of expressInterest, each shown inline below.\n\n  // expressInterest(Name name, Closure closure);                      // deprecated\n  // expressInterest(Name name, Closure closure,   Interest template); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.expressInterestWithClosure(interestOrName, arg2, arg3);\n    else\n      this.expressInterestWithClosure(interestOrName, arg2);\n    return;\n  }\n  \n  var interest;\n  var onData;\n  var onTimeout;\n  // expressInterest(Interest interest, function onData);\n  // expressInterest(Interest interest, function onData, function onTimeout);\n  if (typeof interestOrName == \'object\' && interestOrName instanceof Interest) {\n    // Just use a copy of the interest.\n    interest = new Interest(interestOrName);\n    onData = arg2;\n    onTimeout = (arg3 ? arg3 : function() {});\n  }\n  else {\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    // expressInterest(Name name, Interest template, function onData); \n    // expressInterest(Name name, Interest template, function onData, function onTimeout); \n    if (arg2 && typeof arg2 == \'object\' && arg2 instanceof Interest) {\n      var template = arg2;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n\n      onData = arg3;\n      onTimeout = (arg4 ? arg4 : function() {});\n    }\n    // expressInterest(Name name, function onData); \n    // expressInterest(Name name, function onData,   function onTimeout); \n    else {\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n      onData = arg2;\n      onTimeout = (arg3 ? arg3 : function() {});\n    }\n  }\n  \n  // Make a Closure from the callbacks so we can use expressInterestWithClosure.\n  // TODO: Convert the PIT to use callbacks, not a closure.\n  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout));\n}\n\nFace.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {\n  // Inherit from Closure.\n  Closure.call(this);\n  \n  this.onData = onData;\n  this.onTimeout = onTimeout;\n  this.onInterest = onInterest;\n  this.prefix = prefix;\n  this.transport = transport;\n};\n\nFace.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {\n  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)\n    this.onData(upcallInfo.interest, upcallInfo.data);\n  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)\n    this.onTimeout(upcallInfo.interest);\n  else if (kind == Closure.UPCALL_INTEREST)\n    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.\n    this.onInterest(this.prefix, upcallInfo.interest, this.transport)\n  \n  return Closure.RESULT_OK;\n};\n\n/**\n * A private method to encode name as an Interest and send the it to host:port, read the entire response and call\n * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),\n *                 new UpcallInfo(this, interest, 0, data)). \n * @deprecated Use expressInterest with callback functions, not Closure.\n * @param {Name} name Encode name as an Interest using the template (if supplied).\n * @param {Closure} closure\n * @param {Interest} template If not null, use its attributes.\n */\nFace.prototype.expressInterestWithClosure = function(name, closure, template) \n{\n  var interest = new Interest(name);\n  if (template != null) {\n    interest.minSuffixComponents = template.minSuffixComponents;\n    interest.maxSuffixComponents = template.maxSuffixComponents;\n    interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n    interest.exclude = template.exclude;\n    interest.childSelector = template.childSelector;\n    interest.answerOriginKind = template.answerOriginKind;\n    interest.scope = template.scope;\n    interest.interestLifetime = template.interestLifetime;\n  }\n  else\n    interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n  \n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else {\n      var thisNDN = this;\n      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });\n    }\n  }\n  else\n    this.reconnectAndExpressInterest(interest, closure);\n};\n\n/**\n * If the host and port are different than the ones in this.transport, then call\n *   this.transport.connect to change the connection (or connect for the first time).\n * Then call expressInterestHelper.\n */\nFace.prototype.reconnectAndExpressInterest = function(interest, closure) \n{\n  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {\n    var thisNDN = this;\n    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });\n    this.readyStatus = Face.OPENED;\n  }\n  else\n    this.expressInterestHelper(interest, closure);\n};\n\n/**\n * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call\n *   this.transport.send to send the interest.\n */\nFace.prototype.expressInterestHelper = function(interest, closure) \n{\n  var binaryInterest = interest.wireEncode();\n  var thisNDN = this;    \n  //TODO: check local content store first\n  if (closure != null) {\n    var pitEntry = new PITEntry(interest, closure);\n    // TODO: This needs to be a single thread-safe transaction on a global object.\n    Face.PITTable.push(pitEntry);\n    closure.pitEntry = pitEntry;\n\n    // Set interest timer.\n    var timeoutMilliseconds = (interest.interestLifetime || 4000);\n    var timeoutCallback = function() {\n      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());\n        \n      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express\n      //   the interest because we don\'t want to match it in the mean time.\n      // TODO: Make this a thread-safe operation on the global PITTable.\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0) \n        Face.PITTable.splice(index, 1);\n        \n      // Raise closure callback\n      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {\n        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());\n        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n        Face.PITTable.push(pitEntry);\n        thisNDN.transport.send(binaryInterest.buf());\n      }\n    };\n  \n    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n  }\n\n  this.transport.send(binaryInterest.buf());\n};\n\n/**\n * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.\n * This uses the form:\n * registerPrefix(name, onInterest, onRegisterFailed [, flags]).\n * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.\n * @param {Name} prefix The Name prefix.\n * @param {function} onInterest When an interest is received which matches the name prefix, this calls \n * onInterest(prefix, interest, transport) where:\n *   prefix is the prefix given to registerPrefix.\n *   interest is the received interest.\n *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().\n * @param {function} onRegisterFailed If failed to retrieve the connected hub\'s ID or failed to register the prefix, \n * this calls onRegisterFailed(prefix) where:\n *   prefix is the prefix given to registerPrefix.\n * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.  \n * If omitted, use the default flags defined by the default ForwardingFlags constructor.\n */\nFace.prototype.registerPrefix = function(prefix, arg2, arg3, arg4) \n{\n  // There are several overloaded versions of registerPrefix, each shown inline below.\n\n  // registerPrefix(Name prefix, Closure closure);            // deprecated\n  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.registerPrefixWithClosure(prefix, arg2, arg3);\n    else\n      this.registerPrefixWithClosure(prefix, arg2);\n    return;\n  }\n\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);\n  var onInterest = arg2;\n  var onRegisterFailed = (arg3 ? arg3 : function() {});\n  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());\n  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport), \n                                 intFlags, onRegisterFailed);\n}\n\n/**\n * A private method to register the prefix with the host, receive the data and call\n * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)). \n * @deprecated Use registerPrefix with callback functions, not Closure.\n * @param {Name} prefix\n * @param {Closure} closure\n * @param {number} intFlags\n * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix) \n * if registration fails.\n */\nFace.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed) \n{\n  intFlags = intFlags | 3;\n  var thisNDN = this;\n  var onConnected = function() {\n    if (thisNDN.ndndid == null) {\n      // Fetch ndndid first, then register.\n      var interest = new Interest(Face.ndndIdFetcher);\n      interest.interestLifetime = 4000; // milliseconds\n      if (LOG > 3) console.log(\'Expressing interest for ndndid from ndnd.\');\n      thisNDN.reconnectAndExpressInterest\n        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));\n    }\n    else  \n      thisNDN.registerPrefixHelper(prefix, closure, flags, onRegisterFailed);\n  };\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else\n      this.connectAndExecute(onConnected);\n  }\n  else\n    onConnected();\n};\n\n/**\n * This is a closure to receive the Data for Face.ndndIdFetcher and call\n *   registerPrefixHelper(prefix, callerClosure, flags).\n */\nFace.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed) \n{\n  // Inherit from Closure.\n  Closure.call(this);\n    \n  this.face = face;\n  this.prefix = prefix;\n  this.callerClosure = callerClosure;\n  this.flags = flags;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n       \n  if (LOG > 3) console.log(\'Got ndndid from ndnd.\');\n  // Get the digest of the public key in the data packet content.\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(upcallInfo.data.getContent());\n  this.face.ndndid = new customBuf(hash.digest());\n  if (LOG > 3) console.log(this.face.ndndid);\n  \n  this.face.registerPrefixHelper\n    (this.prefix, this.callerClosure, this.flags, this.onRegisterFailed);\n    \n  return Closure.RESULT_OK;\n};\n/**\n * This is a closure to receive the response Data packet from the register \n * prefix interest sent to the connected NDN hub. If this gets a bad response\n * or a timeout, call onRegisterFailed.\n */\nFace.RegisterResponseClosure = function RegisterResponseClosure\n  (prefix, onRegisterFailed) \n{\n  // Inherit from Closure.\n  Closure.call(this);\n    \n  this.prefix = prefix;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.RegisterResponseClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n       \n  var expectedName = new Name("/ndnx/.../selfreg");\n  // Got a response. Do a quick check of expected name components.\n  if (upcallInfo.data.getName().size() < 4 ||\n      !upcallInfo.data.getName().get(0).equals(expectedName.get(0)) ||\n      !upcallInfo.data.getName().get(2).equals(expectedName.get(2))) {\n    this.onRegisterFailed(this.prefix);\n    return;\n  }\n  \n  // Otherwise, silently succeed.  \n  return Closure.RESULT_OK;\n};\n\n/**\n * Do the work of registerPrefix once we know we are connected with a ndndid.\n */\nFace.prototype.registerPrefixHelper = function\n  (prefix, closure, flags, onRegisterFailed) \n{\n  var fe = new ForwardingEntry(\'selfreg\', prefix, null, null, flags, null);\n    \n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  var encoder = new BinaryXMLEncoder();\n  fe.to_ndnb(encoder);\n  var bytes = encoder.getReducedOstream();\n    \n  var si = new MetaInfo();\n  si.setFields();\n    \n  // Set the name to a random value so that each request is unique.\n  var data = new Data(new Name().append(require("crypto").randomBytes(4)), si, bytes); \n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  data.sign(BinaryXmlWireFormat.get());\n  var coBinary = data.wireEncode(BinaryXmlWireFormat.get());;\n    \n  var nodename = this.ndndid;\n  var interestName = new Name([\'ndnx\', nodename, \'selfreg\', coBinary]);\n\n  var interest = new Interest(interestName);\n  interest.setInterestLifetimeMilliseconds(4000.0);\n  interest.setScope(1);\n  if (LOG > 3) console.log(\'Send Interest registration packet.\');\n      \n  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n    \n  this.reconnectAndExpressInterest\n    (interest, new Face.RegisterResponseClosure(prefix, onRegisterFailed));\n};\n\n/**\n * This is called when an entire binary XML element is received, such as a Data or Interest.\n * Look up in the PITTable and call the closure callback.\n */\nFace.prototype.onReceivedElement = function(element) \n{\n  if (LOG > 3) console.log(\'Complete element received. Length \' + element.length + \'. Start decoding.\');\n  // First, decode as Interest or Data.\n  var interest = null;\n  var data = null;\n  // The type codes for TLV Interest and Data packets are chosen to not\n  //   conflict with the first byte of a binary XML packet, so we can\n  //   just look at the first byte.\n  if (element[0] == Tlv.Interest || element[0] == Tlv.Data) {\n    if (LOG > 3) console.log(\'Detected Tlv element\', element, TlvWireFormat.get())\n    var decoder = new TlvDecoder(element);  \n    if (decoder.peekType(Tlv.Interest, element.length)) {\n      interest = new Interest();\n      interest.wireDecode(element, TlvWireFormat.get());\n    }\n    else if (decoder.peekType(Tlv.Data, element.length)) {\n      data = new Data();\n      data.wireDecode(element, TlvWireFormat.get());\n    }\n  }\n  else {\n    if (LOG > 3) console.log(\'assumed BinaryXML\')\n    // Binary XML.\n    var decoder = new BinaryXMLDecoder(element);\n    if (decoder.peekDTag(NDNProtocolDTags.Interest)) {\n      interest = new Interest();\n      interest.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Data)) {\n      data = new Data();\n      data.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n  }\n\n  // Now process as Interest or Data.\n  if (interest !== null) {\n    if (LOG > 3) console.log(\'Interest packet received.\', interest);\n        setTimeout(function(){console.log(interest)}, 300)\n    var entry = getEntryForRegisteredPrefix(interest.name);\n    if (entry != null) {\n      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());\n      var info = new UpcallInfo(this, interest, 0, null);\n      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);\n      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null) \n        this.transport.send(info.data.wireEncode().buf());\n    }        \n  } \n  else if (data !== null) {\n    if (LOG > 3) console.log(\'Data packet received.\');\n        \n    var pendingInterests = Face.extractEntriesForExpressedInterest(data.name);\n    // Process each matching PIT entry (if any).\n    for (var i = 0; i < pendingInterests.length; ++i) {\n      var pitEntry = pendingInterests[i];\n      var currentClosure = pitEntry.closure;\n                    \n      if (this.verify == false) {\n        // Pass content up without verifying the signature\n        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));\n        continue;\n      }\n        \n      // Key verification\n            \n      // Recursive key fetching & verification closure\n      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {\n        this.data = content;  // unverified data packet object\n        this.closure = closure;  // closure corresponding to the data\n        this.keyName = key;  // name of current key to be fetched\n            \n        Closure.call(this);\n      };\n            \n      var thisNDN = this;\n      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {\n        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n          console.log("In KeyFetchClosure.upcall: interest time out.");\n          console.log(this.keyName.contentName.toUri());\n        } \n        else if (kind == Closure.UPCALL_CONTENT) {\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(upcallInfo.data.content);\n          var verified = data.verify(rsakey);\n                \n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));\n                \n          // Store key in cache\n          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());\n          Face.addKeyEntry(keyEntry);\n        } \n        else if (kind == Closure.UPCALL_CONTENT_BAD)\n          console.log("In KeyFetchClosure.upcall: signature verification failed");\n      };\n            \n      if (data.signedInfo && data.signedInfo.locator && data.signature) {\n        if (LOG > 3) console.log("Key verification...");\n        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();\n              \n        var wit = null;\n        if (data.signature.witness != null)\n            //SWT: deprecate support for Witness decoding and Merkle hash tree verification\n            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));\n          \n        var keylocator = data.signedInfo.locator;\n        if (keylocator.type == KeyLocatorType.KEYNAME) {\n          if (LOG > 3) console.log("KeyLocator contains KEYNAME");\n                \n          if (keylocator.keyName.contentName.match(data.name)) {\n            if (LOG > 3) console.log("Content is key itself");\n                  \n            var rsakey = new Key();\n            rsakey.readDerPublicKey(data.content);\n            var verified = data.verify(rsakey);\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n              \n            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n            // SWT: We don\'t need to store key here since the same key will be stored again in the closure.\n          } \n          else {\n            // Check local key store\n            var keyEntry = Face.getKeyByName(keylocator.keyName);\n            if (keyEntry) {\n              // Key found, verify now\n              if (LOG > 3) console.log("Local key cache hit");\n              var rsakey = keyEntry.rsaKey;\n              var verified = data.verify(rsakey);\n              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n              // Raise callback\n              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n            } \n            else {\n              // Not found, fetch now\n              if (LOG > 3) console.log("Fetch key according to keylocator");\n              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);\n              // TODO: Use expressInterest with callbacks, not Closure.\n              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);\n            }\n          }\n        } \n        else if (keylocator.type == KeyLocatorType.KEY) {\n          if (LOG > 3) console.log("Keylocator contains KEY");\n                \n          var rsakey = new Key();\n          rsakey.readDerPublicKey(keylocator.publicKey);\n          var verified = data.verify(rsakey);\n              \n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          // Raise callback\n          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n          // Since KeyLocator does not contain key name for this key,\n          // we have no way to store it as a key entry in KeyStore.\n        } \n        else {\n          var cert = keylocator.certificate;\n          console.log("KeyLocator contains CERT");\n          console.log(cert);                \n          // TODO: verify certificate\n        }\n      }\n    }\n  } \n};\n\n/**\n * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host\n *   is not alive.  Get a host and port, connect, then execute onConnected().\n */\nFace.prototype.connectAndExecute = function(onConnected) \n{\n  var hostAndPort = this.getHostAndPort();\n  if (hostAndPort == null) {\n    console.log(\'ERROR: No more hosts from getHostAndPort\');\n    this.host = null;\n    return;\n  }\n\n  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {\n    console.log(\'ERROR: The host returned by getHostAndPort is not alive: \' + this.host + ":" + this.port);\n    return;\n  }\n        \n  this.host = hostAndPort.host;\n  this.port = hostAndPort.port;   \n  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);\n    \n  // Fetch any content.\n  var interest = new Interest(new Name("/"));\n  interest.interestLifetime = 4000; // milliseconds    \n\n  var thisNDN = this;\n  var timerID = setTimeout(function() {\n    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);\n      // Try again.\n      thisNDN.connectAndExecute(onConnected);\n  }, 3000);\n  \n  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));\n};\n\n/**\n * This is called by the Transport when the connection is closed by the remote host.\n */\nFace.prototype.closeByTransport = function() \n{\n  this.readyStatus = Face.CLOSED;\n  this.onclose();\n};\n\nFace.ConnectClosure = function ConnectClosure(face, onConnected, timerID) \n{\n  // Inherit from Closure.\n  Closure.call(this);\n    \n  this.face = face;\n  this.onConnected = onConnected;\n  this.timerID = timerID;\n};\n\nFace.ConnectClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.\n    return Closure.RESULT_ERR;\n        \n  // The host is alive, so cancel the timeout and continue with onConnected().\n  clearTimeout(this.timerID);\n\n    // Call Face.onopen after success\n  this.face.readyStatus = Face.OPENED;\n  this.face.onopen();\n\n  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);\n  this.onConnected();\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * @deprecated Use new Face.\n */\nvar NDN = function NDN(settings) \n{\n  // Call the base constructor.\n  Face.call(this, settings); \n}\n\n// Use dummy functions so that the Face constructor will not try to set its own defaults.                                      \nNDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });\n\nexports.NDN = NDN;\n\nNDN.supported = Face.supported;\nNDN.UNOPEN = Face.UNOPEN;\nNDN.OPENED = Face.OPENED;\nNDN.CLOSED = Face.CLOSED;\n\n})()\n},{"./buffer.js":50,"./closure.js":30,"./crypto.js":50,"./data.js":35,"./encoding/binary-xml-decoder.js":81,"./encoding/binary-xml-encoder.js":80,"./encoding/binary-xml-wire-format.js":41,"./encoding/data-utils.js":43,"./encoding/tlv-wire-format.js":42,"./encoding/tlv/tlv-decoder.js":86,"./encoding/tlv/tlv.js":85,"./forwarding-entry.js":84,"./forwarding-flags.js":33,"./interest.js":32,"./key-locator.js":38,"./key.js":37,"./log.js":83,"./meta-info.js":36,"./name.js":31,"./transport/tcp-transport.js":87,"./util/ndn-protoco-id-tags.js":82,"crypto":51}],36:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data MetaInfo object.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Blob = require(\'./util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar Name = require(\'./name.js\').Name;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar NDNTime = require(\'./util/ndn-time.js\').NDNTime;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar LOG = require(\'./log.js\').Log.LOG;\n\nvar ContentType = {\n  BLOB:0,\n  // ContentType DATA is deprecated.  Use ContentType.BLOB .\n  DATA:0, \n  LINK:1, \n  KEY: 2, \n  // ContentType ENCR, GONE and NACK are not supported in NDN-TLV encoding and are deprecated.\n  ENCR:3, \n  GONE:4, \n  NACK:5\n};\n\nexports.ContentType = ContentType;\n\n/**\n * Create a new MetaInfo with the optional values.\n * @constructor\n */\nvar MetaInfo = function MetaInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID, skipSetFields) \n{\n  if (typeof publisherOrMetaInfo === \'object\' && \n      publisherOrMetaInfo instanceof MetaInfo) {\n    // Copy values.\n    var metaInfo = publisherOrMetaInfo;\n    this.publisher = metaInfo.publisher;\n    this.timestamp = metaInfo.timestamp;\n    this.type = metaInfo.type;\n    this.locator = metaInfo.locator == null ? \n      new KeyLocator() : new KeyLocator(metaInfo.locator);\n    this.freshnessSeconds = metaInfo.freshnessSeconds;\n    this.finalBlockID = metaInfo.finalBlockID;\n  }\n  else {\n    this.publisher = publisherOrMetaInfo; //publisherPublicKeyDigest\n    this.timestamp = timestamp; // NDN Time\n    this.type = type; // ContentType\n    this.locator = locator == null ? new KeyLocator() : new KeyLocator(locator);\n    this.freshnessSeconds = freshnessSeconds; // Integer\n    this.finalBlockID = finalBlockID; //byte array\n\n    if (!skipSetFields)\n      this.setFields();\n  }\n};\n\nexports.MetaInfo = MetaInfo;\n\n/**\n * Get the content type.\n * @returns {an int from ContentType} The content type.\n */\nMetaInfo.prototype.getType = function()\n{\n  return this.type;\n};\n\n/**\n * Get the freshness period.\n * @returns {number} The freshness period in milliseconds, or null if not \n * specified.\n */\nMetaInfo.prototype.getFreshnessPeriod = function()\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (this.freshnessSeconds == null || this.freshnessSeconds < 0)\n    return null;\n  else\n    // Convert to milliseconds.\n    return this.freshnessSeconds * 1000.0;\n};\n\n/**\n * Get the final block ID.\n * @returns {Buffer} The final block ID or null if not specified.\n */\nMetaInfo.prototype.getFinalBlockID = function()\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  return this.finalBlockID;\n};\n\n/**\n * Set the content type.\n * @param {an int from ContentType} type The content type.  If null, this \n * uses ContentType.BLOB.\n */\nMetaInfo.prototype.setType = function(type)\n{\n  this.type = type == null || type < 0 ? ContentType.BLOB : type;\n};\n\n/**\n * Set the freshness period.\n * @param {type} freshnessPeriod The freshness period in milliseconds, or null\n * for not specified.\n */\nMetaInfo.prototype.setFreshnessPeriod = function(freshnessPeriod)\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (freshnessPeriod == null || freshnessPeriod < 0)\n    this.freshnessSeconds = null;\n  else\n    // Convert from milliseconds.\n    this.freshnessSeconds = freshnessPeriod / 1000.0;\n};\n\nMetaInfo.prototype.setFinalBlockID = function(finalBlockID)\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  if (finalBlockID == null)\n    this.finalBlockID = null;\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Blob)\n    this.finalBlockID = finalBlockID.buf();\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Name.Component)\n    this.finalBlockID = finalBlockID.getValue();\n  else \n    this.finalBlockID = new customBuf(finalBlockID);\n};\n\nMetaInfo.prototype.setFields = function() \n{\n  var key = globalKeyManager.getKey();\n  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());\n\n  var d = new Date();\n    \n  var time = d.getTime();  \n\n  this.timestamp = new NDNTime(time);\n    \n  if (LOG > 4) console.log(\'TIME msec is\');\n\n  if (LOG > 4) console.log(this.timestamp.msec);\n\n  //DATA\n  this.type = ContentType.BLOB;\n  \n  if (LOG > 4) console.log(\'PUBLIC KEY TO WRITE TO DATA PACKET IS \');\n  if (LOG > 4) console.log(key.publicToDER().toString(\'hex\'));\n\n  this.locator = new KeyLocator(key.getKeyID(), KeyLocatorType.KEY_LOCATOR_DIGEST);\n};\n\nMetaInfo.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    if (LOG > 4) console.log(\'DECODING PUBLISHER KEY\');\n    this.publisher = new PublisherPublicKeyDigest();\n    this.publisher.from_ndnb(decoder);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {\n    if (LOG > 4) console.log(\'DECODING TIMESTAMP\');\n    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Type)) {\n    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);\n    \n    if (LOG > 4) console.log(\'Binary Type of of Signed Info is \'+binType);\n\n    this.type = binType;\n    \n    //TODO Implement type of Key Reading\n    if (null == this.type)\n      throw new Error("Cannot parse signedInfo type: bytes.");\n  } \n  else\n    this.type = ContentType.DATA; // default\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n    if (LOG > 4) console.log(\'FRESHNESS IN SECONDS IS \'+ this.freshnessSeconds);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {\n    if (LOG > 4) console.log(\'DECODING FINAL BLOCKID\');\n    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {\n    if (LOG > 4) console.log(\'DECODING KEY LOCATOR\');\n    this.locator = new KeyLocator();\n    this.locator.from_ndnb(decoder);\n  }\n      \n  decoder.readElementClose();\n};\n\n/**\n * Encode this MetaInfo in ndnb, using the given keyLocator instead of the\n * locator in this object.\n * @param {BinaryXMLEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nMetaInfo.prototype.to_ndnb = function(encoder, keyLocator)  {\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.publisher) {\n    // We have a publisherPublicKeyDigest, so use it.\n    if (LOG > 3) console.log(\'ENCODING PUBLISHER KEY\' + this.publisher.publisherPublicKeyDigest);\n    this.publisher.to_ndnb(encoder);\n  }\n  else {\n    if (null != keyLocator &&\n        keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n        keyLocator.getKeyData() != null &&\n        keyLocator.getKeyData().length > 0)\n      // We have a TLV-style KEY_LOCATOR_DIGEST, so encode as the\n      //   publisherPublicKeyDigest.\n      encoder.writeDTagElement\n        (NDNProtocolDTags.PublisherPublicKeyDigest, keyLocator.getKeyData());\n  }\n\n  if (null != this.timestamp)\n    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);\n  \n  if (null != this.type && this.type != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);\n  \n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  if (null != this.finalBlockID)\n    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);\n\n  if (null != keyLocator)\n    keyLocator.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nMetaInfo.prototype.valueToType = function() \n{\n  return null;  \n};\n\nMetaInfo.prototype.getElementLabel = function() { \n  return NDNProtocolDTags.SignedInfo;\n};\n\nMetaInfo.prototype.validate = function() \n{\n  // We don\'t do partial matches any more, even though encoder/decoder\n  // is still pretty generous.\n  if (null == this.timestamp)\n    return false;\n  return true;\n};\n\n/**\n * @deprecated Use new MetaInfo.\n */\nvar SignedInfo = function SignedInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID) \n{\n  // Call the base constructor.\n  MetaInfo.call(this, publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID); \n}\n\n// Set skipSetFields true since we only need the prototype functions.\nSignedInfo.prototype = new MetaInfo(null, null, null, null, null, null, true);\n\nexports.SignedInfo = SignedInfo;\n\n})()\n},{"./buffer.js":50,"./encoding/binary-xml-decoder.js":81,"./encoding/binary-xml-encoder.js":80,"./key-locator.js":38,"./log.js":83,"./name.js":31,"./publisher-public-key-digest.js":39,"./security/key-manager.js":48,"./util/blob.js":45,"./util/ndn-protoco-id-tags.js":82,"./util/ndn-time.js":47}],38:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN KeyLocator object.\n */\n\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherID = require(\'./publisher-id.js\').PublisherID;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * KeyLocator\n */\nvar KeyLocatorType = {\n  KEYNAME: 1,\n  KEY_LOCATOR_DIGEST: 2,\n  KEY: 3,\n  CERTIFICATE: 4\n};\n\nexports.KeyLocatorType = KeyLocatorType;\n\n/**\n * @constructor\n */\nvar KeyLocator = function KeyLocator(input,type) \n{ \n  if (typeof input === \'object\' && input instanceof KeyLocator) {\n    // Copy from the input KeyLocator.\n    this.type = input.type;\n    this.keyName = new KeyName();\n    if (input.keyName != null) {\n      this.keyName.contentName = input.keyName.contentName == null ? \n        null : new Name(input.keyName.contentName);\n      this.keyName.publisherID = input.keyName.publisherID;\n    }\n    this.keyData = input.keyData == null ? null : new customBuf(input.keyData);\n    this.publicKey = input.publicKey == null ? null : new customBuf(input.publicKey);\n    this.certificate = input.certificate == null ? null : new customBuf(input.certificate);\n  }\n  else {\n    this.type = type;\n    this.keyName = new KeyName();\n\n    if (type == KeyLocatorType.KEYNAME)\n      this.keyName = input;\n    else if (type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n      this.keyData = new customBuf(input);\n    else if (type == KeyLocatorType.KEY) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.publicKey = this.keyData;\n    }\n    else if (type == KeyLocatorType.CERTIFICATE) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.certificate = this.keyData;\n    }\n  }\n};\n\nexports.KeyLocator = KeyLocator;\n\n/**\n * Get the key locator type. If KeyLocatorType.KEYNAME, you may also\n * getKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you may also\n * getKeyData() to get the digest.\n * @returns {number} The key locator type, or null if not specified.\n */\nKeyLocator.prototype.getType = function() { return this.type; };\n\n/**\n * Get the key name.  This is meaningful if getType() is KeyLocatorType.KEYNAME.\n * @returns {Name} The key name. If not specified, the Name is empty.\n */\nKeyLocator.prototype.getKeyName = function() \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  if (this.keyName.contentName == null)\n    this.keyName.contentName = new Name();\n  \n  return this.keyName.contentName;\n};\n\n/**\n * Get the key data. If getType() is KeyLocatorType.KEY_LOCATOR_DIGEST, this is \n * the digest bytes. If getType() is KeyLocatorType.KEY, this is the DER \n * encoded public key. If getType() is KeyLocatorType.CERTIFICATE, this is the \n * DER encoded certificate. \n * @returns {Buffer} The key data, or null if not specified.\n */\nKeyLocator.prototype.getKeyData = function() \n{ \n  if (this.type == KeyLocatorType.KEY)\n    return this.publicKey;\n  else if (this.type == KeyLocatorType.CERTIFICATE)\n    return this.certificate;\n  else\n    return this.keyData;\n};\n\n/**\n * Set the key locator type.  If KeyLocatorType.KEYNAME, you must also\n * setKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you must also\n * setKeyData() to the digest.\n * @param {number} type The key locator type.  If null, the type is unspecified.\n */\nKeyLocator.prototype.setType = function(type) { this.type = type; }; \n\n/**\n * Set key name to a copy of the given Name.  This is the name if getType() \n * is KeyLocatorType.KEYNAME.\n * @param {Name} name The key name which is copied.\n */\nKeyLocator.prototype.setKeyName = function(name) \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  \n  this.keyName.contentName = typeof name === \'object\' && name instanceof Name ?\n                             new Name(name) : new Name(); \n}; \n\n/**\n * Set the key data to the given value. This is the digest bytes if getType() is \n * KeyLocatorType.KEY_LOCATOR_DIGEST.\n * @param {Buffer} keyData The array with the key data bytes.\n */\nKeyLocator.prototype.setKeyData = function(keyData)\n{\n  var value = keyData;\n  if (value != null)\n    // Make a copy.\n    value = new customBuf(value);\n  \n  this.keyData = value;\n  // Set for backwards compatibility.\n  this.publicKey = value;\n  this.certificate = value;\n};\n\n/**\n * Clear the keyData and set the type to none.\n */\nKeyLocator.prototype.clear = function() \n{\n  this.type = null;\n  this.keyName = null;\n  this.keyData = null;\n  this.publicKey = null;\n  this.certificate = null;\n};\n\nKeyLocator.prototype.from_ndnb = function(decoder) {\n\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Key)) \n  {\n    try {\n      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);\n      // This is a DER-encoded SubjectPublicKeyInfo.\n      \n      //TODO FIX THIS, This should create a Key Object instead of keeping bytes\n\n      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);\n      this.type = KeyLocatorType.KEY;    \n\n      if (LOG > 4) console.log(\'PUBLIC KEY FOUND: \'+ this.publicKey);\n    } \n    catch (e) {\n      throw new Error("Cannot parse key: ", e);\n    } \n\n    if (null == this.publicKey)\n      throw new Error("Cannot parse key: ");\n  } \n  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {\n    try {\n      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);\n      \n      /*\n       * Certificates not yet working\n       */\n      \n      this.certificate = encodedCert;\n      this.type = KeyLocatorType.CERTIFICATE;\n\n      if (LOG > 4) console.log(\'CERTIFICATE FOUND: \'+ this.certificate);      \n    } \n    catch (e) {\n      throw new Error("Cannot decode certificate: " +  e);\n    }\n    if (null == this.certificate)\n      throw new Error("Cannot parse certificate! ");\n  } else  {\n    this.type = KeyLocatorType.KEYNAME;\n    \n    this.keyName = new KeyName();\n    this.keyName.from_ndnb(decoder);\n  }\n  decoder.readElementClose();\n};  \n\nKeyLocator.prototype.to_ndnb = function(encoder) \n{\n  if (LOG > 4) console.log(\'type is is \' + this.type);\n\n  if (this.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n    // encodeSignedInfo already encoded this as the publisherPublicKeyDigest,\n    //   so do nothing here.\n    return;\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (this.type == KeyLocatorType.KEY) {\n    if (LOG > 5) console.log(\'About to encode a public key\' +this.publicKey);\n    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);  \n  } \n  else if (this.type == KeyLocatorType.CERTIFICATE) {  \n    try {\n      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);\n    } \n    catch (e) {\n      throw new Error("CertificateEncodingException attempting to write key locator: " + e);\n    }    \n  } \n  else if (this.type == KeyLocatorType.KEYNAME)\n    this.keyName.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyLocator.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.KeyLocator; \n};\n\n/**\n * KeyName is only used by KeyLocator.\n * @constructor\n */\nvar KeyName = function KeyName() \n{\n  this.contentName = new Name();  //contentName\n  this.publisherID = this.publisherID;  //publisherID\n};\n\nexports.KeyName = KeyName;\n\nKeyName.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.contentName = new Name();\n  this.contentName.from_ndnb(decoder);\n  \n  if (LOG > 4) console.log(\'KEY NAME FOUND: \');\n  \n  if (PublisherID.peek(decoder)) {\n    this.publisherID = new PublisherID();\n    this.publisherID.from_ndnb(decoder);\n  }\n  \n  decoder.readElementClose();\n};\n\nKeyName.prototype.to_ndnb = function(encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  this.contentName.to_ndnb(encoder);\n  if (null != this.publisherID)\n    this.publisherID.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nKeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };\n\n\n})()\n},{"./buffer.js":50,"./log.js":83,"./name.js":31,"./publisher-id.js":88,"./util/ndn-protoco-id-tags.js":82}],35:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar SignedBlob = require(\'./util/signed-blob.js\').SignedBlob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Signature = require(\'./signature.js\').Signature;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\n/**\n * Create a new Data with the optional values.  There are 2 forms of constructor:\n * new Data([name] [, content]);\n * new Data(name, metaInfo [, content]);\n * \n * @constructor\n * @param {Name} name\n * @param {MetaInfo} metaInfo\n * @param {Buffer} content\n */\nvar Data = function Data(name, metaInfoOrContent, arg3) \n{\n  if (typeof name === \'string\')\n    this.name = new Name(name);\n  else\n    this.name = typeof name === \'object\' && name instanceof Name ?\n       new Name(name) : new Name();\n\n  var metaInfo;\n  var content;\n  if (typeof metaInfoOrContent === \'object\' && \n      metaInfoOrContent instanceof MetaInfo) {\n    metaInfo = metaInfoOrContent;\n    content = arg3;\n  }\n  else {\n    metaInfo = null;\n    content = metaInfoOrContent;\n  }\n    \n  // Use signedInfo instead of metaInfo for backward compatibility.\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n       new MetaInfo(metaInfo) : new MetaInfo();\n  \n  if (typeof content === \'string\') \n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else \n    this.content = content;\n  \n  this.signature = new Signature();\n  \n  this.wireEncoding = SignedBlob();\n};\n\nexports.Data = Data;\n\n/**\n * Get the data packet\'s name.\n * @returns {Name} The name.\n */\nData.prototype.getName = function() \n{\n  return this.name;\n};\n\n/**\n * Get the data packet\'s meta info.\n * @returns {MetaInfo} The meta info.\n */\nData.prototype.getMetaInfo = function() \n{\n  return this.signedInfo;\n};\n\n/**\n * Get the data packet\'s signature object.\n * @returns {Signature} The signature object.\n */\nData.prototype.getSignature = function() \n{\n  return this.signature;\n};\n\n/**\n * Get the data packet\'s content.\n * @returns {Buffer} The content as a customBuf, which is null if unspecified.\n */\nData.prototype.getContent = function() \n{\n  return this.content;\n};\n\n/**\n * Set name to a copy of the given Name.\n * @param {Name} name The Name which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setName = function(name) \n{\n  this.name = typeof name === \'object\' && name instanceof Name ?\n    new Name(name) : new Name();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set metaInfo to a copy of the given MetaInfo.\n * @param {MetaInfo} metaInfo The MetaInfo which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setMetaInfo = function(metaInfo) \n{\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n    new MetaInfo(metaInfo) : new MetaInfo();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the signature to a copy of the given signature.\n * @param {Signature} signature The signature object which is cloned.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setSignature = function(signature) \n{\n  this.signature = typeof signature === \'object\' && signature instanceof Signature ?\n    signature.clone() : new Signature();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the content to the given value.\n * @param {type} content The array this is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setContent = function(content) \n{\n  if (typeof content === \'string\') \n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else \n    this.content = new customBuf(content);\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\nData.prototype.sign = function(wireFormat) \n{\n  var rs = require(\'buffer\')\n  var ss = require(\'./crypto.js\')\n  console.log(Buffer, ss, rs)\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n \n  if (this.getSignatureOrMetaInfoKeyLocator() == null ||\n      this.getSignatureOrMetaInfoKeyLocator().getType() == null)\n    this.getMetaInfo().setFields();\n  \n  if (this.wireEncoding == null || this.wireEncoding.isNull()) {\n    // Need to encode to set wireEncoding.\n    // Set an initial empty signature so that we can encode.\n    this.getSignature().setSignature(new customBuf(128));\n    this.wireEncode(wireFormat);\n  }\n  \n  var rsa = require("./crypto.js").createSign(\'RSA-SHA256\');\n  rsa.update(this.wireEncoding.signedBuf());\n    \n  var sig = new customBuf(rsa.sign(globalKeyManager.privateKey));\n  this.signature.signature = sig;\n};\n\nData.prototype.verify = function(/*Key*/ key) \n{\n  if (key == null || key.publicKeyPem == null)\n    throw new Error(\'Cannot verify Data without a public key.\');\n\n  if (this.wireEncoding == null || this.wireEncoding.isNull())\n    // Need to encode to set wireEncoding.\n    this.wireEncode();\n  var verifier = require(\'./crypto.js\').createVerify(\'RSA-SHA256\');\n  verifier.update(this.wireEncoding.signedBuf());\n  return verifier.verify(key.publicKeyPem, this.signature.signature);\n};\n\nData.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };\n\n/**\n * Encode this Data for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {SignedBlob} The encoded buffer in a SignedBlob object.\n */\nData.prototype.wireEncode = function(wireFormat) \n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var result = wireFormat.encodeData(this);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  this.wireEncoding = new SignedBlob\n    (result.encoding, result.signedPortionBeginOffset, \n     result.signedPortionEndOffset);\n  return this.wireEncoding;\n};\n\n/**\n * Decode the input using a particular wire format and update this Data.\n * @param {Blob|Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nData.prototype.wireDecode = function(input, wireFormat) \n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ? \n                     input.buf() : input;\n  var result = wireFormat.decodeData(this, decodeBuffer);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  // In the Blob constructor, set copy true, but if input is already a Blob, it \n  //   won\'t copy.\n  this.wireEncoding = new SignedBlob\n    (new Blob(input, true), result.signedPortionBeginOffset, \n     result.signedPortionEndOffset);\n};\n\n/**\n * If getSignature() has a key locator, return it.  Otherwise, use\n * the key locator from getMetaInfo() for backward compatibility and print\n * a warning to console.log that the key locator has moved to the Signature\n * object.  If neither has a key locator, return an empty key locator.\n * When we stop supporting the key locator in MetaInfo, this function is not\n * necessary and we will just use the key locator in the Signature.\n * @returns {KeyLocator} The key locator to use.\n */\nData.prototype.getSignatureOrMetaInfoKeyLocator = function()\n{\n  if (this.signature != null && this.signature.getKeyLocator() != null &&\n      this.signature.getKeyLocator().getType() != null &&\n      this.signature.getKeyLocator().getType() >= 0)\n    // The application is using the key locator in the correct object.\n    return this.signature.getKeyLocator();\n  \n  if (this.signedInfo != null && this.signedInfo.locator != null &&\n      this.signedInfo.locator.type != null &&\n      this.signedInfo.locator.type >= 0) {\n    //console.log("WARNING: Temporarily using the key locator found in the MetaInfo - expected it in the Signature object.");\n    //console.log("WARNING: In the future, the key locator in the Signature object will not be supported.");\n    return this.signedInfo.locator;\n  }\n  \n  // Return the empty key locator from the Signature object if possible.\n  if (this.signature != null && this.signature.getKeyLocator() != null)\n    return this.signature.getKeyLocator();\n  else\n    return new KeyLocator();\n}\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeData.\n */\nData.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  BinaryXmlWireFormat.decodeData(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeData.\n */\nData.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeData(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nData.prototype.encode = function(wireFormat) \n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  return wireFormat.encodeData(this).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nData.prototype.decode = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  wireFormat.decodeData(this, input);\n};\n\n/**\n * @deprecated Use new Data.\n */\nvar ContentObject = function ContentObject(name, signedInfo, content) \n{\n  // Call the base constructor.\n  Data.call(this, name, signedInfo, content); \n}\n\nContentObject.prototype = new Data();\n\nexports.ContentObject = ContentObject;\n\n})(require("__browserify_buffer").Buffer)\n},{"./buffer.js":50,"./crypto.js":50,"./encoding/binary-xml-encoder.js":80,"./encoding/binary-xml-wire-format.js":41,"./encoding/data-utils.js":43,"./encoding/wire-format.js":40,"./key-locator.js":38,"./meta-info.js":36,"./name.js":31,"./security/key-manager.js":48,"./signature.js":90,"./util/blob.js":45,"./util/ndn-protoco-id-tags.js":82,"./util/signed-blob.js":89,"__browserify_buffer":60,"buffer":61}],37:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Key Objects\n */\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\n/**\n * Key\n */\nvar Key = function Key() \n{\n  this.publicKeyDer = null;     // customBuf\n  this.publicKeyDigest = null;  // customBuf\n  this.publicKeyPem = null;     // String\n  this.privateKeyPem = null;    // String\n};\n\nexports.Key = Key;\n\n/**\n * Helper functions to read Key fields\n * TODO: generateRSA()\n */\n\nKey.prototype.publicToDER = function() \n{\n  return this.publicKeyDer;  // customBuf\n};\n\nKey.prototype.privateToDER = function() \n{\n  // Remove the \'-----XXX-----\' from the beginning and the end of the key\n  // and also remove any \\n in the key string\n  var lines = this.privateKeyPem.split(\'\\n\');\n  priKey = "";\n  for (var i = 1; i < lines.length - 1; i++)\n    priKey += lines[i];\n  \n  return new customBuf(priKey, \'base64\');    \n};\n\nKey.prototype.publicToPEM = function() \n{\n  return this.publicKeyPem;\n};\n\nKey.prototype.privateToPEM = function() \n{\n  return this.privateKeyPem;\n};\n\nKey.prototype.getKeyID = function() \n{\n  return this.publicKeyDigest;\n};\n\nexports.Key = Key;\n\nKey.prototype.readDerPublicKey = function(/*Buffer*/pub_der) \n{\n  if (LOG > 4) console.log("Encode DER public key:\\n" + pub_der.toString(\'hex\'));\n\n  this.publicKeyDer = pub_der;\n\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(this.publicKeyDer);\n  this.publicKeyDigest = new customBuf(hash.digest());\n    \n  var keyStr = pub_der.toString(\'base64\'); \n  var keyPem = "-----BEGIN PUBLIC KEY-----\\n";\n  for (var i = 0; i < keyStr.length; i += 64)\n  keyPem += (keyStr.substr(i, 64) + "\\n");\n  keyPem += "-----END PUBLIC KEY-----";\n  this.publicKeyPem = keyPem;\n\n  if (LOG > 4) console.log("Convert public key to PEM format:\\n" + this.publicKeyPem);\n};\n\n/**\n * Load RSA key pair from PEM-encoded strings.\n * Will throw an Error if both \'pub\' and \'pri\' are null.\n */\nKey.prototype.fromPemString = function(pub, pri) \n{\n  if (pub == null && pri == null)\n    throw new Error(\'Cannot create Key object if both public and private PEM string is empty.\');\n\n  // Read public key\n  if (pub != null) {\n    this.publicKeyPem = pub;\n    if (LOG > 4) console.log("Key.publicKeyPem: \\n" + this.publicKeyPem);\n  \n    // Remove the \'-----XXX-----\' from the beginning and the end of the public key\n    // and also remove any \\n in the public key string\n    var lines = pub.split(\'\\n\');\n    pub = "";\n    for (var i = 1; i < lines.length - 1; i++)\n      pub += lines[i];\n    this.publicKeyDer = new customBuf(pub, \'base64\');\n    if (LOG > 4) console.log("Key.publicKeyDer: \\n" + this.publicKeyDer.toString(\'hex\'));\n  \n    var hash = require("./crypto.js").createHash(\'sha256\');\n    hash.update(this.publicKeyDer);\n    this.publicKeyDigest = new customBuf(hash.digest());\n    if (LOG > 4) console.log("Key.publicKeyDigest: \\n" + this.publicKeyDigest.toString(\'hex\'));\n  }\n    \n  // Read private key\n  if (pri != null) {\n    this.privateKeyPem = pri;\n    if (LOG > 4) console.log("Key.privateKeyPem: \\n" + this.privateKeyPem);\n  }\n};\n\nKey.prototype.fromPem = Key.prototype.fromPemString;\n\n/**\n * Static method that create a Key object.\n * Parameter \'obj\' is a JSON object that has two properties:\n *   pub: the PEM string for the public key\n *   pri: the PEM string for the private key\n * Will throw an Error if both obj.pub and obj.pri are null.\n */\nKey.createFromPEM = function(obj) \n{\n    var key = new Key();\n    key.fromPemString(obj.pub, obj.pri);\n    return key;\n};\n\n})()\n},{"./buffer.js":50,"./crypto.js":50,"./log.js":83}],39:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents PublisherPublicKeyDigest Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd) \n{ \n this.PUBLISHER_ID_LEN = 512/8;\n this.publisherPublicKeyDigest = pkd;\n};\n\nexports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;\n\nPublisherPublicKeyDigest.prototype.from_ndnb = function(decoder) \n{\n  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'Publisher public key digest is \' + this.publisherPublicKeyDigest);\n\n  if (null == this.publisherPublicKeyDigest)\n    throw new Error("Cannot parse publisher key digest.");\n    \n  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)\n\n  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {\n    if (LOG > 0)\n      console.log(\'LENGTH OF PUBLISHER ID IS WRONG! Expected \' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);\n      \n    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;    \n  }\n};\n\nPublisherPublicKeyDigest.prototype.to_ndnb= function(encoder) \n{\n  //TODO Check that the ByteArray for the key is present\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  if (LOG > 3) console.log(\'PUBLISHER KEY DIGEST IS\'+this.publisherPublicKeyDigest);\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);\n};\n  \nPublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };\n\nPublisherPublicKeyDigest.prototype.validate = function() \n{\n    return null != this.publisherPublicKeyDigest;\n};\n\n},{"./log.js":83,"./util/ndn-protoco-id-tags.js":82}],50:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n// Library namespace\nvar ndn = ndn || {};\n\nvar exports = ndn;\n\nvar ASN1HEX = require(\'../contrib/securityLib/asn1hex-1.1.js\')\nvar KJUR = require(\'../contrib/securityLib/crypto-1.0.js\')\nvar RSAKey = require(\'../contrib/securityLib/rsasign-1.2.js\')\nvar b64tohex = require(\'../contrib/securityLib/base64.js\').b64tohex\n// Factory method to create node.js compatible buffer objects\nvar customBuf = function customBuf(data, format) \n{\n  var obj;\n\n  if (typeof data == \'number\')\n    obj = new Uint8Array(data);\n  else if (typeof data == \'string\') {\n    if (format == null || format == \'utf8\') {\n      var utf8 = customBuf.str2rstr_utf8(data);\n      obj = new Uint8Array(utf8.length);\n      for (var i = 0; i < utf8.length; i++)\n        obj[i] = utf8.charCodeAt(i);\n    } \n    else if (format == \'binary\') {\n      obj = new Uint8Array(data.length);\n      for (var i = 0; i < data.length; i++)\n        obj[i] = data.charCodeAt(i);\n    } \n    else if (format == \'hex\') {\n      obj = new Uint8Array(Math.floor(data.length / 2));\n      var i = 0;\n      data.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else if (format == \'base64\') {\n      var hex = b64tohex(data);\n      obj = new Uint8Array(Math.floor(hex.length / 2));\n      var i = 0;\n      hex.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else \n      throw new Error(\'Buffer: unknown encoding format \' + format);\n  } \n  else if (typeof data == \'object\' && (data instanceof Uint8Array || data instanceof customBuf)) {\n    // The second argument is a boolean for "copy", default true.\n    if (format == false)\n      obj = data.subarray(0);\n    else\n      obj = new Uint8Array(data);\n  }\n  else if (typeof data == \'object\' && data instanceof ArrayBuffer)\n    // Copy.\n    obj = new Uint8Array(data);\n  else if (typeof data == \'object\')\n    // Assume component is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    obj = new Uint8Array(data);\n  else\n    throw new Error(\'Buffer: unknown data type.\');\n\n  try {\n    obj.__proto__ = customBuf.prototype;\n  } catch(ex) {\n    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);\n  }\n\n  obj.__proto__.toString = function(encoding) {\n    if (encoding == null) {\n      var ret = "";\n      for (var i = 0; i < this.length; i++)\n        ret += String.fromCharCode(this[i]);\n      return ret;\n    }\n\n    var ret = "";\n    for (var i = 0; i < this.length; i++)\n      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);\n\n    if (encoding == \'hex\')\n      return ret;\n    else if (encoding == \'base64\')\n      return hex2b64(ret);\n    else\n      throw new Error(\'Buffer.toString: unknown encoding format \' + encoding);\n  };\n\n  obj.__proto__.slice = function(begin, end) {\n    if (end !== undefined)\n      return new customBuf(this.subarray(begin, end), false);\n    else\n      return new customBuf(this.subarray(begin), false);\n  };\n\n  obj.__proto__.copy = function(target, targetStart) {\n    if (targetStart !== undefined)\n      target.set(this, targetStart);\n    else\n      target.set(this);\n  };\n\n  return obj;\n};\n\ncustomBuf.prototype = Uint8Array.prototype;\n\ncustomBuf.concat = function(arrays) \n{\n  var totalLength = 0;\n  for (var i = 0; i < arrays.length; ++i)\n    totalLength += arrays[i].length;\n    \n  var result = new customBuf(totalLength);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; ++i) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return result;\n};\n\ncustomBuf.str2rstr_utf8 = function(input)\n{\n  var output = "";\n  var i = -1;\n  var x, y;\n\n  while (++i < input.length)\n  {\n    // Decode utf-16 surrogate pairs\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\n    {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    // Encode output as utf-8\n    if (x <= 0x7F)\n      output += String.fromCharCode(x);\n    else if (x <= 0x7FF)\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0xFFFF)\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0x1FFFFF)\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\n                                    0x80 | ((x >>> 12) & 0x3F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n  }\n  return output;\n};\n\n// Factory method to create hasher objects\nexports.createHash = function(alg) \n{\n  if (alg != \'sha256\')\n    throw new Error(\'createHash: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});\n\n  obj.update = function(buf) {\n    this.md.updateHex(buf.toString(\'hex\'));\n  };\n\n  obj.digest = function() {\n    return new customBuf(this.md.digest(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA signer objects\nexports.createSign = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  obj.sign = function(keypem) {\n    var rsa = new RSAKey();\n    rsa.readPrivateKeyFromPEMString(keypem);\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initSign(rsa);\n    for (var i = 0; i < this.arr.length; ++i)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n\n    return new customBuf(signer.sign(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA verifier objects\nexports.createVerify = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n    \n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  var getSubjectPublicKeyPosFromHex = function(hPub) {  \n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0); \n    if (a.length != 2) \n      return -1;\n    var pBitString = a[1];\n    if (hPub.substring(pBitString, pBitString + 2) != \'03\') \n      return -1;\n    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);\n    if (hPub.substring(pBitStringV, pBitStringV + 2) != \'00\') \n      return -1;\n    return pBitStringV + 2;\n  };\n\n  var readPublicDER = function(pub_der) {\n    var hex = pub_der.toString(\'hex\'); \n    var p = getSubjectPublicKeyPosFromHex(hex);\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);\n    if (a.length != 2) \n      return null;\n    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);\n    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);\n    var rsaKey = new RSAKey();\n    rsaKey.setPublic(hN, hE);\n    return rsaKey;\n  };\n\n  obj.verify = function(keypem, sig) {\n    var key = new ndn.Key();\n    key.fromPemString(keypem);\n\n    var rsa = readPublicDER(key.publicToDER());\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initVerifyByPublicKey(rsa);\n    for (var i = 0; i < this.arr.length; i++)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n    var hSig = sig.toString(\'hex\'); \n    return signer.verify(hSig);\n  };\n\n  return obj;\n};\n\nexports.randomBytes = function(size)\n{\n  // TODO: Use a cryptographic random number generator.\n  var result = new customBuf(size);\n  for (var i = 0; i < size; ++i)\n    result[i] = Math.floor(Math.random() * 256);\n  return result;\n};\n\nexports.Buffer = customBuf;\n\nmodule.exports = exports;\n\n})()\n},{"../contrib/securityLib/asn1hex-1.1.js":91,"../contrib/securityLib/base64.js":94,"../contrib/securityLib/crypto-1.0.js":92,"../contrib/securityLib/rsasign-1.2.js":93}],77:[function(require,module,exports){\n// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee "cryptographic quality"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  if (_global.crypto && crypto.getRandomValues) {\n    whatwgRNG = function(size) {\n      var bytes = new Uint8Array(size);\n      crypto.getRandomValues(bytes);\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n\n},{}],95:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],40:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like TlvWireFormat.\n * @constructor\n */\nvar WireFormat = function WireFormat() {\n};\n\nexports.WireFormat = WireFormat;\n\n/**\n * Encode interest and return the encoding.  Your derived class should override.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeInterest = function(interest) \n{\n  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as an interest and set the fields of the interest object. \n * Your derived class should override.\n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Encode data and return the encoding and signed offsets. Your derived class \n * should override.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeData = function(data) \n{\n  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as a data packet, set the fields in the data object, and return \n * the signed offsets.  Your derived class should override.\n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeData = function(data, input) \n{\n  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Set the static default WireFormat used by default encoding and decoding \n * methods.\n * @param wireFormat {a subclass of WireFormat} An object of a subclass of \n * WireFormat.\n */\nWireFormat.setDefaultWireFormat = function(wireFormat)\n{\n  WireFormat.defaultWireFormat = wireFormat;\n};\n\n/**\n * Return the default WireFormat used by default encoding and decoding methods \n * which was set with setDefaultWireFormat.\n * @returns {a subclass of WireFormat} The WireFormat object.\n */\nWireFormat.getDefaultWireFormat = function()\n{\n  return WireFormat.defaultWireFormat;\n};\n\n// Invoke TlvWireFormat to set the default format.\n// Since tlv-wire-format.js includes this file, put this at the bottom \n// to avoid problems with cycles of require.\nvar TlvWireFormat = require(\'./tlv-wire-format.js\').TlvWireFormat;\n\n})()\n},{"../buffer.js":50,"./tlv-wire-format.js":42}],41:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar Blob = require(\'../util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Name = require(\'../name.js\').Name;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar Signature = require(\'../signature.js\').Signature;\nvar MetaInfo = require(\'../meta-info.js\').MetaInfo;\nvar PublisherPublicKeyDigest = require(\'../publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\n\n/**\n * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.\n * @constructor\n */\nvar BinaryXmlWireFormat = function BinaryXmlWireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nexports.BinaryXmlWireFormat = BinaryXmlWireFormat;\n\n// Default object.\nBinaryXmlWireFormat.instance = null;\n\n/**\n * Encode interest as Binary XML and return the encoding.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nBinaryXmlWireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new BinaryXMLEncoder();\n  BinaryXmlWireFormat.encodeInterest(interest, encoder);  \n  return new Blob(encoder.getReducedOstream(), false);  \n};\n\n/**\n * Decode input as a Binary XML interest and set the fields of the interest object. \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nBinaryXmlWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeInterest(interest, decoder);\n};\n\n/**\n * Encode data as Binary XML and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nBinaryXmlWireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new BinaryXMLEncoder(1500);\n  var result = BinaryXmlWireFormat.encodeData(data, encoder);\n  result.encoding = new Blob(encoder.getReducedOstream(), false);\n  return result;\n};\n\n/**\n * @deprecated Use encodeData(data).\n */\nBinaryXmlWireFormat.prototype.encodeContentObject = function(data)\n{\n  return this.encodeData(data);\n};\n\n/**\n * Decode input as a Binary XML data packet, set the fields in the data object, and return \n * the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  return BinaryXmlWireFormat.decodeData(data, decoder);\n};\n\n/**\n * @deprecated Use decodeData(data, input).\n */\nBinaryXmlWireFormat.prototype.decodeContentObject = function(data, input) \n{\n  this.decodeData(data, input);\n};\n\n/**\n * Get a singleton instance of a BinaryXmlWireFormat.  Assuming that the default \n * wire format was set with \n * WireFormat.setDefaultWireFormat(BinaryXmlWireFormat.get()), you can check if \n * this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == BinaryXmlWireFormat.get().\n * @returns {BinaryXmlWireFormat} The singleton instance.\n */\nBinaryXmlWireFormat.get = function()\n{\n  if (BinaryXmlWireFormat.instance === null)\n    BinaryXmlWireFormat.instance = new BinaryXmlWireFormat();\n  return BinaryXmlWireFormat.instance;\n};\n\n/**\n * Encode the interest by calling the operations on the encoder.\n * @param {Interest} interest\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeInterest = function(interest, encoder) \n{\n  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);\n    \n  interest.name.to_ndnb(encoder);\n  \n  if (null != interest.minSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);  \n\n  if (null != interest.maxSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);\n\n  if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n      interest.getKeyLocator().getKeyData() != null &&\n      interest.getKeyLocator().getKeyData().length > 0)\n    // There is a KEY_LOCATOR_DIGEST. Use this instead of the publisherPublicKeyDigest.\n    encoder.writeDTagElement\n      (NDNProtocolDTags.PublisherPublicKeyDigest, \n       interest.getKeyLocator().getKeyData());\n  else {\n    if (null != interest.publisherPublicKeyDigest)\n      interest.publisherPublicKeyDigest.to_ndnb(encoder);\n  }\n    \n  if (null != interest.exclude)\n    interest.exclude.to_ndnb(encoder);\n    \n  if (null != interest.childSelector) \n    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);\n\n  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null) \n    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);\n    \n  if (null != interest.scope) \n    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);\n    \n  if (null != interest.interestLifetime) \n    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime, \n                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));\n    \n  if (null != interest.nonce)\n    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);\n    \n  encoder.writeElementClose();\n};\n\n/**\n * Use the decoder to place the result in interest.\n * @param {Interest} interest\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeInterest = function(interest, decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name = new Name();\n  interest.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))\n    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);\n  else\n    interest.minSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents)) \n    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);\n  else\n    interest.maxSuffixComponents = null;\n      \n  // Initially clear the keyLocator.\n  interest.getKeyLocator().clear();\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    interest.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  else\n    interest.publisherPublicKeyDigest = null;\n  if (interest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest.length > 0) {\n    // We keep the deprecated publisherPublicKeyDigest for backwards \n    //   compatibility.  Also set the key locator.\n    interest.getKeyLocator().setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    interest.getKeyLocator().setKeyData\n      (interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {\n    interest.exclude = new Exclude();\n    interest.exclude.from_ndnb(decoder);\n  }\n  else\n    interest.exclude = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))\n    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);\n  else\n    interest.childSelector = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))\n    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);\n  else\n    interest.answerOriginKind = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.Scope))\n    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);\n  else\n    interest.scope = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))\n    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt\n               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;\n  else\n    interest.interestLifetime = null;              \n    \n  if (decoder.peekDTag(NDNProtocolDTags.Nonce))\n    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);\n  else\n    interest.nonce = null;\n    \n  decoder.readElementClose();\n};\n\n/**\n * Encode the data by calling the operations on the encoder.\n * @param {Data} data\n * @param {BinaryXMLEncoder} encoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.encodeData = function(data, encoder)  \n{\n  //TODO verify name, MetaInfo and Signature is present\n  encoder.writeElementStartDTag(data.getElementLabel());\n\n  if (null != data.signature) \n    data.signature.to_ndnb(encoder);\n    \n  var signedPortionBeginOffset = encoder.offset;\n\n  if (null != data.name) \n    data.name.to_ndnb(encoder);\n  \n  if (null != data.signedInfo) \n    // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n    //   the key locator from the MetaInfo to the Signauture object.\n    data.signedInfo.to_ndnb(encoder, data.getSignatureOrMetaInfoKeyLocator());\n\n  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);\n  \n  var signedPortionEndOffset = encoder.offset;\n  \n  encoder.writeElementClose();\n  \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Use the decoder to place the result in data.\n * @param {Data} data\n * @param {BinaryXMLDecoder} decoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.decodeData = function(data, decoder) \n{\n  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT\n  decoder.readElementStartDTag(data.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {\n    data.signature = new Signature();\n    data.signature.from_ndnb(decoder);\n  }\n  else\n    data.signature = null;\n    \n  var signedPortionBeginOffset = decoder.offset;\n\n  data.name = new Name();\n  data.name.from_ndnb(decoder);\n    \n  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {\n    data.signedInfo = new MetaInfo();\n    data.signedInfo.from_ndnb(decoder);\n    if (data.signedInfo.locator != null && data.getSignature() != null)\n      // Copy the key locator pointer to the Signature object for the transition \n      //   of moving the key locator from the MetaInfo to the Signature object.\n      data.getSignature().keyLocator = data.signedInfo.locator;\n  }\n  else\n    data.signedInfo = null;\n\n  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);\n    \n  var signedPortionEndOffset = decoder.offset;\n    \n  decoder.readElementClose();\n    \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n})()\n},{"../exclude.js":34,"../key-locator.js":38,"../meta-info.js":36,"../name.js":31,"../publisher-public-key-digest.js":39,"../signature.js":90,"../util/blob.js":45,"../util/ndn-protoco-id-tags.js":82,"./binary-xml-decoder.js":81,"./binary-xml-encoder.js":80,"./data-utils.js":43,"./wire-format.js":40}],42:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Tlv0_1a2WireFormat = require(\'./tlv-0_1a2-wire-format.js\').Tlv0_1a2WireFormat;\n\n/**\n * A TlvWireFormat extends Tlv0_1a2WireFormat to override its methods to \n * implement encoding and decoding using the preferred implementation of NDN-TLV.\n * @constructor\n */\nvar TlvWireFormat = function TlvWireFormat() \n{\n  // Inherit from Tlv0_1a2WireFormat.\n  Tlv0_1a2WireFormat.call(this);\n};\n\nTlvWireFormat.prototype = new Tlv0_1a2WireFormat();\nTlvWireFormat.prototype.name = "TlvWireFormat";\n\nexports.TlvWireFormat = TlvWireFormat;\n\n// Default object.\nTlvWireFormat.instance = null;\n\n/**\n * Get a singleton instance of a TlvWireFormat.  Assuming that the default \n * wire format was set with WireFormat.setDefaultWireFormat(TlvWireFormat.get()), \n * you can check if this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == TlvWireFormat.get().\n * @returns {TlvWireFormat} The singleton instance.\n */\nTlvWireFormat.get = function()\n{\n  if (TlvWireFormat.instance === null)\n    TlvWireFormat.instance = new TlvWireFormat();\n  return TlvWireFormat.instance;\n};\n\n// On loading this module, make this the default wire format.\n// This module will be loaded because WireFormat loads it.\nWireFormat.setDefaultWireFormat(TlvWireFormat.get());\n\n},{"./tlv-0_1a2-wire-format.js":96,"./wire-format.js":40}],43:[function(require,module,exports){\n(function(){/**\n * This class contains utilities to help parse the data\n *\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nconsole.log(customBuf)\n \n/**\n * A DataUtils has static methods for converting data.\n * @constructor\n */\n\n\nvar DataUtils = function()\n{\n};\n\nexports.DataUtils = new DataUtils();\n\n/*\n * NOTE THIS IS CURRENTLY NOT BEING USED\n * \n */\n\nDataUtils.prototype.keyStr = "ABCDEFGHIJKLMNOP" +\n                   "QRSTUVWXYZabcdef" +\n                   "ghijklmnopqrstuv" +\n                   "wxyz0123456789+/" +\n                   "=";\n               \n/**\n * Raw String to Base 64\n */\nDataUtils.prototype.stringtoBase64 = function stringtoBase64(input) \n{\n   //input = escape(input);\n   var output = "";\n   var chr1, chr2, chr3 = "";\n   var enc1, enc2, enc3, enc4 = "";\n   var i = 0;\n\n   do {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2))\n       enc3 = enc4 = 64;\n    else if (isNaN(chr3))\n       enc4 = 64;\n\n    output = output +\n       DataUtils.keyStr.charAt(enc1) +\n       DataUtils.keyStr.charAt(enc2) +\n       DataUtils.keyStr.charAt(enc3) +\n       DataUtils.keyStr.charAt(enc4);\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n   } while (i < input.length);\n\n   return output;\n};\n\n/**\n * Base 64 to Raw String \n */\nDataUtils.prototype.base64toString = function base64toString(input) \n{\n  var output = "";\n  var chr1, chr2, chr3 = "";\n  var enc1, enc2, enc3, enc4 = "";\n  var i = 0;\n\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n  /* Test for invalid characters. */\n  if (base64test.exec(input)) {\n    alert("There were invalid base64 characters in the input text.\\n" +\n          "Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\\n" +\n          "Expect errors in decoding.");\n  }\n  \n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");\n\n  do {\n    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 != 64)\n      output = output + String.fromCharCode(chr2);\n\n    if (enc4 != 64)\n      output = output + String.fromCharCode(chr3);\n\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n  } while (i < input.length);\n\n  return output;\n};\n\n/**\n * customBuf to Hex String\n */\nDataUtils.prototype.toHex = function(buffer) \n{\n  return buffer.toString(\'hex\');\n};\n\n/**\n * Raw string to hex string.\n */\nDataUtils.prototype.stringToHex = function(args) \n{\n  var ret = "";\n  for (var i = 0; i < args.length; ++i) {\n    var value = args.charCodeAt(i);\n    ret += (value < 16 ? "0" : "") + value.toString(16);\n  }\n  return ret;\n};\n\n/**\n * customBuf to raw string.\n */\nDataUtils.prototype.toString = function(buffer) \n{\n  return buffer.toString();\n};\n\n/**\n * Hex String to customBuf.\n */\nDataUtils.prototype.toNumbers = function(str) \n{\n  return new customBuf(str, \'hex\');\n};\n\n/**\n * Hex String to raw string.\n */\nDataUtils.prototype.hexToRawString = function(str) \n{\n  if (typeof str ==\'string\') {\n  var ret = "";\n  str.replace(/(..)/g, function(s) {\n    ret += String.fromCharCode(parseInt(s, 16));\n  });\n  return ret;\n  }\n};\n\n/**\n * Raw String to customBuf.\n */\nDataUtils.prototype.toNumbersFromString = function(str) \n{\n  return new customBuf(str, \'binary\');\n};\n\n/**\n * Encode str as utf8 and return as customBuf.\n */\nDataUtils.prototype.stringToUtf8Array = function(str) \n{\n  return new customBuf(str, \'utf8\');\n};\n\n/**\n * arrays is an array of customBuf. Return a new customBuf which is the concatenation of all.\n */\nDataUtils.prototype.concatArrays = function(arrays) \n{\n  return customBuf.concat(arrays);\n};\n \n// TODO: Take customBuf and use TextDecoder when available.\nDataUtils.prototype.decodeUtf8 = function(utftext) \n{\n  var string = "";\n  var i = 0;\n  var c = 0;\n    var c1 = 0;\n    var c2 = 0;\n \n  while (i < utftext.length) {\n    c = utftext.charCodeAt(i);\n \n    if (c < 128) {\n      string += String.fromCharCode(c);\n      i++;\n    }\n    else if (c > 191 && c < 224) {\n      c2 = utftext.charCodeAt(i + 1);\n      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n      i += 2;\n    }\n    else {\n      c2 = utftext.charCodeAt(i+1);\n      var c3 = utftext.charCodeAt(i+2);\n      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n      i += 3;\n    }\n  }\n \n  return string;\n};\n\n/**\n * Return true if a1 and a2 are the same length with equal elements.\n */\nDataUtils.prototype.arraysEqual = function(a1, a2) \n{\n  // A simple sanity check that it is an array.\n  if (!a1.slice)\n    throw new Error("DataUtils.arraysEqual: a1 is not an array");\n  if (!a2.slice)\n    throw new Error("DataUtils.arraysEqual: a2 is not an array");\n    \n  if (a1.length != a2.length)\n    return false;\n  \n  for (var i = 0; i < a1.length; ++i) {\n    if (a1[i] != a2[i])\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Convert the big endian customBuf to an unsigned int.\n * Don\'t check for overflow.\n */\nDataUtils.prototype.bigEndianToUnsignedInt = function(bytes) \n{\n  var result = 0;\n  for (var i = 0; i < bytes.length; ++i) {\n    result <<= 8;\n    result += bytes[i];\n  }\n  return result;\n};\n\n/**\n * Convert the int value to a new big endian customBuf and return.\n * If value is 0 or negative, return new customBuf(0). \n */\nDataUtils.prototype.nonNegativeIntToBigEndian = function(value) \n{\n  value = Math.round(value);\n  if (value <= 0)\n    return new customBuf(0);\n  \n  // Assume value is not over 64 bits.\n  var size = 8;\n  var result = new customBuf(size);\n  var i = 0;\n  while (value != 0) {\n    ++i;\n    result[size - i] = value & 0xff;\n    value >>= 8;\n  }\n  return result.slice(size - i, size);\n};\n\n/**\n * Modify array to randomly shuffle the elements.\n */\nDataUtils.prototype.shuffle = function(array) \n{\n  for (var i = array.length - 1; i >= 1; --i) {\n    // j is from 0 to i.\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n};\n\n})()\n},{"../buffer.js":50}],44:[function(require,module,exports){\n(function(){/**\n * This file contains utilities to help encode and decode NDN objects.\n * Copyright (C) 2013-2014 Regents of the University of California.\n * author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Key = require(\'../key.js\').Key;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Interest = require(\'../interest.js\').Interest;\nvar Data = require(\'../data.js\').Data;\nvar FaceInstance = require(\'../face-instance.js\').FaceInstance;\nvar ForwardingEntry = require(\'../forwarding-entry.js\').ForwardingEntry;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * An EncodingUtils has static methods for encoding data.\n * @constructor\n */\nvar EncodingUtils = function EncodingUtils() \n{\n};\n\nexports.EncodingUtils = EncodingUtils;\n\nEncodingUtils.encodeToHexInterest = function(interest, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(interest.wireEncode(wireFormat).buf());\n};\n\nEncodingUtils.encodeToHexData = function(data, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(data.wireEncode(wireFormat).buf());\n};\n\n/**\n * @deprecated Use EncodingUtils.encodeToHexData(data).\n */\nEncodingUtils.encodeToHexContentObject = function(data, wireFormat) \n{\n  return EncodingUtils.encodeToHexData(data, wireFormat);\n}\n\nEncodingUtils.encodeForwardingEntry = function(data) \n{\n  var enc = new BinaryXMLEncoder();\n  data.to_ndnb(enc);\n  var bytes = enc.getReducedOstream();\n\n  return bytes;\n};\n\nEncodingUtils.decodeHexFaceInstance = function(result) \n{  \n  var numbers = DataUtils.toNumbers(result); \n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODING HEX FACE INSTANCE  \\n\'+numbers);\n\n  var faceInstance = new FaceInstance();\n  faceInstance.from_ndnb(decoder);\n  \n  return faceInstance;\n};\n\nEncodingUtils.decodeHexInterest = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var interest = new Interest();\n  interest.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return interest;\n};\n\nEncodingUtils.decodeHexData = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var data = new Data();\n  data.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return data;\n};\n\n/**\n * @deprecated Use EncodingUtils.decodeHexData(input).\n */\nEncodingUtils.decodeHexContentObject = function(input, wireFormat) \n{\n  return EncodingUtils.decodeHexData(input, wireFormat);\n}\n\nEncodingUtils.decodeHexForwardingEntry = function(result) \n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODED HEX FORWARDING ENTRY \\n\'+numbers);\n  \n  var forwardingEntry = new ForwardingEntry();\n  forwardingEntry.from_ndnb(decoder);\n  return forwardingEntry;\n};\n\n/**\n * Decode the customBuf array which holds SubjectPublicKeyInfo and return an RSAKey.\n */\nEncodingUtils.decodeSubjectPublicKeyInfo = function(array) \n{\n  var hex = DataUtils.toHex(array).toLowerCase();\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));\n  var rsaKey = new RSAKey();\n  rsaKey.setPublic(a[0], a[1]);\n  return rsaKey;\n}\n\n/**\n * Return a user friendly HTML string with the contents of data.\n * This also outputs to console.log.\n */\nEncodingUtils.dataToHtml = function(/* Data */ data) \n{\n  var output ="";\n      \n  if (data == -1)\n    output+= "NO CONTENT FOUND"\n  else if (data == -2)\n    output+= "CONTENT NAME IS EMPTY"\n  else {\n    if (data.name != null && data.name.components != null) {\n      output+= "NAME: " + data.name.toUri();\n        \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.digestAlgorithm != null) {\n      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.witness != null) {\n      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.signature != null) {\n      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {\n      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.timestamp != null) {\n      var d = new Date();\n      d.setTime(data.signedInfo.timestamp.msec);\n      \n      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];\n      \n      output += "TimeStamp: "+d;\n      output+= "<br />";\n      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;\n      \n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {\n      output += "keyLocator: ";\n      if (data.signedInfo.locator.type == KeyLocatorType.KEY)\n        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n        output += "KeyLocatorDigest: " + DataUtils.toHex(data.signedInfo.locator.getKeyData()).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)\n        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)\n        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";\n      else\n        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";      \n    }\n  }\n\n  return output;\n};\n\n/**\n * @deprecated Use return EncodingUtils.dataToHtml(data).\n */\nEncodingUtils.contentObjectToHtml = function(data) \n{\n  return EncodingUtils.dataToHtml(data);\n}\n\n//\n// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.\n//\n\nvar encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }\nvar encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }\nvar encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }\nvar decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }\nvar decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }\nvar decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }\nvar decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }\nvar decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }\nvar contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }\n\n/**\n * @deprecated Use interest.wireEncode().\n */\nfunction encodeToBinaryInterest(interest) { return interest.wireEncode().buf(); }\n/**\n * @deprecated Use data.wireEncode().\n */\nfunction encodeToBinaryContentObject(data) { return data.wireEncode().buf(); }\n\n})()\n},{"../data.js":35,"../face-instance.js":97,"../forwarding-entry.js":84,"../interest.js":32,"../key-locator.js":38,"../key.js":37,"../log.js":83,"./binary-xml-decoder.js":81,"./binary-xml-encoder.js":80,"./data-utils.js":43,"./wire-format.js":40}],45:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * A Blob holds an immutable byte array implemented as a customBuf.  This should be \n * treated like a string which is a pointer to an immutable string. (It is OK to \n * pass a pointer to the string because the new owner can\u2019t change the bytes of \n * the string.)  Blob does not inherit from customBuf. Instead you must call buf() \n * to get the byte array which reminds you that you should not change the \n * contents.  Also remember that buf() can return null.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {boolean} copy (optional) (optional) If true, copy the contents of \n * value into a new customBuf.  If false, just use the existing value without \n * copying. If omitted, then copy the contents (unless value is already a Blob).\n * IMPORTANT: If copy is false, if you keep a pointer to the value then you must\n * treat the value as immutable and promise not to change it.\n */\nvar Blob = function Blob(value, copy) \n{\n  if (copy == null)\n    copy = true;\n  \n  if (value == null)\n    this.buffer = null;\n  else if (typeof value === \'object\' && value instanceof Blob)\n    // Use the existing buffer.  Don\'t need to check for copy.\n    this.buffer = value.buffer;\n  else {\n    if (typeof value === \'string\')\n      // Convert from a string to utf-8 byte encoding.\n      this.buffer = new customBuf(value, \'utf8\');\n    else {\n      if (copy)\n        // We are copying, so just make another customBuf.\n        this.buffer = new customBuf(value);\n      else {\n        if (typeof value === \'object\' && value instanceof customBuf)\n          // We can use as-is.\n          this.buffer = value;\n        else\n          // We need a customBuf, so copy.\n          this.buffer = new customBuf(value);\n      }\n    }\n  }\n};\n\nexports.Blob = Blob;\n\n/**\n * Return the length of the immutable byte array.\n * @returns {number} The length of the array.  If buf() is null, return 0.\n */\nBlob.prototype.size = function()\n{\n  if (this.buffer != null)\n    return this.buffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return the immutable byte array.  DO NOT change the contents of the customBuf.  \n * If you need to change it, make a copy.\n * @returns {Buffer} The customBuf holding the immutable byte array, or null.\n */\nBlob.prototype.buf = function()\n{\n  return this.buffer;\n};\n\n/**\n * Return true if the array is null, otherwise false.\n * @returns {boolean} True if the array is null.\n */\nBlob.prototype.isNull = function()\n{\n  return this.buffer == null;\n};\n\n/**\n * Return the hex representation of the bytes in the byte array.\n * @returns {string} The hex string.\n */\nBlob.prototype.toHex = function() \n{  \n  if (this.buffer == null)\n    return "";\n  else\n    return this.buffer.toString(\'hex\');\n};\n\n})()\n},{"../buffer.js":50}],46:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar BinaryXMLDecoder = require(\'../encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Name = require(\'../name.js\').Name;\n\n/**\n * Create a context for getting the response from the name enumeration command, as neede by getComponents.\n * (To do name enumeration, call the static method NameEnumeration.getComponents.)\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nvar NameEnumeration = function NameEnumeration(face, onComponents) \n{\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n  \n  var self = this;\n  this.onData = function(interest, data) { self.processData(data); };\n  this.onTimeout = function(interest) { self.processTimeout(); };\n};\n\nexports.NameEnumeration = NameEnumeration;\n\n/**\n * Use the name enumeration protocol to get the child components of the name prefix.\n * @param {Face} face The Face object for using expressInterest.\n * @param {Name} name The name prefix for finding the child components.\n * @param {function} onComponents On getting the response, this calls onComponents(components) where\n * components is an array of customBuf name components.  If there is no response, this calls onComponents(null). \n */\nNameEnumeration.getComponents = function(face, prefix, onComponents)\n{\n  var command = new Name(prefix);\n  // Add %C1.E.be\n  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])\n  \n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n/**\n * Parse the response from the name enumeration command and call this.onComponents.\n * @param {Data} data\n */\nNameEnumeration.prototype.processData = function(data) \n{\n  try {\n    if (!NameEnumeration.endsWithSegmentNumber(data.name))\n      // We don\'t expect a name without a segment number.  Treat it as a bad packet.\n      this.onComponents(null);\n    else {\n      var segmentNumber = DataUtils.bigEndianToUnsignedInt\n          (data.name.get(data.name.size() - 1).getValue());\n\n      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.\n      var expectedSegmentNumber = this.contentParts.length;\n      if (segmentNumber != expectedSegmentNumber)\n        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);\n      else {\n        // Save the content and check if we are finished.\n        this.contentParts.push(data.content);\n\n        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);\n          if (segmentNumber == finalSegmentNumber) {\n            // We are finished.  Parse and return the result.\n            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));\n            return;\n          }\n        }\n\n        // Fetch the next segment.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);\n      }\n    }\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Just call onComponents(null).\n */\nNameEnumeration.prototype.processTimeout = function()\n{\n  try {\n    this.onComponents(null);\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.\n * @param {Uint8Array} content The content to parse.\n * @returns {Array<Buffer>} The array of components.\n */\nNameEnumeration.parseComponents = function(content)\n{\n  var components = [];\n  var decoder = new BinaryXMLDecoder(content);\n  \n  decoder.readElementStartDTag(NDNProtocolDTags.Collection);\n \n  while (decoder.peekDTag(NDNProtocolDTags.Link)) {\n    decoder.readElementStartDTag(NDNProtocolDTags.Link);    \n    decoder.readElementStartDTag(NDNProtocolDTags.Name);\n    \n    components.push(new customBuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));\n    \n    decoder.readElementClose();  \n    decoder.readElementClose();  \n  }\n\n  decoder.readElementClose();\n  return components;\n};\n\n/**\n * Check if the last component in the name is a segment number.\n * TODO: Move to Name class.\n * @param {Name} name\n * @returns {Boolean} True if the name ends with a segment number, otherwise false.\n */\nNameEnumeration.endsWithSegmentNumber = function(name) {\n  return name.components != null && name.size() >= 1 &&\n         name.get(name.size() - 1).getValue().length >= 1 &&\n         name.get(name.size() - 1).getValue()[0] == 0;\n};\n\n})(require("__browserify_buffer").Buffer)\n},{"../buffer.js":50,"../encoding/binary-xml-decoder.js":81,"../encoding/data-utils.js":43,"../name.js":31,"./ndn-protoco-id-tags.js":82,"__browserify_buffer":60}],47:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents NDNTime Objects\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar NDNTime = function NDNTime(input) \n{\n  this.NANOS_MAX = 999877929;\n  \n  if (typeof input ==\'number\')\n    this.msec = input;\n  else {\n    if (LOG > 1) console.log(\'UNRECOGNIZED TYPE FOR TIME\');\n  }\n};\n\nexports.NDNTime = NDNTime;\n\nNDNTime.prototype.getJavascriptDate = function() \n{\n  var d = new Date();\n  d.setTime(this.msec);\n  return d\n};  \n\n},{"../log.js":83}],48:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar Key = require(\'../key.js\').Key;\n\n/**\n * @constructor\n */\nvar KeyManager = function KeyManager()\n{\n  this.certificate = \n  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +\n  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +\n  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +\n  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +\n  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +\n  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +\n  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +\n  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +\n  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";\n\n  // Public Key\n    this.publicKey = \n  "-----BEGIN PUBLIC KEY-----\\n" +\n  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\\n" +\n  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\\n" +\n  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\\n" +\n  "WFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "-----END PUBLIC KEY-----";\n  // Private Key\n    this.privateKey = \n  "-----BEGIN RSA PRIVATE KEY-----\\n" +\n  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\\n" +\n  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\\n" +\n  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\\n" +\n  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\\n" +\n  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\\n" +\n  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\\n" +\n  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\\n" +\n  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\\n" +\n  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\\n" +\n  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\\n" +\n  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\\n" +\n  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\\n" +\n  "-----END RSA PRIVATE KEY-----";\n  \n  this.key = null;\n};\n\n/**\n * Return a Key object for the keys in this KeyManager.  This creates the Key on the first\n * call and returns a cached copy after that.\n * @returns {Key}\n */\nKeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n  \n  return this.key;\n}\n\nvar globalKeyManager = globalKeyManager || new KeyManager();\nexports.globalKeyManager = globalKeyManager;\n\n},{"../key.js":37}],49:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLStructureDecoder = require(\'./binary-xml-structure-decoder.js\').BinaryXMLStructureDecoder;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvStructureDecoder = require(\'./tlv/tlv-structure-decoder.js\').TlvStructureDecoder;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * A ElementReader lets you call onReceivedData multiple times which uses a\n * BinaryXMLStructureDecoder or TlvStructureDecoder to detect the end of a \n * binary XML or TLV element and calls elementListener.onReceivedElement(element) \n * with the element.  This handles the case where a single call to \n * onReceivedData may contain multiple elements.\n * @constructor\n * @param {{onReceivedElement:function}} elementListener\n */\nvar ElementReader = function ElementReader(elementListener) \n{\n  this.elementListener = elementListener;\n  this.dataParts = [];\n  this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n  this.tlvStructureDecoder = new TlvStructureDecoder();\n  this.useTlv = null;\n};\n\nexports.ElementReader = ElementReader;\n\nElementReader.prototype.onReceivedData = function(/* customBuf */ data) \n{\n  // Process multiple objects in the data.\n  while (true) {\n    if (this.dataParts.length == 0) {\n      // This is the beginning of an element.  Check whether it is binaryXML or TLV.\n      if (data.length <= 0)\n        // Wait for more data.\n        return;\n      \n      // The type codes for TLV Interest and Data packets are chosen to not\n      //   conflict with the first byte of a binary XML packet, so we can\n      //   just look at the first byte.\n      if (data[0] == Tlv.Interest || data[0] == Tlv.Data || data[0] == 0x80)\n        this.useTlv = true;\n      else\n        // Binary XML.\n        this.useTlv = false;\n    }\n\n    var gotElementEnd;\n    var offset;\n    if (this.useTlv) {\n      // Scan the input to check if a whole TLV object has been read.\n      this.tlvStructureDecoder.seek(0);\n      gotElementEnd = this.tlvStructureDecoder.findElementEnd(data);\n      offset = this.tlvStructureDecoder.getOffset();\n    }\n    else {\n      // Scan the input to check if a whole Binary XML object has been read.\n      this.binaryXmlStructureDecoder.seek(0);\n      gotElementEnd = this.binaryXmlStructureDecoder.findElementEnd(data);\n      offset = this.binaryXmlStructureDecoder.offset;\n    }\n    \n    if (gotElementEnd) {\n      // Got the remainder of an object.  Report to the caller.\n      this.dataParts.push(data.slice(0, offset));\n      var element = DataUtils.concatArrays(this.dataParts);\n      this.dataParts = [];\n      try {\n        this.elementListener.onReceivedElement(element);\n      } catch (ex) {\n          console.log("ElementReader: ignoring exception from onReceivedElement: " , ex);\n      }\n  \n      // Need to read a new object.\n      data = data.slice(offset, data.length);\n      this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n      this.tlvStructureDecoder = new TlvStructureDecoder();\n      if (data.length == 0)\n        // No more data in the packet.\n        return;\n      \n      // else loop back to decode.\n    }\n    else {\n      // Save for a later call to concatArrays so that we only copy data once.\n      this.dataParts.push(data);\n      if (LOG > 3) console.log(\'Incomplete packet received. Length \' + data.length + \'. Wait for more input.\');\n        return;\n    }\n  }    \n};\n\n})()\n},{"../buffer.js":50,"../log.js":83,"./binary-xml-structure-decoder.js":98,"./data-utils.js":43,"./tlv/tlv-structure-decoder.js":99,"./tlv/tlv.js":85}],52:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Forwarding Entries\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar Name = require(\'./name.js\').Name;\n\n/**\n * Create a new ForwardingEntry with the optional arguments.\n * @constructor\n * @param {String} action\n * @param {Name} prefixName\n * @param {PublisherPublicKeyDigest} ndndId\n * @param {number} faceID\n * @param {number} flags\n * @param {number} lifetime in seconds\n */\nvar ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime) \n{\n  this.action = action;\n  this.prefixName = prefixName;\n  this.ndndID = ndndId;\n  this.faceID = faceID;\n  this.flags = flags;\n  this.lifetime = lifetime;\n};\n\nexports.ForwardingEntry = ForwardingEntry;\n\nForwardingEntry.ACTIVE         = 1;\nForwardingEntry.CHILD_INHERIT  = 2;\nForwardingEntry.ADVERTISE      = 4;\nForwardingEntry.LAST           = 8;\nForwardingEntry.CAPTURE       = 16;\nForwardingEntry.LOCAL         = 32;\nForwardingEntry.TAP           = 64;\nForwardingEntry.CAPTURE_OK   = 128;\n\nForwardingEntry.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n  //throws DecodingException\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action); \n  if (decoder.peekDTag(NDNProtocolDTags.Name)) {\n    this.prefixName = new Name();\n    this.prefixName.from_ndnb(decoder) ;\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.NdndId = new PublisherPublicKeyDigest();\n    this.NdndId.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID); \n  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))\n    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\nForwardingEntry.prototype.to_ndnb = function(\n  //XMLEncoder \n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.prefixName)\n    this.prefixName.to_ndnb(encoder);\n  if (null != this.NdndId)\n    this.NdndId.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.flags)\n    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);\n  if (null != this.lifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);\n\n  encoder.writeElementClose();         \n};\n\nForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }\n\n},{"./name.js":9,"./publisher-public-key-digest.js":17,"./util/ndn-protoco-id-tags.js":57}],58:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.\nexports.TcpTransport = require(\'./transport/web-socket-transport.js\').WebSocketTransport;\n\n},{"./transport/web-socket-transport.js":100}],101:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],79:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === \'function\'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === \'[object Array]\'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled \'error\' event\n      } else {\n        throw new Error("Uncaught, unspecified \'error\' event.");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == \'function\') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'addListener only takes instances of Function\');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == "newListeners"! Before\n  // adding it to the listeners, first emit "newListeners".\n  this.emit(\'newListener\', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error(\'(node) warning: possible EventEmitter memory \' +\n                      \'leak detected. %d listeners added. \' +\n                      \'Use emitter.setMaxListeners() to increase limit.\',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'removeListener only takes instances of Function\');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (typeof emitter._events[type] === \'function\')\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\n})(require("__browserify_process"))\n},{"__browserify_process":101}],63:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data Signature object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Signature with the optional values.\n * @constructor\n */\nvar Signature = function Signature(witnessOrSignatureObject, signature, digestAlgorithm) \n{\n  if (typeof witnessOrSignatureObject === \'object\' && \n      witnessOrSignatureObject instanceof Signature) {\n    // Copy the values.\n    this.keyLocator = new KeyLocator(witnessOrSignatureObject.keyLocator);\n    this.signature = witnessOrSignatureObject.signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject.witness;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = witnessOrSignatureObject.digestAlgorithm;\n  }\n  else {\n    this.keyLocator = new KeyLocator();\n    this.signature = signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = digestAlgorithm;\n  }\n};\n\nexports.Signature = Signature;\n\n/**\n * Create a new Signature which is a copy of this object.\n * @returns {Signature} A new object which is a copy of this object.\n */\nSignature.prototype.clone = function()\n{\n  return new Signature(this);\n};\n\n/**\n * Get the key locator.\n * @returns {KeyLocator} The key locator.\n */\nSignature.prototype.getKeyLocator = function()\n{\n  return this.keyLocator;\n};\n\n/**\n * Get the data packet\'s signature bytes.\n * @returns {Buffer} The signature bytes.\n */\nSignature.prototype.getSignature = function()\n{\n  return this.signature;\n};\n\n/**\n * Set the key locator to a copy of the given keyLocator.\n * @param {KeyLocator} keyLocator The KeyLocator to copy.\n */\nSignature.prototype.setKeyLocator = function(keyLocator)\n{\n  this.keyLocator = typeof keyLocator === \'object\' && keyLocator instanceof KeyLocator ?\n                    new KeyLocator(keyLocator) : new KeyLocator();\n};\n  \n/**\n * Set the data packet\'s signature bytes.\n * @param {type} signature\n */\nSignature.prototype.setSignature = function(signature)\n{\n  if (signature == null)\n    this.signature = null;\n  else if (typeof signature === \'object\' && signature instanceof Blob)\n    this.signature = new customBuf(signature.buf());\n  else\n    this.signature = new customBuf(signature);\n};\n\nSignature.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'STARTED DECODING SIGNATURE\');\n    \n  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {\n    if (LOG > 4) console.log(\'DIGIEST ALGORITHM FOUND\');\n    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm); \n  }\n  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {\n    if (LOG > 4) console.log(\'WITNESS FOUND\');\n    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness); \n  }\n    \n  //FORCE TO READ A SIGNATURE\n\n  if (LOG > 4) console.log(\'SIGNATURE FOUND\');\n  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);\n\n  decoder.readElementClose();\n};\n\nSignature.prototype.to_ndnb = function(encoder) \n{      \n  if (!this.validate())\n    throw new Error("Cannot encode: field values missing.");\n  \n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))\n    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));\n  \n  if (null != this.witness)\n    // needs to handle null witness\n    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);\n\n  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);\n\n  encoder.writeElementClose();       \n};\n\nSignature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };\n\nSignature.prototype.validate = function() \n{\n  return null != this.signature;\n};\n\n})()\n},{"./buffer.js":28,"./encoding/binary-xml-decoder.js":55,"./encoding/binary-xml-encoder.js":56,"./key-locator.js":16,"./log.js":59,"./util/blob.js":23,"./util/ndn-protoco-id-tags.js":57}],61:[function(require,module,exports){\n(function(){var assert = require(\'assert\');\nexports.Buffer = Buffer;\nexports.SlowBuffer = Buffer;\nBuffer.poolSize = 8192;\nexports.INSPECT_MAX_BYTES = 50;\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n  this.parent = this;\n  this.offset = 0;\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this[i] = subject.readUInt8(i);\n        }\n        else {\n          this[i] = subject[i];\n        }\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    } else if (type === \'number\') {\n      for (var i = 0; i < this.length; i++) {\n        this[i] = 0;\n      }\n    }\n  }\n}\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this[i];\n};\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this[i] = v;\n};\n\nBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n    case \'binary\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;\n\nBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n};\n\nBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nBuffer.prototype.binarySlice = Buffer.prototype.asciiSlice;\n\nBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  Buffer._charsWritten = i * 2;\n  return i;\n};\n\n\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  if (end === undefined || isNaN(end)) {\n    end = this.length;\n  }\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  var temp = [];\n  for (var i=start; i<end; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=target_start; i<target_start+temp.length; i++) {\n    target[i] = temp[i-target_start];\n  }\n};\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof Buffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// helpers\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\nfunction isArray(subject) {\n  return (Array.isArray ||\n    function(subject){\n      return {}.toString.apply(subject) == \'[object Array]\'\n    })\n    (subject)\n}\n\nfunction isArrayIsh(subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\n// read/write bit-twiddling\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer[offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer[offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1];\n    }\n  } else {\n    val = buffer[offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer[offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer[offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer[offset + 3];\n    val = val + (buffer[offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer[offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer[offset + 1] << 8;\n    val |= buffer[offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer[offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer[offset] & 0x80;\n  if (!neg) {\n    return (buffer[offset]);\n  }\n\n  return ((0xff - buffer[offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer[offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer[offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer[offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\n})()\n},{"./buffer_ieee754":95,"assert":73,"base64-js":102}],64:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Publisher and PublisherType Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNProtocolDTagsStrings = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTagsStrings;\nvar DecodingException = require(\'./encoding/decoding-exception.js\').DecodingException;\n\n/**\n * @constructor\n */\nvar PublisherType = function PublisherType(tag) \n{\n  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;\n  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;\n  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;\n  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  this.Tag = tag;\n}; \n\n/**\n * @constructor\n */\nvar PublisherID = function PublisherID() \n{\n  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";\n  this.PUBLISHER_ID_LEN = 256/8;\n    \n  //TODO, implement publisherID creation and key creation\n\n  //TODO implement generatePublicKeyDigest\n  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray\n    \n  //TODO implement generate key\n  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);\n  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type   \n};\n\nexports.PublisherID = PublisherID;\n\nPublisherID.prototype.from_ndnb = function(decoder) \n{    \n  // We have a choice here of one of 4 binary element types.\n  var nextTag = PublisherID.peekAndGetNextDTag(decoder);\n    \n  this.publisherType = new PublisherType(nextTag); \n    \n  if (nextTag < 0)\n    throw new Error("Invalid publisher ID, got unexpected type");\n\n  this.publisherID = decoder.readBinaryDTagElement(nextTag);\n  if (null == this.publisherID)\n    throw new DecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));\n};\n\nPublisherID.prototype.to_ndnb = function(encoder) \n{\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);\n};\n\n/**\n * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.\n * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.\n * @returns {number} The PublisherID DTag or -1 if it is not one of them.\n */\nPublisherID.peekAndGetNextDTag = function(decoder) \n{\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))\n    return             NDNProtocolDTags.PublisherPublicKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))\n    return             NDNProtocolDTags.PublisherCertificateDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))\n    return             NDNProtocolDTags.PublisherIssuerKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))\n    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;\n  \n  return -1;\n};\n  \nPublisherID.peek = function(/* XMLDecoder */ decoder) \n{\n  return PublisherID.peekAndGetNextDTag(decoder) >= 0;\n};\n\nPublisherID.prototype.getElementLabel = function()\n{ \n  return this.publisherType.Tag;\n};\n\nPublisherID.prototype.validate = function() \n{\n  return null != id() && null != type();\n};\n\n},{"./encoding/decoding-exception.js":103,"./util/ndn-protoco-id-tags.js":57}],55:[function(require,module,exports){\n(function(){/**\n * This class is used to decode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNTime = require(\'../util/ndn-time.js\').NDNTime;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n  \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n\n\n//returns a string\ntagToString = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {\n    return NDNProtocolDTagsStrings[tagVal];\n  } \n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  }\n  \n  return null;\n};\n\n//returns a Long\nstringToTag =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n  }\n  \n  return null;\n};\n\n/**\n * @constructor\n */\nvar BinaryXMLDecoder = function BinaryXMLDecoder(input) \n{\n  var MARK_LEN=512;\n  var DEBUG_MAX_LEN =  32768;\n  \n  this.input = input;\n  this.offset = 0;\n  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.\n  this.previouslyPeekedDTagStartOffset = -1;\n};\n\nexports.BinaryXMLDecoder = BinaryXMLDecoder;\n\n/**\n * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.\n   * Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n */\nBinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset) {\n    // peekDTag already decoded this DTag.\n    if (this.previouslyPeekedDTag != expectedTag)\n      throw new DecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));\n\n    // Fast forward past the header.\n    this.offset = this.previouslyPeekedDTagEndOffset;\n  }\n  else {\n    var typeAndValue = this.decodeTypeAndVal();\n    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)\n      throw new DecodingException(new Error("Header type is not a DTAG"));\n\n    if (typeAndValue.val() != expectedTag)\n      throw new DecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));\n  }  \n};\n\n/**\n * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readStartElement = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes)\n{\n  //TypeAndVal \n  var tv = this.decodeTypeAndVal();\n      \n  if (null == tv)\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));\n      \n  //String \n  var decodedTag = null;\n      \n  if (tv.type() == XML_TAG) {\n    // Tag value represents length-1 as tags can never be empty.\n    var valval;\n        \n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val())) + 1;\n    else\n      valval = (tv.val())+ 1;\n        \n    decodedTag = this.decodeUString(valval);\n  } \n  else if (tv.type() == XML_DTAG)\n    decodedTag = tv.val();\n      \n  if (null ==  decodedTag || decodedTag != startTag) {\n    console.log(\'expecting \'+ startTag + \' but got \'+ decodedTag);\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));\n  }\n      \n  // DKS: does not read attributes out of stream if caller doesn\'t\n  // ask for them. Should possibly peek and skip over them regardless.\n  // TODO: fix this\n  if (null != attributes)\n    readAttributes(attributes); \n};\n  \n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readAttributes = function(\n  // array of [attributeName, attributeValue] \n  attributes) \n{\n  if (null == attributes)\n    return;\n\n  try {\n    // Now need to get attributes.\n    //TypeAndVal \n    var nextTV = this.peekTypeAndVal();\n\n    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {\n      // Decode this attribute. First, really read the type and value.\n      //this.TypeAndVal \n      var thisTV = this.decodeTypeAndVal();\n\n      //String \n      var attributeName = null;\n      if (XML_ATTR == thisTV.type()) {\n        // Tag value represents length-1 as attribute names cannot be empty.\n        var valval ;\n        if (typeof thisTV.val() == \'string\')\n          valval = (parseInt(thisTV.val())) + 1;\n        else\n          valval = (thisTV.val())+ 1;\n        \n        attributeName = this.decodeUString(valval);\n      } \n      else if (XML_DATTR == thisTV.type()) {\n        // DKS TODO are attributes same or different dictionary?\n        attributeName = tagToString(thisTV.val());\n        if (null == attributeName)\n          throw new DecodingException(new Error("Unknown DATTR value" + thisTV.val()));\n      }\n      \n      // Attribute values are always UDATA\n      //String\n      var attributeValue = this.decodeUString();\n\n      attributes.push([attributeName, attributeValue]);\n      nextTV = this.peekTypeAndVal();\n    }\n  } \n  catch (e) {\n    throw new DecodingException(new Error("readStartElement", e));\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsString = function() \n{\n  //String \n  var decodedTag = null;\n  var previousOffset = this.offset;\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal \n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        // Tag value represents length-1 as tags can never be empty.\n        var valval ;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        decodedTag = this.decodeUString(valval);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tagToString(tv.val());          \n    } // else, not a type and val, probably an end element. rewind and return false.\n  } \n  catch (e) {\n  } \n  finally {\n    try {\n      this.offset = previousOffset;\n    } \n    catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new DecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,\n * then set return true.  Do not update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {boolean} True if the tag is the expected tag, otherwise false.\n */\nBinaryXMLDecoder.prototype.peekDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset)\n    // We already decoded this DTag.\n    return this.previouslyPeekedDTag == expectedTag;\n  else {\n    // First check if it is an element close (which cannot be the expected tag).  \n    if (this.input[this.offset] == XML_CLOSE)\n      return false;\n\n    var saveOffset = this.offset;\n    var typeAndValue = this.decodeTypeAndVal();\n    // readElementStartDTag will use this to fast forward.\n    this.previouslyPeekedDTagEndOffset = this.offset;\n    // Restore the position.\n    this.offset = saveOffset;\n\n    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {\n      this.previouslyPeekedDTagStartOffset = saveOffset;\n      this.previouslyPeekedDTag = typeAndValue.val();\n\n      return typeAndValue.val() == expectedTag;\n    }\n    else\n      return false;\n  }  \n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElement = function(\n    //String \n    startTag) \n{\n  //String \n  if (typeof startTag == \'string\') {\n    var decodedTag = this.peekStartElementAsString();\n    \n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else if (typeof startTag == \'number\') {\n    var decodedTag = this.peekStartElementAsLong();\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else\n    throw new DecodingException(new Error("SHOULD BE STRING OR NUMBER"));\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsLong = function() \n{\n  //Long\n  var decodedTag = null;    \n  var previousOffset = this.offset;\n  \n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        if (tv.val() + 1 > DEBUG_MAX_LEN)\n          throw new DecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));\n\n        var valval;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        // Tag value represents length-1 as tags can never be empty.\n        //String \n        var strTag = this.decodeUString(valval);\n        \n        decodedTag = stringToTag(strTag);\n      } \n      else if (tv.type() == XML_DTAG)\n        decodedTag = tv.val();          \n    } // else, not a type and val, probably an end element. rewind and return false.\n\n  } \n  catch (e) {  \n  } \n  finally {\n    try {\n      //this.input.reset();\n      this.offset = previousOffset;\n    } catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new Error("Cannot reset stream! " + e.getMessage(), e);\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a \n * customBuf. However, if allowNull is true, then the item may be absent.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @param {boolean} allowNull True if the binary item may be missing.\n * @returns {Buffer} A customBuf which is a slice on the data inside the input buffer. However, \n * if allowNull is true and the binary data item is absent, then return null.\n */\nBinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readBinaryElement = function(\n    //long \n    startTag,\n    //TreeMap<String, String> \n    attributes,\n    //boolean\n    allowNull) \n{\n  this.readStartElement(startTag, attributes);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * Read one byte from the input starting at its offset, expecting it to be the element close.\n * Update the input\'s offset.\n */\nBinaryXMLDecoder.prototype.readElementClose = function() \n{\n  var next = this.input[this.offset++];     \n  if (next != XML_CLOSE)\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n};\n\n/**\n * @deprecated Use readElementClose.\n */\nBinaryXMLDecoder.prototype.readEndElement = function() \n{\n  if (LOG > 4) console.log(\'this.offset is \'+this.offset);\n  \n  var next = this.input[this.offset]; \n  \n  this.offset++;\n  \n  if (LOG > 4) console.log(\'XML_CLOSE IS \'+XML_CLOSE);\n  if (LOG > 4) console.log(\'next is \'+next);\n  \n  if (next != XML_CLOSE) {\n    console.log("Expected end element, got: " + next);\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n  }\n};\n\n//String  \nBinaryXMLDecoder.prototype.readUString = function() \n{\n  //String \n  var ustring = this.decodeUString();  \n  this.readElementClose();\n  return ustring;\n};\n  \n/**\n * Read a blob as well as the end element. Returns a customBuf (or null for missing blob).\n * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,\n *   just read the end element and return null.\n */\nBinaryXMLDecoder.prototype.readBlob = function(allowNull) \n{\n  if (this.input[this.offset] == XML_CLOSE && allowNull) {\n    this.readElementClose();\n    return null;\n  }\n    \n  var blob = this.decodeBlob();  \n  this.readElementClose();\n  return blob;\n};\n\n/**\n * Decode the header from the input starting at its offset, expecting the type to be \n * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned \n * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {NDNTime} The dateTime value.\n */\nBinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)  \n{\n  var byteTimestamp = this.readBinaryDTagElement(expectedTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\n/**\n * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readDateTime = function(\n  //long \n  startTag)  \n{\n  var byteTimestamp = this.readBinaryElement(startTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  if (LOG > 4) console.log(\'DECODED DATE WITH VALUE\');\n  if (LOG > 4) console.log(lontimestamp);\n  \n  //NDNTime \n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\nBinaryXMLDecoder.prototype.decodeTypeAndVal = function() \n{\n  \n  /*int*/ var type = -1;\n  /*long*/ var val = 0;\n  /*boolean*/ var more = true;\n\n  do {\n    var next = this.input[this.offset ];\n    if (next == null)\n      // Quit the loop.\n      return null; \n    \n    if (next < 0)\n      return null; \n\n    if (0 == next && 0 == val)\n      return null;\n    \n    more = (0 == (next & XML_TT_NO_MORE));\n    \n    if  (more) {\n      val = val << XML_REG_VAL_BITS;\n      val |= (next & XML_REG_VAL_MASK);\n    } \n    else {\n      type = next & XML_TT_MASK;\n      val = val << XML_TT_VAL_BITS;\n      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);\n    }\n    \n    this.offset++;\n  } while (more);\n  \n  if (LOG > 4) console.log(\'TYPE is \'+ type + \' VAL is \'+ val);\n\n  return new TypeAndVal(type, val);\n};\n\n//TypeAndVal\nBinaryXMLDecoder.prototype.peekTypeAndVal = function() \n{\n  //TypeAndVal \n  var tv = null;\n  var previousOffset = this.offset;\n  \n  try {\n    tv = this.decodeTypeAndVal();\n  } \n  finally {\n    this.offset = previousOffset;\n  }\n  \n  return tv;\n};\n\n//Buffer\nBinaryXMLDecoder.prototype.decodeBlob = function(\n    //int \n    blobLength) \n{  \n  if (null == blobLength) {\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    var valval ;\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val()));\n    else\n      valval = (tv.val());\n    \n    return this.decodeBlob(valval);\n  }\n  \n  //Buffer\n  var bytes = new customBuf(this.input.slice(this.offset, this.offset+ blobLength));\n  this.offset += blobLength;\n  \n  return bytes;\n};\n\n//String\nBinaryXMLDecoder.prototype.decodeUString = function(\n    //int \n    byteLength) \n{\n  if (null == byteLength) {\n    var tempStreamPosition = this.offset;\n      \n    //TypeAndVal \n    var tv = this.decodeTypeAndVal();\n    \n    if (LOG > 4) console.log(\'TV is \'+tv);\n    if (LOG > 4) console.log(tv);\n    \n    if (LOG > 4) console.log(\'Type of TV is \'+typeof tv);\n  \n    // if we just have closers left, will get back null\n    if (null == tv || XML_UDATA != tv.type()) {\n      this.offset = tempStreamPosition;      \n      return "";\n    }\n      \n    return this.decodeUString(tv.val());\n  }\n  else {\n    //Buffer \n    var stringBytes = this.decodeBlob(byteLength);\n    \n    // TODO: Should this parse as UTF8?\n    return DataUtils.toString(stringBytes);    \n  }\n};\n\n//OBject containg a pair of type and value\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.t = _type;\n  this.v = _val;\n};\n\nTypeAndVal.prototype.type = function() \n{\n  return this.t;\n};\n\nTypeAndVal.prototype.val = function() \n{\n  return this.v;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {number} The parsed integer.\n */\nBinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)\n{\n  return parseInt(this.readUTF8DTagElement(expectedTag));\n};\n\n/**\n * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readIntegerElement = function(\n  //String \n  startTag) \n{\n  //String \n  if (LOG > 4) console.log(\'READING INTEGER \'+ startTag);\n  if (LOG > 4) console.log(\'TYPE OF \'+ typeof startTag);\n  \n  var strVal = this.readUTF8Element(startTag);\n  \n  return parseInt(strVal);\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item and return a string. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {string} The UDATA string.\n */\nBinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readUString();;\n};\n\n/**\n * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readUTF8Element = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes) \n{\n  //throws Error where name == "DecodingException" \n\n  // can\'t use getElementText, can\'t get attributes\n  this.readStartElement(startTag, attributes);\n  //String \n  var strElementText = this.readUString();\n  return strElementText;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nBinaryXMLDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n})()\n},{"../buffer.js":28,"../log.js":59,"../util/ndn-protoco-id-tags.js":57,"../util/ndn-time.js":25,"./data-utils.js":21,"./decoding-exception.js":103}],56:[function(require,module,exports){\n(function(){/**\n * This class is used to encode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n/**\n * @constructor\n */\nvar BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength) \n{\n  if (!initiaLength)\n    initiaLength = 16;\n  \n  this.ostream = new DynamicBuffer(initiaLength);\n  this.offset = 0;\n  this.CODEC_NAME = "Binary";\n};\n\nexports.BinaryXMLEncoder = BinaryXMLEncoder;\n\n/**\n * Encode utf8Content as utf8 and write to the output buffer as a UDATA.\n * @param {string} utf8Content The string to convert to utf8.\n */\nBinaryXMLEncoder.prototype.writeUString = function(utf8Content) \n{\n  this.encodeUString(utf8Content, XML_UDATA);\n};\n\nBinaryXMLEncoder.prototype.writeBlob = function(\n    /*Buffer*/ binaryContent) \n{  \n  if (LOG >3) console.log(binaryContent);\n  \n  this.encodeBlob(binaryContent, binaryContent.length);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer.\n * @param {number} tag The DTAG tag.\n */\nBinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)\n{\n  this.encodeTypeAndVal(XML_DTAG, tag);\n};\n\n/**\n * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeStartElement = function(\n  /*String*/ tag, \n  /*TreeMap<String,String>*/ attributes) \n{\n  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);\n  \n  if (null == dictionaryVal)\n    this.encodeUString(tag, XML_TAG);\n  else\n    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);\n  \n  if (null != attributes)\n    this.writeAttributes(attributes); \n};\n\n/**\n * Write an element close to the output buffer.\n */\nBinaryXMLEncoder.prototype.writeElementClose = function() \n{\n  this.ostream.ensureLength(this.offset + 1);\n  this.ostream.array[this.offset] = XML_CLOSE;\n  this.offset += 1;\n};\n\n/**\n * @deprecated Use writeElementClose.\n */\nBinaryXMLEncoder.prototype.writeEndElement = function() \n{\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes) \n{\n  if (null == attributes)\n    return;\n\n  // the keySet of a TreeMap is sorted.\n\n  for (var i = 0; i< attributes.length;i++) {\n    var strAttr = attributes[i].k;\n    var strValue = attributes[i].v;\n\n    var dictionaryAttr = stringToTag(strAttr);\n    if (null == dictionaryAttr)\n      // not in dictionary, encode as attr\n      // compressed format wants length of tag represented as length-1\n      // to save that extra bit, as tag cannot be 0 length.\n      // encodeUString knows to do that.\n      this.encodeUString(strAttr, XML_ATTR);\n    else\n      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);\n\n    // Write value\n    this.encodeUString(strValue);    \n  }\n};\n\n//returns a string\nstringToTag = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)\n    return NDNProtocolDTagsStrings[tagVal];\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  \n  return null;\n};\n\n//returns a Long\ntagToString =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  \n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n\n  return null;\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the content as explained below, \n * then an element close.\n * @param {number} tag The DTAG tag.\n * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,\n * call writeUString.  Otherwise, call writeBlob.\n */\nBinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)\n{\n  this.writeElementStartDTag(tag);\n  \n  if (typeof content === \'number\')\n    this.writeUString(content.toString());\n  else if (typeof content === \'string\')\n    this.writeUString(content);\n  else\n    this.writeBlob(content);\n  \n  this.writeElementClose();\n};\n\n/**\n * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n * If Content is a string, then encode as utf8 and write UDATA.\n */\nBinaryXMLEncoder.prototype.writeElement = function(\n    //long \n    tag, \n    //byte[] \n    Content,\n    //TreeMap<String, String> \n    attributes) \n{\n  this.writeStartElement(tag, attributes);\n  // Will omit if 0-length\n  \n  if (typeof Content === \'number\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER .charCodeAt(0) \' + Content.toString().charCodeAt(0));\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER \' + Content.toString());\n    if (LOG > 4) console.log(\'type of number is \' + typeof Content.toString());\n    \n    this.writeUString(Content.toString());\n  }\n  else if (typeof Content === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE STRING  \' + Content);\n    if (LOG > 4) console.log(\'type of STRING is \' + typeof Content);\n    \n    this.writeUString(Content);\n  }\n  else {\n    if (LOG > 4) console.log(\'GOING TO WRITE A BLOB  \' + Content);\n\n    this.writeBlob(Content);\n  }\n  \n  this.writeElementClose();\n};\n\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.type = _type;\n  this.val = _val;  \n};\n\nBinaryXMLEncoder.prototype.encodeTypeAndVal = function(\n    //int\n    type, \n    //long \n    val) \n{  \n  if (LOG > 4) console.log(\'Encoding type \'+ type+ \' and value \'+ val);\n  \n  if (LOG > 4) console.log(\'OFFSET IS \' + this.offset);\n  \n  if (type > XML_UDATA || type < 0 || val < 0)\n    throw new Error("Tag and value must be positive, and tag valid.");\n  \n  // Encode backwards. Calculate how many bytes we need:\n  var numEncodingBytes = this.numEncodingBytes(val);\n  this.ostream.ensureLength(this.offset + numEncodingBytes);\n\n  // Bottom 4 bits of val go in last byte with tag.\n  this.ostream.array[this.offset + numEncodingBytes - 1] = \n    //(byte)\n      (BYTE_MASK &\n          (((XML_TT_MASK & type) | \n           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n           XML_TT_NO_MORE); // set top bit for last byte\n  val = val >>> XML_TT_VAL_BITS;\n  \n  // Rest of val goes into preceding bytes, 7 bits per byte, top bit\n  // is "more" flag.\n  var i = this.offset + numEncodingBytes - 2;\n  while (0 != val && i >= this.offset) {\n    this.ostream.array[i] = //(byte)\n        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset\n    val = val >>> XML_REG_VAL_BITS;\n    --i;\n  }\n  \n  if (val != 0)\n    throw new Error("This should not happen: miscalculated encoding");\n\n  this.offset+= numEncodingBytes;\n  \n  return numEncodingBytes;\n};\n\n/**\n * Encode ustring as utf8.\n */\nBinaryXMLEncoder.prototype.encodeUString = function(\n    //String \n    ustring, \n    //byte \n    type) \n{  \n  if (null == ustring)\n    return;\n  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)\n    return;\n  \n  if (LOG > 3) console.log("The string to write is ");\n  if (LOG > 3) console.log(ustring);\n\n  var strBytes = DataUtils.stringToUtf8Array(ustring);\n  \n  this.encodeTypeAndVal(type, \n            (((type == XML_TAG) || (type == XML_ATTR)) ?\n                (strBytes.length-1) :\n                strBytes.length));\n  \n  if (LOG > 3) console.log("THE string to write is ");\n  \n  if (LOG > 3) console.log(strBytes);\n  \n  this.writeString(strBytes);\n  this.offset+= strBytes.length;\n};\n\n\nBinaryXMLEncoder.prototype.encodeBlob = function(\n    //Buffer \n    blob, \n    //int \n    length) \n{\n  if (null == blob)\n    return;\n  \n  if (LOG > 4) console.log(\'LENGTH OF XML_BLOB IS \'+length);\n  \n  this.encodeTypeAndVal(XML_BLOB, length);\n  this.writeBlobArray(blob);\n  this.offset += length;\n};\n\nvar ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);\n\nBinaryXMLEncoder.prototype.numEncodingBytes = function(\n    //long\n    x) \n{\n  if (x <= ENCODING_LIMIT_1_BYTE) return (1);\n  if (x <= ENCODING_LIMIT_2_BYTES) return (2);\n  if (x <= ENCODING_LIMIT_3_BYTES) return (3);\n  \n  var numbytes = 1;\n  \n  // Last byte gives you XML_TT_VAL_BITS\n  // Remainder each give you XML_REG_VAL_BITS\n  x = x >>> XML_TT_VAL_BITS;\n  while (x != 0) {\n        numbytes++;\n    x = x >>> XML_REG_VAL_BITS;\n  }\n  return (numbytes);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the dateTime\n   * as a big endian BLOB converted to 4096 ticks per second, then an element close.\n * @param {number} tag The DTAG tag.\n * @param {NDNTime} dateTime\n */\nBinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)\n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n/**\n * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeDateTime = function(\n    //String \n    tag, \n    //NDNTime \n    dateTime) \n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n// This does not update this.offset.\nBinaryXMLEncoder.prototype.writeString = function(input) \n{\n  if (typeof input === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING\');\n    if (LOG > 4) console.log(input);\n        \n    this.ostream.ensureLength(this.offset + input.length);\n    for (var i = 0; i < input.length; i++) {\n      if (LOG > 4) console.log(\'input.charCodeAt(i)=\' + input.charCodeAt(i));\n      this.ostream.array[this.offset + i] = (input.charCodeAt(i));\n    }\n  }\n  else\n  {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING IN BINARY FORM\');\n    if (LOG > 4) console.log(input);\n    \n    this.writeBlobArray(input);\n  }\n};\n\nBinaryXMLEncoder.prototype.writeBlobArray = function(\n    //Buffer \n    blob) \n{  \n  if (LOG > 4) console.log(\'GOING TO WRITE A BLOB\');\n    \n  this.ostream.copy(blob, this.offset);\n};\n\nBinaryXMLEncoder.prototype.getReducedOstream = function() \n{\n  return this.ostream.slice(0, this.offset);\n};\n\n})()\n},{"../buffer.js":28,"../log.js":59,"../util/dynamic-buffer.js":104,"../util/ndn-protoco-id-tags.js":57,"./data-utils.js":21}],62:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar Blob = require(\'./blob.js\').Blob;\n\n/**\n * A SignedBlob extends Blob to keep the offsets of a signed portion (e.g., the \n * bytes of Data packet). This inherits from Blob, including Blob.size and Blob.buf.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {number} signedPortionBeginOffset (optional) The offset in the \n * encoding of the beginning of the signed portion. If omitted, set to 0.\n * @param {number} signedPortionEndOffset (optional) The offset in the encoding \n * of the end of the signed portion. If omitted, set to 0.\n */\nvar SignedBlob = function SignedBlob(value, signedPortionBeginOffset, signedPortionEndOffset) \n{\n  // Call the base constructor.\n  Blob.call(this, value);\n  \n  if (this.buffer == null) {\n    this.signedPortionBeginOffset = 0;\n    this.signedPortionEndOffset = 0;\n  }\n  else if (typeof value === \'object\' && value instanceof SignedBlob) {\n    // Copy the SignedBlob, allowing override for offsets.\n    this.signedPortionBeginOffset = signedPortionBeginOffset == null ? \n      value.signedPortionBeginOffset : signedPortionBeginOffset;\n    this.signedPortionEndOffset = signedPortionEndOffset == null ? \n      value.signedPortionEndOffset : signedPortionEndOffset;\n  }\n  else {\n    this.signedPortionBeginOffset = signedPortionBeginOffset || 0;\n    this.signedPortionEndOffset = signedPortionEndOffset || 0;\n  }\n  \n  if (this.buffer == null)\n    this.signedBuffer = null;\n  else\n    this.signedBuffer = this.buffer.slice\n      (this.signedPortionBeginOffset, this.signedPortionEndOffset);\n};\n\nSignedBlob.prototype = new Blob();\nSignedBlob.prototype.name = "SignedBlob";\n\nexports.SignedBlob = SignedBlob;\n\n/**\n * Return the length of the signed portion of the immutable byte array.\n * @returns {number} The length of the signed portion.  If signedBuf() is null, \n * return 0.\n */\nSignedBlob.prototype.signedSize = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return a the signed portion of the immutable byte array.\n * @returns {Buffer} A slice into the customBuf which is the signed portion.  \n * If the pointer to the array is null, return null.\n */\nSignedBlob.prototype.signedBuf = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer;\n  else\n    return null;\n};\n\n/**\n * Return the offset in the array of the beginning of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionBeginOffset = function()\n{\n  return this.signedPortionBeginOffset;\n};\n\n/**\n * Return the offset in the array of the end of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionEndOffset = function()\n{\n  return this.signedPortionEndOffset;\n};\n\n})()\n},{"../buffer.js":28,"./blob.js":23}],70:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Face Instances\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\n\n/**\n * @constructor\n */\nvar FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,\n    multicastTTL, freshnessSeconds) \n{\n  this.action = action;\n  this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n  this.faceID = faceID;\n  this.ipProto = ipProto;\n  this.host = host;\n  this.Port = port;\n  this.multicastInterface =multicastInterface;\n  this.multicastTTL =multicastTTL;\n  this.freshnessSeconds = freshnessSeconds;\n};\n\nexports.FaceInstance = FaceInstance;\n\nFaceInstance.NetworkProtocol = { TCP:6, UDP:17};\n\n/**\n * Used by NetworkObject to decode the object from a network stream.\n */\nFaceInstance.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Action))   \n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    this.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {\n    //int\n    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);\n    \n    this.ipProto = null;\n    \n    if (FaceInstance.NetworkProtocol.TCP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.TCP;\n    else if (FaceInstance.NetworkProtocol.UDP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.UDP;\n    else\n      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Host))\n    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);\n  if (decoder.peekDTag(NDNProtocolDTags.Port))\n    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))\n    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))\n    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\n/**\n * Used by NetworkObject to encode the object to a network stream.\n */\nFaceInstance.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.publisherPublicKeyDigest)\n    this.publisherPublicKeyDigest.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.ipProto)\n    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);\n  if (null != this.host && this.host.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);  \n  if (null != this.Port)\n    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);\n  if (null != this.multicastInterface && this.multicastInterface.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);\n  if (null !=  this.multicastTTL)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  encoder.writeElementClose();         \n};\n\nFaceInstance.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.FaceInstance;\n};\n\n\n},{"./publisher-public-key-digest.js":17,"./util/ndn-protoco-id-tags.js":57}],82:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class contains all NDNx tags\n */\n\n\nvar NDNProtocolDTags = {\n\n  /**\n   * Note if you add one of these, add it to the reverse string map as well.\n   * Emphasize getting the work done at compile time over trying to make something\n   * flexible and developer error-proof.\n   */\n\n   Any : 13,\n   Name : 14,\n   Component : 15,\n   Certificate : 16,\n   Collection : 17,\n   CompleteName : 18,\n   Content : 19,\n   SignedInfo : 20,\n   ContentDigest : 21,\n   ContentHash : 22,\n   Count : 24,\n   Header : 25,\n   Interest : 26,  /* 20090915 */\n   Key : 27,\n   KeyLocator : 28,\n   KeyName : 29,\n   Length : 30,\n   Link : 31,\n   LinkAuthenticator : 32,\n   NameComponentCount : 33,  /* DeprecatedInInterest */\n   RootDigest : 36,\n   Signature : 37,\n   Start : 38,\n   Timestamp : 39,\n   Type : 40,\n   Nonce : 41,\n   Scope : 42,\n   Exclude : 43,\n   Bloom : 44,\n   BloomSeed : 45,\n   AnswerOriginKind : 47,\n   InterestLifetime : 48,\n   Witness : 53,\n   SignatureBits : 54,\n   DigestAlgorithm : 55,\n   BlockSize : 56,\n   FreshnessSeconds : 58,\n   FinalBlockID : 59,\n   PublisherPublicKeyDigest : 60,\n   PublisherCertificateDigest : 61,\n   PublisherIssuerKeyDigest : 62,\n   PublisherIssuerCertificateDigest : 63,\n   Data : 64,  /* 20090915 */\n   WrappedKey : 65,\n   WrappingKeyIdentifier : 66,\n   WrapAlgorithm : 67,\n   KeyAlgorithm : 68,\n   Label : 69,\n   EncryptedKey : 70,\n   EncryptedNonceKey : 71,\n   WrappingKeyName : 72,\n   Action : 73,\n   FaceID : 74,\n   IPProto : 75,\n   Host : 76,\n   Port : 77,\n   MulticastInterface : 78,\n   ForwardingFlags : 79,\n   FaceInstance : 80,\n   ForwardingEntry : 81,\n   MulticastTTL : 82,\n   MinSuffixComponents : 83,\n   MaxSuffixComponents : 84,\n   ChildSelector : 85,\n   RepositoryInfo : 86,\n   Version : 87,\n   RepositoryVersion : 88,\n   GlobalPrefix : 89,\n   LocalName : 90,\n   Policy : 91,\n   Namespace : 92,\n   GlobalPrefixName : 93,\n   PolicyVersion : 94,\n   KeyValueSet : 95,\n   KeyValuePair : 96,\n   IntegerValue : 97,\n   DecimalValue : 98,\n   StringValue : 99,\n   BinaryValue : 100,\n   NameValue : 101,\n   Entry : 102,\n   ACL : 103,\n   ParameterizedName : 104,\n   Prefix : 105,\n   Suffix : 106,\n   Root : 107,\n   ProfileName : 108,\n   Parameters : 109,\n   InfoString : 110,\n  // 111 unallocated\n   StatusResponse : 112,\n   StatusCode : 113,\n   StatusText : 114,\n\n  // Sync protocol\n   SyncNode : 115,\n   SyncNodeKind : 116,\n   SyncNodeElement : 117,\n   SyncVersion : 118,\n   SyncNodeElements : 119,\n   SyncContentHash : 120,\n   SyncLeafCount : 121,\n   SyncTreeDepth : 122,\n   SyncByteCount : 123,\n   ConfigSlice : 124,\n   ConfigSliceList : 125,\n   ConfigSliceOp : 126,\n\n  // Remember to keep in sync with schema/tagnames.csvsdict\n   NDNProtocolDataUnit : 17702112,\n   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"\n};\n\nexports.NDNProtocolDTags = NDNProtocolDTags;\n\nvar NDNProtocolDTagsStrings = [\n  null, null, null, null, null, null, null, null, null, null, null,\n  null, null,\n  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",\n  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",\n  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",\n  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",\n  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",\n  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",\n  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",\n  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",\n  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",\n  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",\n  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",\n  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",\n  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",\n  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",\n  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",\n  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",\n  "InfoString", null,\n    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",\n    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",\n    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];\n\nexports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;\n\n},{}],83:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Log class holds the global static variable LOG.\n */\nvar Log = function Log() \n{\n}\n\nexports.Log = Log;\n\n/**\n * LOG is the level for logging debugging statements.  0 means no log messages. \n * @type Number\n */\nLog.LOG = 0;\n\n})()\n},{}],85:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Tlv class has static type codes for the NDN-TLV wire format.\n * @constructor\n */\nvar Tlv = function Tlv()\n{\n}\n\nexports.Tlv = Tlv;\n\nTlv.Interest =         5;\nTlv.Data =             6;\nTlv.Name =             7;\nTlv.NameComponent =    8;\nTlv.Selectors =        9;\nTlv.Nonce =            10;\nTlv.Scope =            11;\nTlv.InterestLifetime = 12;\nTlv.MinSuffixComponents = 13;\nTlv.MaxSuffixComponents = 14;\nTlv.PublisherPublicKeyLocator = 15;\nTlv.Exclude =          16;\nTlv.ChildSelector =    17;\nTlv.MustBeFresh =      18;\nTlv.Any =              19;\nTlv.MetaInfo =         20;\nTlv.Content =          21;\nTlv.SignatureInfo =    22;\nTlv.SignatureValue =   23;\nTlv.ContentType =      24;\nTlv.FreshnessPeriod =  25;\nTlv.FinalBlockId =     26;\nTlv.SignatureType =    27;\nTlv.KeyLocator =       28;\nTlv.KeyLocatorDigest = 29;\nTlv.FaceInstance =     128;\nTlv.ForwardingEntry =  129;\nTlv.StatusResponse =   130;\nTlv.Action =           131;\nTlv.FaceID =           132;\nTlv.IPProto =          133;\nTlv.Host =             134;\nTlv.Port =             135;\nTlv.MulticastInterface = 136;\nTlv.MulticastTTL =     137;\nTlv.ForwardingFlags =  138;\nTlv.StatusCode =       139;\nTlv.StatusText =       140;\n\nTlv.SignatureType_DigestSha256 = 0;\nTlv.SignatureType_SignatureSha256WithRsa = 1;\n\n},{}],94:[function(require,module,exports){\nvar b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\nvar b64pad="=";\nvar BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction hex2b64(h) {\n  var i;\n  var c;\n  var ret = "";\n  for(i = 0; i+3 <= h.length; i+=3) {\n    c = parseInt(h.substring(i,i+3),16);\n    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n  }\n  if(i+1 == h.length) {\n    c = parseInt(h.substring(i,i+1),16);\n    ret += b64map.charAt(c << 2);\n  }\n  else if(i+2 == h.length) {\n    c = parseInt(h.substring(i,i+2),16);\n    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n  }\n  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n  return ret;\n}\n\n// convert a base64 string to hex\nfunction b64tohex(s) {\n  var ret = ""\n  var i;\n  var k = 0; // b64 state, 0-3\n  var slop;\n  for(i = 0; i < s.length; ++i) {\n    if(s.charAt(i) == b64pad) break;\n    v = b64map.indexOf(s.charAt(i));\n    if(v < 0) continue;\n    if(k == 0) {\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 1;\n    }\n    else if(k == 1) {\n      ret += int2char((slop << 2) | (v >> 4));\n      slop = v & 0xf;\n      k = 2;\n    }\n    else if(k == 2) {\n      ret += int2char(slop);\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 3;\n    }\n    else {\n      ret += int2char((slop << 2) | (v >> 4));\n      ret += int2char(v & 0xf);\n      k = 0;\n    }\n  }\n  if(k == 1)\n    ret += int2char(slop << 2);\n  return ret;\n}\n\n// convert a base64 string to a byte/number array\nfunction b64toBA(s) {\n  //piggyback on b64tohex for now, optimize later\n  var h = b64tohex(s);\n  var i;\n  var a = new Array();\n  for(i = 0; 2*i < h.length; ++i) {\n    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n  }\n  return a;\n}\n\nmodule.exports = {b64tohex: b64tohex, b64toBA: b64toBA, hex2b64: hex2b64};\n\n},{}],54:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DecodingException = require(\'../decoding-exception.js\').DecodingException;\n\n/**\n * Create a new TlvDecoder for decoding the input in the NDN-TLV wire format.\n * @constructor\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nvar TlvDecoder = function TlvDecoder(input)\n{\n  this.input = input;\n  this.offset = 0;\n};\n\nexports.TlvDecoder = TlvDecoder;\n\n/**\n * Decode VAR-NUMBER in NDN-TLV and return it. Update offset.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readVarNumber = function() \n{\n  // Assume array values are in the range 0 to 255.\n  var firstOctet = this.input[this.offset];\n  this.offset += 1;\n  if (firstOctet < 253)\n    return firstOctet;\n  else\n    return this.readExtendedVarNumber(firstOctet);\n};\n\n/**\n * A private function to do the work of readVarNumber, given the firstOctet\n * which is >= 253.\n * @param {number} firstOctet The first octet which is >= 253, used to decode \n * the remaining bytes.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readExtendedVarNumber = function(firstOctet) \n{\n  // This is a private function so we know firstOctet >= 253.\n  if (firstOctet == 253) {\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n    this.offset += 2;\n  }\n  else if (firstOctet == 254) {\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n    this.offset += 4;\n  }\n  else {\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n    this.offset += 8;\n  }\n  \n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType and return the length. Update offset.  Also make \n * sure the decoded length does not exceed the number of bytes remaining in the \n * input.\n * @param {number} expectedType The expected type.\n * @returns {number} The length of the TLV.\n * @throws DecodingException if (did not get the expected TLV type or the TLV length \n * exceeds the buffer length.\n */\nTlvDecoder.prototype.readTypeAndLength = function(expectedType) \n{\n  var type = this.readVarNumber();\n  if (type != expectedType)\n    throw new DecodingException("Did not get the expected TLV type");\n\n  var length = this.readVarNumber();\n  if (this.offset + length > this.input.length)\n    throw new DecodingException("TLV length exceeds the buffer length");\n\n  return length;\n};\n\n/**\n * Decode the type and length from the input starting at offset, expecting the \n * type to be expectedType.  Update offset.  Also make sure the decoded length \n * does not exceed the number of bytes remaining in the input. Return the offset \n * of the end of this parent TLV, which is used in decoding optional nested \n * TLVs. After reading all nested TLVs, call finishNestedTlvs.\n * @param {number} expectedType The expected type.\n * @returns {number} The offset of the end of the parent TLV.\n * @throws DecodingException if did not get the expected TLV type or the TLV \n * length exceeds the buffer length.\n */\nTlvDecoder.prototype.readNestedTlvsStart = function(expectedType) \n{\n  return this.readTypeAndLength(expectedType) + this.offset;\n};\n\n/**\n * Call this after reading all nested TLVs to skip any remaining unrecognized \n * TLVs and to check if the offset after the final nested TLV matches the \n * endOffset returned by readNestedTlvsStart.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @throws DecodingException if the TLV length does not equal the total length \n * of the nested TLVs.\n */\nTlvDecoder.prototype.finishNestedTlvs = function(endOffset) \n{\n  // We expect offset to be endOffset, so check this first.\n  if (this.offset == endOffset)\n    return;\n\n  // Skip remaining TLVs.\n  while (this.offset < endOffset) {\n    // Skip the type VAR-NUMBER.\n    this.readVarNumber();\n    // Read the length and update offset.\n    var length = this.readVarNumber();\n    this.offset += length;\n\n    if (this.offset > this.input.length)\n      throw new DecodingException("TLV length exceeds the buffer length");\n  }\n  \n  if (this.offset != endOffset)\n    throw new DecodingException\n      ("TLV length does not equal the total length of the nested TLVs");\n};\n\n/**\n * Decode the type from this\'s input starting at offset, and if it is the \n * expectedType, then return true, else false.  However, if this\'s offset is \n * greater than or equal to endOffset, then return false and don\'t try to read \n * the type. Do not update offset.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true if the type of the next TLV is the expectedType, \n *  otherwise false.\n */\nTlvDecoder.prototype.peekType = function(expectedType, endOffset) \n{\n  if (this.offset >= endOffset)\n    // No more sub TLVs to look at.\n    return false;\n  else {\n    var saveOffset = this.offset;\n    var type = this.readVarNumber();\n    // Restore offset.\n    this.offset = saveOffset;\n\n    return type == expectedType;\n  }\n};\n\n/**\n * Decode a non-negative integer in NDN-TLV and return it. Update offset by \n * length.\n * @param {number} length The number of bytes in the encoded integer.\n * @returns {number} The integer.\n * @throws DecodingException if length is an invalid length for a TLV \n * non-negative integer.\n */\nTlvDecoder.prototype.readNonNegativeInteger = function(length) \n{\n  var result;\n  if (length == 1)\n    result = this.input[this.offset];\n  else if (length == 2)\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n  else if (length == 4)\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n  else if (length == 8)\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n  else\n    throw new DecodingException("Invalid length for a TLV nonNegativeInteger");\n\n  this.offset += length;\n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then decode a non-negative integer in NDN-TLV \n * and return it.  Update offset.\n * @param {number} expectedType The expected type.\n * @returns {number} The integer.\n * @throws DecodingException if did not get the expected TLV type or can\'t \n * decode the value.\n */\nTlvDecoder.prototype.readNonNegativeIntegerTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  return this.readNonNegativeInteger(length);\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call \n * readNonNegativeIntegerTlv and return the integer.  Otherwise, return null.  \n * However, if this\'s offset is greater than or equal to endOffset, then return \n * null and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {number} The integer or null if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readOptionalNonNegativeIntegerTlv = function\n  (expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readNonNegativeIntegerTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then return an array of the bytes in the value.\n * Update offset.\n * @param {number} expectedType The expected type.\n * @returns {Buffer} The bytes in the value as a slice on the buffer.  This is\n * not a copy of the bytes in the input buffer.  If you need a copy, then you \n * must make a copy of the return value.\n * @throws DecodingException if did not get the expected TLV type.\n */\nTlvDecoder.prototype.readBlobTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  var result = this.input.slice(this.offset, this.offset + length);\n\n  // readTypeAndLength already checked if length exceeds the input buffer.\n  this.offset += length;\n  return result;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call readBlobTlv \n * and return the value.  Otherwise, return null. However, if this\'s offset is \n * greater than or equal to endOffset, then return null and don\'t try to read \n * the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {Buffer} The bytes in the value as a slice on the buffer or null if \n * the next TLV doesn\'t have the expected type.  This is not a copy of the bytes \n * in the input buffer.  If you need a copy, then you must make a copy of the \n * return value.\n */\nTlvDecoder.prototype.readOptionalBlobTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readBlobTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then read a type and \n * value, ignoring the value, and return true. Otherwise, return false.\n * However, if this\'s offset is greater than or equal to endOffset, then return \n * false and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true, or else false if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readBooleanTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset)) {\n    var length = this.readTypeAndLength(expectedType);\n    // We expect the length to be 0, but update offset anyway.\n    this.offset += length;\n    return true;\n  }\n  else\n    return false;\n};\n\n/**\n * Get the offset into the input, used for the next read.\n * @returns {number} The offset.\n */\nTlvDecoder.prototype.getOffset = function() \n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};  \n\n})()\n},{"../../buffer.js":28,"../decoding-exception.js":103}],69:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar crypto = require(\'../crypto.js\');\nvar Blob = require(\'../util/blob.js\').Blob;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvEncoder = require(\'./tlv/tlv-encoder.js\').TlvEncoder;\nvar TlvDecoder = require(\'./tlv/tlv-decoder.js\').TlvDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar ContentType = require(\'../meta-info.js\').ContentType;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Signature = require(\'../signature.js\').Signature;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\n\n/**\n * A Tlv0_1a2WireFormat implements the WireFormat interface for encoding and \n * decoding with the NDN-TLV wire format, version 0.1a2\n * @constructor\n */\nvar Tlv0_1a2WireFormat = function Tlv0_1a2WireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nTlv0_1a2WireFormat.prototype = new WireFormat();\nTlv0_1a2WireFormat.prototype.name = "Tlv0_1a2WireFormat";\n\nexports.Tlv0_1a2WireFormat = Tlv0_1a2WireFormat;\n\n// Default object.\nTlv0_1a2WireFormat.instance = null;\n\n/**\n * Encode the interest using NDN-TLV and return a customBuf.\n * @param {Interest} interest The Interest object to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nTlv0_1a2WireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new TlvEncoder();\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.InterestLifetime, interest.getInterestLifetimeMilliseconds());\n  encoder.writeOptionalNonNegativeIntegerTlv(Tlv.Scope, interest.getScope());\n  \n  // Encode the Nonce as 4 bytes.\n  if (interest.getNonce() == null || interest.getNonce().length == 0)\n    // This is the most common case. Generate a nonce.\n    encoder.writeBlobTlv(Tlv.Nonce, require("../crypto.js").randomBytes(4));\n  else if (interest.getNonce().length < 4) {\n    var nonce = customBuf(4);\n    // Copy existing nonce bytes.\n    interest.getNonce().copy(nonce);\n\n    // Generate random bytes for remaining bytes in the nonce.\n    for (var i = interest.getNonce().length; i < 4; ++i)\n      nonce[i] = require("crypto").randomBytes(1)[0];\n\n    encoder.writeBlobTlv(Tlv.Nonce, nonce);\n  }\n  else if (interest.getNonce().length == 4)\n    // Use the nonce as-is.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce());\n  else\n    // Truncate.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce().slice(0, 4));\n  \n  Tlv0_1a2WireFormat.encodeSelectors(interest, encoder);\n  Tlv0_1a2WireFormat.encodeName(interest.getName(), encoder);\n  \n  encoder.writeTypeAndLength(Tlv.Interest, encoder.getLength() - saveLength);\n      \n  return new Blob(encoder.getOutput(), false);\n};\n\n/**\n * Decode input as an NDN-TLV interest and set the fields of the interest \n * object.  \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nTlv0_1a2WireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Interest);\n  Tlv0_1a2WireFormat.decodeName(interest.getName(), decoder);\n  if (decoder.peekType(Tlv.Selectors, endOffset))\n    Tlv0_1a2WireFormat.decodeSelectors(interest, decoder);\n  // Require a Nonce, but don\'t force it to be 4 bytes.\n  var nonce = decoder.readBlobTlv(Tlv.Nonce);\n  interest.setScope(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.Scope, endOffset));\n  interest.setInterestLifetimeMilliseconds\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.InterestLifetime, endOffset));\n\n  // Set the nonce last because setting other interest fields clears it.\n  interest.setNonce(nonce);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode data as NDN-TLV and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nTlv0_1a2WireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new TlvEncoder(1500);\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  encoder.writeBlobTlv(Tlv.SignatureValue, data.getSignature().getSignature());\n  var signedPortionEndOffsetFromBack = encoder.getLength();\n\n  // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n  //   the key locator from the MetaInfo to the Signauture object.\n  Tlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue\n    (data.getSignature(), encoder, data.getSignatureOrMetaInfoKeyLocator());\n  encoder.writeBlobTlv(Tlv.Content, data.getContent());\n  Tlv0_1a2WireFormat.encodeMetaInfo(data.getMetaInfo(), encoder);\n  Tlv0_1a2WireFormat.encodeName(data.getName(), encoder);\n  var signedPortionBeginOffsetFromBack = encoder.getLength();\n\n  encoder.writeTypeAndLength(Tlv.Data, encoder.getLength() - saveLength);\n  var signedPortionBeginOffset = \n    encoder.getLength() - signedPortionBeginOffsetFromBack;\n  var signedPortionEndOffset = encoder.getLength() - signedPortionEndOffsetFromBack;\n\n  return { encoding: new Blob(encoder.getOutput(), false),\n           signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Decode input as an NDN-TLV data packet, set the fields in the data object, \n * and return the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nTlv0_1a2WireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Data);\n  var signedPortionBeginOffset = decoder.getOffset();\n\n  Tlv0_1a2WireFormat.decodeName(data.getName(), decoder);\n  Tlv0_1a2WireFormat.decodeMetaInfo(data.getMetaInfo(), decoder);\n  data.setContent(decoder.readBlobTlv(Tlv.Content));\n  Tlv0_1a2WireFormat.decodeSignatureInfo(data, decoder);\n  if (data.getSignature() != null && \n      data.getSignature().getKeyLocator() != null && \n      data.getMetaInfo() != null)\n    // Copy the key locator pointer to the MetaInfo object for the transition of \n    //   moving the key locator from the MetaInfo to the Signature object.\n    data.getMetaInfo().locator = data.getSignature().getKeyLocator();\n\n  var signedPortionEndOffset = decoder.getOffset();\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  data.getSignature().setSignature(decoder.readBlobTlv(Tlv.SignatureValue));\n\n  decoder.finishNestedTlvs(endOffset);\n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Get a singleton instance of a Tlv1_0a2WireFormat.  To always use the\n * preferred version NDN-TLV, you should use TlvWireFormat.get().\n * @returns {Tlv0_1a2WireFormat} The singleton instance.\n */\nTlv0_1a2WireFormat.get = function()\n{\n  if (Tlv0_1a2WireFormat.instance === null)\n    Tlv0_1a2WireFormat.instance = new Tlv0_1a2WireFormat();\n  return Tlv0_1a2WireFormat.instance;\n};\n\nTlv0_1a2WireFormat.encodeName = function(name, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode the components backwards.\n  for (var i = name.size() - 1; i >= 0; --i)\n    encoder.writeBlobTlv(Tlv.NameComponent, name.get(i).getValue());\n\n  encoder.writeTypeAndLength(Tlv.Name, encoder.getLength() - saveLength);\n};\n        \nTlv0_1a2WireFormat.decodeName = function(name, decoder)\n{\n  name.clear();\n  \n  var endOffset = decoder.readNestedTlvsStart(Tlv.Name);      \n  while (decoder.getOffset() < endOffset)\n      name.append(decoder.readBlobTlv(Tlv.NameComponent));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the interest selectors.  If no selectors are written, do not output a \n * Selectors TLV.\n */\nTlv0_1a2WireFormat.encodeSelectors = function(interest, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (interest.getMustBeFresh())\n    encoder.writeTypeAndLength(Tlv.MustBeFresh, 0);\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.ChildSelector, interest.getChildSelector());\n  if (interest.getExclude().size() > 0)\n    Tlv0_1a2WireFormat.encodeExclude(interest.getExclude(), encoder);\n  \n  if (interest.getKeyLocator().getType() != null)\n    Tlv0_1a2WireFormat.encodeKeyLocator(interest.getKeyLocator(), encoder);\n  else {\n    // There is no keyLocator. If there is a publisherPublicKeyDigest, then \n    //   encode as KEY_LOCATOR_DIGEST. (When we remove the deprecated \n    //   publisherPublicKeyDigest, we don\'t need this.)\n    if (null != interest.publisherPublicKeyDigest) {\n      var savePublisherPublicKeyDigestLength = encoder.getLength();\n      encoder.writeBlobTlv\n        (Tlv.KeyLocatorDigest, \n         interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n      encoder.writeTypeAndLength\n        (Tlv.KeyLocator, encoder.getLength() - savePublisherPublicKeyDigestLength);\n    }\n  }\n  \n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MaxSuffixComponents, interest.getMaxSuffixComponents());\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MinSuffixComponents, interest.getMinSuffixComponents());\n\n  // Only output the type and length if values were written.\n  if (encoder.getLength() != saveLength)\n    encoder.writeTypeAndLength(Tlv.Selectors, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSelectors = function(interest, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Selectors);\n\n  interest.setMinSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MinSuffixComponents, endOffset));\n  interest.setMaxSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MaxSuffixComponents, endOffset));\n\n  // Initially set publisherPublicKeyDigest to none.\n  interest.publisherPublicKeyDigest = null;\n  if (decoder.peekType(Tlv.KeyLocator, endOffset)) {\n    Tlv0_1a2WireFormat.decodeKeyLocator(interest.getKeyLocator(), decoder);\n    if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST) {\n      // For backwards compatibility, also set the publisherPublicKeyDigest.\n      interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest =\n        interest.getKeyLocator().getKeyData();\n    }\n  }\n  else\n    interest.getKeyLocator().clear();\n\n  if (decoder.peekType(Tlv.Exclude, endOffset))\n    Tlv0_1a2WireFormat.decodeExclude(interest.getExclude(), decoder);\n  else\n    interest.getExclude().clear();\n\n  interest.setChildSelector(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ChildSelector, endOffset));\n  interest.setMustBeFresh(decoder.readBooleanTlv(Tlv.MustBeFresh, endOffset));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n  \nTlv0_1a2WireFormat.encodeExclude = function(exclude, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // TODO: Do we want to order the components (except for ANY)?\n  // Encode the entries backwards.\n  for (var i = exclude.size() - 1; i >= 0; --i) {\n    var entry = exclude.get(i);\n\n    if (entry == Exclude.ANY)\n      encoder.writeTypeAndLength(Tlv.Any, 0);\n    else\n      encoder.writeBlobTlv(Tlv.NameComponent, entry.getValue());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.Exclude, encoder.getLength() - saveLength);\n};\n  \nTlv0_1a2WireFormat.decodeExclude = function(exclude, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Exclude);\n\n  exclude.clear();\n  while (true) {\n    if (decoder.peekType(Tlv.NameComponent, endOffset))\n      exclude.appendComponent(decoder.readBlobTlv(Tlv.NameComponent));\n    else if (decoder.readBooleanTlv(Tlv.Any, endOffset))\n      exclude.appendAny();\n    else\n      // Else no more entries.\n      break;\n  }\n  \n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeKeyLocator = function(keyLocator, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (keyLocator.getType() != null) {\n    if (keyLocator.getType() == KeyLocatorType.KEYNAME)\n      Tlv0_1a2WireFormat.encodeName(keyLocator.getKeyName(), encoder);\n    else if (keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST &&\n             keyLocator.getKeyData().length > 0)\n      encoder.writeBlobTlv(Tlv.KeyLocatorDigest, keyLocator.getKeyData());\n    else\n      throw new Error("Unrecognized KeyLocatorType " + keyLocator.getType());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.KeyLocator, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeKeyLocator = function(keyLocator, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.KeyLocator);\n\n  keyLocator.clear();\n\n  if (decoder.getOffset() == endOffset)\n    // The KeyLocator is omitted, so leave the fields as none.\n    return;\n\n  if (decoder.peekType(Tlv.Name, endOffset)) {\n    // KeyLocator is a Name.\n    keyLocator.setType(KeyLocatorType.KEYNAME);\n    Tlv0_1a2WireFormat.decodeName(keyLocator.getKeyName(), decoder);\n  }\n  else if (decoder.peekType(Tlv.KeyLocatorDigest, endOffset)) {\n    // KeyLocator is a KeyLocatorDigest.\n    keyLocator.setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    keyLocator.setKeyData(decoder.readBlobTlv(Tlv.KeyLocatorDigest));\n  }\n  else\n    throw new DecodingException\n      ("decodeKeyLocator: Unrecognized key locator type");\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the signature object in TLV, using the given keyLocator instead of the\n * locator in this object.\n * @param {Signature} signature The Signature object to encode.\n * @param {TlvEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nTlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue = function\n  (signature, encoder, keyLocator)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  Tlv0_1a2WireFormat.encodeKeyLocator(keyLocator, encoder);\n  encoder.writeNonNegativeIntegerTlv\n    (Tlv.SignatureType, Tlv.SignatureType_SignatureSha256WithRsa);\n\n  encoder.writeTypeAndLength(Tlv.SignatureInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSignatureInfo = function(data, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.SignatureInfo);\n\n  var signatureType = decoder.readNonNegativeIntegerTlv(Tlv.SignatureType);\n  // TODO: The library needs to handle other signature types than \n  //     SignatureSha256WithRsa.\n  if (signatureType == Tlv.SignatureType_SignatureSha256WithRsa) {\n      var signature = {}\n      signature.sig = Signature\n      data.setSignature(signature.sig());\n      // Modify data\'s signature object because if we create an object\n      //   and set it, then data will have to copy all the fields.\n      var signatureInfo = data.getSignature();\n      Tlv0_1a2WireFormat.decodeKeyLocator\n        (signatureInfo.getKeyLocator(), decoder);\n  }\n  else\n      throw new DecodingException\n       ("decodeSignatureInfo: unrecognized SignatureInfo type" + signatureType);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeMetaInfo = function(metaInfo, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  var finalBlockIdBuf = metaInfo.getFinalBlockID();\n  if (finalBlockIdBuf != null && finalBlockIdBuf.length > 0) {\n    // FinalBlockId has an inner NameComponent.\n    var finalBlockIdSaveLength = encoder.getLength();\n    encoder.writeBlobTlv(Tlv.NameComponent, finalBlockIdBuf);\n    encoder.writeTypeAndLength\n      (Tlv.FinalBlockId, encoder.getLength() - finalBlockIdSaveLength);\n  }\n\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.FreshnessPeriod, metaInfo.getFreshnessPeriod());\n  if (metaInfo.getType() != ContentType.BLOB) {\n    // Not the default, so we need to encode the type.\n    if (metaInfo.getType() == ContentType.LINK ||\n        metaInfo.getType() == ContentType.KEY)\n      // The ContentType enum is set up with the correct integer for \n      // each NDN-TLV ContentType.\n      encoder.writeNonNegativeIntegerTlv(Tlv.ContentType, metaInfo.getType());\n    else\n      throw new Error("unrecognized TLV ContentType");\n  }\n\n  encoder.writeTypeAndLength(Tlv.MetaInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeMetaInfo = function(metaInfo, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.MetaInfo);  \n\n  // The ContentType enum is set up with the correct integer for each \n  // NDN-TLV ContentType.  If readOptionalNonNegativeIntegerTlv returns\n  // None, then setType will convert it to BLOB.\n  metaInfo.setType(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ContentType, endOffset));\n  metaInfo.setFreshnessPeriod\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.FreshnessPeriod, endOffset));\n  if (decoder.peekType(Tlv.FinalBlockId, endOffset)) {\n    var finalBlockIdEndOffset = decoder.readNestedTlvsStart(Tlv.FinalBlockId);\n    metaInfo.setFinalBlockID(decoder.readBlobTlv(Tlv.NameComponent));\n    decoder.finishNestedTlvs(finalBlockIdEndOffset);\n  }\n  else\n    metaInfo.setFinalBlockID(null);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n})()\n},{"../crypto.js":28,"../exclude.js":12,"../key-locator.js":16,"../meta-info.js":14,"../signature.js":63,"../util/blob.js":23,"./decoding-exception.js":103,"./tlv/tlv-decoder.js":54,"./tlv/tlv-encoder.js":105,"./tlv/tlv.js":53,"./wire-format.js":18,"crypto":51}],71:[function(require,module,exports){\n/**\n * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to \n * determine its end.\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\n\nvar XML_EXT = 0x00; \nvar XML_TAG = 0x01; \nvar XML_DTAG = 0x02; \nvar XML_ATTR = 0x03; \nvar XML_DATTR = 0x04; \nvar XML_BLOB = 0x05; \nvar XML_UDATA = 0x06;   \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\n\n/**\n * @constructor\n */\nvar BinaryXMLStructureDecoder = function BinaryXMLDecoder() \n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.level = 0;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.headerBuffer = new DynamicBuffer(5);\n  this.nBytesToRead = 0;\n};\n\nexports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;\n\nBinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;\nBinaryXMLStructureDecoder.READ_BYTES = 1;\n\n/**\n * Continue scanning input starting from this.offset.  If found the end of the element\n *   which started at offset 0 then return true, else false.\n * If this returns false, you should read more into input and call again.\n * You have to pass in input each time because the array could be reallocated.\n * This throws an exception for badly formed ndnb.\n */\nBinaryXMLStructureDecoder.prototype.findElementEnd = function(\n  // customBuf\n  input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new BinaryXMLDecoder(input);\n  \n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input.\n      return false;\n  \n    switch (this.state) {\n      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:               \n        // First check for XML_CLOSE.\n        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {\n          ++this.offset;\n          // Close the level.\n          --this.level;\n          if (this.level == 0) {\n            // Finished.\n            this.gotElementEnd = true;\n            return true;\n          }\n          if (this.level < 0)\n            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));\n              \n          // Get ready for the next header.\n          this.startHeader();\n          break;\n        }\n        \n        var startingHeaderLength = this.headerLength;\n        while (true) {\n          if (this.offset >= input.length) {\n            // We can\'t get all of the header bytes from this input. Save in headerBuffer.\n            this.useHeaderBuffer = true;\n            var nNewBytes = this.headerLength - startingHeaderLength;\n            this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n              \n            return false;\n          }\n          var headerByte = input[this.offset++];\n          ++this.headerLength;\n          if (headerByte & XML_TT_NO_MORE)\n            // Break and read the header.\n            break;\n        }\n        \n        var typeAndVal;\n        if (this.useHeaderBuffer) {\n          // Copy the remaining bytes into headerBuffer.\n          nNewBytes = this.headerLength - startingHeaderLength;\n          this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();\n        }\n        else {\n          // We didn\'t have to use the headerBuffer.\n          decoder.seek(this.offset - this.headerLength);\n          typeAndVal = decoder.decodeTypeAndVal();\n        }\n        \n        if (typeAndVal == null)\n          throw new Error("BinaryXMLStructureDecoder: Can\'t read header starting at offset " +\n                          (this.offset - this.headerLength));\n        \n        // Set the next state based on the type.\n        var type = typeAndVal.t;\n        if (type == XML_DATTR)\n          // We already consumed the item. READ_HEADER_OR_CLOSE again.\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n          this.startHeader();\n        else if (type == XML_DTAG || type == XML_EXT) {\n          // Start a new level and READ_HEADER_OR_CLOSE again.\n          ++this.level;\n          this.startHeader();\n        }\n        else if (type == XML_TAG || type == XML_ATTR) {\n          if (type == XML_TAG)\n            // Start a new level and read the tag.\n            ++this.level;\n          // Minimum tag or attribute length is 1.\n          this.nBytesToRead = typeAndVal.v + 1;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n        }\n        else if (type == XML_BLOB || type == XML_UDATA) {\n          this.nBytesToRead = typeAndVal.v;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n        }\n        else\n          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);\n        break;\n    \n      case BinaryXMLStructureDecoder.READ_BYTES:\n        var nRemainingBytes = input.length - this.offset;\n        if (nRemainingBytes < this.nBytesToRead) {\n          // Need more.\n          this.offset += nRemainingBytes;\n          this.nBytesToRead -= nRemainingBytes;\n          return false;\n        }\n        // Got the bytes.  Read a new header or close.\n        this.offset += this.nBytesToRead;\n        this.startHeader();\n        break;\n    \n      default:\n        // We don\'t expect this to happen.\n        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);\n    }\n  }\n};\n\n/**\n * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header\n */\nBinaryXMLStructureDecoder.prototype.startHeader = function() \n{\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;    \n};\n\n/**\n *  Set the offset into the input, used for the next read.\n */\nBinaryXMLStructureDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n},{"../util/dynamic-buffer.js":104,"./binary-xml-decoder.js":55}],72:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar TlvDecoder = require(\'./tlv-decoder.js\').TlvDecoder;\nvar customBuf = require(\'../../buffer.js\').Buffer\n/**\n * Create and initialize a TlvStructureDecoder.\n */\nvar TlvStructureDecoder = function TlvStructureDecoder()\n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.state = TlvStructureDecoder.READ_TYPE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  // 8 bytes is enough to hold the extended bytes in the length encoding \n  // where it is an 8-byte number.\n  this.headerBuffer = new customBuf(8);\n  this.nBytesToRead = 0;\n};\n\nexports.TlvStructureDecoder = TlvStructureDecoder;\n\nTlvStructureDecoder.READ_TYPE =         0;\nTlvStructureDecoder.READ_TYPE_BYTES =   1;\nTlvStructureDecoder.READ_LENGTH =       2;\nTlvStructureDecoder.READ_LENGTH_BYTES = 3;\nTlvStructureDecoder.READ_VALUE_BYTES =  4;\n\n/**\n * Continue scanning input starting from this.offset to find the element end.  \n * If the end of the element which started at offset 0 is found, this returns \n * true and getOffset() is the length of the element.  Otherwise, this returns \n * false which means you should read more into input and call again.\n * @param {Buffer} input The input buffer. You have to pass in input each time\n * because the buffer could be reallocated.\n * @returns {boolean} true if found the element end, false if not.\n */\nTlvStructureDecoder.prototype.findElementEnd = function(input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new TlvDecoder(input);\n\n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input. Return and wait for more.\n      return false;\n\n    if (this.state == TlvStructureDecoder.READ_TYPE) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253)\n        // The value is simple, so we can skip straight to reading the length.\n        this.state = TlvStructureDecoder.READ_LENGTH;\n      else {\n        // Set up to skip the type bytes.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        this.state = TlvStructureDecoder.READ_TYPE_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_TYPE_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the type bytes. Move on to read the length.\n      this.offset += this.nBytesToRead;\n      this.state = TlvStructureDecoder.READ_LENGTH;\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253) {\n        // The value is simple, so we can skip straight to reading \n        //  the value bytes.\n        this.nBytesToRead = firstOctet;\n        if (this.nBytesToRead == 0) {\n          // No value bytes to read. We\'re finished.\n          this.gotElementEnd = true;\n          return true;\n        }\n\n        this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n      }\n      else {\n        // We need to read the bytes in the extended encoding of \n        //  the length.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        // We need to use firstOctet in the next state.\n        this.firstOctet = firstOctet;\n        this.state = TlvStructureDecoder.READ_LENGTH_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (!this.useHeaderBuffer && nRemainingBytes >= this.nBytesToRead) {\n        // We don\'t have to use the headerBuffer. Set nBytesToRead.\n        decoder.seek(this.offset);\n\n        this.nBytesToRead = decoder.readExtendedVarNumber(this.firstOctet);\n        // Update this.offset to the decoder\'s offset after reading.\n        this.offset = decoder.getOffset();\n      }\n      else {\n        this.useHeaderBuffer = true;\n\n        var nNeededBytes = this.nBytesToRead - this.headerLength;\n        if (nNeededBytes > nRemainingBytes) {\n          // We can\'t get all of the header bytes from this input. \n          // Save in headerBuffer.\n          if (this.headerLength + nRemainingBytes > this.headerBuffer.length)\n            // We don\'t expect this to happen.\n            throw new Error\n              ("Cannot store more header bytes than the size of headerBuffer");\n          input.slice(this.offset, this.offset + nRemainingBytes).copy\n            (this.headerBuffer, this.headerLength);\n          this.offset += nRemainingBytes;\n          this.headerLength += nRemainingBytes;\n\n          return false;\n        }\n\n        // Copy the remaining bytes into headerBuffer, read the \n        //   length and set nBytesToRead.\n        if (this.headerLength + nNeededBytes > this.headerBuffer.length)\n          // We don\'t expect this to happen.\n          throw new Error\n            ("Cannot store more header bytes than the size of headerBuffer");\n        input.slice(this.offset, this.offset + nNeededBytes).copy\n          (this.headerBuffer, this.headerLength);\n        this.offset += nNeededBytes;\n\n        // Use a local decoder just for the headerBuffer.\n        var bufferDecoder = new TlvDecoder(this.headerBuffer);\n        // Replace nBytesToRead with the length of the value.\n        this.nBytesToRead = bufferDecoder.readExtendedVarNumber(this.firstOctet);\n      }\n      \n      if (this.nBytesToRead == 0) {\n        // No value bytes to read. We\'re finished.\n        this.gotElementEnd = true;\n        return true;\n      }\n\n      // Get ready to read the value bytes.\n      this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n    }\n    else if (this.state == TlvStructureDecoder.READ_VALUE_BYTES) {\n      nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the bytes. We\'re finished.\n      this.offset += this.nBytesToRead;\n      this.gotElementEnd = true;\n      return true;\n    }\n    else\n      // We don\'t expect this to happen.\n      throw new Error("findElementEnd: unrecognized state");\n  }\n};\n\n/**\n * Get the current offset into the input buffer.\n * @returns {number} The offset.\n */\nTlvStructureDecoder.prototype.getOffset = function()\n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvStructureDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n\n})()\n},{"../../buffer.js":28,"./tlv-decoder.js":54}],76:[function(require,module,exports){\n\n/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar helpers = require(\'./helpers\');\n\nvar safe_add = function(x, y) {\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n};\n\nvar S = function(X, n) {\n  return (X >>> n) | (X << (32 - n));\n};\n\nvar R = function(X, n) {\n  return (X >>> n);\n};\n\nvar Ch = function(x, y, z) {\n  return ((x & y) ^ ((~x) & z));\n};\n\nvar Maj = function(x, y, z) {\n  return ((x & y) ^ (x & z) ^ (y & z));\n};\n\nvar Sigma0256 = function(x) {\n  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n};\n\nvar Sigma1256 = function(x) {\n  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n};\n\nvar Gamma0256 = function(x) {\n  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n};\n\nvar Gamma1256 = function(x) {\n  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n};\n\nvar core_sha256 = function(m, l) {\n  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);\n  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);\n    var W = new Array(64);\n    var a, b, c, d, e, f, g, h, i, j;\n    var T1, T2;\n  /* append padding */\n  m[l >> 5] |= 0x80 << (24 - l % 32);\n  m[((l + 64 >> 9) << 4) + 15] = l;\n  for (var i = 0; i < m.length; i += 16) {\n    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];\n    for (var j = 0; j < 64; j++) {\n      if (j < 16) {\n        W[j] = m[j + i];\n      } else {\n        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);\n      }\n      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);\n      T2 = safe_add(Sigma0256(a), Maj(a, b, c));\n      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);\n    }\n    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);\n    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);\n  }\n  return HASH;\n};\n\nmodule.exports = function sha256(buf) {\n  return helpers.hash(buf, core_sha256, 32, true);\n};\n\n},{"./helpers":106}],75:[function(require,module,exports){\n/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar helpers = require(\'./helpers\');\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function sha1(buf) {\n  return helpers.hash(buf, core_sha1, 20, true);\n};\n\n},{"./helpers":106}],78:[function(require,module,exports){\n/*\r\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\r\n * Digest Algorithm, as defined in RFC 1321.\r\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for more info.\r\n */\r\n\r\nvar helpers = require(\'./helpers\');\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nfunction md5_vm_test()\r\n{\r\n  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";\r\n}\r\n\r\n/*\r\n * Calculate the MD5 of an array of little-endian words, and a bit length\r\n */\r\nfunction core_md5(x, len)\r\n{\r\n  /* append padding */\r\n  x[len >> 5] |= 0x80 << ((len) % 32);\r\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\r\n\r\n  var a =  1732584193;\r\n  var b = -271733879;\r\n  var c = -1732584194;\r\n  var d =  271733878;\r\n\r\n  for(var i = 0; i < x.length; i += 16)\r\n  {\r\n    var olda = a;\r\n    var oldb = b;\r\n    var oldc = c;\r\n    var oldd = d;\r\n\r\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\r\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\r\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\r\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\r\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\r\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\r\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\r\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\r\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\r\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\r\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\r\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\r\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\r\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\r\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\r\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\r\n\r\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\r\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\r\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\r\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\r\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\r\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\r\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\r\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\r\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\r\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\r\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\r\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\r\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\r\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\r\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\r\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\r\n\r\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\r\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\r\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\r\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\r\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\r\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\r\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\r\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\r\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\r\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\r\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\r\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\r\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\r\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\r\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\r\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\r\n\r\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\r\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\r\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\r\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\r\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\r\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\r\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\r\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\r\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\r\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\r\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\r\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\r\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\r\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\r\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\r\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\r\n\r\n    a = safe_add(a, olda);\r\n    b = safe_add(b, oldb);\r\n    c = safe_add(c, oldc);\r\n    d = safe_add(d, oldd);\r\n  }\r\n  return Array(a, b, c, d);\r\n\r\n}\r\n\r\n/*\r\n * These functions implement the four basic operations the algorithm uses.\r\n */\r\nfunction md5_cmn(q, a, b, x, s, t)\r\n{\r\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\r\n}\r\nfunction md5_ff(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\r\n}\r\nfunction md5_gg(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\r\n}\r\nfunction md5_hh(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\r\n}\r\nfunction md5_ii(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y)\r\n{\r\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n  return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction bit_rol(num, cnt)\r\n{\r\n  return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\nmodule.exports = function md5(buf) {\r\n  return helpers.hash(buf, core_md5, 16);\r\n};\r\n\n},{"./helpers":106}],102:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],103:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * Create a new DecodingException wrapping the given error object.\n * Call with: throw new DecodingException(new Error("message")).\n * @constructor\n * @param {string} error The exception created with new Error.\n */\nfunction DecodingException(error) \n{\n  this.message = error.message;\n  // Copy lineNumber, etc. from where new Error was called.\n  for (var prop in error)\n      this[prop] = error[prop];\n}\nDecodingException.prototype = new Error();\nDecodingException.prototype.name = "DecodingException";\n\nexports.DecodingException = DecodingException;\n\n},{}],84:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Forwarding Entries\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar Name = require(\'./name.js\').Name;\n\n/**\n * Create a new ForwardingEntry with the optional arguments.\n * @constructor\n * @param {String} action\n * @param {Name} prefixName\n * @param {PublisherPublicKeyDigest} ndndId\n * @param {number} faceID\n * @param {number} flags\n * @param {number} lifetime in seconds\n */\nvar ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime) \n{\n  this.action = action;\n  this.prefixName = prefixName;\n  this.ndndID = ndndId;\n  this.faceID = faceID;\n  this.flags = flags;\n  this.lifetime = lifetime;\n};\n\nexports.ForwardingEntry = ForwardingEntry;\n\nForwardingEntry.ACTIVE         = 1;\nForwardingEntry.CHILD_INHERIT  = 2;\nForwardingEntry.ADVERTISE      = 4;\nForwardingEntry.LAST           = 8;\nForwardingEntry.CAPTURE       = 16;\nForwardingEntry.LOCAL         = 32;\nForwardingEntry.TAP           = 64;\nForwardingEntry.CAPTURE_OK   = 128;\n\nForwardingEntry.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n  //throws DecodingException\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action); \n  if (decoder.peekDTag(NDNProtocolDTags.Name)) {\n    this.prefixName = new Name();\n    this.prefixName.from_ndnb(decoder) ;\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.NdndId = new PublisherPublicKeyDigest();\n    this.NdndId.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID); \n  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))\n    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\nForwardingEntry.prototype.to_ndnb = function(\n  //XMLEncoder \n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.prefixName)\n    this.prefixName.to_ndnb(encoder);\n  if (null != this.NdndId)\n    this.NdndId.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.flags)\n    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);\n  if (null != this.lifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);\n\n  encoder.writeElementClose();         \n};\n\nForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }\n\n},{"./name.js":31,"./publisher-public-key-digest.js":39,"./util/ndn-protoco-id-tags.js":82}],87:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.\nexports.TcpTransport = require(\'./transport/web-socket-transport.js\').WebSocketTransport;\n\n},{"./transport/web-socket-transport.js":107}],88:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Publisher and PublisherType Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNProtocolDTagsStrings = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTagsStrings;\nvar DecodingException = require(\'./encoding/decoding-exception.js\').DecodingException;\n\n/**\n * @constructor\n */\nvar PublisherType = function PublisherType(tag) \n{\n  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;\n  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;\n  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;\n  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  this.Tag = tag;\n}; \n\n/**\n * @constructor\n */\nvar PublisherID = function PublisherID() \n{\n  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";\n  this.PUBLISHER_ID_LEN = 256/8;\n    \n  //TODO, implement publisherID creation and key creation\n\n  //TODO implement generatePublicKeyDigest\n  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray\n    \n  //TODO implement generate key\n  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);\n  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type   \n};\n\nexports.PublisherID = PublisherID;\n\nPublisherID.prototype.from_ndnb = function(decoder) \n{    \n  // We have a choice here of one of 4 binary element types.\n  var nextTag = PublisherID.peekAndGetNextDTag(decoder);\n    \n  this.publisherType = new PublisherType(nextTag); \n    \n  if (nextTag < 0)\n    throw new Error("Invalid publisher ID, got unexpected type");\n\n  this.publisherID = decoder.readBinaryDTagElement(nextTag);\n  if (null == this.publisherID)\n    throw new DecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));\n};\n\nPublisherID.prototype.to_ndnb = function(encoder) \n{\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);\n};\n\n/**\n * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.\n * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.\n * @returns {number} The PublisherID DTag or -1 if it is not one of them.\n */\nPublisherID.peekAndGetNextDTag = function(decoder) \n{\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))\n    return             NDNProtocolDTags.PublisherPublicKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))\n    return             NDNProtocolDTags.PublisherCertificateDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))\n    return             NDNProtocolDTags.PublisherIssuerKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))\n    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;\n  \n  return -1;\n};\n  \nPublisherID.peek = function(/* XMLDecoder */ decoder) \n{\n  return PublisherID.peekAndGetNextDTag(decoder) >= 0;\n};\n\nPublisherID.prototype.getElementLabel = function()\n{ \n  return this.publisherType.Tag;\n};\n\nPublisherID.prototype.validate = function() \n{\n  return null != id() && null != type();\n};\n\n},{"./encoding/decoding-exception.js":108,"./util/ndn-protoco-id-tags.js":82}],90:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data Signature object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Signature with the optional values.\n * @constructor\n */\nvar Signature = function Signature(witnessOrSignatureObject, signature, digestAlgorithm) \n{\n  if (typeof witnessOrSignatureObject === \'object\' && \n      witnessOrSignatureObject instanceof Signature) {\n    // Copy the values.\n    this.keyLocator = new KeyLocator(witnessOrSignatureObject.keyLocator);\n    this.signature = witnessOrSignatureObject.signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject.witness;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = witnessOrSignatureObject.digestAlgorithm;\n  }\n  else {\n    this.keyLocator = new KeyLocator();\n    this.signature = signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = digestAlgorithm;\n  }\n};\n\nexports.Signature = Signature;\n\n/**\n * Create a new Signature which is a copy of this object.\n * @returns {Signature} A new object which is a copy of this object.\n */\nSignature.prototype.clone = function()\n{\n  return new Signature(this);\n};\n\n/**\n * Get the key locator.\n * @returns {KeyLocator} The key locator.\n */\nSignature.prototype.getKeyLocator = function()\n{\n  return this.keyLocator;\n};\n\n/**\n * Get the data packet\'s signature bytes.\n * @returns {Buffer} The signature bytes.\n */\nSignature.prototype.getSignature = function()\n{\n  return this.signature;\n};\n\n/**\n * Set the key locator to a copy of the given keyLocator.\n * @param {KeyLocator} keyLocator The KeyLocator to copy.\n */\nSignature.prototype.setKeyLocator = function(keyLocator)\n{\n  this.keyLocator = typeof keyLocator === \'object\' && keyLocator instanceof KeyLocator ?\n                    new KeyLocator(keyLocator) : new KeyLocator();\n};\n  \n/**\n * Set the data packet\'s signature bytes.\n * @param {type} signature\n */\nSignature.prototype.setSignature = function(signature)\n{\n  if (signature == null)\n    this.signature = null;\n  else if (typeof signature === \'object\' && signature instanceof Blob)\n    this.signature = new customBuf(signature.buf());\n  else\n    this.signature = new customBuf(signature);\n};\n\nSignature.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'STARTED DECODING SIGNATURE\');\n    \n  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {\n    if (LOG > 4) console.log(\'DIGIEST ALGORITHM FOUND\');\n    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm); \n  }\n  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {\n    if (LOG > 4) console.log(\'WITNESS FOUND\');\n    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness); \n  }\n    \n  //FORCE TO READ A SIGNATURE\n\n  if (LOG > 4) console.log(\'SIGNATURE FOUND\');\n  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);\n\n  decoder.readElementClose();\n};\n\nSignature.prototype.to_ndnb = function(encoder) \n{      \n  if (!this.validate())\n    throw new Error("Cannot encode: field values missing.");\n  \n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))\n    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));\n  \n  if (null != this.witness)\n    // needs to handle null witness\n    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);\n\n  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);\n\n  encoder.writeElementClose();       \n};\n\nSignature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };\n\nSignature.prototype.validate = function() \n{\n  return null != this.signature;\n};\n\n})()\n},{"./buffer.js":50,"./encoding/binary-xml-decoder.js":81,"./encoding/binary-xml-encoder.js":80,"./key-locator.js":38,"./log.js":83,"./util/blob.js":45,"./util/ndn-protoco-id-tags.js":82}],106:[function(require,module,exports){\n(function(){var Buffer = require(\'buffer\').Buffer;\nvar intSize = 4;\nvar zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);\nvar chrsz = 8;\n\nfunction toArray(buf, bigEndian) {\n  if ((buf.length % intSize) !== 0) {\n    var len = buf.length + (intSize - (buf.length % intSize));\n    buf = Buffer.concat([buf, zeroBuffer], len);\n  }\n\n  var arr = [];\n  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n  for (var i = 0; i < buf.length; i += intSize) {\n    arr.push(fn.call(buf, i));\n  }\n  return arr;\n}\n\nfunction toBuffer(arr, size, bigEndian) {\n  var buf = new Buffer(size);\n  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n  for (var i = 0; i < arr.length; i++) {\n    fn.call(buf, arr[i], i * 4, true);\n  }\n  return buf;\n}\n\nfunction hash(buf, fn, hashSize, bigEndian) {\n  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);\n  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);\n  return toBuffer(arr, hashSize, bigEndian);\n}\n\nmodule.exports = { hash: hash };\n\n})()\n},{"buffer":61}],80:[function(require,module,exports){\n(function(){/**\n * This class is used to encode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n/**\n * @constructor\n */\nvar BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength) \n{\n  if (!initiaLength)\n    initiaLength = 16;\n  \n  this.ostream = new DynamicBuffer(initiaLength);\n  this.offset = 0;\n  this.CODEC_NAME = "Binary";\n};\n\nexports.BinaryXMLEncoder = BinaryXMLEncoder;\n\n/**\n * Encode utf8Content as utf8 and write to the output buffer as a UDATA.\n * @param {string} utf8Content The string to convert to utf8.\n */\nBinaryXMLEncoder.prototype.writeUString = function(utf8Content) \n{\n  this.encodeUString(utf8Content, XML_UDATA);\n};\n\nBinaryXMLEncoder.prototype.writeBlob = function(\n    /*Buffer*/ binaryContent) \n{  \n  if (LOG >3) console.log(binaryContent);\n  \n  this.encodeBlob(binaryContent, binaryContent.length);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer.\n * @param {number} tag The DTAG tag.\n */\nBinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)\n{\n  this.encodeTypeAndVal(XML_DTAG, tag);\n};\n\n/**\n * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeStartElement = function(\n  /*String*/ tag, \n  /*TreeMap<String,String>*/ attributes) \n{\n  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);\n  \n  if (null == dictionaryVal)\n    this.encodeUString(tag, XML_TAG);\n  else\n    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);\n  \n  if (null != attributes)\n    this.writeAttributes(attributes); \n};\n\n/**\n * Write an element close to the output buffer.\n */\nBinaryXMLEncoder.prototype.writeElementClose = function() \n{\n  this.ostream.ensureLength(this.offset + 1);\n  this.ostream.array[this.offset] = XML_CLOSE;\n  this.offset += 1;\n};\n\n/**\n * @deprecated Use writeElementClose.\n */\nBinaryXMLEncoder.prototype.writeEndElement = function() \n{\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes) \n{\n  if (null == attributes)\n    return;\n\n  // the keySet of a TreeMap is sorted.\n\n  for (var i = 0; i< attributes.length;i++) {\n    var strAttr = attributes[i].k;\n    var strValue = attributes[i].v;\n\n    var dictionaryAttr = stringToTag(strAttr);\n    if (null == dictionaryAttr)\n      // not in dictionary, encode as attr\n      // compressed format wants length of tag represented as length-1\n      // to save that extra bit, as tag cannot be 0 length.\n      // encodeUString knows to do that.\n      this.encodeUString(strAttr, XML_ATTR);\n    else\n      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);\n\n    // Write value\n    this.encodeUString(strValue);    \n  }\n};\n\n//returns a string\nstringToTag = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)\n    return NDNProtocolDTagsStrings[tagVal];\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  \n  return null;\n};\n\n//returns a Long\ntagToString =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  \n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n\n  return null;\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the content as explained below, \n * then an element close.\n * @param {number} tag The DTAG tag.\n * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,\n * call writeUString.  Otherwise, call writeBlob.\n */\nBinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)\n{\n  this.writeElementStartDTag(tag);\n  \n  if (typeof content === \'number\')\n    this.writeUString(content.toString());\n  else if (typeof content === \'string\')\n    this.writeUString(content);\n  else\n    this.writeBlob(content);\n  \n  this.writeElementClose();\n};\n\n/**\n * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n * If Content is a string, then encode as utf8 and write UDATA.\n */\nBinaryXMLEncoder.prototype.writeElement = function(\n    //long \n    tag, \n    //byte[] \n    Content,\n    //TreeMap<String, String> \n    attributes) \n{\n  this.writeStartElement(tag, attributes);\n  // Will omit if 0-length\n  \n  if (typeof Content === \'number\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER .charCodeAt(0) \' + Content.toString().charCodeAt(0));\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER \' + Content.toString());\n    if (LOG > 4) console.log(\'type of number is \' + typeof Content.toString());\n    \n    this.writeUString(Content.toString());\n  }\n  else if (typeof Content === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE STRING  \' + Content);\n    if (LOG > 4) console.log(\'type of STRING is \' + typeof Content);\n    \n    this.writeUString(Content);\n  }\n  else {\n    if (LOG > 4) console.log(\'GOING TO WRITE A BLOB  \' + Content);\n\n    this.writeBlob(Content);\n  }\n  \n  this.writeElementClose();\n};\n\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.type = _type;\n  this.val = _val;  \n};\n\nBinaryXMLEncoder.prototype.encodeTypeAndVal = function(\n    //int\n    type, \n    //long \n    val) \n{  \n  if (LOG > 4) console.log(\'Encoding type \'+ type+ \' and value \'+ val);\n  \n  if (LOG > 4) console.log(\'OFFSET IS \' + this.offset);\n  \n  if (type > XML_UDATA || type < 0 || val < 0)\n    throw new Error("Tag and value must be positive, and tag valid.");\n  \n  // Encode backwards. Calculate how many bytes we need:\n  var numEncodingBytes = this.numEncodingBytes(val);\n  this.ostream.ensureLength(this.offset + numEncodingBytes);\n\n  // Bottom 4 bits of val go in last byte with tag.\n  this.ostream.array[this.offset + numEncodingBytes - 1] = \n    //(byte)\n      (BYTE_MASK &\n          (((XML_TT_MASK & type) | \n           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n           XML_TT_NO_MORE); // set top bit for last byte\n  val = val >>> XML_TT_VAL_BITS;\n  \n  // Rest of val goes into preceding bytes, 7 bits per byte, top bit\n  // is "more" flag.\n  var i = this.offset + numEncodingBytes - 2;\n  while (0 != val && i >= this.offset) {\n    this.ostream.array[i] = //(byte)\n        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset\n    val = val >>> XML_REG_VAL_BITS;\n    --i;\n  }\n  \n  if (val != 0)\n    throw new Error("This should not happen: miscalculated encoding");\n\n  this.offset+= numEncodingBytes;\n  \n  return numEncodingBytes;\n};\n\n/**\n * Encode ustring as utf8.\n */\nBinaryXMLEncoder.prototype.encodeUString = function(\n    //String \n    ustring, \n    //byte \n    type) \n{  \n  if (null == ustring)\n    return;\n  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)\n    return;\n  \n  if (LOG > 3) console.log("The string to write is ");\n  if (LOG > 3) console.log(ustring);\n\n  var strBytes = DataUtils.stringToUtf8Array(ustring);\n  \n  this.encodeTypeAndVal(type, \n            (((type == XML_TAG) || (type == XML_ATTR)) ?\n                (strBytes.length-1) :\n                strBytes.length));\n  \n  if (LOG > 3) console.log("THE string to write is ");\n  \n  if (LOG > 3) console.log(strBytes);\n  \n  this.writeString(strBytes);\n  this.offset+= strBytes.length;\n};\n\n\nBinaryXMLEncoder.prototype.encodeBlob = function(\n    //Buffer \n    blob, \n    //int \n    length) \n{\n  if (null == blob)\n    return;\n  \n  if (LOG > 4) console.log(\'LENGTH OF XML_BLOB IS \'+length);\n  \n  this.encodeTypeAndVal(XML_BLOB, length);\n  this.writeBlobArray(blob);\n  this.offset += length;\n};\n\nvar ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);\n\nBinaryXMLEncoder.prototype.numEncodingBytes = function(\n    //long\n    x) \n{\n  if (x <= ENCODING_LIMIT_1_BYTE) return (1);\n  if (x <= ENCODING_LIMIT_2_BYTES) return (2);\n  if (x <= ENCODING_LIMIT_3_BYTES) return (3);\n  \n  var numbytes = 1;\n  \n  // Last byte gives you XML_TT_VAL_BITS\n  // Remainder each give you XML_REG_VAL_BITS\n  x = x >>> XML_TT_VAL_BITS;\n  while (x != 0) {\n        numbytes++;\n    x = x >>> XML_REG_VAL_BITS;\n  }\n  return (numbytes);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the dateTime\n   * as a big endian BLOB converted to 4096 ticks per second, then an element close.\n * @param {number} tag The DTAG tag.\n * @param {NDNTime} dateTime\n */\nBinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)\n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n/**\n * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeDateTime = function(\n    //String \n    tag, \n    //NDNTime \n    dateTime) \n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n// This does not update this.offset.\nBinaryXMLEncoder.prototype.writeString = function(input) \n{\n  if (typeof input === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING\');\n    if (LOG > 4) console.log(input);\n        \n    this.ostream.ensureLength(this.offset + input.length);\n    for (var i = 0; i < input.length; i++) {\n      if (LOG > 4) console.log(\'input.charCodeAt(i)=\' + input.charCodeAt(i));\n      this.ostream.array[this.offset + i] = (input.charCodeAt(i));\n    }\n  }\n  else\n  {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING IN BINARY FORM\');\n    if (LOG > 4) console.log(input);\n    \n    this.writeBlobArray(input);\n  }\n};\n\nBinaryXMLEncoder.prototype.writeBlobArray = function(\n    //Buffer \n    blob) \n{  \n  if (LOG > 4) console.log(\'GOING TO WRITE A BLOB\');\n    \n  this.ostream.copy(blob, this.offset);\n};\n\nBinaryXMLEncoder.prototype.getReducedOstream = function() \n{\n  return this.ostream.slice(0, this.offset);\n};\n\n})()\n},{"../buffer.js":50,"../log.js":83,"../util/dynamic-buffer.js":109,"../util/ndn-protoco-id-tags.js":82,"./data-utils.js":43}],81:[function(require,module,exports){\n(function(){/**\n * This class is used to decode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNTime = require(\'../util/ndn-time.js\').NDNTime;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n  \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n\n\n//returns a string\ntagToString = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {\n    return NDNProtocolDTagsStrings[tagVal];\n  } \n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  }\n  \n  return null;\n};\n\n//returns a Long\nstringToTag =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n  }\n  \n  return null;\n};\n\n/**\n * @constructor\n */\nvar BinaryXMLDecoder = function BinaryXMLDecoder(input) \n{\n  var MARK_LEN=512;\n  var DEBUG_MAX_LEN =  32768;\n  \n  this.input = input;\n  this.offset = 0;\n  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.\n  this.previouslyPeekedDTagStartOffset = -1;\n};\n\nexports.BinaryXMLDecoder = BinaryXMLDecoder;\n\n/**\n * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.\n   * Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n */\nBinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset) {\n    // peekDTag already decoded this DTag.\n    if (this.previouslyPeekedDTag != expectedTag)\n      throw new DecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));\n\n    // Fast forward past the header.\n    this.offset = this.previouslyPeekedDTagEndOffset;\n  }\n  else {\n    var typeAndValue = this.decodeTypeAndVal();\n    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)\n      throw new DecodingException(new Error("Header type is not a DTAG"));\n\n    if (typeAndValue.val() != expectedTag)\n      throw new DecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));\n  }  \n};\n\n/**\n * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readStartElement = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes)\n{\n  //TypeAndVal \n  var tv = this.decodeTypeAndVal();\n      \n  if (null == tv)\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));\n      \n  //String \n  var decodedTag = null;\n      \n  if (tv.type() == XML_TAG) {\n    // Tag value represents length-1 as tags can never be empty.\n    var valval;\n        \n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val())) + 1;\n    else\n      valval = (tv.val())+ 1;\n        \n    decodedTag = this.decodeUString(valval);\n  } \n  else if (tv.type() == XML_DTAG)\n    decodedTag = tv.val();\n      \n  if (null ==  decodedTag || decodedTag != startTag) {\n    console.log(\'expecting \'+ startTag + \' but got \'+ decodedTag);\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));\n  }\n      \n  // DKS: does not read attributes out of stream if caller doesn\'t\n  // ask for them. Should possibly peek and skip over them regardless.\n  // TODO: fix this\n  if (null != attributes)\n    readAttributes(attributes); \n};\n  \n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readAttributes = function(\n  // array of [attributeName, attributeValue] \n  attributes) \n{\n  if (null == attributes)\n    return;\n\n  try {\n    // Now need to get attributes.\n    //TypeAndVal \n    var nextTV = this.peekTypeAndVal();\n\n    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {\n      // Decode this attribute. First, really read the type and value.\n      //this.TypeAndVal \n      var thisTV = this.decodeTypeAndVal();\n\n      //String \n      var attributeName = null;\n      if (XML_ATTR == thisTV.type()) {\n        // Tag value represents length-1 as attribute names cannot be empty.\n        var valval ;\n        if (typeof thisTV.val() == \'string\')\n          valval = (parseInt(thisTV.val())) + 1;\n        else\n          valval = (thisTV.val())+ 1;\n        \n        attributeName = this.decodeUString(valval);\n      } \n      else if (XML_DATTR == thisTV.type()) {\n        // DKS TODO are attributes same or different dictionary?\n        attributeName = tagToString(thisTV.val());\n        if (null == attributeName)\n          throw new DecodingException(new Error("Unknown DATTR value" + thisTV.val()));\n      }\n      \n      // Attribute values are always UDATA\n      //String\n      var attributeValue = this.decodeUString();\n\n      attributes.push([attributeName, attributeValue]);\n      nextTV = this.peekTypeAndVal();\n    }\n  } \n  catch (e) {\n    throw new DecodingException(new Error("readStartElement", e));\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsString = function() \n{\n  //String \n  var decodedTag = null;\n  var previousOffset = this.offset;\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal \n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        // Tag value represents length-1 as tags can never be empty.\n        var valval ;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        decodedTag = this.decodeUString(valval);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tagToString(tv.val());          \n    } // else, not a type and val, probably an end element. rewind and return false.\n  } \n  catch (e) {\n  } \n  finally {\n    try {\n      this.offset = previousOffset;\n    } \n    catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new DecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,\n * then set return true.  Do not update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {boolean} True if the tag is the expected tag, otherwise false.\n */\nBinaryXMLDecoder.prototype.peekDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset)\n    // We already decoded this DTag.\n    return this.previouslyPeekedDTag == expectedTag;\n  else {\n    // First check if it is an element close (which cannot be the expected tag).  \n    if (this.input[this.offset] == XML_CLOSE)\n      return false;\n\n    var saveOffset = this.offset;\n    var typeAndValue = this.decodeTypeAndVal();\n    // readElementStartDTag will use this to fast forward.\n    this.previouslyPeekedDTagEndOffset = this.offset;\n    // Restore the position.\n    this.offset = saveOffset;\n\n    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {\n      this.previouslyPeekedDTagStartOffset = saveOffset;\n      this.previouslyPeekedDTag = typeAndValue.val();\n\n      return typeAndValue.val() == expectedTag;\n    }\n    else\n      return false;\n  }  \n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElement = function(\n    //String \n    startTag) \n{\n  //String \n  if (typeof startTag == \'string\') {\n    var decodedTag = this.peekStartElementAsString();\n    \n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else if (typeof startTag == \'number\') {\n    var decodedTag = this.peekStartElementAsLong();\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else\n    throw new DecodingException(new Error("SHOULD BE STRING OR NUMBER"));\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsLong = function() \n{\n  //Long\n  var decodedTag = null;    \n  var previousOffset = this.offset;\n  \n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        if (tv.val() + 1 > DEBUG_MAX_LEN)\n          throw new DecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));\n\n        var valval;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        // Tag value represents length-1 as tags can never be empty.\n        //String \n        var strTag = this.decodeUString(valval);\n        \n        decodedTag = stringToTag(strTag);\n      } \n      else if (tv.type() == XML_DTAG)\n        decodedTag = tv.val();          \n    } // else, not a type and val, probably an end element. rewind and return false.\n\n  } \n  catch (e) {  \n  } \n  finally {\n    try {\n      //this.input.reset();\n      this.offset = previousOffset;\n    } catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new Error("Cannot reset stream! " + e.getMessage(), e);\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a \n * customBuf. However, if allowNull is true, then the item may be absent.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @param {boolean} allowNull True if the binary item may be missing.\n * @returns {Buffer} A customBuf which is a slice on the data inside the input buffer. However, \n * if allowNull is true and the binary data item is absent, then return null.\n */\nBinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readBinaryElement = function(\n    //long \n    startTag,\n    //TreeMap<String, String> \n    attributes,\n    //boolean\n    allowNull) \n{\n  this.readStartElement(startTag, attributes);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * Read one byte from the input starting at its offset, expecting it to be the element close.\n * Update the input\'s offset.\n */\nBinaryXMLDecoder.prototype.readElementClose = function() \n{\n  var next = this.input[this.offset++];     \n  if (next != XML_CLOSE)\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n};\n\n/**\n * @deprecated Use readElementClose.\n */\nBinaryXMLDecoder.prototype.readEndElement = function() \n{\n  if (LOG > 4) console.log(\'this.offset is \'+this.offset);\n  \n  var next = this.input[this.offset]; \n  \n  this.offset++;\n  \n  if (LOG > 4) console.log(\'XML_CLOSE IS \'+XML_CLOSE);\n  if (LOG > 4) console.log(\'next is \'+next);\n  \n  if (next != XML_CLOSE) {\n    console.log("Expected end element, got: " + next);\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n  }\n};\n\n//String  \nBinaryXMLDecoder.prototype.readUString = function() \n{\n  //String \n  var ustring = this.decodeUString();  \n  this.readElementClose();\n  return ustring;\n};\n  \n/**\n * Read a blob as well as the end element. Returns a customBuf (or null for missing blob).\n * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,\n *   just read the end element and return null.\n */\nBinaryXMLDecoder.prototype.readBlob = function(allowNull) \n{\n  if (this.input[this.offset] == XML_CLOSE && allowNull) {\n    this.readElementClose();\n    return null;\n  }\n    \n  var blob = this.decodeBlob();  \n  this.readElementClose();\n  return blob;\n};\n\n/**\n * Decode the header from the input starting at its offset, expecting the type to be \n * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned \n * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {NDNTime} The dateTime value.\n */\nBinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)  \n{\n  var byteTimestamp = this.readBinaryDTagElement(expectedTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\n/**\n * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readDateTime = function(\n  //long \n  startTag)  \n{\n  var byteTimestamp = this.readBinaryElement(startTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  if (LOG > 4) console.log(\'DECODED DATE WITH VALUE\');\n  if (LOG > 4) console.log(lontimestamp);\n  \n  //NDNTime \n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\nBinaryXMLDecoder.prototype.decodeTypeAndVal = function() \n{\n  \n  /*int*/ var type = -1;\n  /*long*/ var val = 0;\n  /*boolean*/ var more = true;\n\n  do {\n    var next = this.input[this.offset ];\n    if (next == null)\n      // Quit the loop.\n      return null; \n    \n    if (next < 0)\n      return null; \n\n    if (0 == next && 0 == val)\n      return null;\n    \n    more = (0 == (next & XML_TT_NO_MORE));\n    \n    if  (more) {\n      val = val << XML_REG_VAL_BITS;\n      val |= (next & XML_REG_VAL_MASK);\n    } \n    else {\n      type = next & XML_TT_MASK;\n      val = val << XML_TT_VAL_BITS;\n      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);\n    }\n    \n    this.offset++;\n  } while (more);\n  \n  if (LOG > 4) console.log(\'TYPE is \'+ type + \' VAL is \'+ val);\n\n  return new TypeAndVal(type, val);\n};\n\n//TypeAndVal\nBinaryXMLDecoder.prototype.peekTypeAndVal = function() \n{\n  //TypeAndVal \n  var tv = null;\n  var previousOffset = this.offset;\n  \n  try {\n    tv = this.decodeTypeAndVal();\n  } \n  finally {\n    this.offset = previousOffset;\n  }\n  \n  return tv;\n};\n\n//Buffer\nBinaryXMLDecoder.prototype.decodeBlob = function(\n    //int \n    blobLength) \n{  \n  if (null == blobLength) {\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    var valval ;\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val()));\n    else\n      valval = (tv.val());\n    \n    return this.decodeBlob(valval);\n  }\n  \n  //Buffer\n  var bytes = new customBuf(this.input.slice(this.offset, this.offset+ blobLength));\n  this.offset += blobLength;\n  \n  return bytes;\n};\n\n//String\nBinaryXMLDecoder.prototype.decodeUString = function(\n    //int \n    byteLength) \n{\n  if (null == byteLength) {\n    var tempStreamPosition = this.offset;\n      \n    //TypeAndVal \n    var tv = this.decodeTypeAndVal();\n    \n    if (LOG > 4) console.log(\'TV is \'+tv);\n    if (LOG > 4) console.log(tv);\n    \n    if (LOG > 4) console.log(\'Type of TV is \'+typeof tv);\n  \n    // if we just have closers left, will get back null\n    if (null == tv || XML_UDATA != tv.type()) {\n      this.offset = tempStreamPosition;      \n      return "";\n    }\n      \n    return this.decodeUString(tv.val());\n  }\n  else {\n    //Buffer \n    var stringBytes = this.decodeBlob(byteLength);\n    \n    // TODO: Should this parse as UTF8?\n    return DataUtils.toString(stringBytes);    \n  }\n};\n\n//OBject containg a pair of type and value\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.t = _type;\n  this.v = _val;\n};\n\nTypeAndVal.prototype.type = function() \n{\n  return this.t;\n};\n\nTypeAndVal.prototype.val = function() \n{\n  return this.v;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {number} The parsed integer.\n */\nBinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)\n{\n  return parseInt(this.readUTF8DTagElement(expectedTag));\n};\n\n/**\n * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readIntegerElement = function(\n  //String \n  startTag) \n{\n  //String \n  if (LOG > 4) console.log(\'READING INTEGER \'+ startTag);\n  if (LOG > 4) console.log(\'TYPE OF \'+ typeof startTag);\n  \n  var strVal = this.readUTF8Element(startTag);\n  \n  return parseInt(strVal);\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item and return a string. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {string} The UDATA string.\n */\nBinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readUString();;\n};\n\n/**\n * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readUTF8Element = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes) \n{\n  //throws Error where name == "DecodingException" \n\n  // can\'t use getElementText, can\'t get attributes\n  this.readStartElement(startTag, attributes);\n  //String \n  var strElementText = this.readUString();\n  return strElementText;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nBinaryXMLDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n})()\n},{"../buffer.js":50,"../log.js":83,"../util/ndn-protoco-id-tags.js":82,"../util/ndn-time.js":47,"./data-utils.js":43,"./decoding-exception.js":108}],89:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar Blob = require(\'./blob.js\').Blob;\n\n/**\n * A SignedBlob extends Blob to keep the offsets of a signed portion (e.g., the \n * bytes of Data packet). This inherits from Blob, including Blob.size and Blob.buf.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {number} signedPortionBeginOffset (optional) The offset in the \n * encoding of the beginning of the signed portion. If omitted, set to 0.\n * @param {number} signedPortionEndOffset (optional) The offset in the encoding \n * of the end of the signed portion. If omitted, set to 0.\n */\nvar SignedBlob = function SignedBlob(value, signedPortionBeginOffset, signedPortionEndOffset) \n{\n  // Call the base constructor.\n  Blob.call(this, value);\n  \n  if (this.buffer == null) {\n    this.signedPortionBeginOffset = 0;\n    this.signedPortionEndOffset = 0;\n  }\n  else if (typeof value === \'object\' && value instanceof SignedBlob) {\n    // Copy the SignedBlob, allowing override for offsets.\n    this.signedPortionBeginOffset = signedPortionBeginOffset == null ? \n      value.signedPortionBeginOffset : signedPortionBeginOffset;\n    this.signedPortionEndOffset = signedPortionEndOffset == null ? \n      value.signedPortionEndOffset : signedPortionEndOffset;\n  }\n  else {\n    this.signedPortionBeginOffset = signedPortionBeginOffset || 0;\n    this.signedPortionEndOffset = signedPortionEndOffset || 0;\n  }\n  \n  if (this.buffer == null)\n    this.signedBuffer = null;\n  else\n    this.signedBuffer = this.buffer.slice\n      (this.signedPortionBeginOffset, this.signedPortionEndOffset);\n};\n\nSignedBlob.prototype = new Blob();\nSignedBlob.prototype.name = "SignedBlob";\n\nexports.SignedBlob = SignedBlob;\n\n/**\n * Return the length of the signed portion of the immutable byte array.\n * @returns {number} The length of the signed portion.  If signedBuf() is null, \n * return 0.\n */\nSignedBlob.prototype.signedSize = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return a the signed portion of the immutable byte array.\n * @returns {Buffer} A slice into the customBuf which is the signed portion.  \n * If the pointer to the array is null, return null.\n */\nSignedBlob.prototype.signedBuf = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer;\n  else\n    return null;\n};\n\n/**\n * Return the offset in the array of the beginning of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionBeginOffset = function()\n{\n  return this.signedPortionBeginOffset;\n};\n\n/**\n * Return the offset in the array of the end of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionEndOffset = function()\n{\n  return this.signedPortionEndOffset;\n};\n\n})()\n},{"../buffer.js":50,"./blob.js":45}],97:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Face Instances\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\n\n/**\n * @constructor\n */\nvar FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,\n    multicastTTL, freshnessSeconds) \n{\n  this.action = action;\n  this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n  this.faceID = faceID;\n  this.ipProto = ipProto;\n  this.host = host;\n  this.Port = port;\n  this.multicastInterface =multicastInterface;\n  this.multicastTTL =multicastTTL;\n  this.freshnessSeconds = freshnessSeconds;\n};\n\nexports.FaceInstance = FaceInstance;\n\nFaceInstance.NetworkProtocol = { TCP:6, UDP:17};\n\n/**\n * Used by NetworkObject to decode the object from a network stream.\n */\nFaceInstance.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Action))   \n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    this.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {\n    //int\n    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);\n    \n    this.ipProto = null;\n    \n    if (FaceInstance.NetworkProtocol.TCP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.TCP;\n    else if (FaceInstance.NetworkProtocol.UDP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.UDP;\n    else\n      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Host))\n    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);\n  if (decoder.peekDTag(NDNProtocolDTags.Port))\n    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))\n    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))\n    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\n/**\n * Used by NetworkObject to encode the object to a network stream.\n */\nFaceInstance.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.publisherPublicKeyDigest)\n    this.publisherPublicKeyDigest.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.ipProto)\n    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);\n  if (null != this.host && this.host.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);  \n  if (null != this.Port)\n    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);\n  if (null != this.multicastInterface && this.multicastInterface.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);\n  if (null !=  this.multicastTTL)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  encoder.writeElementClose();         \n};\n\nFaceInstance.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.FaceInstance;\n};\n\n\n},{"./publisher-public-key-digest.js":39,"./util/ndn-protoco-id-tags.js":82}],86:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DecodingException = require(\'../decoding-exception.js\').DecodingException;\n\n/**\n * Create a new TlvDecoder for decoding the input in the NDN-TLV wire format.\n * @constructor\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nvar TlvDecoder = function TlvDecoder(input)\n{\n  this.input = input;\n  this.offset = 0;\n};\n\nexports.TlvDecoder = TlvDecoder;\n\n/**\n * Decode VAR-NUMBER in NDN-TLV and return it. Update offset.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readVarNumber = function() \n{\n  // Assume array values are in the range 0 to 255.\n  var firstOctet = this.input[this.offset];\n  this.offset += 1;\n  if (firstOctet < 253)\n    return firstOctet;\n  else\n    return this.readExtendedVarNumber(firstOctet);\n};\n\n/**\n * A private function to do the work of readVarNumber, given the firstOctet\n * which is >= 253.\n * @param {number} firstOctet The first octet which is >= 253, used to decode \n * the remaining bytes.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readExtendedVarNumber = function(firstOctet) \n{\n  // This is a private function so we know firstOctet >= 253.\n  if (firstOctet == 253) {\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n    this.offset += 2;\n  }\n  else if (firstOctet == 254) {\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n    this.offset += 4;\n  }\n  else {\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n    this.offset += 8;\n  }\n  \n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType and return the length. Update offset.  Also make \n * sure the decoded length does not exceed the number of bytes remaining in the \n * input.\n * @param {number} expectedType The expected type.\n * @returns {number} The length of the TLV.\n * @throws DecodingException if (did not get the expected TLV type or the TLV length \n * exceeds the buffer length.\n */\nTlvDecoder.prototype.readTypeAndLength = function(expectedType) \n{\n  var type = this.readVarNumber();\n  if (type != expectedType)\n    throw new DecodingException("Did not get the expected TLV type");\n\n  var length = this.readVarNumber();\n  if (this.offset + length > this.input.length)\n    throw new DecodingException("TLV length exceeds the buffer length");\n\n  return length;\n};\n\n/**\n * Decode the type and length from the input starting at offset, expecting the \n * type to be expectedType.  Update offset.  Also make sure the decoded length \n * does not exceed the number of bytes remaining in the input. Return the offset \n * of the end of this parent TLV, which is used in decoding optional nested \n * TLVs. After reading all nested TLVs, call finishNestedTlvs.\n * @param {number} expectedType The expected type.\n * @returns {number} The offset of the end of the parent TLV.\n * @throws DecodingException if did not get the expected TLV type or the TLV \n * length exceeds the buffer length.\n */\nTlvDecoder.prototype.readNestedTlvsStart = function(expectedType) \n{\n  return this.readTypeAndLength(expectedType) + this.offset;\n};\n\n/**\n * Call this after reading all nested TLVs to skip any remaining unrecognized \n * TLVs and to check if the offset after the final nested TLV matches the \n * endOffset returned by readNestedTlvsStart.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @throws DecodingException if the TLV length does not equal the total length \n * of the nested TLVs.\n */\nTlvDecoder.prototype.finishNestedTlvs = function(endOffset) \n{\n  // We expect offset to be endOffset, so check this first.\n  if (this.offset == endOffset)\n    return;\n\n  // Skip remaining TLVs.\n  while (this.offset < endOffset) {\n    // Skip the type VAR-NUMBER.\n    this.readVarNumber();\n    // Read the length and update offset.\n    var length = this.readVarNumber();\n    this.offset += length;\n\n    if (this.offset > this.input.length)\n      throw new DecodingException("TLV length exceeds the buffer length");\n  }\n  \n  if (this.offset != endOffset)\n    throw new DecodingException\n      ("TLV length does not equal the total length of the nested TLVs");\n};\n\n/**\n * Decode the type from this\'s input starting at offset, and if it is the \n * expectedType, then return true, else false.  However, if this\'s offset is \n * greater than or equal to endOffset, then return false and don\'t try to read \n * the type. Do not update offset.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true if the type of the next TLV is the expectedType, \n *  otherwise false.\n */\nTlvDecoder.prototype.peekType = function(expectedType, endOffset) \n{\n  if (this.offset >= endOffset)\n    // No more sub TLVs to look at.\n    return false;\n  else {\n    var saveOffset = this.offset;\n    var type = this.readVarNumber();\n    // Restore offset.\n    this.offset = saveOffset;\n\n    return type == expectedType;\n  }\n};\n\n/**\n * Decode a non-negative integer in NDN-TLV and return it. Update offset by \n * length.\n * @param {number} length The number of bytes in the encoded integer.\n * @returns {number} The integer.\n * @throws DecodingException if length is an invalid length for a TLV \n * non-negative integer.\n */\nTlvDecoder.prototype.readNonNegativeInteger = function(length) \n{\n  var result;\n  if (length == 1)\n    result = this.input[this.offset];\n  else if (length == 2)\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n  else if (length == 4)\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n  else if (length == 8)\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n  else\n    throw new DecodingException("Invalid length for a TLV nonNegativeInteger");\n\n  this.offset += length;\n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then decode a non-negative integer in NDN-TLV \n * and return it.  Update offset.\n * @param {number} expectedType The expected type.\n * @returns {number} The integer.\n * @throws DecodingException if did not get the expected TLV type or can\'t \n * decode the value.\n */\nTlvDecoder.prototype.readNonNegativeIntegerTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  return this.readNonNegativeInteger(length);\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call \n * readNonNegativeIntegerTlv and return the integer.  Otherwise, return null.  \n * However, if this\'s offset is greater than or equal to endOffset, then return \n * null and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {number} The integer or null if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readOptionalNonNegativeIntegerTlv = function\n  (expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readNonNegativeIntegerTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then return an array of the bytes in the value.\n * Update offset.\n * @param {number} expectedType The expected type.\n * @returns {Buffer} The bytes in the value as a slice on the buffer.  This is\n * not a copy of the bytes in the input buffer.  If you need a copy, then you \n * must make a copy of the return value.\n * @throws DecodingException if did not get the expected TLV type.\n */\nTlvDecoder.prototype.readBlobTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  var result = this.input.slice(this.offset, this.offset + length);\n\n  // readTypeAndLength already checked if length exceeds the input buffer.\n  this.offset += length;\n  return result;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call readBlobTlv \n * and return the value.  Otherwise, return null. However, if this\'s offset is \n * greater than or equal to endOffset, then return null and don\'t try to read \n * the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {Buffer} The bytes in the value as a slice on the buffer or null if \n * the next TLV doesn\'t have the expected type.  This is not a copy of the bytes \n * in the input buffer.  If you need a copy, then you must make a copy of the \n * return value.\n */\nTlvDecoder.prototype.readOptionalBlobTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readBlobTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then read a type and \n * value, ignoring the value, and return true. Otherwise, return false.\n * However, if this\'s offset is greater than or equal to endOffset, then return \n * false and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true, or else false if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readBooleanTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset)) {\n    var length = this.readTypeAndLength(expectedType);\n    // We expect the length to be 0, but update offset anyway.\n    this.offset += length;\n    return true;\n  }\n  else\n    return false;\n};\n\n/**\n * Get the offset into the input, used for the next read.\n * @returns {number} The offset.\n */\nTlvDecoder.prototype.getOffset = function() \n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};  \n\n})()\n},{"../../buffer.js":50,"../decoding-exception.js":108}],96:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar crypto = require(\'../crypto.js\');\nvar Blob = require(\'../util/blob.js\').Blob;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvEncoder = require(\'./tlv/tlv-encoder.js\').TlvEncoder;\nvar TlvDecoder = require(\'./tlv/tlv-decoder.js\').TlvDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar ContentType = require(\'../meta-info.js\').ContentType;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Signature = require(\'../signature.js\').Signature;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\n\n/**\n * A Tlv0_1a2WireFormat implements the WireFormat interface for encoding and \n * decoding with the NDN-TLV wire format, version 0.1a2\n * @constructor\n */\nvar Tlv0_1a2WireFormat = function Tlv0_1a2WireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nTlv0_1a2WireFormat.prototype = new WireFormat();\nTlv0_1a2WireFormat.prototype.name = "Tlv0_1a2WireFormat";\n\nexports.Tlv0_1a2WireFormat = Tlv0_1a2WireFormat;\n\n// Default object.\nTlv0_1a2WireFormat.instance = null;\n\n/**\n * Encode the interest using NDN-TLV and return a customBuf.\n * @param {Interest} interest The Interest object to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nTlv0_1a2WireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new TlvEncoder();\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.InterestLifetime, interest.getInterestLifetimeMilliseconds());\n  encoder.writeOptionalNonNegativeIntegerTlv(Tlv.Scope, interest.getScope());\n  \n  // Encode the Nonce as 4 bytes.\n  if (interest.getNonce() == null || interest.getNonce().length == 0)\n    // This is the most common case. Generate a nonce.\n    encoder.writeBlobTlv(Tlv.Nonce, require("../crypto.js").randomBytes(4));\n  else if (interest.getNonce().length < 4) {\n    var nonce = customBuf(4);\n    // Copy existing nonce bytes.\n    interest.getNonce().copy(nonce);\n\n    // Generate random bytes for remaining bytes in the nonce.\n    for (var i = interest.getNonce().length; i < 4; ++i)\n      nonce[i] = require("crypto").randomBytes(1)[0];\n\n    encoder.writeBlobTlv(Tlv.Nonce, nonce);\n  }\n  else if (interest.getNonce().length == 4)\n    // Use the nonce as-is.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce());\n  else\n    // Truncate.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce().slice(0, 4));\n  \n  Tlv0_1a2WireFormat.encodeSelectors(interest, encoder);\n  Tlv0_1a2WireFormat.encodeName(interest.getName(), encoder);\n  \n  encoder.writeTypeAndLength(Tlv.Interest, encoder.getLength() - saveLength);\n      \n  return new Blob(encoder.getOutput(), false);\n};\n\n/**\n * Decode input as an NDN-TLV interest and set the fields of the interest \n * object.  \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nTlv0_1a2WireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Interest);\n  Tlv0_1a2WireFormat.decodeName(interest.getName(), decoder);\n  if (decoder.peekType(Tlv.Selectors, endOffset))\n    Tlv0_1a2WireFormat.decodeSelectors(interest, decoder);\n  // Require a Nonce, but don\'t force it to be 4 bytes.\n  var nonce = decoder.readBlobTlv(Tlv.Nonce);\n  interest.setScope(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.Scope, endOffset));\n  interest.setInterestLifetimeMilliseconds\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.InterestLifetime, endOffset));\n\n  // Set the nonce last because setting other interest fields clears it.\n  interest.setNonce(nonce);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode data as NDN-TLV and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nTlv0_1a2WireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new TlvEncoder(1500);\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  encoder.writeBlobTlv(Tlv.SignatureValue, data.getSignature().getSignature());\n  var signedPortionEndOffsetFromBack = encoder.getLength();\n\n  // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n  //   the key locator from the MetaInfo to the Signauture object.\n  Tlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue\n    (data.getSignature(), encoder, data.getSignatureOrMetaInfoKeyLocator());\n  encoder.writeBlobTlv(Tlv.Content, data.getContent());\n  Tlv0_1a2WireFormat.encodeMetaInfo(data.getMetaInfo(), encoder);\n  Tlv0_1a2WireFormat.encodeName(data.getName(), encoder);\n  var signedPortionBeginOffsetFromBack = encoder.getLength();\n\n  encoder.writeTypeAndLength(Tlv.Data, encoder.getLength() - saveLength);\n  var signedPortionBeginOffset = \n    encoder.getLength() - signedPortionBeginOffsetFromBack;\n  var signedPortionEndOffset = encoder.getLength() - signedPortionEndOffsetFromBack;\n\n  return { encoding: new Blob(encoder.getOutput(), false),\n           signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Decode input as an NDN-TLV data packet, set the fields in the data object, \n * and return the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nTlv0_1a2WireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Data);\n  var signedPortionBeginOffset = decoder.getOffset();\n\n  Tlv0_1a2WireFormat.decodeName(data.getName(), decoder);\n  Tlv0_1a2WireFormat.decodeMetaInfo(data.getMetaInfo(), decoder);\n  data.setContent(decoder.readBlobTlv(Tlv.Content));\n  Tlv0_1a2WireFormat.decodeSignatureInfo(data, decoder);\n  if (data.getSignature() != null && \n      data.getSignature().getKeyLocator() != null && \n      data.getMetaInfo() != null)\n    // Copy the key locator pointer to the MetaInfo object for the transition of \n    //   moving the key locator from the MetaInfo to the Signature object.\n    data.getMetaInfo().locator = data.getSignature().getKeyLocator();\n\n  var signedPortionEndOffset = decoder.getOffset();\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  data.getSignature().setSignature(decoder.readBlobTlv(Tlv.SignatureValue));\n\n  decoder.finishNestedTlvs(endOffset);\n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Get a singleton instance of a Tlv1_0a2WireFormat.  To always use the\n * preferred version NDN-TLV, you should use TlvWireFormat.get().\n * @returns {Tlv0_1a2WireFormat} The singleton instance.\n */\nTlv0_1a2WireFormat.get = function()\n{\n  if (Tlv0_1a2WireFormat.instance === null)\n    Tlv0_1a2WireFormat.instance = new Tlv0_1a2WireFormat();\n  return Tlv0_1a2WireFormat.instance;\n};\n\nTlv0_1a2WireFormat.encodeName = function(name, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode the components backwards.\n  for (var i = name.size() - 1; i >= 0; --i)\n    encoder.writeBlobTlv(Tlv.NameComponent, name.get(i).getValue());\n\n  encoder.writeTypeAndLength(Tlv.Name, encoder.getLength() - saveLength);\n};\n        \nTlv0_1a2WireFormat.decodeName = function(name, decoder)\n{\n  name.clear();\n  \n  var endOffset = decoder.readNestedTlvsStart(Tlv.Name);      \n  while (decoder.getOffset() < endOffset)\n      name.append(decoder.readBlobTlv(Tlv.NameComponent));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the interest selectors.  If no selectors are written, do not output a \n * Selectors TLV.\n */\nTlv0_1a2WireFormat.encodeSelectors = function(interest, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (interest.getMustBeFresh())\n    encoder.writeTypeAndLength(Tlv.MustBeFresh, 0);\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.ChildSelector, interest.getChildSelector());\n  if (interest.getExclude().size() > 0)\n    Tlv0_1a2WireFormat.encodeExclude(interest.getExclude(), encoder);\n  \n  if (interest.getKeyLocator().getType() != null)\n    Tlv0_1a2WireFormat.encodeKeyLocator(interest.getKeyLocator(), encoder);\n  else {\n    // There is no keyLocator. If there is a publisherPublicKeyDigest, then \n    //   encode as KEY_LOCATOR_DIGEST. (When we remove the deprecated \n    //   publisherPublicKeyDigest, we don\'t need this.)\n    if (null != interest.publisherPublicKeyDigest) {\n      var savePublisherPublicKeyDigestLength = encoder.getLength();\n      encoder.writeBlobTlv\n        (Tlv.KeyLocatorDigest, \n         interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n      encoder.writeTypeAndLength\n        (Tlv.KeyLocator, encoder.getLength() - savePublisherPublicKeyDigestLength);\n    }\n  }\n  \n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MaxSuffixComponents, interest.getMaxSuffixComponents());\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MinSuffixComponents, interest.getMinSuffixComponents());\n\n  // Only output the type and length if values were written.\n  if (encoder.getLength() != saveLength)\n    encoder.writeTypeAndLength(Tlv.Selectors, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSelectors = function(interest, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Selectors);\n\n  interest.setMinSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MinSuffixComponents, endOffset));\n  interest.setMaxSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MaxSuffixComponents, endOffset));\n\n  // Initially set publisherPublicKeyDigest to none.\n  interest.publisherPublicKeyDigest = null;\n  if (decoder.peekType(Tlv.KeyLocator, endOffset)) {\n    Tlv0_1a2WireFormat.decodeKeyLocator(interest.getKeyLocator(), decoder);\n    if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST) {\n      // For backwards compatibility, also set the publisherPublicKeyDigest.\n      interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest =\n        interest.getKeyLocator().getKeyData();\n    }\n  }\n  else\n    interest.getKeyLocator().clear();\n\n  if (decoder.peekType(Tlv.Exclude, endOffset))\n    Tlv0_1a2WireFormat.decodeExclude(interest.getExclude(), decoder);\n  else\n    interest.getExclude().clear();\n\n  interest.setChildSelector(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ChildSelector, endOffset));\n  interest.setMustBeFresh(decoder.readBooleanTlv(Tlv.MustBeFresh, endOffset));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n  \nTlv0_1a2WireFormat.encodeExclude = function(exclude, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // TODO: Do we want to order the components (except for ANY)?\n  // Encode the entries backwards.\n  for (var i = exclude.size() - 1; i >= 0; --i) {\n    var entry = exclude.get(i);\n\n    if (entry == Exclude.ANY)\n      encoder.writeTypeAndLength(Tlv.Any, 0);\n    else\n      encoder.writeBlobTlv(Tlv.NameComponent, entry.getValue());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.Exclude, encoder.getLength() - saveLength);\n};\n  \nTlv0_1a2WireFormat.decodeExclude = function(exclude, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Exclude);\n\n  exclude.clear();\n  while (true) {\n    if (decoder.peekType(Tlv.NameComponent, endOffset))\n      exclude.appendComponent(decoder.readBlobTlv(Tlv.NameComponent));\n    else if (decoder.readBooleanTlv(Tlv.Any, endOffset))\n      exclude.appendAny();\n    else\n      // Else no more entries.\n      break;\n  }\n  \n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeKeyLocator = function(keyLocator, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (keyLocator.getType() != null) {\n    if (keyLocator.getType() == KeyLocatorType.KEYNAME)\n      Tlv0_1a2WireFormat.encodeName(keyLocator.getKeyName(), encoder);\n    else if (keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST &&\n             keyLocator.getKeyData().length > 0)\n      encoder.writeBlobTlv(Tlv.KeyLocatorDigest, keyLocator.getKeyData());\n    else\n      throw new Error("Unrecognized KeyLocatorType " + keyLocator.getType());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.KeyLocator, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeKeyLocator = function(keyLocator, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.KeyLocator);\n\n  keyLocator.clear();\n\n  if (decoder.getOffset() == endOffset)\n    // The KeyLocator is omitted, so leave the fields as none.\n    return;\n\n  if (decoder.peekType(Tlv.Name, endOffset)) {\n    // KeyLocator is a Name.\n    keyLocator.setType(KeyLocatorType.KEYNAME);\n    Tlv0_1a2WireFormat.decodeName(keyLocator.getKeyName(), decoder);\n  }\n  else if (decoder.peekType(Tlv.KeyLocatorDigest, endOffset)) {\n    // KeyLocator is a KeyLocatorDigest.\n    keyLocator.setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    keyLocator.setKeyData(decoder.readBlobTlv(Tlv.KeyLocatorDigest));\n  }\n  else\n    throw new DecodingException\n      ("decodeKeyLocator: Unrecognized key locator type");\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the signature object in TLV, using the given keyLocator instead of the\n * locator in this object.\n * @param {Signature} signature The Signature object to encode.\n * @param {TlvEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nTlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue = function\n  (signature, encoder, keyLocator)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  Tlv0_1a2WireFormat.encodeKeyLocator(keyLocator, encoder);\n  encoder.writeNonNegativeIntegerTlv\n    (Tlv.SignatureType, Tlv.SignatureType_SignatureSha256WithRsa);\n\n  encoder.writeTypeAndLength(Tlv.SignatureInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSignatureInfo = function(data, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.SignatureInfo);\n\n  var signatureType = decoder.readNonNegativeIntegerTlv(Tlv.SignatureType);\n  // TODO: The library needs to handle other signature types than \n  //     SignatureSha256WithRsa.\n  if (signatureType == Tlv.SignatureType_SignatureSha256WithRsa) {\n      var signature = {}\n      signature.sig = Signature\n      data.setSignature(signature.sig());\n      // Modify data\'s signature object because if we create an object\n      //   and set it, then data will have to copy all the fields.\n      var signatureInfo = data.getSignature();\n      Tlv0_1a2WireFormat.decodeKeyLocator\n        (signatureInfo.getKeyLocator(), decoder);\n  }\n  else\n      throw new DecodingException\n       ("decodeSignatureInfo: unrecognized SignatureInfo type" + signatureType);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeMetaInfo = function(metaInfo, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  var finalBlockIdBuf = metaInfo.getFinalBlockID();\n  if (finalBlockIdBuf != null && finalBlockIdBuf.length > 0) {\n    // FinalBlockId has an inner NameComponent.\n    var finalBlockIdSaveLength = encoder.getLength();\n    encoder.writeBlobTlv(Tlv.NameComponent, finalBlockIdBuf);\n    encoder.writeTypeAndLength\n      (Tlv.FinalBlockId, encoder.getLength() - finalBlockIdSaveLength);\n  }\n\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.FreshnessPeriod, metaInfo.getFreshnessPeriod());\n  if (metaInfo.getType() != ContentType.BLOB) {\n    // Not the default, so we need to encode the type.\n    if (metaInfo.getType() == ContentType.LINK ||\n        metaInfo.getType() == ContentType.KEY)\n      // The ContentType enum is set up with the correct integer for \n      // each NDN-TLV ContentType.\n      encoder.writeNonNegativeIntegerTlv(Tlv.ContentType, metaInfo.getType());\n    else\n      throw new Error("unrecognized TLV ContentType");\n  }\n\n  encoder.writeTypeAndLength(Tlv.MetaInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeMetaInfo = function(metaInfo, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.MetaInfo);  \n\n  // The ContentType enum is set up with the correct integer for each \n  // NDN-TLV ContentType.  If readOptionalNonNegativeIntegerTlv returns\n  // None, then setType will convert it to BLOB.\n  metaInfo.setType(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ContentType, endOffset));\n  metaInfo.setFreshnessPeriod\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.FreshnessPeriod, endOffset));\n  if (decoder.peekType(Tlv.FinalBlockId, endOffset)) {\n    var finalBlockIdEndOffset = decoder.readNestedTlvsStart(Tlv.FinalBlockId);\n    metaInfo.setFinalBlockID(decoder.readBlobTlv(Tlv.NameComponent));\n    decoder.finishNestedTlvs(finalBlockIdEndOffset);\n  }\n  else\n    metaInfo.setFinalBlockID(null);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n})()\n},{"../crypto.js":50,"../exclude.js":34,"../key-locator.js":38,"../meta-info.js":36,"../signature.js":90,"../util/blob.js":45,"./decoding-exception.js":108,"./tlv/tlv-decoder.js":86,"./tlv/tlv-encoder.js":110,"./tlv/tlv.js":85,"./wire-format.js":40,"crypto":51}],98:[function(require,module,exports){\n/**\n * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to \n * determine its end.\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\n\nvar XML_EXT = 0x00; \nvar XML_TAG = 0x01; \nvar XML_DTAG = 0x02; \nvar XML_ATTR = 0x03; \nvar XML_DATTR = 0x04; \nvar XML_BLOB = 0x05; \nvar XML_UDATA = 0x06;   \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\n\n/**\n * @constructor\n */\nvar BinaryXMLStructureDecoder = function BinaryXMLDecoder() \n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.level = 0;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.headerBuffer = new DynamicBuffer(5);\n  this.nBytesToRead = 0;\n};\n\nexports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;\n\nBinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;\nBinaryXMLStructureDecoder.READ_BYTES = 1;\n\n/**\n * Continue scanning input starting from this.offset.  If found the end of the element\n *   which started at offset 0 then return true, else false.\n * If this returns false, you should read more into input and call again.\n * You have to pass in input each time because the array could be reallocated.\n * This throws an exception for badly formed ndnb.\n */\nBinaryXMLStructureDecoder.prototype.findElementEnd = function(\n  // customBuf\n  input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new BinaryXMLDecoder(input);\n  \n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input.\n      return false;\n  \n    switch (this.state) {\n      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:               \n        // First check for XML_CLOSE.\n        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {\n          ++this.offset;\n          // Close the level.\n          --this.level;\n          if (this.level == 0) {\n            // Finished.\n            this.gotElementEnd = true;\n            return true;\n          }\n          if (this.level < 0)\n            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));\n              \n          // Get ready for the next header.\n          this.startHeader();\n          break;\n        }\n        \n        var startingHeaderLength = this.headerLength;\n        while (true) {\n          if (this.offset >= input.length) {\n            // We can\'t get all of the header bytes from this input. Save in headerBuffer.\n            this.useHeaderBuffer = true;\n            var nNewBytes = this.headerLength - startingHeaderLength;\n            this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n              \n            return false;\n          }\n          var headerByte = input[this.offset++];\n          ++this.headerLength;\n          if (headerByte & XML_TT_NO_MORE)\n            // Break and read the header.\n            break;\n        }\n        \n        var typeAndVal;\n        if (this.useHeaderBuffer) {\n          // Copy the remaining bytes into headerBuffer.\n          nNewBytes = this.headerLength - startingHeaderLength;\n          this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();\n        }\n        else {\n          // We didn\'t have to use the headerBuffer.\n          decoder.seek(this.offset - this.headerLength);\n          typeAndVal = decoder.decodeTypeAndVal();\n        }\n        \n        if (typeAndVal == null)\n          throw new Error("BinaryXMLStructureDecoder: Can\'t read header starting at offset " +\n                          (this.offset - this.headerLength));\n        \n        // Set the next state based on the type.\n        var type = typeAndVal.t;\n        if (type == XML_DATTR)\n          // We already consumed the item. READ_HEADER_OR_CLOSE again.\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n          this.startHeader();\n        else if (type == XML_DTAG || type == XML_EXT) {\n          // Start a new level and READ_HEADER_OR_CLOSE again.\n          ++this.level;\n          this.startHeader();\n        }\n        else if (type == XML_TAG || type == XML_ATTR) {\n          if (type == XML_TAG)\n            // Start a new level and read the tag.\n            ++this.level;\n          // Minimum tag or attribute length is 1.\n          this.nBytesToRead = typeAndVal.v + 1;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n        }\n        else if (type == XML_BLOB || type == XML_UDATA) {\n          this.nBytesToRead = typeAndVal.v;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n        }\n        else\n          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);\n        break;\n    \n      case BinaryXMLStructureDecoder.READ_BYTES:\n        var nRemainingBytes = input.length - this.offset;\n        if (nRemainingBytes < this.nBytesToRead) {\n          // Need more.\n          this.offset += nRemainingBytes;\n          this.nBytesToRead -= nRemainingBytes;\n          return false;\n        }\n        // Got the bytes.  Read a new header or close.\n        this.offset += this.nBytesToRead;\n        this.startHeader();\n        break;\n    \n      default:\n        // We don\'t expect this to happen.\n        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);\n    }\n  }\n};\n\n/**\n * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header\n */\nBinaryXMLStructureDecoder.prototype.startHeader = function() \n{\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;    \n};\n\n/**\n *  Set the offset into the input, used for the next read.\n */\nBinaryXMLStructureDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n},{"../util/dynamic-buffer.js":109,"./binary-xml-decoder.js":81}],99:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar TlvDecoder = require(\'./tlv-decoder.js\').TlvDecoder;\nvar customBuf = require(\'../../buffer.js\').Buffer\n/**\n * Create and initialize a TlvStructureDecoder.\n */\nvar TlvStructureDecoder = function TlvStructureDecoder()\n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.state = TlvStructureDecoder.READ_TYPE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  // 8 bytes is enough to hold the extended bytes in the length encoding \n  // where it is an 8-byte number.\n  this.headerBuffer = new customBuf(8);\n  this.nBytesToRead = 0;\n};\n\nexports.TlvStructureDecoder = TlvStructureDecoder;\n\nTlvStructureDecoder.READ_TYPE =         0;\nTlvStructureDecoder.READ_TYPE_BYTES =   1;\nTlvStructureDecoder.READ_LENGTH =       2;\nTlvStructureDecoder.READ_LENGTH_BYTES = 3;\nTlvStructureDecoder.READ_VALUE_BYTES =  4;\n\n/**\n * Continue scanning input starting from this.offset to find the element end.  \n * If the end of the element which started at offset 0 is found, this returns \n * true and getOffset() is the length of the element.  Otherwise, this returns \n * false which means you should read more into input and call again.\n * @param {Buffer} input The input buffer. You have to pass in input each time\n * because the buffer could be reallocated.\n * @returns {boolean} true if found the element end, false if not.\n */\nTlvStructureDecoder.prototype.findElementEnd = function(input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new TlvDecoder(input);\n\n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input. Return and wait for more.\n      return false;\n\n    if (this.state == TlvStructureDecoder.READ_TYPE) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253)\n        // The value is simple, so we can skip straight to reading the length.\n        this.state = TlvStructureDecoder.READ_LENGTH;\n      else {\n        // Set up to skip the type bytes.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        this.state = TlvStructureDecoder.READ_TYPE_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_TYPE_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the type bytes. Move on to read the length.\n      this.offset += this.nBytesToRead;\n      this.state = TlvStructureDecoder.READ_LENGTH;\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253) {\n        // The value is simple, so we can skip straight to reading \n        //  the value bytes.\n        this.nBytesToRead = firstOctet;\n        if (this.nBytesToRead == 0) {\n          // No value bytes to read. We\'re finished.\n          this.gotElementEnd = true;\n          return true;\n        }\n\n        this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n      }\n      else {\n        // We need to read the bytes in the extended encoding of \n        //  the length.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        // We need to use firstOctet in the next state.\n        this.firstOctet = firstOctet;\n        this.state = TlvStructureDecoder.READ_LENGTH_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (!this.useHeaderBuffer && nRemainingBytes >= this.nBytesToRead) {\n        // We don\'t have to use the headerBuffer. Set nBytesToRead.\n        decoder.seek(this.offset);\n\n        this.nBytesToRead = decoder.readExtendedVarNumber(this.firstOctet);\n        // Update this.offset to the decoder\'s offset after reading.\n        this.offset = decoder.getOffset();\n      }\n      else {\n        this.useHeaderBuffer = true;\n\n        var nNeededBytes = this.nBytesToRead - this.headerLength;\n        if (nNeededBytes > nRemainingBytes) {\n          // We can\'t get all of the header bytes from this input. \n          // Save in headerBuffer.\n          if (this.headerLength + nRemainingBytes > this.headerBuffer.length)\n            // We don\'t expect this to happen.\n            throw new Error\n              ("Cannot store more header bytes than the size of headerBuffer");\n          input.slice(this.offset, this.offset + nRemainingBytes).copy\n            (this.headerBuffer, this.headerLength);\n          this.offset += nRemainingBytes;\n          this.headerLength += nRemainingBytes;\n\n          return false;\n        }\n\n        // Copy the remaining bytes into headerBuffer, read the \n        //   length and set nBytesToRead.\n        if (this.headerLength + nNeededBytes > this.headerBuffer.length)\n          // We don\'t expect this to happen.\n          throw new Error\n            ("Cannot store more header bytes than the size of headerBuffer");\n        input.slice(this.offset, this.offset + nNeededBytes).copy\n          (this.headerBuffer, this.headerLength);\n        this.offset += nNeededBytes;\n\n        // Use a local decoder just for the headerBuffer.\n        var bufferDecoder = new TlvDecoder(this.headerBuffer);\n        // Replace nBytesToRead with the length of the value.\n        this.nBytesToRead = bufferDecoder.readExtendedVarNumber(this.firstOctet);\n      }\n      \n      if (this.nBytesToRead == 0) {\n        // No value bytes to read. We\'re finished.\n        this.gotElementEnd = true;\n        return true;\n      }\n\n      // Get ready to read the value bytes.\n      this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n    }\n    else if (this.state == TlvStructureDecoder.READ_VALUE_BYTES) {\n      nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the bytes. We\'re finished.\n      this.offset += this.nBytesToRead;\n      this.gotElementEnd = true;\n      return true;\n    }\n    else\n      // We don\'t expect this to happen.\n      throw new Error("findElementEnd: unrecognized state");\n  }\n};\n\n/**\n * Get the current offset into the input buffer.\n * @returns {number} The offset.\n */\nTlvStructureDecoder.prototype.getOffset = function()\n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvStructureDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n\n})()\n},{"../../buffer.js":50,"./tlv-decoder.js":86}],100:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar ElementReader = require(\'../encoding/element-reader.js\').ElementReader;\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n\nfunction makeShuffledGetHostAndPort (hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n\n/**\n * @constructor\n */\nvar WebSocketTransport = function WebSocketTransport() \n{    \n  if (!WebSocket)\n    throw new Error("WebSocket support is not available on this platform.");\n    \n  this.ws = null;\n  this.connectedHost = null; // Read by Face.\n  this.connectedPort = null; // Read by Face.\n  this.elementReader = null;\n  this.defaultGetHostAndPort = makeShuffledGetHostAndPort\n    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu", \n      "E.ws.ndn.ucla.edu", "F.ws.ndn.ucla.edu", "G.ws.ndn.ucla.edu", "H.ws.ndn.ucla.edu", \n      "I.ws.ndn.ucla.edu", "J.ws.ndn.ucla.edu", "K.ws.ndn.ucla.edu", "L.ws.ndn.ucla.edu", \n      "M.ws.ndn.ucla.edu", "N.ws.ndn.ucla.edu"],\n     9696);\n};\n\nexports.WebSocketTransport = WebSocketTransport;\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nWebSocketTransport.prototype.connect = function(face, onopenCallback) \n{\n  this.close();\n  \n  this.ws = new WebSocket(\'ws:\' + face.host + \':\' + face.port);\n  if (LOG > 0) console.log(\'ws connection created.\');\n    this.connectedHost = face.host;\n    this.connectedPort = face.port;\n  \n  this.ws.binaryType = "arraybuffer";\n  \n  this.elementReader = new ElementReader(face);\n  var self = this;\n  this.ws.onmessage = function(ev) {\n    var result = ev.data;\n    //console.log(\'RecvHandle called.\');\n      \n    if (result == null || result == undefined || result == "") {\n      console.log(\'INVALID ANSWER\');\n    } \n    else if (result instanceof ArrayBuffer) {\n      var bytearray = new customBuf(result);\n          \n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n      \n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n    }\n  }\n  \n  this.ws.onopen = function(ev) {\n    if (LOG > 3) console.log(ev);\n    if (LOG > 3) console.log(\'ws.onopen: WebSocket connection opened.\');\n    if (LOG > 3) console.log(\'ws.onopen: ReadyState: \' + this.readyState);\n    // Face.registerPrefix will fetch the ndndid when needed.\n\n    onopenCallback();\n  }\n  \n  this.ws.onerror = function(ev) {\n    console.log(\'ws.onerror: ReadyState: \' + this.readyState);\n    console.log(ev);\n    console.log(\'ws.onerror: WebSocket error: \' + ev.data);\n  }\n  \n  this.ws.onclose = function(ev) {\n    console.log(\'ws.onclose: WebSocket connection closed.\');\n    self.ws = null;\n    \n    // Close Face when WebSocket is closed\n    face.readyStatus = 2; //Face.CLOSED\n    face.onclose();\n    //console.log("NDN.onclose event fired.");\n  }\n};\n\n/**\n * Send the Uint8Array data.\n */\nWebSocketTransport.prototype.send = function(data) \n{\n  if (this.ws != null) {\n    // If we directly use data.buffer to feed ws.send(), \n    // WebSocket may end up sending a packet with 10000 bytes of data.\n    // That is, WebSocket will flush the entire buffer\n    // regardless of the offset of the Uint8Array. So we have to create\n    // a new Uint8Array buffer with just the right size and copy the \n    // content from binaryInterest to the new buffer.\n    //    ---Wentao\n    var bytearray = new Uint8Array(data.length);\n    bytearray.set(data);\n    this.ws.send(bytearray.buffer);\n    if (LOG > 3) console.log(\'ws.send() returned.\');\n  }\n  else\n    console.log(\'WebSocket connection is not established.\');\n};\n\n/**\n * Close the connection.\n */\nWebSocketTransport.prototype.close = function()\n{\n  if (this.ws != null)\n    delete this.ws;\n}\n\n\n})()\n},{"../buffer.js":28,"../encoding/data-utils.js":21,"../encoding/element-reader.js":27,"../log.js":59}],108:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * Create a new DecodingException wrapping the given error object.\n * Call with: throw new DecodingException(new Error("message")).\n * @constructor\n * @param {string} error The exception created with new Error.\n */\nfunction DecodingException(error) \n{\n  this.message = error.message;\n  // Copy lineNumber, etc. from where new Error was called.\n  for (var prop in error)\n      this[prop] = error[prop];\n}\nDecodingException.prototype = new Error();\nDecodingException.prototype.name = "DecodingException";\n\nexports.DecodingException = DecodingException;\n\n},{}],104:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Encapsulate a customBuf and support dynamic reallocation.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a DynamicBuffer where this.array is a customBuf of size length.\n * To access the array, use this.array or call slice.\n * @constructor\n * @param {number} length the initial length of the array.  If null, use a default.\n */\nvar DynamicBuffer = function DynamicBuffer(length) \n{\n  if (!length)\n    length = 16;\n    \n  this.array = new customBuf(length);\n};\n\nexports.DynamicBuffer = DynamicBuffer;\n\n/**\n * Ensure that this.array has the length, reallocate and copy if necessary.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLength = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  this.array.copy(newArray);\n  this.array = newArray;\n};\n\n/**\n * Copy the value to this.array at offset, reallocating if necessary. \n * @param {Buffer} value The buffer to copy.\n * @param {number} offset The offset in the buffer to start copying into.\n */\nDynamicBuffer.prototype.copy = function(value, offset) \n{\n  this.ensureLength(value.length + offset);\n    \n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, offset);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, offset);\n};\n\n/**\n * Ensure that this.array has the length. If necessary, reallocate the array\n *   and shift existing data to the back of the new array.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLengthFromBack = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  // Copy to the back of newArray.\n  this.array.copy(newArray, newArray.length - this.array.length);\n  this.array = newArray;\n};\n\n/**\n * First call ensureLengthFromBack to make sure the bytearray has\n * offsetFromBack bytes, then copy value into the array starting\n * offsetFromBack bytes from the back of the array.\n * @param {Buffer} value The buffer to copy.\n * @param {offsetFromBack} offset The offset from the back of the array to start\n * copying.\n */\nDynamicBuffer.prototype.copyFromBack = function(value, offsetFromBack) \n{\n  this.ensureLengthFromBack(offsetFromBack);\n\n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, this.array.length - offsetFromBack);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, this.array.length - offsetFromBack);\n};\n\n/**\n * Return this.array.slice(begin, end);\n * @param {number} begin The begin index for the slice.\n * @param {number} end The end index for the slice.\n * @returns {Buffer} The buffer slice.\n */\nDynamicBuffer.prototype.slice = function(begin, end) \n{\n  return this.array.slice(begin, end);\n};\n\n})()\n},{"../buffer.js":28}],111:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n    // Shortcuts\n    var C = require(\'./core.js\');\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var Hasher = C_lib.Hasher;\n    var C_algo = C.algo;\n\n    // Initialization and round constants tables\n    var H = [];\n    var K = [];\n\n    // Compute constants\n    (function () {\n        function isPrime(n) {\n            var sqrtN = Math.sqrt(n);\n            for (var factor = 2; factor <= sqrtN; factor++) {\n                if (!(n % factor)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function getFractionalBits(n) {\n            return ((n - (n | 0)) * 0x100000000) | 0;\n        }\n\n        var n = 2;\n        var nPrime = 0;\n        while (nPrime < 64) {\n            if (isPrime(n)) {\n                if (nPrime < 8) {\n                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                }\n                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n                nPrime++;\n            }\n\n            n++;\n        }\n    }());\n\n    // Reusable object\n    var W = [];\n\n    /**\n     * SHA-256 hash algorithm.\n     */\n    var SHA256 = C_algo.SHA256 = Hasher.extend({\n        _doReset: function () {\n            this._hash = new WordArray.init(H.slice(0));\n        },\n\n        _doProcessBlock: function (M, offset) {\n            // Shortcut\n            var H = this._hash.words;\n\n            // Working variables\n            var a = H[0];\n            var b = H[1];\n            var c = H[2];\n            var d = H[3];\n            var e = H[4];\n            var f = H[5];\n            var g = H[6];\n            var h = H[7];\n\n            // Computation\n            for (var i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                } else {\n                    var gamma0x = W[i - 15];\n                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                                   (gamma0x >>> 3);\n\n                    var gamma1x = W[i - 2];\n                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                                   (gamma1x >>> 10);\n\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n\n                var ch  = (e & f) ^ (~e & g);\n                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n                var t1 = h + sigma1 + ch + K[i] + W[i];\n                var t2 = sigma0 + maj;\n\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n            H[4] = (H[4] + e) | 0;\n            H[5] = (H[5] + f) | 0;\n            H[6] = (H[6] + g) | 0;\n            H[7] = (H[7] + h) | 0;\n        },\n\n        _doFinalize: function () {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n\n            var nBitsTotal = this._nDataBytes * 8;\n            var nBitsLeft = data.sigBytes * 8;\n\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            data.sigBytes = dataWords.length * 4;\n\n            // Hash final blocks\n            this._process();\n\n            // Return final computed hash\n            return this._hash;\n        },\n\n        clone: function () {\n            var clone = Hasher.clone.call(this);\n            clone._hash = this._hash.clone();\n\n            return clone;\n        }\n    });\n\n    /**\n     * Shortcut function to the hasher\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     *\n     * @return {WordArray} The hash.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hash = CryptoJS.SHA256(\'message\');\n     *     var hash = CryptoJS.SHA256(wordArray);\n     */\n    C.SHA256 = Hasher._createHelper(SHA256);\n\n    /**\n     * Shortcut function to the HMAC\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     * @param {WordArray|string} key The secret key.\n     *\n     * @return {WordArray} The HMAC.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hmac = CryptoJS.HmacSHA256(message, key);\n     */\n    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\nmodule.exports = C\n\n},{"./core.js":112}],113:[function(require,module,exports){\n/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key\n//              to RSAKey class.\n//\n// version: 1.1.1 (2013-Apr-12)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n// \n//\n// Depends on:\n//\n//\n//\n// _RSApem_pemToBase64(sPEM)\n//\n//   removing PEM header, PEM footer and space characters including\n//   new lines from PEM formatted RSA private key string.\n//\nvar ASN1HEX = require(\'./asn1hex-1.1.js\')\nvar b64tohex = require(\'./base64.js\').b64tohex\nvar RSAKey = require(\'./rsa2.js\')\n/**\n * @fileOverview\n * @name rsapem-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nfunction _rsapem_pemToBase64(sPEMPrivateKey) {\n  var s = sPEMPrivateKey;\n  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");\n  s = s.replace("-----END RSA PRIVATE KEY-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {\n  var a = new Array();\n  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);\n  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);\n  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);\n  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);\n  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);\n  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);\n  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);\n  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);\n  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);\n  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);\n  return a;\n}\n\nfunction _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {\n  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);\n  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);\n  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);\n  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);\n  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);\n  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);\n  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);\n  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);\n  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);\n  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);\n  var a = new Array();\n  a.push(v, n, e, d, p, q, dp, dq, co);\n  return a;\n}\n\n/**\n * read RSA private key from a ASN.1 hexadecimal string\n * @name readPrivateKeyFromASN1HexString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.\n * @since 1.1.1\n */\nfunction _rsapem_readPrivateKeyFromASN1HexString(keyHex) {\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\n/**\n * read PKCS#1 private key from a string\n * @name readPrivateKeyFromPEMString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyPEM string of PKCS#1 private key.\n */\nfunction _rsapem_readPrivateKeyFromPEMString(keyPEM) {\n  var keyB64 = _rsapem_pemToBase64(keyPEM);\n  var keyHex = b64tohex(keyB64) // depends base64.js\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\nRSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;\nRSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;\n\nmodule.exports = RSAKey\n\n},{"./asn1hex-1.1.js":65,"./base64.js":68,"./rsa2.js":114}],105:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DynamicBuffer = require(\'../../util/dynamic-buffer.js\').DynamicBuffer;\n\n/**\n * Create a new TlvEncoder with an initialCapacity for the encoding buffer.\n * @constructor\n * @param {number} initialCapacity (optional) The initial capacity of the \n * encoding buffer. If omitted, use a default value.\n */\nvar TlvEncoder = function TlvEncoder(initialCapacity)\n{\n  initialCapacity = initialCapacity || 16;\n  this.output = new DynamicBuffer(initialCapacity);\n  // length is the number of bytes that have been written to the back of \n  //  this.output.array.\n  this.length = 0;\n};\n\nexports.TlvEncoder = TlvEncoder;\n\n/**\n * Get the number of bytes that have been written to the output.  You can\n * save this number, write sub TLVs, then subtract the new length from this\n * to get the total length of the sub TLVs.\n * @returns {number} The number of bytes that have been written to the output.\n */\nTlvEncoder.prototype.getLength = function()\n{\n  return this.length;\n};\n\n/**\n * Encode varNumber as a VAR-NUMBER in NDN-TLV and write it to this.output just \n * before this.length from the back.  Advance this.length.\n * @param {number} varNumber The non-negative number to encode.\n */\nTlvEncoder.prototype.writeVarNumber = function(varNumber)\n{\n  if (varNumber < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffff) {\n    this.length += 3;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 253;\n    this.output.array[offset + 1] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 2] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffffffff) {\n    this.length += 5;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 254;\n    this.output.array[offset + 1] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 4] = varNumber & 0xff;\n  }\n  else {\n    this.length += 9;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 255;\n    this.output.array[offset + 1] = (varNumber >> 56) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 48) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 40) & 0xff;\n    this.output.array[offset + 4] = (varNumber >> 32) & 0xff;\n    this.output.array[offset + 5] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 6] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 7] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 8] = varNumber & 0xff;\n  }\n};\n\n/**\n * Encode the type and length as VAR-NUMBER and write to this.output just before \n * this.length from the back.  Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} length The non-negative length of the TLV.\n */\nTlvEncoder.prototype.writeTypeAndLength = function(type, length)\n{\n  // Write backwards.\n  this.writeVarNumber(length);\n  this.writeVarNumber(type);\n};\n\n/**\n * Write the type, then the length of the encoded value then encode value as a \n * non-negative integer and write it to this.output just before this.length from \n * the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} value The non-negative integer to encode.\n */\nTlvEncoder.prototype.writeNonNegativeIntegerTlv = function(type, value)\n{\n  if (value < 0)\n    throw new Error("TLV integer value may not be negative");\n\n  // JavaScript doesn\'t distinguish int from float, so round.\n  value = Math.round(value)\n\n  // Write backwards.\n  var saveNBytes = this.length;\n  if (value < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = value & 0xff;\n  }\n  else if (value <= 0xffff) {\n    this.length += 2;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 8) & 0xff;\n    this.output.array[offset + 1] = value & 0xff;\n  }\n  else if (value <= 0xffffffff) {\n    this.length += 4;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 24) & 0xff;\n    this.output.array[offset + 1] = (value >> 16) & 0xff;\n    this.output.array[offset + 2] = (value >> 8) & 0xff;\n    this.output.array[offset + 3] = value & 0xff;\n  }\n  else {\n    this.length += 8;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 56) & 0xff;\n    this.output.array[offset + 1] = (value >> 48) & 0xff;\n    this.output.array[offset + 2] = (value >> 40) & 0xff;\n    this.output.array[offset + 3] = (value >> 32) & 0xff;\n    this.output.array[offset + 4] = (value >> 24) & 0xff;\n    this.output.array[offset + 5] = (value >> 16) & 0xff;\n    this.output.array[offset + 6] = (value >> 8) & 0xff;\n    this.output.array[offset + 7] = value & 0xff;\n  }\n\n  this.writeTypeAndLength(type, this.length - saveNBytes);\n};\n\n/**\n * If value is negative or null then do nothing, otherwise call \n * writeNonNegativeIntegerTlv.\n * @param {number} type The type of the TLV.\n * @param {number} value If negative or None do nothing, otherwise the integer \n *   to encode.\n */\nTlvEncoder.prototype.writeOptionalNonNegativeIntegerTlv = function(type, value)\n{\n  if (value != null && value >= 0)\n    this.writeNonNegativeIntegerTlv(type, value);\n};\n\n/**\n * Write the type, then the length of the buffer then the buffer value to \n * this.output just before this.length from the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value The byte array with the bytes of the blob.  If value is\n    null, then just write the type and length 0.\n */\nTlvEncoder.prototype.writeBlobTlv = function(type, value)\n{\n  if (value == null) {\n    this.writeTypeAndLength(type, 0);\n    return;\n  }\n\n  // Write backwards, starting with the blob array.    \n  this.length += value.length;\n  this.output.copyFromBack(value, this.length);\n\n  this.writeTypeAndLength(type, value.length);\n};\n\n/**\n * If the byte array is null or zero length then do nothing, otherwise call \n * writeBlobTlv.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value If null or zero length do nothing, otherwise the byte \n * array with the bytes of the blob.\n */\nTlvEncoder.prototype.writeOptionalBlobTlv = function(type, value)\n{\n  if (value != null && value.length > 0)\n    this.writeBlobTlv(type, value);\n};\n\n/**\n * Get a slice of the encoded bytes.\n * @returns {Buffer} A slice backed by the encoding customBuf.\n */\nTlvEncoder.prototype.getOutput = function()\n{\n  return this.output.array.slice(this.output.array.length - this.length);\n};\n\n})()\n},{"../../buffer.js":28,"../../util/dynamic-buffer.js":104}],112:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/**\n * CryptoJS core components.\n */\nvar CryptoJS = CryptoJS || (function (Math, undefined) {\n    /**\n     * CryptoJS namespace.\n     */\n    var C = {};\n\n    /**\n     * Library namespace.\n     */\n    var C_lib = C.lib = {};\n\n    /**\n     * Base object for prototypal inheritance.\n     */\n    var Base = C_lib.Base = (function () {\n        function F() {}\n\n        return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: \'value\',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function (overrides) {\n                // Spawn\n                F.prototype = this;\n                var subtype = new F();\n\n                // Augment\n                if (overrides) {\n                    subtype.mixIn(overrides);\n                }\n\n                // Create default initializer\n                if (!subtype.hasOwnProperty(\'init\')) {\n                    subtype.init = function () {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                }\n\n                // Initializer\'s prototype is the subtype object\n                subtype.init.prototype = subtype;\n\n                // Reference supertype\n                subtype.$super = this;\n\n                return subtype;\n            },\n\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function () {\n                var instance = this.extend();\n                instance.init.apply(instance, arguments);\n\n                return instance;\n            },\n\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function () {\n            },\n\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: \'value\'\n             *     });\n             */\n            mixIn: function (properties) {\n                for (var propertyName in properties) {\n                    if (properties.hasOwnProperty(propertyName)) {\n                        this[propertyName] = properties[propertyName];\n                    }\n                }\n\n                // IE won\'t copy toString using the loop above\n                if (properties.hasOwnProperty(\'toString\')) {\n                    this.toString = properties.toString;\n                }\n            },\n\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function () {\n                return this.init.prototype.extend(this);\n            }\n        };\n    }());\n\n    /**\n     * An array of 32-bit words.\n     *\n     * @property {Array} words The array of 32-bit words.\n     * @property {number} sigBytes The number of significant bytes in this word array.\n     */\n    var WordArray = C_lib.WordArray = Base.extend({\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param {Array} words (Optional) An array of 32-bit words.\n         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.create();\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n         */\n        init: function (words, sigBytes) {\n            words = this.words = words || [];\n\n            if (sigBytes != undefined) {\n                this.sigBytes = sigBytes;\n            } else {\n                this.sigBytes = words.length * 4;\n            }\n        },\n\n        /**\n         * Converts this word array to a string.\n         *\n         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {string} The stringified word array.\n         *\n         * @example\n         *\n         *     var string = wordArray + \'\';\n         *     var string = wordArray.toString();\n         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        toString: function (encoder) {\n            return (encoder || Hex).stringify(this);\n        },\n\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param {WordArray} wordArray The word array to append.\n         *\n         * @return {WordArray} This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        concat: function (wordArray) {\n            // Shortcuts\n            var thisWords = this.words;\n            var thatWords = wordArray.words;\n            var thisSigBytes = this.sigBytes;\n            var thatSigBytes = wordArray.sigBytes;\n\n            // Clamp excess bits\n            this.clamp();\n\n            // Concat\n            if (thisSigBytes % 4) {\n                // Copy one byte at a time\n                for (var i = 0; i < thatSigBytes; i++) {\n                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n                }\n            } else if (thatWords.length > 0xffff) {\n                // Copy one word at a time\n                for (var i = 0; i < thatSigBytes; i += 4) {\n                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n                }\n            } else {\n                // Copy all words at once\n                thisWords.push.apply(thisWords, thatWords);\n            }\n            this.sigBytes += thatSigBytes;\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        clamp: function () {\n            // Shortcuts\n            var words = this.words;\n            var sigBytes = this.sigBytes;\n\n            // Clamp\n            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n            words.length = Math.ceil(sigBytes / 4);\n        },\n\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return {WordArray} The clone.\n         *\n         * @example\n         *\n         *     var clone = wordArray.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone.words = this.words.slice(0);\n\n            return clone;\n        },\n\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * @param {number} nBytes The number of random bytes to generate.\n         *\n         * @return {WordArray} The random word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n         */\n        random: function (nBytes) {\n            var words = [];\n            for (var i = 0; i < nBytes; i += 4) {\n                words.push((Math.random() * 0x100000000) | 0);\n            }\n\n            return new WordArray.init(words, nBytes);\n        }\n    });\n\n    /**\n     * Encoder namespace.\n     */\n    var C_enc = C.enc = {};\n\n    /**\n     * Hex encoding strategy.\n     */\n    var Hex = C_enc.Hex = {\n        /**\n         * Converts a word array to a hex string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The hex string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var hexChars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n\n            return hexChars.join(\'\');\n        },\n\n        /**\n         * Converts a hex string to a word array.\n         *\n         * @param {string} hexStr The hex string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n         */\n        parse: function (hexStr) {\n            // Shortcut\n            var hexStrLength = hexStr.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n\n            return new WordArray.init(words, hexStrLength / 2);\n        }\n    };\n\n    /**\n     * Latin1 encoding strategy.\n     */\n    var Latin1 = C_enc.Latin1 = {\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Latin1 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var latin1Chars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n\n            return latin1Chars.join(\'\');\n        },\n\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * @param {string} latin1Str The Latin1 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n         */\n        parse: function (latin1Str) {\n            // Shortcut\n            var latin1StrLength = latin1Str.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n\n            return new WordArray.init(words, latin1StrLength);\n        }\n    };\n\n    /**\n     * UTF-8 encoding strategy.\n     */\n    var Utf8 = C_enc.Utf8 = {\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The UTF-8 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            } catch (e) {\n                throw new Error(\'Malformed UTF-8 data\');\n            }\n        },\n\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * @param {string} utf8Str The UTF-8 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n         */\n        parse: function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        }\n    };\n\n    /**\n     * Abstract buffered block algorithm template.\n     *\n     * The property blockSize must be implemented in a concrete subtype.\n     *\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n     */\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n        /**\n         * Resets this block algorithm\'s data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        reset: function () {\n            // Initial values\n            this._data = new WordArray.init();\n            this._nDataBytes = 0;\n        },\n\n        /**\n         * Adds new data to this block algorithm\'s buffer.\n         *\n         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append(\'data\');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        _append: function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data == \'string\') {\n                data = Utf8.parse(data);\n            }\n\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        },\n\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {WordArray} The processed data.\n         *\n         * @example\n         *\n         *     var processedData = bufferedBlockAlgorithm._process();\n         *     var processedData = bufferedBlockAlgorithm._process(!!\'flush\');\n         */\n        _process: function (doFlush) {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n            var dataSigBytes = data.sigBytes;\n            var blockSize = this.blockSize;\n            var blockSizeBytes = blockSize * 4;\n\n            // Count blocks ready\n            var nBlocksReady = dataSigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            } else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n\n            // Count words ready\n            var nWordsReady = nBlocksReady * blockSize;\n\n            // Count bytes ready\n            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n            // Process blocks\n            if (nWordsReady) {\n                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                }\n\n                // Remove processed words\n                var processedWords = dataWords.splice(0, nWordsReady);\n                data.sigBytes -= nBytesReady;\n            }\n\n            // Return processed words\n            return new WordArray.init(processedWords, nBytesReady);\n        },\n\n        /**\n         * Creates a copy of this object.\n         *\n         * @return {Object} The clone.\n         *\n         * @example\n         *\n         *     var clone = bufferedBlockAlgorithm.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone._data = this._data.clone();\n\n            return clone;\n        },\n\n        _minBufferSize: 0\n    });\n\n    /**\n     * Abstract hasher template.\n     *\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n     */\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n        /**\n         * Configuration options.\n         */\n        cfg: Base.extend(),\n\n        /**\n         * Initializes a newly created hasher.\n         *\n         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n         *\n         * @example\n         *\n         *     var hasher = CryptoJS.algo.SHA256.create();\n         */\n        init: function (cfg) {\n            // Apply config defaults\n            this.cfg = this.cfg.extend(cfg);\n\n            // Set initial values\n            this.reset();\n        },\n\n        /**\n         * Resets this hasher to its initial state.\n         *\n         * @example\n         *\n         *     hasher.reset();\n         */\n        reset: function () {\n            // Reset data buffer\n            BufferedBlockAlgorithm.reset.call(this);\n\n            // Perform concrete-hasher logic\n            this._doReset();\n        },\n\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param {WordArray|string} messageUpdate The message to append.\n         *\n         * @return {Hasher} This hasher.\n         *\n         * @example\n         *\n         *     hasher.update(\'message\');\n         *     hasher.update(wordArray);\n         */\n        update: function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n\n            // Update the hash\n            this._process();\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n         *\n         * @return {WordArray} The hash.\n         *\n         * @example\n         *\n         *     var hash = hasher.finalize();\n         *     var hash = hasher.finalize(\'message\');\n         *     var hash = hasher.finalize(wordArray);\n         */\n        finalize: function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n\n            // Perform concrete-hasher logic\n            var hash = this._doFinalize();\n\n            return hash;\n        },\n\n        blockSize: 512/32,\n\n        /**\n         * Creates a shortcut function to a hasher\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to create a helper for.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n         */\n        _createHelper: function (hasher) {\n            return function (message, cfg) {\n                return new hasher.init(cfg).finalize(message);\n            };\n        },\n\n        /**\n         * Creates a shortcut function to the HMAC\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n         */\n        _createHmacHelper: function (hasher) {\n            return function (message, key) {\n                return new C_algo.HMAC.init(hasher, key).finalize(message);\n            };\n        }\n    });\n\n    /**\n     * Algorithm namespace.\n     */\n    var C_algo = C.algo = {};\n\n    return C;\n}(Math));\n\nmodule.exports = CryptoJS\n\n},{}],65:[function(require,module,exports){\n/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// asn1hex.js - Hexadecimal represented ASN.1 string library\n//\n// version: 1.1 (09-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n//\n// Depends on:\n//\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n// MEMO:\n//   f(\'3082025b02...\', 2) ... 82025b ... 3bytes\n//   f(\'020100\', 2) ... 01 ... 1byte\n//   f(\'0203001...\', 2) ... 03 ... 1byte\n//   f(\'02818003...\', 2) ... 8180 ... 2bytes\n//   f(\'3080....0000\', 2) ... 80 ... -1\n//\n//   Requirements:\n//   - ASN.1 type octet length MUST be 1. \n//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)\n//   - \n\n/**\n * @fileOverview\n * @name asn1hex-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * get byte length for ASN.1 L(length) bytes\n * @name getByteLengthOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return byte length for ASN.1 L(length) bytes\n */\nfunction _asnhex_getByteLengthOfL_AtObj(s, pos) {\n  if (s.substring(pos + 2, pos + 3) != \'8\') return 1;\n  var i = parseInt(s.substring(pos + 3, pos + 4));\n  if (i == 0) return -1; \t\t// length octet \'80\' indefinite length\n  if (0 < i && i < 10) return i + 1;\t// including \'8?\' octet;\n  return -2;\t\t\t\t// malformed format\n}\n\n\n/**\n * get hexadecimal string for ASN.1 L(length) bytes\n * @name getHexOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string for ASN.1 L(length) bytes\n */\nfunction _asnhex_getHexOfL_AtObj(s, pos) {\n  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (len < 1) return \'\';\n  return s.substring(pos + 2, pos + 2 + len * 2);\n}\n\n//\n//   getting ASN.1 length value at the position \'idx\' of\n//   hexa decimal string \'s\'.\n//\n//   f(\'3082025b02...\', 0) ... 82025b ... ???\n//   f(\'020100\', 0) ... 01 ... 1\n//   f(\'0203001...\', 0) ... 03 ... 3\n//   f(\'02818003...\', 0) ... 8180 ... 128\n/**\n * get integer value of ASN.1 length for ASN.1 data\n * @name getIntOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return ASN.1 L(length) integer value\n */\nfunction _asnhex_getIntOfL_AtObj(s, pos) {\n  var hLength = _asnhex_getHexOfL_AtObj(s, pos);\n  if (hLength == \'\') return -1;\n  var bi;\n  if (parseInt(hLength.substring(0, 1)) < 8) {\n     bi = parseBigInt(hLength, 16);\n  } else {\n     bi = parseBigInt(hLength.substring(2), 16);\n  }\n  return bi.intValue();\n}\n\n/**\n * get ASN.1 value starting string position for ASN.1 object refered by index \'idx\'.\n * @name getStartPosOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n */\nfunction _asnhex_getStartPosOfV_AtObj(s, pos) {\n  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (l_len < 0) return l_len;\n  return pos + (l_len + 1) * 2;\n}\n\n/**\n * get hexadecimal string of ASN.1 V(value)\n * @name getHexOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 value.\n */\nfunction _asnhex_getHexOfV_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return s.substring(pos1, pos1 + len * 2);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV at\n * @name getHexOfTLV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 TLV.\n * @since 1.1\n */\nfunction _asnhex_getHexOfTLV_AtObj(s, pos) {\n  var hT = s.substr(pos, 2);\n  var hL = _asnhex_getHexOfL_AtObj(s, pos);\n  var hV = _asnhex_getHexOfV_AtObj(s, pos);\n  return hT + hL + hV;\n}\n\n/**\n * get next sibling starting index for ASN.1 object string\n * @name getPosOfNextSibling_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return next sibling starting index for ASN.1 object string\n */\nfunction _asnhex_getPosOfNextSibling_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return pos1 + len * 2;\n}\n\n/**\n * get array of indexes of child ASN.1 objects\n * @name getPosArrayOfChildren_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} start string index of ASN.1 object\n * @return {Array of Number} array of indexes for childen of ASN.1 objects\n */\nfunction _asnhex_getPosArrayOfChildren_AtObj(h, pos) {\n  var a = new Array();\n  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);\n  a.push(p0);\n\n  var len = _asnhex_getIntOfL_AtObj(h, pos);\n  var p = p0;\n  var k = 0;\n  while (1) {\n    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);\n    if (pNext == null || (pNext - p0  >= (len * 2))) break;\n    if (k >= 200) break;\n\n    a.push(pNext);\n    p = pNext;\n\n    k++;\n  }\n\n  return a;\n}\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getNthChildIndex_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} idx start string index of ASN.1 object\n * @param {Number} nth for child\n * @return {Number} string index of nth child.\n * @since 1.1\n */\nfunction _asnhex_getNthChildIndex_AtObj(h, idx, nth) {\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);\n  return a[nth];\n}\n\n// ========== decendant methods ==============================\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getDecendantIndexByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} string index refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {\n  if (nthList.length == 0) {\n    return currentIndex;\n  }\n  var firstNth = nthList.shift();\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);\n  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.\n * @name getDecendantHexTLVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfTLV_AtObj(h, idx);\n}\n\n/**\n * get hexadecimal string of ASN.1 V refered by current index and nth index list.\n * @name getDecendantHexVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 V refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfV_AtObj(h, idx);\n}\n\n// ========== class definition ==============================\n\n/**\n * ASN.1 DER encoded hexadecimal string utility class\n * @class ASN.1 DER encoded hexadecimal string utility class\n * @author Kenji Urushima\n * @version 1.1 (09 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n * @since 1.1\n */\nfunction ASN1HEX() {\n  return ASN1HEX;\n}\n\nASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;\nASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;\nASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;\nASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;\nASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;\nASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;\nASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;\nASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;\nASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;\nASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;\nASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;\nASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;\n\nmodule.exports = ASN1HEX;\n\n},{"jsbn":115}],66:[function(require,module,exports){\n/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-sign.js - adding signing functions to RSAKey class.\n//\n//\n// version: 1.2.2 (13 May 2013)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n\n//\n// Depends on:\n//   function sha1.hex(s) of sha1.js\n//   jsbn.js\n//   jsbn2.js\n//   rsa.js\n//   rsa2.js\n//\nvar BigInteger = require(\'jsbn\')\nvar RSAKey= require(\'./rsapem-1.1.js\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// keysize / pmstrlen\n//  512 /  128\n// 1024 /  256\n// 2048 /  512\n// 4096 / 1024\n\n/**\n * @fileOverview\n * @name rsasign-1.2.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * @property {Dictionary} _RSASIGN_DIHEAD\n * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.\n * You can add any DigestInfo hash algorith for signing.\n * See PKCS#1 v2.1 spec (p38).\n */\nvar _RSASIGN_DIHEAD = [];\n_RSASIGN_DIHEAD[\'sha1\'] =      "3021300906052b0e03021a05000414";\n_RSASIGN_DIHEAD[\'sha256\'] =    "3031300d060960864801650304020105000420";\n_RSASIGN_DIHEAD[\'sha384\'] =    "3041300d060960864801650304020205000430";\n_RSASIGN_DIHEAD[\'sha512\'] =    "3051300d060960864801650304020305000440";\n_RSASIGN_DIHEAD[\'md2\'] =       "3020300c06082a864886f70d020205000410";\n_RSASIGN_DIHEAD[\'md5\'] =       "3020300c06082a864886f70d020505000410";\n_RSASIGN_DIHEAD[\'ripemd160\'] = "3021300906052b2403020105000414";\n\n/**\n * @property {Dictionary} _RSASIGN_HASHHEXFUNC\n * @description Array of functions which calculate hash and returns it as hexadecimal.\n * You can add any hash algorithm implementations.\n */\nvar _RSASIGN_HASHHEXFUNC = [];\n_RSASIGN_HASHHEXFUNC[\'sha1\'] =      function(s){return KJUR.crypto.Util.sha1(s);};\n_RSASIGN_HASHHEXFUNC[\'sha256\'] =    function(s){return KJUR.crypto.Util.sha256(s);}\n_RSASIGN_HASHHEXFUNC[\'sha512\'] =    function(s){return KJUR.crypto.Util.sha512(s);}\n_RSASIGN_HASHHEXFUNC[\'md5\'] =       function(s){return KJUR.crypto.Util.md5(s);};\n_RSASIGN_HASHHEXFUNC[\'ripemd160\'] = function(s){return KJUR.crypto.Util.ripemd160(s);};\n\n//_RSASIGN_HASHHEXFUNC[\'sha1\'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n//_RSASIGN_HASHHEXFUNC[\'sha256\'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n\nvar _RE_HEXDECONLY = new RegExp("");\n_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");\n\n// ========================================================================\n// Signature Generation\n// ========================================================================\n\nfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n    var pmStrLen = keySize / 4;\n    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];\n    var sHashHex = hashFunc(s);\n\n    var sHead = "0001";\n    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;\n    var sMid = "";\n    var fLen = pmStrLen - sHead.length - sTail.length;\n    for (var i = 0; i < fLen; i += 2) {\n\tsMid += "ff";\n    }\n    sPaddedMessageHex = sHead + sMid + sTail;\n    return sPaddedMessageHex;\n}\n\nfunction _zeroPaddingOfSignature(hex, bitLength) {\n    var s = "";\n    var nZero = bitLength / 4 - hex.length;\n    for (var i = 0; i < nZero; i++) {\n\ts = s + "0";\n    }\n    return s + hex;\n}\n\n/**\n * sign for a message string with RSA private key.<br/>\n * @name signString\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signString(s, hashAlg) {\n    //alert("this.n.bitLength() = " + this.n.bitLength());\n    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);\n    var biPaddedMessage = parseBigInt(hPM, 16);\n    var biSign = this.doPrivate(biPaddedMessage);\n    var hexSign = biSign.toString(16);\n    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n}\n\nfunction _rsasign_signStringWithSHA1(s) {\n    return _rsasign_signString.call(this, s, \'sha1\');\n}\n\nfunction _rsasign_signStringWithSHA256(s) {\n    return _rsasign_signString.call(this, s, \'sha256\');\n}\n\n// PKCS#1 (PSS) mask generation function\nfunction pss_mgf1_str(seed, len, hash) {\n    var mask = \'\', i = 0;\n\n    while (mask.length < len) {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(s);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var salt = \'\';\n\n    if (sLen > 0) {\n        salt = new Array(sLen);\n        new SecureRandom().nextBytes(salt);\n        salt = String.fromCharCode.apply(String, salt);\n    }\n\n    var H = hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash + salt);\n    var PS = [];\n\n    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n        PS[i] = 0x00;\n    }\n\n    var DB = String.fromCharCode.apply(String, PS) + \'\\x01\' + salt;\n    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n    maskedDB[0] &= ~mask;\n\n    for (i = 0; i < hLen; i++) {\n        maskedDB.push(H.charCodeAt(i));\n    }\n\n    maskedDB.push(0xbc);\n\n    return _zeroPaddingOfSignature(\n            this.doPrivate(new BigInteger(maskedDB)).toString(16),\n            this.n.bitLength());\n}\n\n// ========================================================================\n// Signature Verification\n// ========================================================================\n\nfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n    var rsa = new RSAKey();\n    rsa.setPublic(hN, hE);\n    var biDecryptedSig = rsa.doPublic(biSig);\n    return biDecryptedSig;\n}\n\nfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    return hDigestInfo;\n}\n\nfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n    for (var algName in _RSASIGN_DIHEAD) {\n\tvar head = _RSASIGN_DIHEAD[algName];\n\tvar len = head.length;\n\tif (hDigestInfo.substring(0, len) == head) {\n\t    var a = [algName, hDigestInfo.substring(len)];\n\t    return a;\n\t}\n    }\n    return [];\n}\n\nfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\nfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n    var biSig = parseBigInt(hSig, 16);\n    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t  this.e.toString(16));\n    return result;\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyString\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyString(sMsg, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, \'\');\n    if (hSig.length != this.n.bitLength() / 4) return 0;\n    hSig = hSig.replace(/[ \\n]+/g, "");\n    var biSig = parseBigInt(hSig, 16);\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n  \n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n    if (hSig.length !== this.n.bitLength() / 4) {\n        return false;\n    }\n\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(sMsg);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();\n\n    for (i = 0; i < em.length; i += 1) {\n        em[i] &= 0xff;\n    }\n\n    while (em.length < emLen) {\n        em.unshift(0);\n    }\n\n    if (em[emLen -1] !== 0xbc) {\n        throw "encoded message does not end in 0xbc";\n    }\n\n    em = String.fromCharCode.apply(String, em);\n\n    var maskedDB = em.substr(0, emLen - hLen - 1);\n    var H = em.substr(maskedDB.length, hLen);\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n        throw "bits beyond keysize not zero";\n    }\n\n    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1) {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB[0] &= ~mask;\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i += 1) {\n        if (DB[i] !== 0x00) {\n            throw "leftmost octets not zero";\n        }\n    }\n\n    if (DB[checkLen] !== 0x01) {\n        throw "0x01 marker not found";\n    }\n\n    return H === hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash +\n                          String.fromCharCode.apply(String, DB.slice(-sLen)));\n}\n\nRSAKey.prototype.signString = _rsasign_signString;\nRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.sign = _rsasign_signString;\nRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\nRSAKey.prototype.signPSS = _rsasign_signStringPSS;\nRSAKey.SALT_LEN_HLEN = -1;\nRSAKey.SALT_LEN_MAX = -2;\n\nRSAKey.prototype.verifyString = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verify = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\nRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\nRSAKey.SALT_LEN_RECOVER = -2;\n\n/**\n * @name RSAKey\n * @class key of RSA public key algorithm\n * @description Tom Wu\'s RSA Key class and extension\n */\n\nmodule.exports = RSAKey\n\n},{"./rsapem-1.1.js":113,"jsbn":115}],67:[function(require,module,exports){\n/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * crypto.js - Cryptographic Algorithm Provider class\n *\n * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name crypto-1.0.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.0.4 (2013-Mar-28)\n * @since 2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nvar CryptoJS = require(\'./sha256.js\')\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n/** \n * kjur\'s class library name space\n * @name KJUR\n * @namespace kjur\'s class library name space\n */\nif (typeof KJUR == "undefined" || !KJUR) KJUR = {};\n/**\n * kjur\'s cryptographic algorithm provider library name space\n * <p>\n * This namespace privides following crytpgrahic classes.\n * <ul>\n * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.crypto\n * @namespace\n */\nif (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.Util\n * @class static object for cryptographic function utilities\n * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n * @description\n */\nKJUR.crypto.Util = new function() {\n    this.DIGESTINFOHEAD = {\n\t\'sha1\':      "3021300906052b0e03021a05000414",\n        \'sha224\':    "302d300d06096086480165030402040500041c",\n\t\'sha256\':    "3031300d060960864801650304020105000420",\n\t\'sha384\':    "3041300d060960864801650304020205000430",\n\t\'sha512\':    "3051300d060960864801650304020305000440",\n\t\'md2\':       "3020300c06082a864886f70d020205000410",\n\t\'md5\':       "3020300c06082a864886f70d020505000410",\n\t\'ripemd160\': "3021300906052b2403020105000414"\n    };\n\n    /**\n     * get hexadecimal DigestInfo\n     * @name getDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n     */\n    this.getDigestInfoHex = function(hHash, alg) {\n\tif (typeof this.DIGESTINFOHEAD[alg] == "undefined")\n\t    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;\n\treturn this.DIGESTINFOHEAD[alg] + hHash;\n    };\n\n    /**\n     * get PKCS#1 padded hexadecimal DigestInfo\n     * @name getPaddedDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @param {Integer} keySize key bit length (ex. 1024)\n     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n     */\n    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\tvar pmStrLen = keySize / 4; // minimum PM length\n\n\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;\n\n\tvar hHead = "0001";\n\tvar hTail = "00" + hDigestInfo;\n\tvar hMid = "";\n\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\tfor (var i = 0; i < fLen; i += 2) {\n\t    hMid += "ff";\n\t}\n\tvar hPaddedMessage = hHead + hMid + hTail;\n\treturn hPaddedMessage;\n    };\n\n    /**\n     * get hexadecimal SHA1 hash of string\n     * @name sha1\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha1 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha1\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA256 hash of string\n     * @name sha256\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha256 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha256\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA512 hash of string\n     * @name sha512\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha512 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha512\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal MD5 hash of string\n     * @name md5\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.md5 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'md5\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal RIPEMD160 hash of string\n     * @name ripemd160\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.ripemd160 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'ripemd160\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n};\n\n/**\n * MessageDigest class which is very similar to java.security.MessageDigest class\n * @name KJUR.crypto.MessageDigest\n * @class MessageDigest class which is very similar to java.security.MessageDigest class\n * @param {Array} params parameters for constructor\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>md5 - cryptojs</li>\n * <li>sha1 - cryptojs</li>\n * <li>sha224 - cryptojs</li>\n * <li>sha256 - cryptojs</li>\n * <li>sha384 - cryptojs</li>\n * <li>sha512 - cryptojs</li>\n * <li>ripemd160 - cryptojs</li>\n * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n * </ul>\n * @example\n * // CryptoJS provider sample\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n *\n * // SJCL(Stanford JavaScript Crypto Library) provider sample\n * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n */\nKJUR.crypto.MessageDigest = function(params) {\n    var md = null;\n    var algName = null;\n    var provName = null;\n    var _CryptoJSMdName = {\n\t\'md5\': \'CryptoJS.algo.MD5\',\n\t\'sha1\': \'CryptoJS.algo.SHA1\',\n\t\'sha224\': \'CryptoJS.algo.SHA224\',\n\t\'sha256\': \'CryptoJS.algo.SHA256\',\n\t\'sha384\': \'CryptoJS.algo.SHA384\',\n\t\'sha512\': \'CryptoJS.algo.SHA512\',\n\t\'ripemd160\': \'CryptoJS.algo.RIPEMD160\'\n    };\n\n    /**\n     * set hash algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} alg hash algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * // for SHA1\n     * md.setAlgAndProvider(\'sha1\', \'cryptojs\');\n     * // for RIPEMD160\n     * md.setAlgAndProvider(\'ripemd160\', \'cryptojs\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(alg) != -1 &&\n\t    prov == \'cryptojs\') {\n\t    try {\n\t\tthis.md = eval(_CryptoJSMdName[alg]).create();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.md.update(wHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n\tif (\':sha256:\'.indexOf(alg) != -1 &&\n\t    prov == \'sjcl\') {\n\t    try {\n\t\tthis.md = new sjcl.hash.sha256();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\tthis.md.update(baHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn sjcl.codec.hex.fromBits(hash);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString(\'New York\');\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex(\'0afe36\');\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name digest\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.digest = function() {\n\tthrow "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name digestString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString(\'aaa\')\n     */\n    this.digestString = function(str) {\n\tthrow "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, then completes the digest computation\n     * @name digestHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex(\'0f2abd\')\n     */\n    this.digestHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t}\n    }\n};\n\n\n/**\n * Signature class which is very similar to java.security.Signature class\n * @name KJUR.crypto.Signature\n * @class Signature class which is very similar to java.security.Signature class\n * @param {Array} params parameters for constructor\n * @property {String} state Current state of this signature object whether \'SIGN\', \'VERIFY\' or null\n * @description\n * <br/>\n * As for params of constructor\'s argument, it can be specify following attributes:\n * <ul>\n * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>\n * <li>provider - currently \'cryptojs/jsrsa\' only</li>\n * <li>prvkeypem - PEM string of signer\'s private key. If this specified, no need to call initSign(prvKey).</li>\n * </ul>\n * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}\n * withRSA algorithm in \'cryptojs/jsrsa\' provider.\n * <h4>EXAMPLES</h4>\n * @example\n * // signature generation\n * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig.initSign(prvKey);\n * sig.updateString(\'aaa\');\n * var hSigVal = sig.sign();\n *\n * // signature validation\n * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig2.initVerifyByCertificatePEM(cert)\n * sig.updateString(\'aaa\');\n * var isValid = sig2.verify(hSigVal);\n */\nKJUR.crypto.Signature = function(params) {\n    var prvKey = null; // RSAKey for signing\n    var pubKey = null; // RSAKey for verifying\n\n    var md = null; // KJUR.crypto.MessageDigest object\n    var sig = null;\n    var algName = null;\n    var provName = null;\n    var algProvName = null;\n    var mdAlgName = null;\n    var pubkeyAlgName = null;\n    var state = null;\n\n    var sHashHex = null; // hex hash value for hex\n    var hDigestInfo = null;\n    var hPaddedDigestInfo = null;\n    var hSign = null;\n\n    this._setAlgNames = function() {\n\tif (this.algName.match(/^(.+)with(.+)$/)) {\n\t    this.mdAlgName = RegExp.$1.toLowerCase();\n\t    this.pubkeyAlgName = RegExp.$2.toLowerCase();\n\t}\n    };\n\n    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\tvar s = "";\n\tvar nZero = bitLength / 4 - hex.length;\n\tfor (var i = 0; i < nZero; i++) {\n\t    s = s + "0";\n\t}\n\treturn s + hex;\n    };\n\n    /**\n     * set signature algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} alg signature algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * md.setAlgAndProvider(\'SHA1withRSA\', \'cryptojs/jsrsa\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tthis._setAlgNames();\n\tif (prov != \'cryptojs/jsrsa\')\n\t    throw "provider not supported: " + prov;\n\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(this.mdAlgName) != -1) {\n\t    try {\n\t\tthis.md = new KJUR.crypto.MessageDigest({\'alg\':this.mdAlgName,\'prov\':\'cryptojs\'});\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;\n\t    }\n\n\t    this.initSign = function(prvKey) {\n\t\tthis.prvKey = prvKey;\n\t\tthis.state = "SIGN";\n\t    };\n\n\t    this.initVerifyByPublicKey = function(rsaPubKey) {\n\t\tthis.pubKey = rsaPubKey;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tvar x509 = new X509();\n\t\tx509.readCertPEM(certPEM);\n\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.updateString = function(str) {\n\t\tthis.md.updateString(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tthis.md.updateHex(hex);\n\t    };\n\t    this.sign = function() {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.prvKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\t\tthis.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);\n\t\tthis.hPaddedDigestInfo = \n                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);\n\n\t\tvar biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);\n\t\tthis.hoge = biPaddedDigestInfo.toString(16);\n\n\t\tvar biSign = this.prvKey.doPrivate(biPaddedDigestInfo);\n\t\tthis.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);\n\t\treturn this.hSign;\n\t    };\n\t    this.signString = function(str) {\n\t\tthis.updateString(str);\n\t\tthis.sign();\n\t    };\n\t    this.signHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\tthis.sign();\n\t    };\n\t    this.verify = function(hSigVal) {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.pubKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\n\t\tvar biSigVal = parseBigInt(hSigVal, 16);\n\t\tvar biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);\n\t\tthis.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);\n                var s = this.hPaddedDigestInfo;\n                s = s.replace(/^1ff+00/, \'\');\n\n\t\tvar hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];\n                if (s.indexOf(hDIHEAD) != 0) {\n\t\t    return false;\n\t\t}\n\t\tvar hHashFromDI = s.substr(hDIHEAD.length);\n\t\t//alert(hHashFromDI + "\\n" + this.sHashHex);\n\t\treturn (hHashFromDI == this.sHashHex);\n\t    };\n\t}\n    };\n\n    /**\n     * Initialize this object for verifying with a public key\n     * @name initVerifyByPublicKey\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} rsaPubKey RSAKey object of public key\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByPublicKey(prvKey)\n     */\n    this.initVerifyByPublicKey = function(rsaPubKey) {\n\tthrow "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a certficate\n     * @name initVerifyByCertificatePEM\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} certPEM PEM formatted string of certificate\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByCertificatePEM(certPEM)\n     */\n    this.initVerifyByCertificatePEM = function(certPEM) {\n\tthrow "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for signing\n     * @name initSign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} prvKey RSAKey object of private key\n     * @description\n     * @example\n     * sig.initSign(prvKey)\n     */\n    this.initSign = function(prvKey) {\n\tthrow "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a string\n     * @name updateString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to use for the update\n     * @description\n     * @example\n     * sig.updateString(\'aaa\')\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to use for the update\n     * @description\n     * @example\n     * sig.updateHex(\'1f2f3f\')\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Returns the signature bytes of all data updates as a hexadecimal string\n     * @name sign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @return the signature bytes as a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.sign()\n     */\n    this.sign = function() {\n\tthrow "sign() not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signString(\'aaa\')\n     */\n    this.signString = function(str) {\n\tthrow "digestString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signHex(\'1fdc33\')\n     */\n    this.signHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * verifies the passed-in signature.\n     * @name verify\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return {Boolean} true if the signature was verified, otherwise false\n     * @description\n     * @example\n     * var isValid = sig.verify(\'1fbcefdca4823a7(snip)\')\n     */\n    this.verify = function(hSigVal) {\n\tthrow "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.algProvName = params[\'alg\'] + ":" + params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t    this._setAlgNames();\n\t}\n\tif (typeof params[\'prvkeypem\'] != "undefined") {\n\t    if (typeof params[\'prvkeypas\'] != "undefined") {\n\t\tthrow "both prvkeypem and prvkeypas parameters not supported";\n\t    } else {\n\t\ttry {\n\t\t    var prvKey = new RSAKey();\n\t\t    prvKey.readPrivateKeyFromPEMString(params[\'prvkeypem\']);\n\t\t    this.initSign(prvKey);\n\t\t} catch (ex) {\n\t\t    throw "fatal error to load pem private key: " + ex;\n\t\t}\n\t    }\n\t}\n    }\n};\nmodule.exports = KJUR\n\n},{"./sha256.js":111,"jsbn":115}],107:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar ElementReader = require(\'../encoding/element-reader.js\').ElementReader;\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n\nfunction makeShuffledGetHostAndPort (hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n\n/**\n * @constructor\n */\nvar WebSocketTransport = function WebSocketTransport() \n{    \n  if (!WebSocket)\n    throw new Error("WebSocket support is not available on this platform.");\n    \n  this.ws = null;\n  this.connectedHost = null; // Read by Face.\n  this.connectedPort = null; // Read by Face.\n  this.elementReader = null;\n  this.defaultGetHostAndPort = makeShuffledGetHostAndPort\n    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu", \n      "E.ws.ndn.ucla.edu", "F.ws.ndn.ucla.edu", "G.ws.ndn.ucla.edu", "H.ws.ndn.ucla.edu", \n      "I.ws.ndn.ucla.edu", "J.ws.ndn.ucla.edu", "K.ws.ndn.ucla.edu", "L.ws.ndn.ucla.edu", \n      "M.ws.ndn.ucla.edu", "N.ws.ndn.ucla.edu"],\n     9696);\n};\n\nexports.WebSocketTransport = WebSocketTransport;\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nWebSocketTransport.prototype.connect = function(face, onopenCallback) \n{\n  this.close();\n  \n  this.ws = new WebSocket(\'ws:\' + face.host + \':\' + face.port);\n  if (LOG > 0) console.log(\'ws connection created.\');\n    this.connectedHost = face.host;\n    this.connectedPort = face.port;\n  \n  this.ws.binaryType = "arraybuffer";\n  \n  this.elementReader = new ElementReader(face);\n  var self = this;\n  this.ws.onmessage = function(ev) {\n    var result = ev.data;\n    //console.log(\'RecvHandle called.\');\n      \n    if (result == null || result == undefined || result == "") {\n      console.log(\'INVALID ANSWER\');\n    } \n    else if (result instanceof ArrayBuffer) {\n      var bytearray = new customBuf(result);\n          \n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n      \n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n    }\n  }\n  \n  this.ws.onopen = function(ev) {\n    if (LOG > 3) console.log(ev);\n    if (LOG > 3) console.log(\'ws.onopen: WebSocket connection opened.\');\n    if (LOG > 3) console.log(\'ws.onopen: ReadyState: \' + this.readyState);\n    // Face.registerPrefix will fetch the ndndid when needed.\n\n    onopenCallback();\n  }\n  \n  this.ws.onerror = function(ev) {\n    console.log(\'ws.onerror: ReadyState: \' + this.readyState);\n    console.log(ev);\n    console.log(\'ws.onerror: WebSocket error: \' + ev.data);\n  }\n  \n  this.ws.onclose = function(ev) {\n    console.log(\'ws.onclose: WebSocket connection closed.\');\n    self.ws = null;\n    \n    // Close Face when WebSocket is closed\n    face.readyStatus = 2; //Face.CLOSED\n    face.onclose();\n    //console.log("NDN.onclose event fired.");\n  }\n};\n\n/**\n * Send the Uint8Array data.\n */\nWebSocketTransport.prototype.send = function(data) \n{\n  if (this.ws != null) {\n    // If we directly use data.buffer to feed ws.send(), \n    // WebSocket may end up sending a packet with 10000 bytes of data.\n    // That is, WebSocket will flush the entire buffer\n    // regardless of the offset of the Uint8Array. So we have to create\n    // a new Uint8Array buffer with just the right size and copy the \n    // content from binaryInterest to the new buffer.\n    //    ---Wentao\n    var bytearray = new Uint8Array(data.length);\n    bytearray.set(data);\n    this.ws.send(bytearray.buffer);\n    if (LOG > 3) console.log(\'ws.send() returned.\');\n  }\n  else\n    console.log(\'WebSocket connection is not established.\');\n};\n\n/**\n * Close the connection.\n */\nWebSocketTransport.prototype.close = function()\n{\n  if (this.ws != null)\n    delete this.ws;\n}\n\n\n})()\n},{"../buffer.js":50,"../encoding/data-utils.js":43,"../encoding/element-reader.js":49,"../log.js":83}],109:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Encapsulate a customBuf and support dynamic reallocation.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a DynamicBuffer where this.array is a customBuf of size length.\n * To access the array, use this.array or call slice.\n * @constructor\n * @param {number} length the initial length of the array.  If null, use a default.\n */\nvar DynamicBuffer = function DynamicBuffer(length) \n{\n  if (!length)\n    length = 16;\n    \n  this.array = new customBuf(length);\n};\n\nexports.DynamicBuffer = DynamicBuffer;\n\n/**\n * Ensure that this.array has the length, reallocate and copy if necessary.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLength = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  this.array.copy(newArray);\n  this.array = newArray;\n};\n\n/**\n * Copy the value to this.array at offset, reallocating if necessary. \n * @param {Buffer} value The buffer to copy.\n * @param {number} offset The offset in the buffer to start copying into.\n */\nDynamicBuffer.prototype.copy = function(value, offset) \n{\n  this.ensureLength(value.length + offset);\n    \n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, offset);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, offset);\n};\n\n/**\n * Ensure that this.array has the length. If necessary, reallocate the array\n *   and shift existing data to the back of the new array.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLengthFromBack = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  // Copy to the back of newArray.\n  this.array.copy(newArray, newArray.length - this.array.length);\n  this.array = newArray;\n};\n\n/**\n * First call ensureLengthFromBack to make sure the bytearray has\n * offsetFromBack bytes, then copy value into the array starting\n * offsetFromBack bytes from the back of the array.\n * @param {Buffer} value The buffer to copy.\n * @param {offsetFromBack} offset The offset from the back of the array to start\n * copying.\n */\nDynamicBuffer.prototype.copyFromBack = function(value, offsetFromBack) \n{\n  this.ensureLengthFromBack(offsetFromBack);\n\n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, this.array.length - offsetFromBack);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, this.array.length - offsetFromBack);\n};\n\n/**\n * Return this.array.slice(begin, end);\n * @param {number} begin The begin index for the slice.\n * @param {number} end The end index for the slice.\n * @returns {Buffer} The buffer slice.\n */\nDynamicBuffer.prototype.slice = function(begin, end) \n{\n  return this.array.slice(begin, end);\n};\n\n})()\n},{"../buffer.js":50}],116:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n    // Shortcuts\n    var C = require(\'./core.js\');\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var Hasher = C_lib.Hasher;\n    var C_algo = C.algo;\n\n    // Initialization and round constants tables\n    var H = [];\n    var K = [];\n\n    // Compute constants\n    (function () {\n        function isPrime(n) {\n            var sqrtN = Math.sqrt(n);\n            for (var factor = 2; factor <= sqrtN; factor++) {\n                if (!(n % factor)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function getFractionalBits(n) {\n            return ((n - (n | 0)) * 0x100000000) | 0;\n        }\n\n        var n = 2;\n        var nPrime = 0;\n        while (nPrime < 64) {\n            if (isPrime(n)) {\n                if (nPrime < 8) {\n                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                }\n                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n                nPrime++;\n            }\n\n            n++;\n        }\n    }());\n\n    // Reusable object\n    var W = [];\n\n    /**\n     * SHA-256 hash algorithm.\n     */\n    var SHA256 = C_algo.SHA256 = Hasher.extend({\n        _doReset: function () {\n            this._hash = new WordArray.init(H.slice(0));\n        },\n\n        _doProcessBlock: function (M, offset) {\n            // Shortcut\n            var H = this._hash.words;\n\n            // Working variables\n            var a = H[0];\n            var b = H[1];\n            var c = H[2];\n            var d = H[3];\n            var e = H[4];\n            var f = H[5];\n            var g = H[6];\n            var h = H[7];\n\n            // Computation\n            for (var i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                } else {\n                    var gamma0x = W[i - 15];\n                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                                   (gamma0x >>> 3);\n\n                    var gamma1x = W[i - 2];\n                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                                   (gamma1x >>> 10);\n\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n\n                var ch  = (e & f) ^ (~e & g);\n                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n                var t1 = h + sigma1 + ch + K[i] + W[i];\n                var t2 = sigma0 + maj;\n\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n            H[4] = (H[4] + e) | 0;\n            H[5] = (H[5] + f) | 0;\n            H[6] = (H[6] + g) | 0;\n            H[7] = (H[7] + h) | 0;\n        },\n\n        _doFinalize: function () {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n\n            var nBitsTotal = this._nDataBytes * 8;\n            var nBitsLeft = data.sigBytes * 8;\n\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            data.sigBytes = dataWords.length * 4;\n\n            // Hash final blocks\n            this._process();\n\n            // Return final computed hash\n            return this._hash;\n        },\n\n        clone: function () {\n            var clone = Hasher.clone.call(this);\n            clone._hash = this._hash.clone();\n\n            return clone;\n        }\n    });\n\n    /**\n     * Shortcut function to the hasher\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     *\n     * @return {WordArray} The hash.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hash = CryptoJS.SHA256(\'message\');\n     *     var hash = CryptoJS.SHA256(wordArray);\n     */\n    C.SHA256 = Hasher._createHelper(SHA256);\n\n    /**\n     * Shortcut function to the HMAC\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     * @param {WordArray|string} key The secret key.\n     *\n     * @return {WordArray} The HMAC.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hmac = CryptoJS.HmacSHA256(message, key);\n     */\n    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\nmodule.exports = C\n\n},{"./core.js":117}],118:[function(require,module,exports){\n/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key\n//              to RSAKey class.\n//\n// version: 1.1.1 (2013-Apr-12)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n// \n//\n// Depends on:\n//\n//\n//\n// _RSApem_pemToBase64(sPEM)\n//\n//   removing PEM header, PEM footer and space characters including\n//   new lines from PEM formatted RSA private key string.\n//\nvar ASN1HEX = require(\'./asn1hex-1.1.js\')\nvar b64tohex = require(\'./base64.js\').b64tohex\nvar RSAKey = require(\'./rsa2.js\')\n/**\n * @fileOverview\n * @name rsapem-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nfunction _rsapem_pemToBase64(sPEMPrivateKey) {\n  var s = sPEMPrivateKey;\n  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");\n  s = s.replace("-----END RSA PRIVATE KEY-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {\n  var a = new Array();\n  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);\n  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);\n  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);\n  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);\n  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);\n  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);\n  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);\n  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);\n  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);\n  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);\n  return a;\n}\n\nfunction _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {\n  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);\n  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);\n  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);\n  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);\n  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);\n  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);\n  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);\n  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);\n  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);\n  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);\n  var a = new Array();\n  a.push(v, n, e, d, p, q, dp, dq, co);\n  return a;\n}\n\n/**\n * read RSA private key from a ASN.1 hexadecimal string\n * @name readPrivateKeyFromASN1HexString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.\n * @since 1.1.1\n */\nfunction _rsapem_readPrivateKeyFromASN1HexString(keyHex) {\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\n/**\n * read PKCS#1 private key from a string\n * @name readPrivateKeyFromPEMString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyPEM string of PKCS#1 private key.\n */\nfunction _rsapem_readPrivateKeyFromPEMString(keyPEM) {\n  var keyB64 = _rsapem_pemToBase64(keyPEM);\n  var keyHex = b64tohex(keyB64) // depends base64.js\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\nRSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;\nRSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;\n\nmodule.exports = RSAKey\n\n},{"./asn1hex-1.1.js":91,"./base64.js":94,"./rsa2.js":119}],110:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DynamicBuffer = require(\'../../util/dynamic-buffer.js\').DynamicBuffer;\n\n/**\n * Create a new TlvEncoder with an initialCapacity for the encoding buffer.\n * @constructor\n * @param {number} initialCapacity (optional) The initial capacity of the \n * encoding buffer. If omitted, use a default value.\n */\nvar TlvEncoder = function TlvEncoder(initialCapacity)\n{\n  initialCapacity = initialCapacity || 16;\n  this.output = new DynamicBuffer(initialCapacity);\n  // length is the number of bytes that have been written to the back of \n  //  this.output.array.\n  this.length = 0;\n};\n\nexports.TlvEncoder = TlvEncoder;\n\n/**\n * Get the number of bytes that have been written to the output.  You can\n * save this number, write sub TLVs, then subtract the new length from this\n * to get the total length of the sub TLVs.\n * @returns {number} The number of bytes that have been written to the output.\n */\nTlvEncoder.prototype.getLength = function()\n{\n  return this.length;\n};\n\n/**\n * Encode varNumber as a VAR-NUMBER in NDN-TLV and write it to this.output just \n * before this.length from the back.  Advance this.length.\n * @param {number} varNumber The non-negative number to encode.\n */\nTlvEncoder.prototype.writeVarNumber = function(varNumber)\n{\n  if (varNumber < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffff) {\n    this.length += 3;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 253;\n    this.output.array[offset + 1] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 2] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffffffff) {\n    this.length += 5;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 254;\n    this.output.array[offset + 1] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 4] = varNumber & 0xff;\n  }\n  else {\n    this.length += 9;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 255;\n    this.output.array[offset + 1] = (varNumber >> 56) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 48) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 40) & 0xff;\n    this.output.array[offset + 4] = (varNumber >> 32) & 0xff;\n    this.output.array[offset + 5] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 6] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 7] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 8] = varNumber & 0xff;\n  }\n};\n\n/**\n * Encode the type and length as VAR-NUMBER and write to this.output just before \n * this.length from the back.  Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} length The non-negative length of the TLV.\n */\nTlvEncoder.prototype.writeTypeAndLength = function(type, length)\n{\n  // Write backwards.\n  this.writeVarNumber(length);\n  this.writeVarNumber(type);\n};\n\n/**\n * Write the type, then the length of the encoded value then encode value as a \n * non-negative integer and write it to this.output just before this.length from \n * the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} value The non-negative integer to encode.\n */\nTlvEncoder.prototype.writeNonNegativeIntegerTlv = function(type, value)\n{\n  if (value < 0)\n    throw new Error("TLV integer value may not be negative");\n\n  // JavaScript doesn\'t distinguish int from float, so round.\n  value = Math.round(value)\n\n  // Write backwards.\n  var saveNBytes = this.length;\n  if (value < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = value & 0xff;\n  }\n  else if (value <= 0xffff) {\n    this.length += 2;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 8) & 0xff;\n    this.output.array[offset + 1] = value & 0xff;\n  }\n  else if (value <= 0xffffffff) {\n    this.length += 4;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 24) & 0xff;\n    this.output.array[offset + 1] = (value >> 16) & 0xff;\n    this.output.array[offset + 2] = (value >> 8) & 0xff;\n    this.output.array[offset + 3] = value & 0xff;\n  }\n  else {\n    this.length += 8;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 56) & 0xff;\n    this.output.array[offset + 1] = (value >> 48) & 0xff;\n    this.output.array[offset + 2] = (value >> 40) & 0xff;\n    this.output.array[offset + 3] = (value >> 32) & 0xff;\n    this.output.array[offset + 4] = (value >> 24) & 0xff;\n    this.output.array[offset + 5] = (value >> 16) & 0xff;\n    this.output.array[offset + 6] = (value >> 8) & 0xff;\n    this.output.array[offset + 7] = value & 0xff;\n  }\n\n  this.writeTypeAndLength(type, this.length - saveNBytes);\n};\n\n/**\n * If value is negative or null then do nothing, otherwise call \n * writeNonNegativeIntegerTlv.\n * @param {number} type The type of the TLV.\n * @param {number} value If negative or None do nothing, otherwise the integer \n *   to encode.\n */\nTlvEncoder.prototype.writeOptionalNonNegativeIntegerTlv = function(type, value)\n{\n  if (value != null && value >= 0)\n    this.writeNonNegativeIntegerTlv(type, value);\n};\n\n/**\n * Write the type, then the length of the buffer then the buffer value to \n * this.output just before this.length from the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value The byte array with the bytes of the blob.  If value is\n    null, then just write the type and length 0.\n */\nTlvEncoder.prototype.writeBlobTlv = function(type, value)\n{\n  if (value == null) {\n    this.writeTypeAndLength(type, 0);\n    return;\n  }\n\n  // Write backwards, starting with the blob array.    \n  this.length += value.length;\n  this.output.copyFromBack(value, this.length);\n\n  this.writeTypeAndLength(type, value.length);\n};\n\n/**\n * If the byte array is null or zero length then do nothing, otherwise call \n * writeBlobTlv.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value If null or zero length do nothing, otherwise the byte \n * array with the bytes of the blob.\n */\nTlvEncoder.prototype.writeOptionalBlobTlv = function(type, value)\n{\n  if (value != null && value.length > 0)\n    this.writeBlobTlv(type, value);\n};\n\n/**\n * Get a slice of the encoded bytes.\n * @returns {Buffer} A slice backed by the encoding customBuf.\n */\nTlvEncoder.prototype.getOutput = function()\n{\n  return this.output.array.slice(this.output.array.length - this.length);\n};\n\n})()\n},{"../../buffer.js":50,"../../util/dynamic-buffer.js":109}],115:[function(require,module,exports){\n(function(){\n    \n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary&0xffffff)==0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a,b,c) {\n      if(a != null)\n        if("number" == typeof a) this.fromNumber(a,b,c);\n        else if(b == null && "string" != typeof a) this.fromString(a,256);\n        else this.fromString(a,b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i,x,w,j,c,n) {\n      while(--n >= 0) {\n        var v = x*this[i++]+w[j]+c;\n        c = Math.floor(v/0x4000000);\n        w[j++] = v&0x3ffffff;\n      }\n      return c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i,x,w,j,c,n) {\n      var xl = x&0x7fff, xh = x>>15;\n      while(--n >= 0) {\n        var l = this[i]&0x7fff;\n        var h = this[i++]>>15;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n        w[j++] = l&0x3fffffff;\n      }\n      return c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i,x,w,j,c,n) {\n      var xl = x&0x3fff, xh = x>>14;\n      while(--n >= 0) {\n        var l = this[i]&0x3fff;\n        var h = this[i++]>>14;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n        c = (l>>28)+(m>>14)+xh*h;\n        w[j++] = l&0xfffffff;\n      }\n      return c;\n    }\n    var inBrowser = typeof navigator !== "undefined";\n    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\n      BigInteger.prototype.am = am2;\n      dbits = 30;\n    }\n    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {\n      BigInteger.prototype.am = am1;\n      dbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1<<dbits)-1);\n    BigInteger.prototype.DV = (1<<dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n    BigInteger.prototype.F1 = BI_FP-dbits;\n    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n    // Digit conversions\n    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\n    var BI_RC = new Array();\n    var rr,vv;\n    rr = "0".charCodeAt(0);\n    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = "a".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = "A".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s,i) {\n      var c = BI_RC[s.charCodeAt(i)];\n      return (c==null)?-1:c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n      r.t = this.t;\n      r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n      this.t = 1;\n      this.s = (x<0)?-1:0;\n      if(x > 0) this[0] = x;\n      else if(x < -1) this[0] = x+DV;\n      else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n    function bnpFromString(s,b) {\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 256) k = 8; // byte array\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else { this.fromRadix(s,b); return; }\n      this.t = 0;\n      this.s = 0;\n      var i = s.length, mi = false, sh = 0;\n      while(--i >= 0) {\n        var x = (k==8)?s[i]&0xff:intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-") mi = true;\n          continue;\n        }\n        mi = false;\n        if(sh == 0)\n          this[this.t++] = x;\n        else if(sh+k > this.DB) {\n          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n          this[this.t++] = (x>>(this.DB-sh));\n        }\n        else\n          this[this.t-1] |= x<<sh;\n        sh += k;\n        if(sh >= this.DB) sh -= this.DB;\n      }\n      if(k == 8 && (s[0]&0x80) != 0) {\n        this.s = -1;\n        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n      }\n      this.clamp();\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n      var c = this.s&this.DM;\n      while(this.t > 0 && this[this.t-1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n      if(this.s < 0) return "-"+this.negate().toString(b);\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else return this.toRadix(b);\n      var km = (1<<k)-1, d, m = false, r = "", i = this.t;\n      var p = this.DB-(i*this.DB)%k;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n        while(i >= 0) {\n          if(p < k) {\n            d = (this[i]&((1<<p)-1))<<(k-p);\n            d |= this[--i]>>(p+=this.DB-k);\n          }\n          else {\n            d = (this[i]>>(p-=k))&km;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if(d > 0) m = true;\n          if(m) r += int2char(d);\n        }\n      }\n      return m?r:"0";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s<0)?this.negate():this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n      var r = this.s-a.s;\n      if(r != 0) return r;\n      var i = this.t;\n      r = i-a.t;\n      if(r != 0) return (this.s<0)?-r:r;\n      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n      return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n      var r = 1, t;\n      if((t=x>>>16) != 0) { x = t; r += 16; }\n      if((t=x>>8) != 0) { x = t; r += 8; }\n      if((t=x>>4) != 0) { x = t; r += 4; }\n      if((t=x>>2) != 0) { x = t; r += 2; }\n      if((t=x>>1) != 0) { x = t; r += 1; }\n      return r;\n    }\n\n    // (public) return the number of bits in "this"\n    function bnBitLength() {\n      if(this.t <= 0) return 0;\n      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n,r) {\n      var i;\n      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n      for(i = n-1; i >= 0; --i) r[i] = 0;\n      r.t = this.t+n;\n      r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n,r) {\n      for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n      r.t = Math.max(this.t-n,0);\n      r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n,r) {\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<cbs)-1;\n      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n      for(i = this.t-1; i >= 0; --i) {\n        r[i+ds+1] = (this[i]>>cbs)|c;\n        c = (this[i]&bm)<<bs;\n      }\n      for(i = ds-1; i >= 0; --i) r[i] = 0;\n      r[ds] = c;\n      r.t = this.t+ds+1;\n      r.s = this.s;\n      r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n,r) {\n      r.s = this.s;\n      var ds = Math.floor(n/this.DB);\n      if(ds >= this.t) { r.t = 0; return; }\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<bs)-1;\n      r[0] = this[ds]>>bs;\n      for(var i = ds+1; i < this.t; ++i) {\n        r[i-ds-1] |= (this[i]&bm)<<cbs;\n        r[i-ds] = this[i]>>bs;\n      }\n      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n      r.t = this.t-ds;\n      r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]-a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c -= a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c -= a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c -= a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c < -1) r[i++] = this.DV+c;\n      else if(c > 0) r[i++] = c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyTo(a,r) {\n      var x = this.abs(), y = a.abs();\n      var i = x.t;\n      r.t = i+y.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n      r.s = 0;\n      r.clamp();\n      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n      var x = this.abs();\n      var i = r.t = 2*x.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < x.t-1; ++i) {\n        var c = x.am(i,x[i],r,2*i,0,1);\n        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n          r[i+x.t] -= x.DV;\n          r[i+x.t+1] = 1;\n        }\n      }\n      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n      r.s = 0;\n      r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m,q,r) {\n      var pm = m.abs();\n      if(pm.t <= 0) return;\n      var pt = this.abs();\n      if(pt.t < pm.t) {\n        if(q != null) q.fromInt(0);\n        if(r != null) this.copyTo(r);\n        return;\n      }\n      if(r == null) r = nbi();\n      var y = nbi(), ts = this.s, ms = m.s;\n      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n      else { pm.copyTo(y); pt.copyTo(r); }\n      var ys = y.t;\n      var y0 = y[ys-1];\n      if(y0 == 0) return;\n      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n      var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n      y.dlShiftTo(j,t);\n      if(r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t,r);\n      }\n      BigInteger.ONE.dlShiftTo(ys,t);\n      t.subTo(y,y);  // "negative" y so we can replace sub with am later\n      while(y.t < ys) y[y.t++] = 0;\n      while(--j >= 0) {\n        // Estimate quotient digit\n        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n          y.dlShiftTo(j,t);\n          r.subTo(t,r);\n          while(r[i] < --qd) r.subTo(t,r);\n        }\n      }\n      if(q != null) {\n        r.drShiftTo(ys,q);\n        if(ts != ms) BigInteger.ZERO.subTo(q,q);\n      }\n      r.t = ys;\n      r.clamp();\n      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n      if(ts < 0) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n      var r = nbi();\n      this.abs().divRemTo(a,null,r);\n      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n      return r;\n    }\n\n    // Modular reduction using "classic" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n      else return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m,null,x); }\n    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply "overflows" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n      if(this.t < 1) return 0;\n      var x = this[0];\n      if((x&1) == 0) return 0;\n      var y = x&3;       // y == 1/x mod 2^2\n      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n      // last step - calculate inverse mod DV directly;\n      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n      // we really want the negative inverse, and -DV < y < DV\n      return (y>0)?this.DV-y:-y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n      this.m = m;\n      this.mp = m.invDigit();\n      this.mpl = this.mp&0x7fff;\n      this.mph = this.mp>>15;\n      this.um = (1<<(m.DB-15))-1;\n      this.mt2 = 2*m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n      var r = nbi();\n      x.abs().dlShiftTo(this.m.t,r);\n      r.divRemTo(this.m,null,r);\n      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n      return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n      while(x.t <= this.mt2) // pad x so am has enough room later\n        x[x.t++] = 0;\n      for(var i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        var j = x[i]&0x7fff;\n        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i+this.m.t;\n        x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n        // propagate carry\n        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n      }\n      x.clamp();\n      x.drShiftTo(this.m.t,x);\n      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = "x^2/R mod m"; x != r\n    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = "xy/R mod m"; x,y != r\n    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)\n    function bnpExp(e,z) {\n      if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n      g.copyTo(r);\n      while(--i >= 0) {\n        z.sqrTo(r,r2);\n        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n        else { var t = r; r = r2; r2 = t; }\n      }\n      return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e,m) {\n      var z;\n      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n      return this.exp(e,z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // "constants"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger("0", 10) returns "proper" zero\n    // Version 1.2: square() API, isProbablePrime fix\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n      if(this.s < 0) {\n        if(this.t == 1) return this[0]-this.DV;\n        else if(this.t == 0) return -1;\n      }\n      else if(this.t == 1) return this[0];\n      else if(this.t == 0) return 0;\n      // assumes 16 < DB < 32\n      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n      if(this.s < 0) return -1;\n      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n      else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n      if(b == null) b = 10;\n      if(this.signum() == 0 || b < 2 || b > 36) return "0";\n      var cs = this.chunkSize(b);\n      var a = Math.pow(b,cs);\n      var d = nbv(a), y = nbi(), z = nbi(), r = "";\n      this.divRemTo(d,y,z);\n      while(y.signum() > 0) {\n        r = (a+z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d,y,z);\n      }\n      return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s,b) {\n      this.fromInt(0);\n      if(b == null) b = 10;\n      var cs = this.chunkSize(b);\n      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n      for(var i = 0; i < s.length; ++i) {\n        var x = intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;\n          continue;\n        }\n        w = b*w+x;\n        if(++j >= cs) {\n          this.dMultiply(d);\n          this.dAddOffset(w,0);\n          j = 0;\n          w = 0;\n        }\n      }\n      if(j > 0) {\n        this.dMultiply(Math.pow(b,j));\n        this.dAddOffset(w,0);\n      }\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a,b,c) {\n      if("number" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if(a < 2) this.fromInt(1);\n        else {\n          this.fromNumber(a,c);\n          if(!this.testBit(a-1))\t// force MSB set\n            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n          if(this.isEven()) this.dAddOffset(1,0); // force odd\n          while(!this.isProbablePrime(b)) {\n            this.dAddOffset(2,0);\n            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n          }\n        }\n      }\n      else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a&7;\n        x.length = (a>>3)+1;\n        b.nextBytes(x);\n        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n        this.fromString(x,256);\n      }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n      var i = this.t, r = new Array();\n      r[0] = this.s;\n      var p = this.DB-(i*this.DB)%8, d, k = 0;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n          r[k++] = d|(this.s<<(this.DB-p));\n        while(i >= 0) {\n          if(p < 8) {\n            d = (this[i]&((1<<p)-1))<<(8-p);\n            d |= this[--i]>>(p+=this.DB-8);\n          }\n          else {\n            d = (this[i]>>(p-=8))&0xff;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if((d&0x80) != 0) d |= -256;\n          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n          if(k > 0 || d != this.s) r[k++] = d;\n        }\n      }\n      return r;\n    }\n\n    function bnEquals(a) { return(this.compareTo(a)==0); }\n    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a,op,r) {\n      var i, f, m = Math.min(a.t,this.t);\n      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n      if(a.t < this.t) {\n        f = a.s&this.DM;\n        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n        r.t = this.t;\n      }\n      else {\n        f = this.s&this.DM;\n        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n        r.t = a.t;\n      }\n      r.s = op(this.s,a.s);\n      r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x,y) { return x&y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n    // (public) this | a\n    function op_or(x,y) { return x|y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x,y) { return x^y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x,y) { return x&~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n      var r = nbi();\n      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n      r.t = this.t;\n      r.s = ~this.s;\n      return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n      var r = nbi();\n      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n      return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n      var r = nbi();\n      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n      return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n      if(x == 0) return -1;\n      var r = 0;\n      if((x&0xffff) == 0) { x >>= 16; r += 16; }\n      if((x&0xff) == 0) { x >>= 8; r += 8; }\n      if((x&0xf) == 0) { x >>= 4; r += 4; }\n      if((x&3) == 0) { x >>= 2; r += 2; }\n      if((x&1) == 0) ++r;\n      return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n      for(var i = 0; i < this.t; ++i)\n        if(this[i] != 0) return i*this.DB+lbit(this[i]);\n      if(this.s < 0) return this.t*this.DB;\n      return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n      var r = 0;\n      while(x != 0) { x &= x-1; ++r; }\n      return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n      var r = 0, x = this.s&this.DM;\n      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n      return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n      var j = Math.floor(n/this.DB);\n      if(j >= this.t) return(this.s!=0);\n      return((this[j]&(1<<(n%this.DB)))!=0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n,op) {\n      var r = BigInteger.ONE.shiftLeft(n);\n      this.bitwiseTo(r,op,r);\n      return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]+a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c += a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c += a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c > 0) r[i++] = c;\n      else if(c < -1) r[i++] = this.DV+c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n    // (public) this^2\n    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n      var q = nbi(), r = nbi();\n      this.divRemTo(a,q,r);\n      return new Array(q,r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n      this[this.t] = this.am(0,n-1,this,0,0,this.t);\n      ++this.t;\n      this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n,w) {\n      if(n == 0) return;\n      while(this.t <= w) this[this.t++] = 0;\n      this[w] += n;\n      while(this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if(++w >= this.t) this[this.t++] = 0;\n        ++this[w];\n      }\n    }\n\n    // A "null" reducer\n    function NullExp() {}\n    function nNop(x) { return x; }\n    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n    function nSqrTo(x,r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.exp(e,new NullExp()); }\n\n    // (protected) r = lower n words of "this * a", a.t <= n\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a,n,r) {\n      var i = Math.min(this.t+a.t,n);\n      r.s = 0; // assumes a,this >= 0\n      r.t = i;\n      while(i > 0) r[--i] = 0;\n      var j;\n      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n      r.clamp();\n    }\n\n    // (protected) r = "this * a" without lower n words, n > 0\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a,n,r) {\n      --n;\n      var i = r.t = this.t+a.t-n;\n      r.s = 0; // assumes a,this >= 0\n      while(--i >= 0) r[i] = 0;\n      for(i = Math.max(n-this.t,0); i < a.t; ++i)\n        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n      r.clamp();\n      r.drShiftTo(1,r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n      // setup Barrett\n      this.r2 = nbi();\n      this.q3 = nbi();\n      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n      this.mu = this.r2.divide(m);\n      this.m = m;\n    }\n\n    function barrettConvert(x) {\n      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n      else if(x.compareTo(this.m) < 0) return x;\n      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n      x.drShiftTo(this.m.t-1,this.r2);\n      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n      x.subTo(this.r2,x);\n      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e,m) {\n      var i = e.bitLength(), k, r = nbv(1), z;\n      if(i <= 0) return r;\n      else if(i < 18) k = 1;\n      else if(i < 48) k = 3;\n      else if(i < 144) k = 4;\n      else if(i < 768) k = 5;\n      else k = 6;\n      if(i < 8)\n        z = new Classic(m);\n      else if(m.isEven())\n        z = new Barrett(m);\n      else\n        z = new Montgomery(m);\n\n      // precomputation\n      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n      g[1] = z.convert(this);\n      if(k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1],g2);\n        while(n <= km) {\n          g[n] = nbi();\n          z.mulTo(g2,g[n-2],g[n]);\n          n += 2;\n        }\n      }\n\n      var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n      i = nbits(e[j])-1;\n      while(j >= 0) {\n        if(i >= k1) w = (e[j]>>(i-k1))&km;\n        else {\n          w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n        }\n\n        n = k;\n        while((w&1) == 0) { w >>= 1; --n; }\n        if((i -= n) < 0) { i += this.DB; --j; }\n        if(is1) {\t// ret == 1, don\'t bother squaring or multiplying it\n          g[w].copyTo(r);\n          is1 = false;\n        }\n        else {\n          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n          z.mulTo(r2,g[w],r);\n        }\n\n        while(j >= 0 && (e[j]&(1<<i)) == 0) {\n          z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n          if(--i < 0) { i = this.DB-1; --j; }\n        }\n      }\n      return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n      var x = (this.s<0)?this.negate():this.clone();\n      var y = (a.s<0)?a.negate():a.clone();\n      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n      if(g < 0) return x;\n      if(i < g) g = i;\n      if(g > 0) {\n        x.rShiftTo(g,x);\n        y.rShiftTo(g,y);\n      }\n      while(x.signum() > 0) {\n        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n        if(x.compareTo(y) >= 0) {\n          x.subTo(y,x);\n          x.rShiftTo(1,x);\n        }\n        else {\n          y.subTo(x,y);\n          y.rShiftTo(1,y);\n        }\n      }\n      if(g > 0) y.lShiftTo(g,y);\n      return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n      if(n <= 0) return 0;\n      var d = this.DV%n, r = (this.s<0)?n-1:0;\n      if(this.t > 0)\n        if(d == 0) r = this[0]%n;\n        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n      return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n      var ac = m.isEven();\n      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n      var u = m.clone(), v = this.clone();\n      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n      while(u.signum() != 0) {\n        while(u.isEven()) {\n          u.rShiftTo(1,u);\n          if(ac) {\n            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n            a.rShiftTo(1,a);\n          }\n          else if(!b.isEven()) b.subTo(m,b);\n          b.rShiftTo(1,b);\n        }\n        while(v.isEven()) {\n          v.rShiftTo(1,v);\n          if(ac) {\n            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n            c.rShiftTo(1,c);\n          }\n          else if(!d.isEven()) d.subTo(m,d);\n          d.rShiftTo(1,d);\n        }\n        if(u.compareTo(v) >= 0) {\n          u.subTo(v,u);\n          if(ac) a.subTo(c,a);\n          b.subTo(d,b);\n        }\n        else {\n          v.subTo(u,v);\n          if(ac) c.subTo(a,c);\n          d.subTo(b,d);\n        }\n      }\n      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n      if(d.compareTo(m) >= 0) return d.subtract(m);\n      if(d.signum() < 0) d.addTo(m,d); else return d;\n      if(d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n      var i, x = this.abs();\n      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n        for(i = 0; i < lowprimes.length; ++i)\n          if(x[0] == lowprimes[i]) return true;\n        return false;\n      }\n      if(x.isEven()) return false;\n      i = 1;\n      while(i < lowprimes.length) {\n        var m = lowprimes[i], j = i+1;\n        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j) if(m%lowprimes[i++] == 0) return false;\n      }\n      return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n      var n1 = this.subtract(BigInteger.ONE);\n      var k = n1.getLowestSetBit();\n      if(k <= 0) return false;\n      var r = n1.shiftRight(k);\n      t = (t+1)>>1;\n      if(t > lowprimes.length) t = lowprimes.length;\n      var a = nbi();\n      for(var i = 0; i < t; ++i) {\n        //Pick bases at random, instead of starting at 2\n        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n        var y = a.modPow(r,this);\n        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n          var j = 1;\n          while(j++ < k && y.compareTo(n1) != 0) {\n            y = y.modPowInt(2,this);\n            if(y.compareTo(BigInteger.ONE) == 0) return false;\n          }\n          if(y.compareTo(n1) != 0) return false;\n        }\n      }\n      return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // JSBN-specific extension\n    BigInteger.prototype.square = bnSquare;\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n    if (typeof exports !== \'undefined\') {\n        exports = module.exports = BigInteger;\n    } else {\n        this.BigInteger = BigInteger;\n    }\n    \n}).call(this);\n},{}],117:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/**\n * CryptoJS core components.\n */\nvar CryptoJS = CryptoJS || (function (Math, undefined) {\n    /**\n     * CryptoJS namespace.\n     */\n    var C = {};\n\n    /**\n     * Library namespace.\n     */\n    var C_lib = C.lib = {};\n\n    /**\n     * Base object for prototypal inheritance.\n     */\n    var Base = C_lib.Base = (function () {\n        function F() {}\n\n        return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: \'value\',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function (overrides) {\n                // Spawn\n                F.prototype = this;\n                var subtype = new F();\n\n                // Augment\n                if (overrides) {\n                    subtype.mixIn(overrides);\n                }\n\n                // Create default initializer\n                if (!subtype.hasOwnProperty(\'init\')) {\n                    subtype.init = function () {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                }\n\n                // Initializer\'s prototype is the subtype object\n                subtype.init.prototype = subtype;\n\n                // Reference supertype\n                subtype.$super = this;\n\n                return subtype;\n            },\n\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function () {\n                var instance = this.extend();\n                instance.init.apply(instance, arguments);\n\n                return instance;\n            },\n\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function () {\n            },\n\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: \'value\'\n             *     });\n             */\n            mixIn: function (properties) {\n                for (var propertyName in properties) {\n                    if (properties.hasOwnProperty(propertyName)) {\n                        this[propertyName] = properties[propertyName];\n                    }\n                }\n\n                // IE won\'t copy toString using the loop above\n                if (properties.hasOwnProperty(\'toString\')) {\n                    this.toString = properties.toString;\n                }\n            },\n\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function () {\n                return this.init.prototype.extend(this);\n            }\n        };\n    }());\n\n    /**\n     * An array of 32-bit words.\n     *\n     * @property {Array} words The array of 32-bit words.\n     * @property {number} sigBytes The number of significant bytes in this word array.\n     */\n    var WordArray = C_lib.WordArray = Base.extend({\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param {Array} words (Optional) An array of 32-bit words.\n         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.create();\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n         */\n        init: function (words, sigBytes) {\n            words = this.words = words || [];\n\n            if (sigBytes != undefined) {\n                this.sigBytes = sigBytes;\n            } else {\n                this.sigBytes = words.length * 4;\n            }\n        },\n\n        /**\n         * Converts this word array to a string.\n         *\n         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {string} The stringified word array.\n         *\n         * @example\n         *\n         *     var string = wordArray + \'\';\n         *     var string = wordArray.toString();\n         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        toString: function (encoder) {\n            return (encoder || Hex).stringify(this);\n        },\n\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param {WordArray} wordArray The word array to append.\n         *\n         * @return {WordArray} This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        concat: function (wordArray) {\n            // Shortcuts\n            var thisWords = this.words;\n            var thatWords = wordArray.words;\n            var thisSigBytes = this.sigBytes;\n            var thatSigBytes = wordArray.sigBytes;\n\n            // Clamp excess bits\n            this.clamp();\n\n            // Concat\n            if (thisSigBytes % 4) {\n                // Copy one byte at a time\n                for (var i = 0; i < thatSigBytes; i++) {\n                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n                }\n            } else if (thatWords.length > 0xffff) {\n                // Copy one word at a time\n                for (var i = 0; i < thatSigBytes; i += 4) {\n                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n                }\n            } else {\n                // Copy all words at once\n                thisWords.push.apply(thisWords, thatWords);\n            }\n            this.sigBytes += thatSigBytes;\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        clamp: function () {\n            // Shortcuts\n            var words = this.words;\n            var sigBytes = this.sigBytes;\n\n            // Clamp\n            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n            words.length = Math.ceil(sigBytes / 4);\n        },\n\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return {WordArray} The clone.\n         *\n         * @example\n         *\n         *     var clone = wordArray.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone.words = this.words.slice(0);\n\n            return clone;\n        },\n\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * @param {number} nBytes The number of random bytes to generate.\n         *\n         * @return {WordArray} The random word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n         */\n        random: function (nBytes) {\n            var words = [];\n            for (var i = 0; i < nBytes; i += 4) {\n                words.push((Math.random() * 0x100000000) | 0);\n            }\n\n            return new WordArray.init(words, nBytes);\n        }\n    });\n\n    /**\n     * Encoder namespace.\n     */\n    var C_enc = C.enc = {};\n\n    /**\n     * Hex encoding strategy.\n     */\n    var Hex = C_enc.Hex = {\n        /**\n         * Converts a word array to a hex string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The hex string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var hexChars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n\n            return hexChars.join(\'\');\n        },\n\n        /**\n         * Converts a hex string to a word array.\n         *\n         * @param {string} hexStr The hex string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n         */\n        parse: function (hexStr) {\n            // Shortcut\n            var hexStrLength = hexStr.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n\n            return new WordArray.init(words, hexStrLength / 2);\n        }\n    };\n\n    /**\n     * Latin1 encoding strategy.\n     */\n    var Latin1 = C_enc.Latin1 = {\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Latin1 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var latin1Chars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n\n            return latin1Chars.join(\'\');\n        },\n\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * @param {string} latin1Str The Latin1 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n         */\n        parse: function (latin1Str) {\n            // Shortcut\n            var latin1StrLength = latin1Str.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n\n            return new WordArray.init(words, latin1StrLength);\n        }\n    };\n\n    /**\n     * UTF-8 encoding strategy.\n     */\n    var Utf8 = C_enc.Utf8 = {\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The UTF-8 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            } catch (e) {\n                throw new Error(\'Malformed UTF-8 data\');\n            }\n        },\n\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * @param {string} utf8Str The UTF-8 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n         */\n        parse: function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        }\n    };\n\n    /**\n     * Abstract buffered block algorithm template.\n     *\n     * The property blockSize must be implemented in a concrete subtype.\n     *\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n     */\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n        /**\n         * Resets this block algorithm\'s data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        reset: function () {\n            // Initial values\n            this._data = new WordArray.init();\n            this._nDataBytes = 0;\n        },\n\n        /**\n         * Adds new data to this block algorithm\'s buffer.\n         *\n         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append(\'data\');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        _append: function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data == \'string\') {\n                data = Utf8.parse(data);\n            }\n\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        },\n\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {WordArray} The processed data.\n         *\n         * @example\n         *\n         *     var processedData = bufferedBlockAlgorithm._process();\n         *     var processedData = bufferedBlockAlgorithm._process(!!\'flush\');\n         */\n        _process: function (doFlush) {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n            var dataSigBytes = data.sigBytes;\n            var blockSize = this.blockSize;\n            var blockSizeBytes = blockSize * 4;\n\n            // Count blocks ready\n            var nBlocksReady = dataSigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            } else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n\n            // Count words ready\n            var nWordsReady = nBlocksReady * blockSize;\n\n            // Count bytes ready\n            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n            // Process blocks\n            if (nWordsReady) {\n                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                }\n\n                // Remove processed words\n                var processedWords = dataWords.splice(0, nWordsReady);\n                data.sigBytes -= nBytesReady;\n            }\n\n            // Return processed words\n            return new WordArray.init(processedWords, nBytesReady);\n        },\n\n        /**\n         * Creates a copy of this object.\n         *\n         * @return {Object} The clone.\n         *\n         * @example\n         *\n         *     var clone = bufferedBlockAlgorithm.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone._data = this._data.clone();\n\n            return clone;\n        },\n\n        _minBufferSize: 0\n    });\n\n    /**\n     * Abstract hasher template.\n     *\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n     */\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n        /**\n         * Configuration options.\n         */\n        cfg: Base.extend(),\n\n        /**\n         * Initializes a newly created hasher.\n         *\n         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n         *\n         * @example\n         *\n         *     var hasher = CryptoJS.algo.SHA256.create();\n         */\n        init: function (cfg) {\n            // Apply config defaults\n            this.cfg = this.cfg.extend(cfg);\n\n            // Set initial values\n            this.reset();\n        },\n\n        /**\n         * Resets this hasher to its initial state.\n         *\n         * @example\n         *\n         *     hasher.reset();\n         */\n        reset: function () {\n            // Reset data buffer\n            BufferedBlockAlgorithm.reset.call(this);\n\n            // Perform concrete-hasher logic\n            this._doReset();\n        },\n\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param {WordArray|string} messageUpdate The message to append.\n         *\n         * @return {Hasher} This hasher.\n         *\n         * @example\n         *\n         *     hasher.update(\'message\');\n         *     hasher.update(wordArray);\n         */\n        update: function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n\n            // Update the hash\n            this._process();\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n         *\n         * @return {WordArray} The hash.\n         *\n         * @example\n         *\n         *     var hash = hasher.finalize();\n         *     var hash = hasher.finalize(\'message\');\n         *     var hash = hasher.finalize(wordArray);\n         */\n        finalize: function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n\n            // Perform concrete-hasher logic\n            var hash = this._doFinalize();\n\n            return hash;\n        },\n\n        blockSize: 512/32,\n\n        /**\n         * Creates a shortcut function to a hasher\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to create a helper for.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n         */\n        _createHelper: function (hasher) {\n            return function (message, cfg) {\n                return new hasher.init(cfg).finalize(message);\n            };\n        },\n\n        /**\n         * Creates a shortcut function to the HMAC\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n         */\n        _createHmacHelper: function (hasher) {\n            return function (message, key) {\n                return new C_algo.HMAC.init(hasher, key).finalize(message);\n            };\n        }\n    });\n\n    /**\n     * Algorithm namespace.\n     */\n    var C_algo = C.algo = {};\n\n    return C;\n}(Math));\n\nmodule.exports = CryptoJS\n\n},{}],91:[function(require,module,exports){\n/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// asn1hex.js - Hexadecimal represented ASN.1 string library\n//\n// version: 1.1 (09-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n//\n// Depends on:\n//\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n// MEMO:\n//   f(\'3082025b02...\', 2) ... 82025b ... 3bytes\n//   f(\'020100\', 2) ... 01 ... 1byte\n//   f(\'0203001...\', 2) ... 03 ... 1byte\n//   f(\'02818003...\', 2) ... 8180 ... 2bytes\n//   f(\'3080....0000\', 2) ... 80 ... -1\n//\n//   Requirements:\n//   - ASN.1 type octet length MUST be 1. \n//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)\n//   - \n\n/**\n * @fileOverview\n * @name asn1hex-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * get byte length for ASN.1 L(length) bytes\n * @name getByteLengthOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return byte length for ASN.1 L(length) bytes\n */\nfunction _asnhex_getByteLengthOfL_AtObj(s, pos) {\n  if (s.substring(pos + 2, pos + 3) != \'8\') return 1;\n  var i = parseInt(s.substring(pos + 3, pos + 4));\n  if (i == 0) return -1; \t\t// length octet \'80\' indefinite length\n  if (0 < i && i < 10) return i + 1;\t// including \'8?\' octet;\n  return -2;\t\t\t\t// malformed format\n}\n\n\n/**\n * get hexadecimal string for ASN.1 L(length) bytes\n * @name getHexOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string for ASN.1 L(length) bytes\n */\nfunction _asnhex_getHexOfL_AtObj(s, pos) {\n  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (len < 1) return \'\';\n  return s.substring(pos + 2, pos + 2 + len * 2);\n}\n\n//\n//   getting ASN.1 length value at the position \'idx\' of\n//   hexa decimal string \'s\'.\n//\n//   f(\'3082025b02...\', 0) ... 82025b ... ???\n//   f(\'020100\', 0) ... 01 ... 1\n//   f(\'0203001...\', 0) ... 03 ... 3\n//   f(\'02818003...\', 0) ... 8180 ... 128\n/**\n * get integer value of ASN.1 length for ASN.1 data\n * @name getIntOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return ASN.1 L(length) integer value\n */\nfunction _asnhex_getIntOfL_AtObj(s, pos) {\n  var hLength = _asnhex_getHexOfL_AtObj(s, pos);\n  if (hLength == \'\') return -1;\n  var bi;\n  if (parseInt(hLength.substring(0, 1)) < 8) {\n     bi = parseBigInt(hLength, 16);\n  } else {\n     bi = parseBigInt(hLength.substring(2), 16);\n  }\n  return bi.intValue();\n}\n\n/**\n * get ASN.1 value starting string position for ASN.1 object refered by index \'idx\'.\n * @name getStartPosOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n */\nfunction _asnhex_getStartPosOfV_AtObj(s, pos) {\n  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (l_len < 0) return l_len;\n  return pos + (l_len + 1) * 2;\n}\n\n/**\n * get hexadecimal string of ASN.1 V(value)\n * @name getHexOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 value.\n */\nfunction _asnhex_getHexOfV_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return s.substring(pos1, pos1 + len * 2);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV at\n * @name getHexOfTLV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 TLV.\n * @since 1.1\n */\nfunction _asnhex_getHexOfTLV_AtObj(s, pos) {\n  var hT = s.substr(pos, 2);\n  var hL = _asnhex_getHexOfL_AtObj(s, pos);\n  var hV = _asnhex_getHexOfV_AtObj(s, pos);\n  return hT + hL + hV;\n}\n\n/**\n * get next sibling starting index for ASN.1 object string\n * @name getPosOfNextSibling_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return next sibling starting index for ASN.1 object string\n */\nfunction _asnhex_getPosOfNextSibling_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return pos1 + len * 2;\n}\n\n/**\n * get array of indexes of child ASN.1 objects\n * @name getPosArrayOfChildren_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} start string index of ASN.1 object\n * @return {Array of Number} array of indexes for childen of ASN.1 objects\n */\nfunction _asnhex_getPosArrayOfChildren_AtObj(h, pos) {\n  var a = new Array();\n  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);\n  a.push(p0);\n\n  var len = _asnhex_getIntOfL_AtObj(h, pos);\n  var p = p0;\n  var k = 0;\n  while (1) {\n    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);\n    if (pNext == null || (pNext - p0  >= (len * 2))) break;\n    if (k >= 200) break;\n\n    a.push(pNext);\n    p = pNext;\n\n    k++;\n  }\n\n  return a;\n}\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getNthChildIndex_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} idx start string index of ASN.1 object\n * @param {Number} nth for child\n * @return {Number} string index of nth child.\n * @since 1.1\n */\nfunction _asnhex_getNthChildIndex_AtObj(h, idx, nth) {\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);\n  return a[nth];\n}\n\n// ========== decendant methods ==============================\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getDecendantIndexByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} string index refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {\n  if (nthList.length == 0) {\n    return currentIndex;\n  }\n  var firstNth = nthList.shift();\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);\n  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.\n * @name getDecendantHexTLVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfTLV_AtObj(h, idx);\n}\n\n/**\n * get hexadecimal string of ASN.1 V refered by current index and nth index list.\n * @name getDecendantHexVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 V refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfV_AtObj(h, idx);\n}\n\n// ========== class definition ==============================\n\n/**\n * ASN.1 DER encoded hexadecimal string utility class\n * @class ASN.1 DER encoded hexadecimal string utility class\n * @author Kenji Urushima\n * @version 1.1 (09 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n * @since 1.1\n */\nfunction ASN1HEX() {\n  return ASN1HEX;\n}\n\nASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;\nASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;\nASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;\nASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;\nASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;\nASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;\nASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;\nASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;\nASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;\nASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;\nASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;\nASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;\n\nmodule.exports = ASN1HEX;\n\n},{"jsbn":120}],92:[function(require,module,exports){\n/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * crypto.js - Cryptographic Algorithm Provider class\n *\n * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name crypto-1.0.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.0.4 (2013-Mar-28)\n * @since 2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nvar CryptoJS = require(\'./sha256.js\')\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n/** \n * kjur\'s class library name space\n * @name KJUR\n * @namespace kjur\'s class library name space\n */\nif (typeof KJUR == "undefined" || !KJUR) KJUR = {};\n/**\n * kjur\'s cryptographic algorithm provider library name space\n * <p>\n * This namespace privides following crytpgrahic classes.\n * <ul>\n * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.crypto\n * @namespace\n */\nif (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.Util\n * @class static object for cryptographic function utilities\n * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n * @description\n */\nKJUR.crypto.Util = new function() {\n    this.DIGESTINFOHEAD = {\n\t\'sha1\':      "3021300906052b0e03021a05000414",\n        \'sha224\':    "302d300d06096086480165030402040500041c",\n\t\'sha256\':    "3031300d060960864801650304020105000420",\n\t\'sha384\':    "3041300d060960864801650304020205000430",\n\t\'sha512\':    "3051300d060960864801650304020305000440",\n\t\'md2\':       "3020300c06082a864886f70d020205000410",\n\t\'md5\':       "3020300c06082a864886f70d020505000410",\n\t\'ripemd160\': "3021300906052b2403020105000414"\n    };\n\n    /**\n     * get hexadecimal DigestInfo\n     * @name getDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n     */\n    this.getDigestInfoHex = function(hHash, alg) {\n\tif (typeof this.DIGESTINFOHEAD[alg] == "undefined")\n\t    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;\n\treturn this.DIGESTINFOHEAD[alg] + hHash;\n    };\n\n    /**\n     * get PKCS#1 padded hexadecimal DigestInfo\n     * @name getPaddedDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @param {Integer} keySize key bit length (ex. 1024)\n     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n     */\n    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\tvar pmStrLen = keySize / 4; // minimum PM length\n\n\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;\n\n\tvar hHead = "0001";\n\tvar hTail = "00" + hDigestInfo;\n\tvar hMid = "";\n\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\tfor (var i = 0; i < fLen; i += 2) {\n\t    hMid += "ff";\n\t}\n\tvar hPaddedMessage = hHead + hMid + hTail;\n\treturn hPaddedMessage;\n    };\n\n    /**\n     * get hexadecimal SHA1 hash of string\n     * @name sha1\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha1 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha1\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA256 hash of string\n     * @name sha256\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha256 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha256\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA512 hash of string\n     * @name sha512\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha512 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha512\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal MD5 hash of string\n     * @name md5\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.md5 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'md5\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal RIPEMD160 hash of string\n     * @name ripemd160\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.ripemd160 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'ripemd160\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n};\n\n/**\n * MessageDigest class which is very similar to java.security.MessageDigest class\n * @name KJUR.crypto.MessageDigest\n * @class MessageDigest class which is very similar to java.security.MessageDigest class\n * @param {Array} params parameters for constructor\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>md5 - cryptojs</li>\n * <li>sha1 - cryptojs</li>\n * <li>sha224 - cryptojs</li>\n * <li>sha256 - cryptojs</li>\n * <li>sha384 - cryptojs</li>\n * <li>sha512 - cryptojs</li>\n * <li>ripemd160 - cryptojs</li>\n * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n * </ul>\n * @example\n * // CryptoJS provider sample\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n *\n * // SJCL(Stanford JavaScript Crypto Library) provider sample\n * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n */\nKJUR.crypto.MessageDigest = function(params) {\n    var md = null;\n    var algName = null;\n    var provName = null;\n    var _CryptoJSMdName = {\n\t\'md5\': \'CryptoJS.algo.MD5\',\n\t\'sha1\': \'CryptoJS.algo.SHA1\',\n\t\'sha224\': \'CryptoJS.algo.SHA224\',\n\t\'sha256\': \'CryptoJS.algo.SHA256\',\n\t\'sha384\': \'CryptoJS.algo.SHA384\',\n\t\'sha512\': \'CryptoJS.algo.SHA512\',\n\t\'ripemd160\': \'CryptoJS.algo.RIPEMD160\'\n    };\n\n    /**\n     * set hash algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} alg hash algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * // for SHA1\n     * md.setAlgAndProvider(\'sha1\', \'cryptojs\');\n     * // for RIPEMD160\n     * md.setAlgAndProvider(\'ripemd160\', \'cryptojs\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(alg) != -1 &&\n\t    prov == \'cryptojs\') {\n\t    try {\n\t\tthis.md = eval(_CryptoJSMdName[alg]).create();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.md.update(wHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n\tif (\':sha256:\'.indexOf(alg) != -1 &&\n\t    prov == \'sjcl\') {\n\t    try {\n\t\tthis.md = new sjcl.hash.sha256();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\tthis.md.update(baHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn sjcl.codec.hex.fromBits(hash);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString(\'New York\');\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex(\'0afe36\');\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name digest\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.digest = function() {\n\tthrow "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name digestString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString(\'aaa\')\n     */\n    this.digestString = function(str) {\n\tthrow "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, then completes the digest computation\n     * @name digestHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex(\'0f2abd\')\n     */\n    this.digestHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t}\n    }\n};\n\n\n/**\n * Signature class which is very similar to java.security.Signature class\n * @name KJUR.crypto.Signature\n * @class Signature class which is very similar to java.security.Signature class\n * @param {Array} params parameters for constructor\n * @property {String} state Current state of this signature object whether \'SIGN\', \'VERIFY\' or null\n * @description\n * <br/>\n * As for params of constructor\'s argument, it can be specify following attributes:\n * <ul>\n * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>\n * <li>provider - currently \'cryptojs/jsrsa\' only</li>\n * <li>prvkeypem - PEM string of signer\'s private key. If this specified, no need to call initSign(prvKey).</li>\n * </ul>\n * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}\n * withRSA algorithm in \'cryptojs/jsrsa\' provider.\n * <h4>EXAMPLES</h4>\n * @example\n * // signature generation\n * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig.initSign(prvKey);\n * sig.updateString(\'aaa\');\n * var hSigVal = sig.sign();\n *\n * // signature validation\n * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig2.initVerifyByCertificatePEM(cert)\n * sig.updateString(\'aaa\');\n * var isValid = sig2.verify(hSigVal);\n */\nKJUR.crypto.Signature = function(params) {\n    var prvKey = null; // RSAKey for signing\n    var pubKey = null; // RSAKey for verifying\n\n    var md = null; // KJUR.crypto.MessageDigest object\n    var sig = null;\n    var algName = null;\n    var provName = null;\n    var algProvName = null;\n    var mdAlgName = null;\n    var pubkeyAlgName = null;\n    var state = null;\n\n    var sHashHex = null; // hex hash value for hex\n    var hDigestInfo = null;\n    var hPaddedDigestInfo = null;\n    var hSign = null;\n\n    this._setAlgNames = function() {\n\tif (this.algName.match(/^(.+)with(.+)$/)) {\n\t    this.mdAlgName = RegExp.$1.toLowerCase();\n\t    this.pubkeyAlgName = RegExp.$2.toLowerCase();\n\t}\n    };\n\n    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\tvar s = "";\n\tvar nZero = bitLength / 4 - hex.length;\n\tfor (var i = 0; i < nZero; i++) {\n\t    s = s + "0";\n\t}\n\treturn s + hex;\n    };\n\n    /**\n     * set signature algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} alg signature algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * md.setAlgAndProvider(\'SHA1withRSA\', \'cryptojs/jsrsa\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tthis._setAlgNames();\n\tif (prov != \'cryptojs/jsrsa\')\n\t    throw "provider not supported: " + prov;\n\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(this.mdAlgName) != -1) {\n\t    try {\n\t\tthis.md = new KJUR.crypto.MessageDigest({\'alg\':this.mdAlgName,\'prov\':\'cryptojs\'});\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;\n\t    }\n\n\t    this.initSign = function(prvKey) {\n\t\tthis.prvKey = prvKey;\n\t\tthis.state = "SIGN";\n\t    };\n\n\t    this.initVerifyByPublicKey = function(rsaPubKey) {\n\t\tthis.pubKey = rsaPubKey;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tvar x509 = new X509();\n\t\tx509.readCertPEM(certPEM);\n\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.updateString = function(str) {\n\t\tthis.md.updateString(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tthis.md.updateHex(hex);\n\t    };\n\t    this.sign = function() {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.prvKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\t\tthis.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);\n\t\tthis.hPaddedDigestInfo = \n                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);\n\n\t\tvar biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);\n\t\tthis.hoge = biPaddedDigestInfo.toString(16);\n\n\t\tvar biSign = this.prvKey.doPrivate(biPaddedDigestInfo);\n\t\tthis.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);\n\t\treturn this.hSign;\n\t    };\n\t    this.signString = function(str) {\n\t\tthis.updateString(str);\n\t\tthis.sign();\n\t    };\n\t    this.signHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\tthis.sign();\n\t    };\n\t    this.verify = function(hSigVal) {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.pubKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\n\t\tvar biSigVal = parseBigInt(hSigVal, 16);\n\t\tvar biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);\n\t\tthis.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);\n                var s = this.hPaddedDigestInfo;\n                s = s.replace(/^1ff+00/, \'\');\n\n\t\tvar hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];\n                if (s.indexOf(hDIHEAD) != 0) {\n\t\t    return false;\n\t\t}\n\t\tvar hHashFromDI = s.substr(hDIHEAD.length);\n\t\t//alert(hHashFromDI + "\\n" + this.sHashHex);\n\t\treturn (hHashFromDI == this.sHashHex);\n\t    };\n\t}\n    };\n\n    /**\n     * Initialize this object for verifying with a public key\n     * @name initVerifyByPublicKey\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} rsaPubKey RSAKey object of public key\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByPublicKey(prvKey)\n     */\n    this.initVerifyByPublicKey = function(rsaPubKey) {\n\tthrow "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a certficate\n     * @name initVerifyByCertificatePEM\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} certPEM PEM formatted string of certificate\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByCertificatePEM(certPEM)\n     */\n    this.initVerifyByCertificatePEM = function(certPEM) {\n\tthrow "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for signing\n     * @name initSign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} prvKey RSAKey object of private key\n     * @description\n     * @example\n     * sig.initSign(prvKey)\n     */\n    this.initSign = function(prvKey) {\n\tthrow "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a string\n     * @name updateString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to use for the update\n     * @description\n     * @example\n     * sig.updateString(\'aaa\')\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to use for the update\n     * @description\n     * @example\n     * sig.updateHex(\'1f2f3f\')\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Returns the signature bytes of all data updates as a hexadecimal string\n     * @name sign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @return the signature bytes as a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.sign()\n     */\n    this.sign = function() {\n\tthrow "sign() not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signString(\'aaa\')\n     */\n    this.signString = function(str) {\n\tthrow "digestString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signHex(\'1fdc33\')\n     */\n    this.signHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * verifies the passed-in signature.\n     * @name verify\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return {Boolean} true if the signature was verified, otherwise false\n     * @description\n     * @example\n     * var isValid = sig.verify(\'1fbcefdca4823a7(snip)\')\n     */\n    this.verify = function(hSigVal) {\n\tthrow "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.algProvName = params[\'alg\'] + ":" + params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t    this._setAlgNames();\n\t}\n\tif (typeof params[\'prvkeypem\'] != "undefined") {\n\t    if (typeof params[\'prvkeypas\'] != "undefined") {\n\t\tthrow "both prvkeypem and prvkeypas parameters not supported";\n\t    } else {\n\t\ttry {\n\t\t    var prvKey = new RSAKey();\n\t\t    prvKey.readPrivateKeyFromPEMString(params[\'prvkeypem\']);\n\t\t    this.initSign(prvKey);\n\t\t} catch (ex) {\n\t\t    throw "fatal error to load pem private key: " + ex;\n\t\t}\n\t    }\n\t}\n    }\n};\nmodule.exports = KJUR\n\n},{"./sha256.js":116,"jsbn":120}],93:[function(require,module,exports){\n/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-sign.js - adding signing functions to RSAKey class.\n//\n//\n// version: 1.2.2 (13 May 2013)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n\n//\n// Depends on:\n//   function sha1.hex(s) of sha1.js\n//   jsbn.js\n//   jsbn2.js\n//   rsa.js\n//   rsa2.js\n//\nvar BigInteger = require(\'jsbn\')\nvar RSAKey= require(\'./rsapem-1.1.js\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// keysize / pmstrlen\n//  512 /  128\n// 1024 /  256\n// 2048 /  512\n// 4096 / 1024\n\n/**\n * @fileOverview\n * @name rsasign-1.2.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * @property {Dictionary} _RSASIGN_DIHEAD\n * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.\n * You can add any DigestInfo hash algorith for signing.\n * See PKCS#1 v2.1 spec (p38).\n */\nvar _RSASIGN_DIHEAD = [];\n_RSASIGN_DIHEAD[\'sha1\'] =      "3021300906052b0e03021a05000414";\n_RSASIGN_DIHEAD[\'sha256\'] =    "3031300d060960864801650304020105000420";\n_RSASIGN_DIHEAD[\'sha384\'] =    "3041300d060960864801650304020205000430";\n_RSASIGN_DIHEAD[\'sha512\'] =    "3051300d060960864801650304020305000440";\n_RSASIGN_DIHEAD[\'md2\'] =       "3020300c06082a864886f70d020205000410";\n_RSASIGN_DIHEAD[\'md5\'] =       "3020300c06082a864886f70d020505000410";\n_RSASIGN_DIHEAD[\'ripemd160\'] = "3021300906052b2403020105000414";\n\n/**\n * @property {Dictionary} _RSASIGN_HASHHEXFUNC\n * @description Array of functions which calculate hash and returns it as hexadecimal.\n * You can add any hash algorithm implementations.\n */\nvar _RSASIGN_HASHHEXFUNC = [];\n_RSASIGN_HASHHEXFUNC[\'sha1\'] =      function(s){return KJUR.crypto.Util.sha1(s);};\n_RSASIGN_HASHHEXFUNC[\'sha256\'] =    function(s){return KJUR.crypto.Util.sha256(s);}\n_RSASIGN_HASHHEXFUNC[\'sha512\'] =    function(s){return KJUR.crypto.Util.sha512(s);}\n_RSASIGN_HASHHEXFUNC[\'md5\'] =       function(s){return KJUR.crypto.Util.md5(s);};\n_RSASIGN_HASHHEXFUNC[\'ripemd160\'] = function(s){return KJUR.crypto.Util.ripemd160(s);};\n\n//_RSASIGN_HASHHEXFUNC[\'sha1\'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n//_RSASIGN_HASHHEXFUNC[\'sha256\'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n\nvar _RE_HEXDECONLY = new RegExp("");\n_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");\n\n// ========================================================================\n// Signature Generation\n// ========================================================================\n\nfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n    var pmStrLen = keySize / 4;\n    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];\n    var sHashHex = hashFunc(s);\n\n    var sHead = "0001";\n    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;\n    var sMid = "";\n    var fLen = pmStrLen - sHead.length - sTail.length;\n    for (var i = 0; i < fLen; i += 2) {\n\tsMid += "ff";\n    }\n    sPaddedMessageHex = sHead + sMid + sTail;\n    return sPaddedMessageHex;\n}\n\nfunction _zeroPaddingOfSignature(hex, bitLength) {\n    var s = "";\n    var nZero = bitLength / 4 - hex.length;\n    for (var i = 0; i < nZero; i++) {\n\ts = s + "0";\n    }\n    return s + hex;\n}\n\n/**\n * sign for a message string with RSA private key.<br/>\n * @name signString\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signString(s, hashAlg) {\n    //alert("this.n.bitLength() = " + this.n.bitLength());\n    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);\n    var biPaddedMessage = parseBigInt(hPM, 16);\n    var biSign = this.doPrivate(biPaddedMessage);\n    var hexSign = biSign.toString(16);\n    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n}\n\nfunction _rsasign_signStringWithSHA1(s) {\n    return _rsasign_signString.call(this, s, \'sha1\');\n}\n\nfunction _rsasign_signStringWithSHA256(s) {\n    return _rsasign_signString.call(this, s, \'sha256\');\n}\n\n// PKCS#1 (PSS) mask generation function\nfunction pss_mgf1_str(seed, len, hash) {\n    var mask = \'\', i = 0;\n\n    while (mask.length < len) {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(s);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var salt = \'\';\n\n    if (sLen > 0) {\n        salt = new Array(sLen);\n        new SecureRandom().nextBytes(salt);\n        salt = String.fromCharCode.apply(String, salt);\n    }\n\n    var H = hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash + salt);\n    var PS = [];\n\n    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n        PS[i] = 0x00;\n    }\n\n    var DB = String.fromCharCode.apply(String, PS) + \'\\x01\' + salt;\n    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n    maskedDB[0] &= ~mask;\n\n    for (i = 0; i < hLen; i++) {\n        maskedDB.push(H.charCodeAt(i));\n    }\n\n    maskedDB.push(0xbc);\n\n    return _zeroPaddingOfSignature(\n            this.doPrivate(new BigInteger(maskedDB)).toString(16),\n            this.n.bitLength());\n}\n\n// ========================================================================\n// Signature Verification\n// ========================================================================\n\nfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n    var rsa = new RSAKey();\n    rsa.setPublic(hN, hE);\n    var biDecryptedSig = rsa.doPublic(biSig);\n    return biDecryptedSig;\n}\n\nfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    return hDigestInfo;\n}\n\nfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n    for (var algName in _RSASIGN_DIHEAD) {\n\tvar head = _RSASIGN_DIHEAD[algName];\n\tvar len = head.length;\n\tif (hDigestInfo.substring(0, len) == head) {\n\t    var a = [algName, hDigestInfo.substring(len)];\n\t    return a;\n\t}\n    }\n    return [];\n}\n\nfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\nfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n    var biSig = parseBigInt(hSig, 16);\n    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t  this.e.toString(16));\n    return result;\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyString\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyString(sMsg, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, \'\');\n    if (hSig.length != this.n.bitLength() / 4) return 0;\n    hSig = hSig.replace(/[ \\n]+/g, "");\n    var biSig = parseBigInt(hSig, 16);\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n  \n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n    if (hSig.length !== this.n.bitLength() / 4) {\n        return false;\n    }\n\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(sMsg);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();\n\n    for (i = 0; i < em.length; i += 1) {\n        em[i] &= 0xff;\n    }\n\n    while (em.length < emLen) {\n        em.unshift(0);\n    }\n\n    if (em[emLen -1] !== 0xbc) {\n        throw "encoded message does not end in 0xbc";\n    }\n\n    em = String.fromCharCode.apply(String, em);\n\n    var maskedDB = em.substr(0, emLen - hLen - 1);\n    var H = em.substr(maskedDB.length, hLen);\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n        throw "bits beyond keysize not zero";\n    }\n\n    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1) {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB[0] &= ~mask;\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i += 1) {\n        if (DB[i] !== 0x00) {\n            throw "leftmost octets not zero";\n        }\n    }\n\n    if (DB[checkLen] !== 0x01) {\n        throw "0x01 marker not found";\n    }\n\n    return H === hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash +\n                          String.fromCharCode.apply(String, DB.slice(-sLen)));\n}\n\nRSAKey.prototype.signString = _rsasign_signString;\nRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.sign = _rsasign_signString;\nRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\nRSAKey.prototype.signPSS = _rsasign_signStringPSS;\nRSAKey.SALT_LEN_HLEN = -1;\nRSAKey.SALT_LEN_MAX = -2;\n\nRSAKey.prototype.verifyString = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verify = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\nRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\nRSAKey.SALT_LEN_RECOVER = -2;\n\n/**\n * @name RSAKey\n * @class key of RSA public key algorithm\n * @description Tom Wu\'s RSA Key class and extension\n */\n\nmodule.exports = RSAKey\n\n},{"./rsapem-1.1.js":118,"jsbn":120}],120:[function(require,module,exports){\n(function(){\n    \n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary&0xffffff)==0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a,b,c) {\n      if(a != null)\n        if("number" == typeof a) this.fromNumber(a,b,c);\n        else if(b == null && "string" != typeof a) this.fromString(a,256);\n        else this.fromString(a,b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i,x,w,j,c,n) {\n      while(--n >= 0) {\n        var v = x*this[i++]+w[j]+c;\n        c = Math.floor(v/0x4000000);\n        w[j++] = v&0x3ffffff;\n      }\n      return c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i,x,w,j,c,n) {\n      var xl = x&0x7fff, xh = x>>15;\n      while(--n >= 0) {\n        var l = this[i]&0x7fff;\n        var h = this[i++]>>15;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n        w[j++] = l&0x3fffffff;\n      }\n      return c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i,x,w,j,c,n) {\n      var xl = x&0x3fff, xh = x>>14;\n      while(--n >= 0) {\n        var l = this[i]&0x3fff;\n        var h = this[i++]>>14;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n        c = (l>>28)+(m>>14)+xh*h;\n        w[j++] = l&0xfffffff;\n      }\n      return c;\n    }\n    var inBrowser = typeof navigator !== "undefined";\n    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\n      BigInteger.prototype.am = am2;\n      dbits = 30;\n    }\n    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {\n      BigInteger.prototype.am = am1;\n      dbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1<<dbits)-1);\n    BigInteger.prototype.DV = (1<<dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n    BigInteger.prototype.F1 = BI_FP-dbits;\n    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n    // Digit conversions\n    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\n    var BI_RC = new Array();\n    var rr,vv;\n    rr = "0".charCodeAt(0);\n    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = "a".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = "A".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s,i) {\n      var c = BI_RC[s.charCodeAt(i)];\n      return (c==null)?-1:c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n      r.t = this.t;\n      r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n      this.t = 1;\n      this.s = (x<0)?-1:0;\n      if(x > 0) this[0] = x;\n      else if(x < -1) this[0] = x+DV;\n      else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n    function bnpFromString(s,b) {\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 256) k = 8; // byte array\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else { this.fromRadix(s,b); return; }\n      this.t = 0;\n      this.s = 0;\n      var i = s.length, mi = false, sh = 0;\n      while(--i >= 0) {\n        var x = (k==8)?s[i]&0xff:intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-") mi = true;\n          continue;\n        }\n        mi = false;\n        if(sh == 0)\n          this[this.t++] = x;\n        else if(sh+k > this.DB) {\n          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n          this[this.t++] = (x>>(this.DB-sh));\n        }\n        else\n          this[this.t-1] |= x<<sh;\n        sh += k;\n        if(sh >= this.DB) sh -= this.DB;\n      }\n      if(k == 8 && (s[0]&0x80) != 0) {\n        this.s = -1;\n        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n      }\n      this.clamp();\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n      var c = this.s&this.DM;\n      while(this.t > 0 && this[this.t-1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n      if(this.s < 0) return "-"+this.negate().toString(b);\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else return this.toRadix(b);\n      var km = (1<<k)-1, d, m = false, r = "", i = this.t;\n      var p = this.DB-(i*this.DB)%k;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n        while(i >= 0) {\n          if(p < k) {\n            d = (this[i]&((1<<p)-1))<<(k-p);\n            d |= this[--i]>>(p+=this.DB-k);\n          }\n          else {\n            d = (this[i]>>(p-=k))&km;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if(d > 0) m = true;\n          if(m) r += int2char(d);\n        }\n      }\n      return m?r:"0";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s<0)?this.negate():this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n      var r = this.s-a.s;\n      if(r != 0) return r;\n      var i = this.t;\n      r = i-a.t;\n      if(r != 0) return (this.s<0)?-r:r;\n      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n      return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n      var r = 1, t;\n      if((t=x>>>16) != 0) { x = t; r += 16; }\n      if((t=x>>8) != 0) { x = t; r += 8; }\n      if((t=x>>4) != 0) { x = t; r += 4; }\n      if((t=x>>2) != 0) { x = t; r += 2; }\n      if((t=x>>1) != 0) { x = t; r += 1; }\n      return r;\n    }\n\n    // (public) return the number of bits in "this"\n    function bnBitLength() {\n      if(this.t <= 0) return 0;\n      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n,r) {\n      var i;\n      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n      for(i = n-1; i >= 0; --i) r[i] = 0;\n      r.t = this.t+n;\n      r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n,r) {\n      for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n      r.t = Math.max(this.t-n,0);\n      r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n,r) {\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<cbs)-1;\n      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n      for(i = this.t-1; i >= 0; --i) {\n        r[i+ds+1] = (this[i]>>cbs)|c;\n        c = (this[i]&bm)<<bs;\n      }\n      for(i = ds-1; i >= 0; --i) r[i] = 0;\n      r[ds] = c;\n      r.t = this.t+ds+1;\n      r.s = this.s;\n      r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n,r) {\n      r.s = this.s;\n      var ds = Math.floor(n/this.DB);\n      if(ds >= this.t) { r.t = 0; return; }\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<bs)-1;\n      r[0] = this[ds]>>bs;\n      for(var i = ds+1; i < this.t; ++i) {\n        r[i-ds-1] |= (this[i]&bm)<<cbs;\n        r[i-ds] = this[i]>>bs;\n      }\n      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n      r.t = this.t-ds;\n      r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]-a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c -= a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c -= a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c -= a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c < -1) r[i++] = this.DV+c;\n      else if(c > 0) r[i++] = c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyTo(a,r) {\n      var x = this.abs(), y = a.abs();\n      var i = x.t;\n      r.t = i+y.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n      r.s = 0;\n      r.clamp();\n      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n      var x = this.abs();\n      var i = r.t = 2*x.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < x.t-1; ++i) {\n        var c = x.am(i,x[i],r,2*i,0,1);\n        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n          r[i+x.t] -= x.DV;\n          r[i+x.t+1] = 1;\n        }\n      }\n      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n      r.s = 0;\n      r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m,q,r) {\n      var pm = m.abs();\n      if(pm.t <= 0) return;\n      var pt = this.abs();\n      if(pt.t < pm.t) {\n        if(q != null) q.fromInt(0);\n        if(r != null) this.copyTo(r);\n        return;\n      }\n      if(r == null) r = nbi();\n      var y = nbi(), ts = this.s, ms = m.s;\n      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n      else { pm.copyTo(y); pt.copyTo(r); }\n      var ys = y.t;\n      var y0 = y[ys-1];\n      if(y0 == 0) return;\n      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n      var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n      y.dlShiftTo(j,t);\n      if(r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t,r);\n      }\n      BigInteger.ONE.dlShiftTo(ys,t);\n      t.subTo(y,y);  // "negative" y so we can replace sub with am later\n      while(y.t < ys) y[y.t++] = 0;\n      while(--j >= 0) {\n        // Estimate quotient digit\n        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n          y.dlShiftTo(j,t);\n          r.subTo(t,r);\n          while(r[i] < --qd) r.subTo(t,r);\n        }\n      }\n      if(q != null) {\n        r.drShiftTo(ys,q);\n        if(ts != ms) BigInteger.ZERO.subTo(q,q);\n      }\n      r.t = ys;\n      r.clamp();\n      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n      if(ts < 0) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n      var r = nbi();\n      this.abs().divRemTo(a,null,r);\n      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n      return r;\n    }\n\n    // Modular reduction using "classic" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n      else return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m,null,x); }\n    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply "overflows" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n      if(this.t < 1) return 0;\n      var x = this[0];\n      if((x&1) == 0) return 0;\n      var y = x&3;       // y == 1/x mod 2^2\n      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n      // last step - calculate inverse mod DV directly;\n      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n      // we really want the negative inverse, and -DV < y < DV\n      return (y>0)?this.DV-y:-y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n      this.m = m;\n      this.mp = m.invDigit();\n      this.mpl = this.mp&0x7fff;\n      this.mph = this.mp>>15;\n      this.um = (1<<(m.DB-15))-1;\n      this.mt2 = 2*m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n      var r = nbi();\n      x.abs().dlShiftTo(this.m.t,r);\n      r.divRemTo(this.m,null,r);\n      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n      return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n      while(x.t <= this.mt2) // pad x so am has enough room later\n        x[x.t++] = 0;\n      for(var i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        var j = x[i]&0x7fff;\n        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i+this.m.t;\n        x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n        // propagate carry\n        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n      }\n      x.clamp();\n      x.drShiftTo(this.m.t,x);\n      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = "x^2/R mod m"; x != r\n    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = "xy/R mod m"; x,y != r\n    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)\n    function bnpExp(e,z) {\n      if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n      g.copyTo(r);\n      while(--i >= 0) {\n        z.sqrTo(r,r2);\n        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n        else { var t = r; r = r2; r2 = t; }\n      }\n      return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e,m) {\n      var z;\n      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n      return this.exp(e,z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // "constants"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger("0", 10) returns "proper" zero\n    // Version 1.2: square() API, isProbablePrime fix\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n      if(this.s < 0) {\n        if(this.t == 1) return this[0]-this.DV;\n        else if(this.t == 0) return -1;\n      }\n      else if(this.t == 1) return this[0];\n      else if(this.t == 0) return 0;\n      // assumes 16 < DB < 32\n      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n      if(this.s < 0) return -1;\n      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n      else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n      if(b == null) b = 10;\n      if(this.signum() == 0 || b < 2 || b > 36) return "0";\n      var cs = this.chunkSize(b);\n      var a = Math.pow(b,cs);\n      var d = nbv(a), y = nbi(), z = nbi(), r = "";\n      this.divRemTo(d,y,z);\n      while(y.signum() > 0) {\n        r = (a+z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d,y,z);\n      }\n      return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s,b) {\n      this.fromInt(0);\n      if(b == null) b = 10;\n      var cs = this.chunkSize(b);\n      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n      for(var i = 0; i < s.length; ++i) {\n        var x = intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;\n          continue;\n        }\n        w = b*w+x;\n        if(++j >= cs) {\n          this.dMultiply(d);\n          this.dAddOffset(w,0);\n          j = 0;\n          w = 0;\n        }\n      }\n      if(j > 0) {\n        this.dMultiply(Math.pow(b,j));\n        this.dAddOffset(w,0);\n      }\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a,b,c) {\n      if("number" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if(a < 2) this.fromInt(1);\n        else {\n          this.fromNumber(a,c);\n          if(!this.testBit(a-1))\t// force MSB set\n            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n          if(this.isEven()) this.dAddOffset(1,0); // force odd\n          while(!this.isProbablePrime(b)) {\n            this.dAddOffset(2,0);\n            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n          }\n        }\n      }\n      else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a&7;\n        x.length = (a>>3)+1;\n        b.nextBytes(x);\n        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n        this.fromString(x,256);\n      }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n      var i = this.t, r = new Array();\n      r[0] = this.s;\n      var p = this.DB-(i*this.DB)%8, d, k = 0;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n          r[k++] = d|(this.s<<(this.DB-p));\n        while(i >= 0) {\n          if(p < 8) {\n            d = (this[i]&((1<<p)-1))<<(8-p);\n            d |= this[--i]>>(p+=this.DB-8);\n          }\n          else {\n            d = (this[i]>>(p-=8))&0xff;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if((d&0x80) != 0) d |= -256;\n          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n          if(k > 0 || d != this.s) r[k++] = d;\n        }\n      }\n      return r;\n    }\n\n    function bnEquals(a) { return(this.compareTo(a)==0); }\n    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a,op,r) {\n      var i, f, m = Math.min(a.t,this.t);\n      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n      if(a.t < this.t) {\n        f = a.s&this.DM;\n        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n        r.t = this.t;\n      }\n      else {\n        f = this.s&this.DM;\n        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n        r.t = a.t;\n      }\n      r.s = op(this.s,a.s);\n      r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x,y) { return x&y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n    // (public) this | a\n    function op_or(x,y) { return x|y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x,y) { return x^y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x,y) { return x&~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n      var r = nbi();\n      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n      r.t = this.t;\n      r.s = ~this.s;\n      return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n      var r = nbi();\n      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n      return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n      var r = nbi();\n      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n      return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n      if(x == 0) return -1;\n      var r = 0;\n      if((x&0xffff) == 0) { x >>= 16; r += 16; }\n      if((x&0xff) == 0) { x >>= 8; r += 8; }\n      if((x&0xf) == 0) { x >>= 4; r += 4; }\n      if((x&3) == 0) { x >>= 2; r += 2; }\n      if((x&1) == 0) ++r;\n      return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n      for(var i = 0; i < this.t; ++i)\n        if(this[i] != 0) return i*this.DB+lbit(this[i]);\n      if(this.s < 0) return this.t*this.DB;\n      return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n      var r = 0;\n      while(x != 0) { x &= x-1; ++r; }\n      return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n      var r = 0, x = this.s&this.DM;\n      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n      return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n      var j = Math.floor(n/this.DB);\n      if(j >= this.t) return(this.s!=0);\n      return((this[j]&(1<<(n%this.DB)))!=0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n,op) {\n      var r = BigInteger.ONE.shiftLeft(n);\n      this.bitwiseTo(r,op,r);\n      return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]+a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c += a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c += a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c > 0) r[i++] = c;\n      else if(c < -1) r[i++] = this.DV+c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n    // (public) this^2\n    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n      var q = nbi(), r = nbi();\n      this.divRemTo(a,q,r);\n      return new Array(q,r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n      this[this.t] = this.am(0,n-1,this,0,0,this.t);\n      ++this.t;\n      this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n,w) {\n      if(n == 0) return;\n      while(this.t <= w) this[this.t++] = 0;\n      this[w] += n;\n      while(this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if(++w >= this.t) this[this.t++] = 0;\n        ++this[w];\n      }\n    }\n\n    // A "null" reducer\n    function NullExp() {}\n    function nNop(x) { return x; }\n    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n    function nSqrTo(x,r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.exp(e,new NullExp()); }\n\n    // (protected) r = lower n words of "this * a", a.t <= n\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a,n,r) {\n      var i = Math.min(this.t+a.t,n);\n      r.s = 0; // assumes a,this >= 0\n      r.t = i;\n      while(i > 0) r[--i] = 0;\n      var j;\n      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n      r.clamp();\n    }\n\n    // (protected) r = "this * a" without lower n words, n > 0\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a,n,r) {\n      --n;\n      var i = r.t = this.t+a.t-n;\n      r.s = 0; // assumes a,this >= 0\n      while(--i >= 0) r[i] = 0;\n      for(i = Math.max(n-this.t,0); i < a.t; ++i)\n        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n      r.clamp();\n      r.drShiftTo(1,r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n      // setup Barrett\n      this.r2 = nbi();\n      this.q3 = nbi();\n      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n      this.mu = this.r2.divide(m);\n      this.m = m;\n    }\n\n    function barrettConvert(x) {\n      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n      else if(x.compareTo(this.m) < 0) return x;\n      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n      x.drShiftTo(this.m.t-1,this.r2);\n      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n      x.subTo(this.r2,x);\n      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e,m) {\n      var i = e.bitLength(), k, r = nbv(1), z;\n      if(i <= 0) return r;\n      else if(i < 18) k = 1;\n      else if(i < 48) k = 3;\n      else if(i < 144) k = 4;\n      else if(i < 768) k = 5;\n      else k = 6;\n      if(i < 8)\n        z = new Classic(m);\n      else if(m.isEven())\n        z = new Barrett(m);\n      else\n        z = new Montgomery(m);\n\n      // precomputation\n      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n      g[1] = z.convert(this);\n      if(k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1],g2);\n        while(n <= km) {\n          g[n] = nbi();\n          z.mulTo(g2,g[n-2],g[n]);\n          n += 2;\n        }\n      }\n\n      var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n      i = nbits(e[j])-1;\n      while(j >= 0) {\n        if(i >= k1) w = (e[j]>>(i-k1))&km;\n        else {\n          w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n        }\n\n        n = k;\n        while((w&1) == 0) { w >>= 1; --n; }\n        if((i -= n) < 0) { i += this.DB; --j; }\n        if(is1) {\t// ret == 1, don\'t bother squaring or multiplying it\n          g[w].copyTo(r);\n          is1 = false;\n        }\n        else {\n          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n          z.mulTo(r2,g[w],r);\n        }\n\n        while(j >= 0 && (e[j]&(1<<i)) == 0) {\n          z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n          if(--i < 0) { i = this.DB-1; --j; }\n        }\n      }\n      return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n      var x = (this.s<0)?this.negate():this.clone();\n      var y = (a.s<0)?a.negate():a.clone();\n      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n      if(g < 0) return x;\n      if(i < g) g = i;\n      if(g > 0) {\n        x.rShiftTo(g,x);\n        y.rShiftTo(g,y);\n      }\n      while(x.signum() > 0) {\n        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n        if(x.compareTo(y) >= 0) {\n          x.subTo(y,x);\n          x.rShiftTo(1,x);\n        }\n        else {\n          y.subTo(x,y);\n          y.rShiftTo(1,y);\n        }\n      }\n      if(g > 0) y.lShiftTo(g,y);\n      return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n      if(n <= 0) return 0;\n      var d = this.DV%n, r = (this.s<0)?n-1:0;\n      if(this.t > 0)\n        if(d == 0) r = this[0]%n;\n        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n      return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n      var ac = m.isEven();\n      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n      var u = m.clone(), v = this.clone();\n      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n      while(u.signum() != 0) {\n        while(u.isEven()) {\n          u.rShiftTo(1,u);\n          if(ac) {\n            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n            a.rShiftTo(1,a);\n          }\n          else if(!b.isEven()) b.subTo(m,b);\n          b.rShiftTo(1,b);\n        }\n        while(v.isEven()) {\n          v.rShiftTo(1,v);\n          if(ac) {\n            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n            c.rShiftTo(1,c);\n          }\n          else if(!d.isEven()) d.subTo(m,d);\n          d.rShiftTo(1,d);\n        }\n        if(u.compareTo(v) >= 0) {\n          u.subTo(v,u);\n          if(ac) a.subTo(c,a);\n          b.subTo(d,b);\n        }\n        else {\n          v.subTo(u,v);\n          if(ac) c.subTo(a,c);\n          d.subTo(b,d);\n        }\n      }\n      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n      if(d.compareTo(m) >= 0) return d.subtract(m);\n      if(d.signum() < 0) d.addTo(m,d); else return d;\n      if(d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n      var i, x = this.abs();\n      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n        for(i = 0; i < lowprimes.length; ++i)\n          if(x[0] == lowprimes[i]) return true;\n        return false;\n      }\n      if(x.isEven()) return false;\n      i = 1;\n      while(i < lowprimes.length) {\n        var m = lowprimes[i], j = i+1;\n        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j) if(m%lowprimes[i++] == 0) return false;\n      }\n      return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n      var n1 = this.subtract(BigInteger.ONE);\n      var k = n1.getLowestSetBit();\n      if(k <= 0) return false;\n      var r = n1.shiftRight(k);\n      t = (t+1)>>1;\n      if(t > lowprimes.length) t = lowprimes.length;\n      var a = nbi();\n      for(var i = 0; i < t; ++i) {\n        //Pick bases at random, instead of starting at 2\n        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n        var y = a.modPow(r,this);\n        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n          var j = 1;\n          while(j++ < k && y.compareTo(n1) != 0) {\n            y = y.modPowInt(2,this);\n            if(y.compareTo(BigInteger.ONE) == 0) return false;\n          }\n          if(y.compareTo(n1) != 0) return false;\n        }\n      }\n      return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // JSBN-specific extension\n    BigInteger.prototype.square = bnSquare;\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n    if (typeof exports !== \'undefined\') {\n        exports = module.exports = BigInteger;\n    } else {\n        this.BigInteger = BigInteger;\n    }\n    \n}).call(this);\n},{}],114:[function(require,module,exports){\n// Depends on rsa.js and jsbn2.js\nvar BigInteger = require(\'jsbn\')\nvar RSAKey = require(\'./rsa.js\')\n// Version 1.1: support utf-8 decoding in pkcs1unpad2\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\nfunction pkcs1unpad2(d,n) {\n  var b = d.toByteArray();\n  var i = 0;\n  while(i < b.length && b[i] == 0) ++i;\n  if(b.length-i != n-1 || b[i] != 2)\n    return null;\n  ++i;\n  while(b[i] != 0)\n    if(++i >= b.length) return null;\n  var ret = "";\n  while(++i < b.length) {\n    var c = b[i] & 255;\n    if(c < 128) { // utf-8 decode\n      ret += String.fromCharCode(c);\n    }\n    else if((c > 191) && (c < 224)) {\n      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));\n      ++i;\n    }\n    else {\n      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));\n      i += 2;\n    }\n  }\n  return ret;\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_str(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext\nfunction oaep_unpad(d, n, hash)\n{\n    d = d.toByteArray();\n\n    var i;\n\n    for (i = 0; i < d.length; i += 1)\n    {\n        d[i] &= 0xff;\n    }\n\n    while (d.length < n)\n    {\n        d.unshift(0);\n    }\n\n    d = String.fromCharCode.apply(String, d);\n\n    if (d.length < 2 * SHA1_SIZE + 2)\n    {\n        throw "Cipher too short";\n    }\n\n    var maskedSeed = d.substr(1, SHA1_SIZE)\n    var maskedDB = d.substr(SHA1_SIZE + 1);\n\n    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);\n    var seed = [], i;\n\n    for (i = 0; i < maskedSeed.length; i += 1)\n    {\n        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);\n    }\n\n    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),\n                           d.length - SHA1_SIZE, rstr_sha1);\n\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1)\n    {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB = String.fromCharCode.apply(String, DB);\n\n    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(\'\'))\n    {\n        throw "Hash mismatch";\n    }\n\n    DB = DB.substr(SHA1_SIZE);\n\n    var first_one = DB.indexOf(\'\\x01\');\n    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf(\'\\x00\') : -1;\n\n    if (last_zero + 1 != first_one)\n    {\n        throw "Malformed data";\n    }\n\n    return DB.substr(first_one + 1);\n}\n\n// Set the private key fields N, e, and d from hex strings\nfunction RSASetPrivate(N,E,D) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n    this.d = D;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n  }\n  else\n    alert("Invalid RSA private key");\n}\n\n// Set the private key fields N, e, d and CRT params from hex strings\nfunction RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {\n  //alert("RSASetPrivateEx called");\n  if (N == null) throw "RSASetPrivateEx N == null";\n  if (E == null) throw "RSASetPrivateEx E == null";\n  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";\n  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";\n\n  if (N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n    this.p = parseBigInt(P,16);\n    this.q = parseBigInt(Q,16);\n    this.dmp1 = parseBigInt(DP,16);\n    this.dmq1 = parseBigInt(DQ,16);\n    this.coeff = parseBigInt(C,16);\n  } else {\n    alert("Invalid RSA private key in RSASetPrivateEx");\n  }\n}\n\n// Generate a new random private key B bits long, using public expt E\nfunction RSAGenerate(B,E) {\n  var rng = new SecureRandom();\n  var qs = B>>1;\n  this.e = parseInt(E,16);\n  var ee = new BigInteger(E,16);\n  for(;;) {\n    for(;;) {\n      this.p = new BigInteger(B-qs,1,rng);\n      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;\n    }\n    for(;;) {\n      this.q = new BigInteger(qs,1,rng);\n      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;\n    }\n    if(this.p.compareTo(this.q) <= 0) {\n      var t = this.p;\n      this.p = this.q;\n      this.q = t;\n    }\n    var p1 = this.p.subtract(BigInteger.ONE);\t// p1 = p - 1\n    var q1 = this.q.subtract(BigInteger.ONE);\t// q1 = q - 1\n    var phi = p1.multiply(q1);\n    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n      this.n = this.p.multiply(this.q);\t// this.n = p * q\n      this.d = ee.modInverse(phi);\t// this.d = \n      this.dmp1 = this.d.mod(p1);\t// this.dmp1 = d mod (p - 1)\n      this.dmq1 = this.d.mod(q1);\t// this.dmq1 = d mod (q - 1)\n      this.coeff = this.q.modInverse(this.p);\t// this.coeff = (q ^ -1) mod p\n      break;\n    }\n  }\n}\n\n// Perform raw private operation on "x": return x^d (mod n)\nfunction RSADoPrivate(x) {\n  if(this.p == null || this.q == null)\n    return x.modPow(this.d, this.n);\n\n  // TODO: re-calculate any missing CRT params\n  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?\n  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?\n\n  while(xp.compareTo(xq) < 0)\n    xp = xp.add(this.p);\n  // NOTE:\n  // xp.subtract(xq) => cp -cq\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M\n  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecrypt(ctext) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);\n}\n\n// Return the PKCS#1 OAEP RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecryptOAEP(ctext, hash) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is a Base64-encoded string and the output is a plain string.\n//function RSAB64Decrypt(ctext) {\n//  var h = b64tohex(ctext);\n//  if(h) return this.decrypt(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPrivate = RSADoPrivate;\n\n// public\nRSAKey.prototype.setPrivate = RSASetPrivate;\nRSAKey.prototype.setPrivateEx = RSASetPrivateEx;\nRSAKey.prototype.generate = RSAGenerate;\nRSAKey.prototype.decrypt = RSADecrypt;\nRSAKey.prototype.decryptOAEP = RSADecryptOAEP;\n//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;\n\nmodule.exports = RSAKey\n\n},{"./rsa.js":121,"jsbn":115}],119:[function(require,module,exports){\n// Depends on rsa.js and jsbn2.js\nvar BigInteger = require(\'jsbn\')\nvar RSAKey = require(\'./rsa.js\')\n// Version 1.1: support utf-8 decoding in pkcs1unpad2\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\nfunction pkcs1unpad2(d,n) {\n  var b = d.toByteArray();\n  var i = 0;\n  while(i < b.length && b[i] == 0) ++i;\n  if(b.length-i != n-1 || b[i] != 2)\n    return null;\n  ++i;\n  while(b[i] != 0)\n    if(++i >= b.length) return null;\n  var ret = "";\n  while(++i < b.length) {\n    var c = b[i] & 255;\n    if(c < 128) { // utf-8 decode\n      ret += String.fromCharCode(c);\n    }\n    else if((c > 191) && (c < 224)) {\n      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));\n      ++i;\n    }\n    else {\n      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));\n      i += 2;\n    }\n  }\n  return ret;\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_str(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext\nfunction oaep_unpad(d, n, hash)\n{\n    d = d.toByteArray();\n\n    var i;\n\n    for (i = 0; i < d.length; i += 1)\n    {\n        d[i] &= 0xff;\n    }\n\n    while (d.length < n)\n    {\n        d.unshift(0);\n    }\n\n    d = String.fromCharCode.apply(String, d);\n\n    if (d.length < 2 * SHA1_SIZE + 2)\n    {\n        throw "Cipher too short";\n    }\n\n    var maskedSeed = d.substr(1, SHA1_SIZE)\n    var maskedDB = d.substr(SHA1_SIZE + 1);\n\n    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);\n    var seed = [], i;\n\n    for (i = 0; i < maskedSeed.length; i += 1)\n    {\n        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);\n    }\n\n    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),\n                           d.length - SHA1_SIZE, rstr_sha1);\n\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1)\n    {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB = String.fromCharCode.apply(String, DB);\n\n    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(\'\'))\n    {\n        throw "Hash mismatch";\n    }\n\n    DB = DB.substr(SHA1_SIZE);\n\n    var first_one = DB.indexOf(\'\\x01\');\n    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf(\'\\x00\') : -1;\n\n    if (last_zero + 1 != first_one)\n    {\n        throw "Malformed data";\n    }\n\n    return DB.substr(first_one + 1);\n}\n\n// Set the private key fields N, e, and d from hex strings\nfunction RSASetPrivate(N,E,D) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n    this.d = D;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n  }\n  else\n    alert("Invalid RSA private key");\n}\n\n// Set the private key fields N, e, d and CRT params from hex strings\nfunction RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {\n  //alert("RSASetPrivateEx called");\n  if (N == null) throw "RSASetPrivateEx N == null";\n  if (E == null) throw "RSASetPrivateEx E == null";\n  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";\n  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";\n\n  if (N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n    this.p = parseBigInt(P,16);\n    this.q = parseBigInt(Q,16);\n    this.dmp1 = parseBigInt(DP,16);\n    this.dmq1 = parseBigInt(DQ,16);\n    this.coeff = parseBigInt(C,16);\n  } else {\n    alert("Invalid RSA private key in RSASetPrivateEx");\n  }\n}\n\n// Generate a new random private key B bits long, using public expt E\nfunction RSAGenerate(B,E) {\n  var rng = new SecureRandom();\n  var qs = B>>1;\n  this.e = parseInt(E,16);\n  var ee = new BigInteger(E,16);\n  for(;;) {\n    for(;;) {\n      this.p = new BigInteger(B-qs,1,rng);\n      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;\n    }\n    for(;;) {\n      this.q = new BigInteger(qs,1,rng);\n      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;\n    }\n    if(this.p.compareTo(this.q) <= 0) {\n      var t = this.p;\n      this.p = this.q;\n      this.q = t;\n    }\n    var p1 = this.p.subtract(BigInteger.ONE);\t// p1 = p - 1\n    var q1 = this.q.subtract(BigInteger.ONE);\t// q1 = q - 1\n    var phi = p1.multiply(q1);\n    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n      this.n = this.p.multiply(this.q);\t// this.n = p * q\n      this.d = ee.modInverse(phi);\t// this.d = \n      this.dmp1 = this.d.mod(p1);\t// this.dmp1 = d mod (p - 1)\n      this.dmq1 = this.d.mod(q1);\t// this.dmq1 = d mod (q - 1)\n      this.coeff = this.q.modInverse(this.p);\t// this.coeff = (q ^ -1) mod p\n      break;\n    }\n  }\n}\n\n// Perform raw private operation on "x": return x^d (mod n)\nfunction RSADoPrivate(x) {\n  if(this.p == null || this.q == null)\n    return x.modPow(this.d, this.n);\n\n  // TODO: re-calculate any missing CRT params\n  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?\n  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?\n\n  while(xp.compareTo(xq) < 0)\n    xp = xp.add(this.p);\n  // NOTE:\n  // xp.subtract(xq) => cp -cq\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M\n  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecrypt(ctext) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);\n}\n\n// Return the PKCS#1 OAEP RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecryptOAEP(ctext, hash) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is a Base64-encoded string and the output is a plain string.\n//function RSAB64Decrypt(ctext) {\n//  var h = b64tohex(ctext);\n//  if(h) return this.decrypt(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPrivate = RSADoPrivate;\n\n// public\nRSAKey.prototype.setPrivate = RSASetPrivate;\nRSAKey.prototype.setPrivateEx = RSASetPrivateEx;\nRSAKey.prototype.generate = RSAGenerate;\nRSAKey.prototype.decrypt = RSADecrypt;\nRSAKey.prototype.decryptOAEP = RSADecryptOAEP;\n//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;\n\nmodule.exports = RSAKey\n\n},{"./rsa.js":122,"jsbn":120}],121:[function(require,module,exports){\n// Depends on jsbn.js and rng.js\nvar BigInteger = require(\'jsbn\')\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n\n// convert a (hex) string to a bignum object\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\nfunction linebrk(s,n) {\n  var ret = "";\n  var i = 0;\n  while(i + n < s.length) {\n    ret += s.substring(i,i+n) + "\\n";\n    i += n;\n  }\n  return ret + s.substring(i,s.length);\n}\n\nfunction byte2Hex(b) {\n  if(b < 0x10)\n    return "0" + b.toString(16);\n  else\n    return b.toString(16);\n}\n\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s,n) {\n  if(n < s.length + 11) { // TODO: fix for utf-8\n    alert("Message too long for RSA");\n    return null;\n  }\n  var ba = new Array();\n  var i = s.length - 1;\n  while(i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n    if(c < 128) { // encode using utf-8\n      ba[--n] = c;\n    }\n    else if((c > 127) && (c < 2048)) {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = (c >> 6) | 192;\n    }\n    else {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = ((c >> 6) & 63) | 128;\n      ba[--n] = (c >> 12) | 224;\n    }\n  }\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = new Array();\n  while(n > 2) { // random non-zero pad\n    x[0] = 0;\n    while(x[0] == 0) rng.nextBytes(x);\n    ba[--n] = x[0];\n  }\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\nfunction oaep_pad(s, n, hash)\n{\n    if (s.length + 2 * SHA1_SIZE + 2 > n)\n    {\n        throw "Message too long for RSA";\n    }\n\n    var PS = \'\', i;\n\n    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)\n    {\n        PS += \'\\x00\';\n    }\n\n    var DB = rstr_sha1(\'\') + PS + \'\\x01\' + s;\n    var seed = new Array(SHA1_SIZE);\n    new SecureRandom().nextBytes(seed);\n    \n    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1)\n    {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);\n    var maskedSeed = [0];\n\n    for (i = 0; i < seed.length; i += 1)\n    {\n        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n    }\n\n    return new BigInteger(maskedSeed.concat(maskedDB));\n}\n\n// "empty" RSA key constructor\nfunction RSAKey() {\n  this.n = null;\n  this.e = 0;\n  this.d = null;\n  this.p = null;\n  this.q = null;\n  this.dmp1 = null;\n  this.dmq1 = null;\n  this.coeff = null;\n}\n\n// Set the public key fields N and e from hex strings\nfunction RSASetPublic(N,E) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n  }\n  else\n    alert("Invalid RSA public key");\n}\n\n// Perform raw public operation on "x": return x^e (mod n)\nfunction RSADoPublic(x) {\n  return x.modPowInt(this.e, this.n);\n}\n\n// Return the PKCS#1 RSA encryption of "text" as an even-length hex string\nfunction RSAEncrypt(text) {\n  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string\nfunction RSAEncryptOAEP(text, hash) {\n  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string\n//function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPublic = RSADoPublic;\n\n// public\nRSAKey.prototype.setPublic = RSASetPublic;\nRSAKey.prototype.encrypt = RSAEncrypt;\nRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n\n\nmodule.exports = RSAKey\n//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n\n},{"jsbn":115}],122:[function(require,module,exports){\n// Depends on jsbn.js and rng.js\nvar BigInteger = require(\'jsbn\')\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n\n// convert a (hex) string to a bignum object\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\nfunction linebrk(s,n) {\n  var ret = "";\n  var i = 0;\n  while(i + n < s.length) {\n    ret += s.substring(i,i+n) + "\\n";\n    i += n;\n  }\n  return ret + s.substring(i,s.length);\n}\n\nfunction byte2Hex(b) {\n  if(b < 0x10)\n    return "0" + b.toString(16);\n  else\n    return b.toString(16);\n}\n\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s,n) {\n  if(n < s.length + 11) { // TODO: fix for utf-8\n    alert("Message too long for RSA");\n    return null;\n  }\n  var ba = new Array();\n  var i = s.length - 1;\n  while(i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n    if(c < 128) { // encode using utf-8\n      ba[--n] = c;\n    }\n    else if((c > 127) && (c < 2048)) {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = (c >> 6) | 192;\n    }\n    else {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = ((c >> 6) & 63) | 128;\n      ba[--n] = (c >> 12) | 224;\n    }\n  }\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = new Array();\n  while(n > 2) { // random non-zero pad\n    x[0] = 0;\n    while(x[0] == 0) rng.nextBytes(x);\n    ba[--n] = x[0];\n  }\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\nfunction oaep_pad(s, n, hash)\n{\n    if (s.length + 2 * SHA1_SIZE + 2 > n)\n    {\n        throw "Message too long for RSA";\n    }\n\n    var PS = \'\', i;\n\n    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)\n    {\n        PS += \'\\x00\';\n    }\n\n    var DB = rstr_sha1(\'\') + PS + \'\\x01\' + s;\n    var seed = new Array(SHA1_SIZE);\n    new SecureRandom().nextBytes(seed);\n    \n    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1)\n    {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);\n    var maskedSeed = [0];\n\n    for (i = 0; i < seed.length; i += 1)\n    {\n        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n    }\n\n    return new BigInteger(maskedSeed.concat(maskedDB));\n}\n\n// "empty" RSA key constructor\nfunction RSAKey() {\n  this.n = null;\n  this.e = 0;\n  this.d = null;\n  this.p = null;\n  this.q = null;\n  this.dmp1 = null;\n  this.dmq1 = null;\n  this.coeff = null;\n}\n\n// Set the public key fields N and e from hex strings\nfunction RSASetPublic(N,E) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n  }\n  else\n    alert("Invalid RSA public key");\n}\n\n// Perform raw public operation on "x": return x^e (mod n)\nfunction RSADoPublic(x) {\n  return x.modPowInt(this.e, this.n);\n}\n\n// Return the PKCS#1 RSA encryption of "text" as an even-length hex string\nfunction RSAEncrypt(text) {\n  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string\nfunction RSAEncryptOAEP(text, hash) {\n  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string\n//function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPublic = RSADoPublic;\n\n// public\nRSAKey.prototype.setPublic = RSASetPublic;\nRSAKey.prototype.encrypt = RSAEncrypt;\nRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n\n\nmodule.exports = RSAKey\n//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n\n},{"jsbn":120}]},{},[1])\n;'],{type:"text/javascript"})));

io.outstandingFetches = [];
io.outstandingMakes = []
io.executeTangleCallback;
io.executeHashNameCallback;

io.localTangle = function(port, cb){
  io.worker.postMessage({command: "tangle", transport: "local"}, [port]);
  io.executeTangleCallback = cb
}

io.remoteTangle = function(opts, cb){
  io.worker.postMessage({command: "tangle", transport: "websocket", host: opts.host, port: opts.port})
  io.executeTangleCallback = cb
}

io.importPKI = function(cert, priPem, pubPem) {
  io.worker.postMessage({cert: cert, priPem: priPem, pubPem: pubPem})
}

io.getHashName = function(callback){
  executeHashNameCallback = callback
  io.worker.postMessage({command: "getHashName"})
}

io.fetch = function(req, whenGotten, whenNotGotten) {
  io.worker.postMessage({
    "command": "fetch",
    "uri": req.uri,
    "type": req.type,
    "version": req.version,
    "selectors": req.selectors
  });
  console.log(req.uri)
  io.outstandingFetches.push({uri: req.uri, whenGotten: whenGotten, whenNotGotten: whenNotGotten});
}

io.publish = function(opts){
  console.log('sending publish command')
  io.worker.postMessage({
    "command": "publish",
    "uri": opts.uri,
    "type": opts.type,
    "thing": opts.thing,
    "version": opts.version
  })
}

io.mirror = function(uri){
  io.worker.postMessage({
    "command": "mirror",
    "uri": uri
  })
}

io.makeEncodedData = function(uri, bytes, callback){
  io.outstandingMakes.push({id: bytes.toString(), callback: callback})
  io.worker.postMessage({command: "makeEncoded", uri: uri, bytes: bytes, id: bytes.toString()})
}

io.worker.onmessage = function (e) {
  if (e.data.responseTo == "fetch") {
    io.executeFetchCallback(e.data);
  } else if (e.data.responseTo == "publish") {
    io.executePublishCallback(e.data);
  } else if (e.data.responseTo == "makeEncoded") {
    io.executeEncodedDataCallback(e.data)
  } else if (e.data.responseTo == "getHashName") {
    io.executeHashNameCallback(e.data.hashName)
  } else if (e.data.responseTo == "tangle") {
    io.executeTangleCallback()
  }
}

io.executeEncodedDataCallback = function(data) {
  for (var i = 0; i < io.outstandingMakes.length; i++) {
    if (io.outstandingMakes[i].id == data.id){
      io.outstandingMakes[i].callback(data.encoded)
    }
  }

}

io.executeFetchCallback = function(response) {
  var mtch;
  console.log(response, io.outstandingFetches)
  for (var i = 0; i < io.outstandingFetches.length; i++){
    if (io.outstandingFetches[i].uri == response.uri) {
      console.log('matched outstanding fetch')
      mtch = io.outstandingFetches.splice(i,1)[0]
    }
  }
  console.log(mtch)
  if (response.success == true){
    mtch.whenGotten(mtch.uri, response.thing, response.firstCo);
  } else {
    mtch.whenNotGotten(mtch.uri);
  }

}

module.exports = io;

},{}],2:[function(require,module,exports){
var io = require('../../browser.js')
var ndn = require('ndn-lib')
var utils = require('ndn-utils')
var chanTrans = require('ndn-messageChannelTransport').transport
  , RegisteredPrefix = function RegisteredPrefix(prefix, closure) {  this.prefix = new ndn.Name(prefix);    this.closure = closure}
  , ms = new MessageChannel()
  , transport = new chanTrans(ms.port2)
  , face = new ndn.Face({host:1,port:1, getTransport: function(){return transport}})

face.transport.connect(face, function(){console.log('connected')})

function onInterest (prefix,interest,transport){
  console.log("got interest", prefix)
  var d = new ndn.Data(new ndn.Name(interest.name.toUri()), new ndn.SignedInfo(), "success")
  d.signedInfo.setFinalBlockID(new ndn.Name.Component([0x14]))
  d.signedInfo.setFields()
  var encoded = d.wireEncode()
  console.log("sending encoded", encoded)
  transport.send(encoded.buffer)
}

closure = new ndn.Face.CallbackClosure(null, null, onInterest, 'test', face.transport)
ndn.Face.registeredPrefixTable.push(new RegisteredPrefix('test', closure))


describe('Setup', function(){
  describe('should tangle', function(){
    it('with websocket', function(done) {
      function cb (){done()}
      io.remoteTangle({host: "rosewiki.org", port:9696}, cb)

    })
    
    it('with messageChannel', function(done){
      this.timeout(10000)
      function cb (){ done()}
      io.localTangle(ms.port1, cb)
    })
  })
})

describe('fetch', function(){
  it('should pipeline fetch 20 segments', function(done){
    function onData(data, transport, thing){
      console.log(data, transport, thing)
      done()
    }
    function onTimeout(){
      console.log('fail')
    }
    io.fetch({uri: "test/text/text/name", type: 'blob'}, onData, onTimeout)
  })
})


},{"../../browser.js":1,"ndn-lib":12,"ndn-messageChannelTransport":55,"ndn-utils":108}],3:[function(require,module,exports){
/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// asn1hex.js - Hexadecimal represented ASN.1 string library
//
// version: 1.1 (09-May-2012)
//
// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license/
//
// The above copyright and license notice shall be 
// included in all copies or substantial portions of the Software.
//
// Depends on:
//
var BigInteger = require('jsbn')
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}
// MEMO:
//   f('3082025b02...', 2) ... 82025b ... 3bytes
//   f('020100', 2) ... 01 ... 1byte
//   f('0203001...', 2) ... 03 ... 1byte
//   f('02818003...', 2) ... 8180 ... 2bytes
//   f('3080....0000', 2) ... 80 ... -1
//
//   Requirements:
//   - ASN.1 type octet length MUST be 1. 
//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)
//   - 

/**
 * @fileOverview
 * @name asn1hex-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.1
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * get byte length for ASN.1 L(length) bytes
 * @name getByteLengthOfL_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return byte length for ASN.1 L(length) bytes
 */
function _asnhex_getByteLengthOfL_AtObj(s, pos) {
  if (s.substring(pos + 2, pos + 3) != '8') return 1;
  var i = parseInt(s.substring(pos + 3, pos + 4));
  if (i == 0) return -1; 		// length octet '80' indefinite length
  if (0 < i && i < 10) return i + 1;	// including '8?' octet;
  return -2;				// malformed format
}


/**
 * get hexadecimal string for ASN.1 L(length) bytes
 * @name getHexOfL_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return {String} hexadecimal string for ASN.1 L(length) bytes
 */
function _asnhex_getHexOfL_AtObj(s, pos) {
  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);
  if (len < 1) return '';
  return s.substring(pos + 2, pos + 2 + len * 2);
}

//
//   getting ASN.1 length value at the position 'idx' of
//   hexa decimal string 's'.
//
//   f('3082025b02...', 0) ... 82025b ... ???
//   f('020100', 0) ... 01 ... 1
//   f('0203001...', 0) ... 03 ... 3
//   f('02818003...', 0) ... 8180 ... 128
/**
 * get integer value of ASN.1 length for ASN.1 data
 * @name getIntOfL_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return ASN.1 L(length) integer value
 */
function _asnhex_getIntOfL_AtObj(s, pos) {
  var hLength = _asnhex_getHexOfL_AtObj(s, pos);
  if (hLength == '') return -1;
  var bi;
  if (parseInt(hLength.substring(0, 1)) < 8) {
     bi = parseBigInt(hLength, 16);
  } else {
     bi = parseBigInt(hLength.substring(2), 16);
  }
  return bi.intValue();
}

/**
 * get ASN.1 value starting string position for ASN.1 object refered by index 'idx'.
 * @name getStartPosOfV_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 */
function _asnhex_getStartPosOfV_AtObj(s, pos) {
  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);
  if (l_len < 0) return l_len;
  return pos + (l_len + 1) * 2;
}

/**
 * get hexadecimal string of ASN.1 V(value)
 * @name getHexOfV_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return {String} hexadecimal string of ASN.1 value.
 */
function _asnhex_getHexOfV_AtObj(s, pos) {
  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);
  var len = _asnhex_getIntOfL_AtObj(s, pos);
  return s.substring(pos1, pos1 + len * 2);
}

/**
 * get hexadecimal string of ASN.1 TLV at
 * @name getHexOfTLV_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return {String} hexadecimal string of ASN.1 TLV.
 * @since 1.1
 */
function _asnhex_getHexOfTLV_AtObj(s, pos) {
  var hT = s.substr(pos, 2);
  var hL = _asnhex_getHexOfL_AtObj(s, pos);
  var hV = _asnhex_getHexOfV_AtObj(s, pos);
  return hT + hL + hV;
}

/**
 * get next sibling starting index for ASN.1 object string
 * @name getPosOfNextSibling_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return next sibling starting index for ASN.1 object string
 */
function _asnhex_getPosOfNextSibling_AtObj(s, pos) {
  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);
  var len = _asnhex_getIntOfL_AtObj(s, pos);
  return pos1 + len * 2;
}

/**
 * get array of indexes of child ASN.1 objects
 * @name getPosArrayOfChildren_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} start string index of ASN.1 object
 * @return {Array of Number} array of indexes for childen of ASN.1 objects
 */
function _asnhex_getPosArrayOfChildren_AtObj(h, pos) {
  var a = new Array();
  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);
  a.push(p0);

  var len = _asnhex_getIntOfL_AtObj(h, pos);
  var p = p0;
  var k = 0;
  while (1) {
    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);
    if (pNext == null || (pNext - p0  >= (len * 2))) break;
    if (k >= 200) break;

    a.push(pNext);
    p = pNext;

    k++;
  }

  return a;
}

/**
 * get string index of nth child object of ASN.1 object refered by h, idx
 * @name getNthChildIndex_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx start string index of ASN.1 object
 * @param {Number} nth for child
 * @return {Number} string index of nth child.
 * @since 1.1
 */
function _asnhex_getNthChildIndex_AtObj(h, idx, nth) {
  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);
  return a[nth];
}

// ========== decendant methods ==============================

/**
 * get string index of nth child object of ASN.1 object refered by h, idx
 * @name getDecendantIndexByNthList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @return {Number} string index refered by nthList
 * @since 1.1
 */
function _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {
  if (nthList.length == 0) {
    return currentIndex;
  }
  var firstNth = nthList.shift();
  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);
  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);
}

/**
 * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.
 * @name getDecendantHexTLVByNthList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList
 * @since 1.1
 */
function _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {
  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);
  return _asnhex_getHexOfTLV_AtObj(h, idx);
}

/**
 * get hexadecimal string of ASN.1 V refered by current index and nth index list.
 * @name getDecendantHexVByNthList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @return {Number} hexadecimal string of ASN.1 V refered by nthList
 * @since 1.1
 */
function _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {
  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);
  return _asnhex_getHexOfV_AtObj(h, idx);
}

// ========== class definition ==============================

/**
 * ASN.1 DER encoded hexadecimal string utility class
 * @class ASN.1 DER encoded hexadecimal string utility class
 * @author Kenji Urushima
 * @version 1.1 (09 May 2012)
 * @see <a href="http://kjur.github.com/jsrsasigns/">'jwrsasign'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>
 * @since 1.1
 */
function ASN1HEX() {
  return ASN1HEX;
}

ASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;
ASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;
ASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;
ASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;
ASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;
ASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;
ASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;
ASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;
ASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;
ASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;
ASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;
ASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;

module.exports = ASN1HEX;

},{"jsbn":54}],4:[function(require,module,exports){
var b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad="=";
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"
function int2char(n) { return BI_RM.charAt(n); }
function hex2b64(h) {
  var i;
  var c;
  var ret = "";
  for(i = 0; i+3 <= h.length; i+=3) {
    c = parseInt(h.substring(i,i+3),16);
    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
  }
  if(i+1 == h.length) {
    c = parseInt(h.substring(i,i+1),16);
    ret += b64map.charAt(c << 2);
  }
  else if(i+2 == h.length) {
    c = parseInt(h.substring(i,i+2),16);
    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
  }
  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;
  return ret;
}

// convert a base64 string to hex
function b64tohex(s) {
  var ret = ""
  var i;
  var k = 0; // b64 state, 0-3
  var slop;
  for(i = 0; i < s.length; ++i) {
    if(s.charAt(i) == b64pad) break;
    v = b64map.indexOf(s.charAt(i));
    if(v < 0) continue;
    if(k == 0) {
      ret += int2char(v >> 2);
      slop = v & 3;
      k = 1;
    }
    else if(k == 1) {
      ret += int2char((slop << 2) | (v >> 4));
      slop = v & 0xf;
      k = 2;
    }
    else if(k == 2) {
      ret += int2char(slop);
      ret += int2char(v >> 2);
      slop = v & 3;
      k = 3;
    }
    else {
      ret += int2char((slop << 2) | (v >> 4));
      ret += int2char(v & 0xf);
      k = 0;
    }
  }
  if(k == 1)
    ret += int2char(slop << 2);
  return ret;
}

// convert a base64 string to a byte/number array
function b64toBA(s) {
  //piggyback on b64tohex for now, optimize later
  var h = b64tohex(s);
  var i;
  var a = new Array();
  for(i = 0; 2*i < h.length; ++i) {
    a[i] = parseInt(h.substring(2*i,2*i+2),16);
  }
  return a;
}

module.exports = {b64tohex: b64tohex, b64toBA: b64toBA, hex2b64: hex2b64};

},{}],5:[function(require,module,exports){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

module.exports = CryptoJS

},{}],6:[function(require,module,exports){
/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
/*
 * crypto.js - Cryptographic Algorithm Provider class
 *
 * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * http://kjur.github.com/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name crypto-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.0.4 (2013-Mar-28)
 * @since 2.2
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */
var CryptoJS = require('./sha256.js')
var BigInteger = require('jsbn')
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

/** 
 * kjur's class library name space
 * @name KJUR
 * @namespace kjur's class library name space
 */
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
/**
 * kjur's cryptographic algorithm provider library name space
 * <p>
 * This namespace privides following crytpgrahic classes.
 * <ul>
 * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>
 * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>
 * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>
 * </ul>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * </p>
 * @name KJUR.crypto
 * @namespace
 */
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};

/**
 * static object for cryptographic function utilities
 * @name KJUR.crypto.Util
 * @class static object for cryptographic function utilities
 * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms
 * @description
 */
KJUR.crypto.Util = new function() {
    this.DIGESTINFOHEAD = {
	'sha1':      "3021300906052b0e03021a05000414",
        'sha224':    "302d300d06096086480165030402040500041c",
	'sha256':    "3031300d060960864801650304020105000420",
	'sha384':    "3041300d060960864801650304020205000430",
	'sha512':    "3051300d060960864801650304020305000440",
	'md2':       "3020300c06082a864886f70d020205000410",
	'md5':       "3020300c06082a864886f70d020505000410",
	'ripemd160': "3021300906052b2403020105000414"
    };

    /**
     * get hexadecimal DigestInfo
     * @name getDigestInfoHex
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} hHash hexadecimal hash value
     * @param {String} alg hash algorithm name (ex. 'sha1')
     * @return {String} hexadecimal string DigestInfo ASN.1 structure
     */
    this.getDigestInfoHex = function(hHash, alg) {
	if (typeof this.DIGESTINFOHEAD[alg] == "undefined")
	    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;
	return this.DIGESTINFOHEAD[alg] + hHash;
    };

    /**
     * get PKCS#1 padded hexadecimal DigestInfo
     * @name getPaddedDigestInfoHex
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} hHash hexadecimal hash value
     * @param {String} alg hash algorithm name (ex. 'sha1')
     * @param {Integer} keySize key bit length (ex. 1024)
     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo
     */
    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {
	var hDigestInfo = this.getDigestInfoHex(hHash, alg);
	var pmStrLen = keySize / 4; // minimum PM length

	if (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22
	    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;

	var hHead = "0001";
	var hTail = "00" + hDigestInfo;
	var hMid = "";
	var fLen = pmStrLen - hHead.length - hTail.length;
	for (var i = 0; i < fLen; i += 2) {
	    hMid += "ff";
	}
	var hPaddedMessage = hHead + hMid + hTail;
	return hPaddedMessage;
    };

    /**
     * get hexadecimal SHA1 hash of string
     * @name sha1
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha1 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'sha1', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal SHA256 hash of string
     * @name sha256
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha256 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'sha256', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal SHA512 hash of string
     * @name sha512
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha512 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'sha512', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal MD5 hash of string
     * @name md5
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.md5 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'md5', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal RIPEMD160 hash of string
     * @name ripemd160
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.ripemd160 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'ripemd160', 'prov':'cryptojs'});
        return md.digestString(s);
    };
};

/**
 * MessageDigest class which is very similar to java.security.MessageDigest class
 * @name KJUR.crypto.MessageDigest
 * @class MessageDigest class which is very similar to java.security.MessageDigest class
 * @param {Array} params parameters for constructor
 * @description
 * <br/>
 * Currently this supports following algorithm and providers combination:
 * <ul>
 * <li>md5 - cryptojs</li>
 * <li>sha1 - cryptojs</li>
 * <li>sha224 - cryptojs</li>
 * <li>sha256 - cryptojs</li>
 * <li>sha384 - cryptojs</li>
 * <li>sha512 - cryptojs</li>
 * <li>ripemd160 - cryptojs</li>
 * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>
 * </ul>
 * @example
 * // CryptoJS provider sample
 * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;
 * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;
 * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;
 * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});
 * md.updateString('aaa')
 * var mdHex = md.digest()
 *
 * // SJCL(Stanford JavaScript Crypto Library) provider sample
 * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;
 * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;
 * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only
 * md.updateString('aaa')
 * var mdHex = md.digest()
 */
KJUR.crypto.MessageDigest = function(params) {
    var md = null;
    var algName = null;
    var provName = null;
    var _CryptoJSMdName = {
	'md5': 'CryptoJS.algo.MD5',
	'sha1': 'CryptoJS.algo.SHA1',
	'sha224': 'CryptoJS.algo.SHA224',
	'sha256': 'CryptoJS.algo.SHA256',
	'sha384': 'CryptoJS.algo.SHA384',
	'sha512': 'CryptoJS.algo.SHA512',
	'ripemd160': 'CryptoJS.algo.RIPEMD160'
    };

    /**
     * set hash algorithm and provider
     * @name setAlgAndProvider
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} alg hash algorithm name
     * @param {String} prov provider name
     * @description
     * @example
     * // for SHA1
     * md.setAlgAndProvider('sha1', 'cryptojs');
     * // for RIPEMD160
     * md.setAlgAndProvider('ripemd160', 'cryptojs');
     */
    this.setAlgAndProvider = function(alg, prov) {
	if (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(alg) != -1 &&
	    prov == 'cryptojs') {
	    try {
		this.md = eval(_CryptoJSMdName[alg]).create();
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;
	    }
	    this.updateString = function(str) {
		this.md.update(str);
	    };
	    this.updateHex = function(hex) {
		var wHex = CryptoJS.enc.Hex.parse(hex);
		this.md.update(wHex);
	    };
	    this.digest = function() {
		var hash = this.md.finalize();
		return hash.toString(CryptoJS.enc.Hex);
	    };
	    this.digestString = function(str) {
		this.updateString(str);
		return this.digest();
	    };
	    this.digestHex = function(hex) {
		this.updateHex(hex);
		return this.digest();
	    };
	}
	if (':sha256:'.indexOf(alg) != -1 &&
	    prov == 'sjcl') {
	    try {
		this.md = new sjcl.hash.sha256();
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;
	    }
	    this.updateString = function(str) {
		this.md.update(str);
	    };
	    this.updateHex = function(hex) {
		var baHex = sjcl.codec.hex.toBits(hex);
		this.md.update(baHex);
	    };
	    this.digest = function() {
		var hash = this.md.finalize();
		return sjcl.codec.hex.fromBits(hash);
	    };
	    this.digestString = function(str) {
		this.updateString(str);
		return this.digest();
	    };
	    this.digestHex = function(hex) {
		this.updateHex(hex);
		return this.digest();
	    };
	}
    };

    /**
     * update digest by specified string
     * @name updateString
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} str string to update
     * @description
     * @example
     * md.updateString('New York');
     */
    this.updateString = function(str) {
	throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * update digest by specified hexadecimal string
     * @name updateHex
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} hex hexadecimal string to update
     * @description
     * @example
     * md.updateHex('0afe36');
     */
    this.updateHex = function(hex) {
	throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * completes hash calculation and returns hash result
     * @name digest
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @description
     * @example
     * md.digest()
     */
    this.digest = function() {
	throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * performs final update on the digest using string, then completes the digest computation
     * @name digestString
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} str string to final update
     * @description
     * @example
     * md.digestString('aaa')
     */
    this.digestString = function(str) {
	throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * performs final update on the digest using hexadecimal string, then completes the digest computation
     * @name digestHex
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} hex hexadecimal string to final update
     * @description
     * @example
     * md.digestHex('0f2abd')
     */
    this.digestHex = function(hex) {
	throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    if (typeof params != "undefined") {
	if (typeof params['alg'] != "undefined") {
	    this.algName = params['alg'];
	    this.provName = params['prov'];
	    this.setAlgAndProvider(params['alg'], params['prov']);
	}
    }
};


/**
 * Signature class which is very similar to java.security.Signature class
 * @name KJUR.crypto.Signature
 * @class Signature class which is very similar to java.security.Signature class
 * @param {Array} params parameters for constructor
 * @property {String} state Current state of this signature object whether 'SIGN', 'VERIFY' or null
 * @description
 * <br/>
 * As for params of constructor's argument, it can be specify following attributes:
 * <ul>
 * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>
 * <li>provider - currently 'cryptojs/jsrsa' only</li>
 * <li>prvkeypem - PEM string of signer's private key. If this specified, no need to call initSign(prvKey).</li>
 * </ul>
 * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>
 * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}
 * withRSA algorithm in 'cryptojs/jsrsa' provider.
 * <h4>EXAMPLES</h4>
 * @example
 * // signature generation
 * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});
 * sig.initSign(prvKey);
 * sig.updateString('aaa');
 * var hSigVal = sig.sign();
 *
 * // signature validation
 * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});
 * sig2.initVerifyByCertificatePEM(cert)
 * sig.updateString('aaa');
 * var isValid = sig2.verify(hSigVal);
 */
KJUR.crypto.Signature = function(params) {
    var prvKey = null; // RSAKey for signing
    var pubKey = null; // RSAKey for verifying

    var md = null; // KJUR.crypto.MessageDigest object
    var sig = null;
    var algName = null;
    var provName = null;
    var algProvName = null;
    var mdAlgName = null;
    var pubkeyAlgName = null;
    var state = null;

    var sHashHex = null; // hex hash value for hex
    var hDigestInfo = null;
    var hPaddedDigestInfo = null;
    var hSign = null;

    this._setAlgNames = function() {
	if (this.algName.match(/^(.+)with(.+)$/)) {
	    this.mdAlgName = RegExp.$1.toLowerCase();
	    this.pubkeyAlgName = RegExp.$2.toLowerCase();
	}
    };

    this._zeroPaddingOfSignature = function(hex, bitLength) {
	var s = "";
	var nZero = bitLength / 4 - hex.length;
	for (var i = 0; i < nZero; i++) {
	    s = s + "0";
	}
	return s + hex;
    };

    /**
     * set signature algorithm and provider
     * @name setAlgAndProvider
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} alg signature algorithm name
     * @param {String} prov provider name
     * @description
     * @example
     * md.setAlgAndProvider('SHA1withRSA', 'cryptojs/jsrsa');
     */
    this.setAlgAndProvider = function(alg, prov) {
	this._setAlgNames();
	if (prov != 'cryptojs/jsrsa')
	    throw "provider not supported: " + prov;

	if (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(this.mdAlgName) != -1) {
	    try {
		this.md = new KJUR.crypto.MessageDigest({'alg':this.mdAlgName,'prov':'cryptojs'});
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;
	    }

	    this.initSign = function(prvKey) {
		this.prvKey = prvKey;
		this.state = "SIGN";
	    };

	    this.initVerifyByPublicKey = function(rsaPubKey) {
		this.pubKey = rsaPubKey;
		this.state = "VERIFY";
	    };

	    this.initVerifyByCertificatePEM = function(certPEM) {
		var x509 = new X509();
		x509.readCertPEM(certPEM);
		this.pubKey = x509.subjectPublicKeyRSA;
		this.state = "VERIFY";
	    };

	    this.updateString = function(str) {
		this.md.updateString(str);
	    };
	    this.updateHex = function(hex) {
		this.md.updateHex(hex);
	    };
	    this.sign = function() {
                var util = KJUR.crypto.Util;
		var keyLen = this.prvKey.n.bitLength();
		this.sHashHex = this.md.digest();
		this.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);
		this.hPaddedDigestInfo = 
                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);

		var biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);
		this.hoge = biPaddedDigestInfo.toString(16);

		var biSign = this.prvKey.doPrivate(biPaddedDigestInfo);
		this.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);
		return this.hSign;
	    };
	    this.signString = function(str) {
		this.updateString(str);
		this.sign();
	    };
	    this.signHex = function(hex) {
		this.updateHex(hex);
		this.sign();
	    };
	    this.verify = function(hSigVal) {
                var util = KJUR.crypto.Util;
		var keyLen = this.pubKey.n.bitLength();
		this.sHashHex = this.md.digest();

		var biSigVal = parseBigInt(hSigVal, 16);
		var biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);
		this.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);
                var s = this.hPaddedDigestInfo;
                s = s.replace(/^1ff+00/, '');

		var hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];
                if (s.indexOf(hDIHEAD) != 0) {
		    return false;
		}
		var hHashFromDI = s.substr(hDIHEAD.length);
		//alert(hHashFromDI + "\n" + this.sHashHex);
		return (hHashFromDI == this.sHashHex);
	    };
	}
    };

    /**
     * Initialize this object for verifying with a public key
     * @name initVerifyByPublicKey
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {RSAKey} rsaPubKey RSAKey object of public key
     * @since 1.0.2
     * @description
     * @example
     * sig.initVerifyByPublicKey(prvKey)
     */
    this.initVerifyByPublicKey = function(rsaPubKey) {
	throw "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Initialize this object for verifying with a certficate
     * @name initVerifyByCertificatePEM
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} certPEM PEM formatted string of certificate
     * @since 1.0.2
     * @description
     * @example
     * sig.initVerifyByCertificatePEM(certPEM)
     */
    this.initVerifyByCertificatePEM = function(certPEM) {
	throw "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Initialize this object for signing
     * @name initSign
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {RSAKey} prvKey RSAKey object of private key
     * @description
     * @example
     * sig.initSign(prvKey)
     */
    this.initSign = function(prvKey) {
	throw "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Updates the data to be signed or verified by a string
     * @name updateString
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} str string to use for the update
     * @description
     * @example
     * sig.updateString('aaa')
     */
    this.updateString = function(str) {
	throw "updateString(str) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Updates the data to be signed or verified by a hexadecimal string
     * @name updateHex
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} hex hexadecimal string to use for the update
     * @description
     * @example
     * sig.updateHex('1f2f3f')
     */
    this.updateHex = function(hex) {
	throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Returns the signature bytes of all data updates as a hexadecimal string
     * @name sign
     * @memberOf KJUR.crypto.Signature
     * @function
     * @return the signature bytes as a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.sign()
     */
    this.sign = function() {
	throw "sign() not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string
     * @name signString
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} str string to final update
     * @return the signature bytes of a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.signString('aaa')
     */
    this.signString = function(str) {
	throw "digestString(str) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string
     * @name signHex
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} hex hexadecimal string to final update
     * @return the signature bytes of a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.signHex('1fdc33')
     */
    this.signHex = function(hex) {
	throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * verifies the passed-in signature.
     * @name verify
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} str string to final update
     * @return {Boolean} true if the signature was verified, otherwise false
     * @description
     * @example
     * var isValid = sig.verify('1fbcefdca4823a7(snip)')
     */
    this.verify = function(hSigVal) {
	throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;
    };

    if (typeof params != "undefined") {
	if (typeof params['alg'] != "undefined") {
	    this.algName = params['alg'];
	    this.provName = params['prov'];
	    this.algProvName = params['alg'] + ":" + params['prov'];
	    this.setAlgAndProvider(params['alg'], params['prov']);
	    this._setAlgNames();
	}
	if (typeof params['prvkeypem'] != "undefined") {
	    if (typeof params['prvkeypas'] != "undefined") {
		throw "both prvkeypem and prvkeypas parameters not supported";
	    } else {
		try {
		    var prvKey = new RSAKey();
		    prvKey.readPrivateKeyFromPEMString(params['prvkeypem']);
		    this.initSign(prvKey);
		} catch (ex) {
		    throw "fatal error to load pem private key: " + ex;
		}
	    }
	}
    }
};
module.exports = KJUR

},{"./sha256.js":11,"jsbn":54}],7:[function(require,module,exports){
// Depends on jsbn.js and rng.js
var BigInteger = require('jsbn')
// Version 1.1: support utf-8 encoding in pkcs1pad2

// convert a (hex) string to a bignum object
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

function linebrk(s,n) {
  var ret = "";
  var i = 0;
  while(i + n < s.length) {
    ret += s.substring(i,i+n) + "\n";
    i += n;
  }
  return ret + s.substring(i,s.length);
}

function byte2Hex(b) {
  if(b < 0x10)
    return "0" + b.toString(16);
  else
    return b.toString(16);
}

// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s,n) {
  if(n < s.length + 11) { // TODO: fix for utf-8
    alert("Message too long for RSA");
    return null;
  }
  var ba = new Array();
  var i = s.length - 1;
  while(i >= 0 && n > 0) {
    var c = s.charCodeAt(i--);
    if(c < 128) { // encode using utf-8
      ba[--n] = c;
    }
    else if((c > 127) && (c < 2048)) {
      ba[--n] = (c & 63) | 128;
      ba[--n] = (c >> 6) | 192;
    }
    else {
      ba[--n] = (c & 63) | 128;
      ba[--n] = ((c >> 6) & 63) | 128;
      ba[--n] = (c >> 12) | 224;
    }
  }
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n > 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}

// PKCS#1 (OAEP) mask generation function
function oaep_mgf1_arr(seed, len, hash)
{
    var mask = '', i = 0;

    while (mask.length < len)
    {
        mask += hash(String.fromCharCode.apply(String, seed.concat([
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff])));
        i += 1;
    }

    return mask;
}

var SHA1_SIZE = 20;

// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint
function oaep_pad(s, n, hash)
{
    if (s.length + 2 * SHA1_SIZE + 2 > n)
    {
        throw "Message too long for RSA";
    }

    var PS = '', i;

    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)
    {
        PS += '\x00';
    }

    var DB = rstr_sha1('') + PS + '\x01' + s;
    var seed = new Array(SHA1_SIZE);
    new SecureRandom().nextBytes(seed);
    
    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);
    var maskedDB = [];

    for (i = 0; i < DB.length; i += 1)
    {
        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);
    var maskedSeed = [0];

    for (i = 0; i < seed.length; i += 1)
    {
        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);
    }

    return new BigInteger(maskedSeed.concat(maskedDB));
}

// "empty" RSA key constructor
function RSAKey() {
  this.n = null;
  this.e = 0;
  this.d = null;
  this.p = null;
  this.q = null;
  this.dmp1 = null;
  this.dmq1 = null;
  this.coeff = null;
}

// Set the public key fields N and e from hex strings
function RSASetPublic(N,E) {
  if (typeof N !== "string")
  {
    this.n = N;
    this.e = E;
  }
  else if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
  }
  else
    alert("Invalid RSA public key");
}

// Perform raw public operation on "x": return x^e (mod n)
function RSADoPublic(x) {
  return x.modPowInt(this.e, this.n);
}

// Return the PKCS#1 RSA encryption of "text" as an even-length hex string
function RSAEncrypt(text) {
  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string
function RSAEncryptOAEP(text, hash) {
  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
//function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
//}

// protected
RSAKey.prototype.doPublic = RSADoPublic;

// public
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
RSAKey.prototype.encryptOAEP = RSAEncryptOAEP;


module.exports = RSAKey
//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

},{"jsbn":54}],8:[function(require,module,exports){
// Depends on rsa.js and jsbn2.js
var BigInteger = require('jsbn')
var RSAKey = require('./rsa.js')
// Version 1.1: support utf-8 decoding in pkcs1unpad2
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d,n) {
  var b = d.toByteArray();
  var i = 0;
  while(i < b.length && b[i] == 0) ++i;
  if(b.length-i != n-1 || b[i] != 2)
    return null;
  ++i;
  while(b[i] != 0)
    if(++i >= b.length) return null;
  var ret = "";
  while(++i < b.length) {
    var c = b[i] & 255;
    if(c < 128) { // utf-8 decode
      ret += String.fromCharCode(c);
    }
    else if((c > 191) && (c < 224)) {
      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));
      ++i;
    }
    else {
      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));
      i += 2;
    }
  }
  return ret;
}

// PKCS#1 (OAEP) mask generation function
function oaep_mgf1_str(seed, len, hash)
{
    var mask = '', i = 0;

    while (mask.length < len)
    {
        mask += hash(seed + String.fromCharCode.apply(String, [
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff]));
        i += 1;
    }

    return mask;
}

var SHA1_SIZE = 20;

// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext
function oaep_unpad(d, n, hash)
{
    d = d.toByteArray();

    var i;

    for (i = 0; i < d.length; i += 1)
    {
        d[i] &= 0xff;
    }

    while (d.length < n)
    {
        d.unshift(0);
    }

    d = String.fromCharCode.apply(String, d);

    if (d.length < 2 * SHA1_SIZE + 2)
    {
        throw "Cipher too short";
    }

    var maskedSeed = d.substr(1, SHA1_SIZE)
    var maskedDB = d.substr(SHA1_SIZE + 1);

    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);
    var seed = [], i;

    for (i = 0; i < maskedSeed.length; i += 1)
    {
        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);
    }

    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),
                           d.length - SHA1_SIZE, rstr_sha1);

    var DB = [];

    for (i = 0; i < maskedDB.length; i += 1)
    {
        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    DB = String.fromCharCode.apply(String, DB);

    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(''))
    {
        throw "Hash mismatch";
    }

    DB = DB.substr(SHA1_SIZE);

    var first_one = DB.indexOf('\x01');
    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf('\x00') : -1;

    if (last_zero + 1 != first_one)
    {
        throw "Malformed data";
    }

    return DB.substr(first_one + 1);
}

// Set the private key fields N, e, and d from hex strings
function RSASetPrivate(N,E,D) {
  if (typeof N !== "string")
  {
    this.n = N;
    this.e = E;
    this.d = D;
  }
  else if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
  }
  else
    alert("Invalid RSA private key");
}

// Set the private key fields N, e, d and CRT params from hex strings
function RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {
  //alert("RSASetPrivateEx called");
  if (N == null) throw "RSASetPrivateEx N == null";
  if (E == null) throw "RSASetPrivateEx E == null";
  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";
  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";

  if (N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
    this.p = parseBigInt(P,16);
    this.q = parseBigInt(Q,16);
    this.dmp1 = parseBigInt(DP,16);
    this.dmq1 = parseBigInt(DQ,16);
    this.coeff = parseBigInt(C,16);
  } else {
    alert("Invalid RSA private key in RSASetPrivateEx");
  }
}

// Generate a new random private key B bits long, using public expt E
function RSAGenerate(B,E) {
  var rng = new SecureRandom();
  var qs = B>>1;
  this.e = parseInt(E,16);
  var ee = new BigInteger(E,16);
  for(;;) {
    for(;;) {
      this.p = new BigInteger(B-qs,1,rng);
      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;
    }
    for(;;) {
      this.q = new BigInteger(qs,1,rng);
      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;
    }
    if(this.p.compareTo(this.q) <= 0) {
      var t = this.p;
      this.p = this.q;
      this.q = t;
    }
    var p1 = this.p.subtract(BigInteger.ONE);	// p1 = p - 1
    var q1 = this.q.subtract(BigInteger.ONE);	// q1 = q - 1
    var phi = p1.multiply(q1);
    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
      this.n = this.p.multiply(this.q);	// this.n = p * q
      this.d = ee.modInverse(phi);	// this.d = 
      this.dmp1 = this.d.mod(p1);	// this.dmp1 = d mod (p - 1)
      this.dmq1 = this.d.mod(q1);	// this.dmq1 = d mod (q - 1)
      this.coeff = this.q.modInverse(this.p);	// this.coeff = (q ^ -1) mod p
      break;
    }
  }
}

// Perform raw private operation on "x": return x^d (mod n)
function RSADoPrivate(x) {
  if(this.p == null || this.q == null)
    return x.modPow(this.d, this.n);

  // TODO: re-calculate any missing CRT params
  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?
  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?

  while(xp.compareTo(xq) < 0)
    xp = xp.add(this.p);
  // NOTE:
  // xp.subtract(xq) => cp -cq
  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h
  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M
  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecrypt(ctext) {
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);
}

// Return the PKCS#1 OAEP RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecryptOAEP(ctext, hash) {
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is a Base64-encoded string and the output is a plain string.
//function RSAB64Decrypt(ctext) {
//  var h = b64tohex(ctext);
//  if(h) return this.decrypt(h); else return null;
//}

// protected
RSAKey.prototype.doPrivate = RSADoPrivate;

// public
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;
RSAKey.prototype.decryptOAEP = RSADecryptOAEP;
//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;

module.exports = RSAKey

},{"./rsa.js":7,"jsbn":54}],9:[function(require,module,exports){
/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key
//              to RSAKey class.
//
// version: 1.1.1 (2013-Apr-12)
//
// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license/
//
// The above copyright and license notice shall be 
// included in all copies or substantial portions of the Software.
// 
//
// Depends on:
//
//
//
// _RSApem_pemToBase64(sPEM)
//
//   removing PEM header, PEM footer and space characters including
//   new lines from PEM formatted RSA private key string.
//
var ASN1HEX = require('./asn1hex-1.1.js')
var b64tohex = require('./base64.js').b64tohex
var RSAKey = require('./rsa2.js')
/**
 * @fileOverview
 * @name rsapem-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.1
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */
function _rsapem_pemToBase64(sPEMPrivateKey) {
  var s = sPEMPrivateKey;
  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");
  s = s.replace("-----END RSA PRIVATE KEY-----", "");
  s = s.replace(/[ \n]+/g, "");
  return s;
}

function _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {
  var a = new Array();
  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);
  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);
  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);
  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);
  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);
  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);
  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);
  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);
  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);
  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);
  return a;
}

function _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {
  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);
  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);
  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);
  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);
  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);
  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);
  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);
  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);
  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);
  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);
  var a = new Array();
  a.push(v, n, e, d, p, q, dp, dq, co);
  return a;
}

/**
 * read RSA private key from a ASN.1 hexadecimal string
 * @name readPrivateKeyFromASN1HexString
 * @memberOf RSAKey#
 * @function
 * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.
 * @since 1.1.1
 */
function _rsapem_readPrivateKeyFromASN1HexString(keyHex) {
  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);
  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
}

/**
 * read PKCS#1 private key from a string
 * @name readPrivateKeyFromPEMString
 * @memberOf RSAKey#
 * @function
 * @param {String} keyPEM string of PKCS#1 private key.
 */
function _rsapem_readPrivateKeyFromPEMString(keyPEM) {
  var keyB64 = _rsapem_pemToBase64(keyPEM);
  var keyHex = b64tohex(keyB64) // depends base64.js
  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);
  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
}

RSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;
RSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;

module.exports = RSAKey

},{"./asn1hex-1.1.js":3,"./base64.js":4,"./rsa2.js":8}],10:[function(require,module,exports){
/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// rsa-sign.js - adding signing functions to RSAKey class.
//
//
// version: 1.2.2 (13 May 2013)
//
// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license/
//
// The above copyright and license notice shall be 
// included in all copies or substantial portions of the Software.

//
// Depends on:
//   function sha1.hex(s) of sha1.js
//   jsbn.js
//   jsbn2.js
//   rsa.js
//   rsa2.js
//
var BigInteger = require('jsbn')
var RSAKey= require('./rsapem-1.1.js')
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

// keysize / pmstrlen
//  512 /  128
// 1024 /  256
// 2048 /  512
// 4096 / 1024

/**
 * @fileOverview
 * @name rsasign-1.2.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.2.2
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * @property {Dictionary} _RSASIGN_DIHEAD
 * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.
 * You can add any DigestInfo hash algorith for signing.
 * See PKCS#1 v2.1 spec (p38).
 */
var _RSASIGN_DIHEAD = [];
_RSASIGN_DIHEAD['sha1'] =      "3021300906052b0e03021a05000414";
_RSASIGN_DIHEAD['sha256'] =    "3031300d060960864801650304020105000420";
_RSASIGN_DIHEAD['sha384'] =    "3041300d060960864801650304020205000430";
_RSASIGN_DIHEAD['sha512'] =    "3051300d060960864801650304020305000440";
_RSASIGN_DIHEAD['md2'] =       "3020300c06082a864886f70d020205000410";
_RSASIGN_DIHEAD['md5'] =       "3020300c06082a864886f70d020505000410";
_RSASIGN_DIHEAD['ripemd160'] = "3021300906052b2403020105000414";

/**
 * @property {Dictionary} _RSASIGN_HASHHEXFUNC
 * @description Array of functions which calculate hash and returns it as hexadecimal.
 * You can add any hash algorithm implementations.
 */
var _RSASIGN_HASHHEXFUNC = [];
_RSASIGN_HASHHEXFUNC['sha1'] =      function(s){return KJUR.crypto.Util.sha1(s);};
_RSASIGN_HASHHEXFUNC['sha256'] =    function(s){return KJUR.crypto.Util.sha256(s);}
_RSASIGN_HASHHEXFUNC['sha512'] =    function(s){return KJUR.crypto.Util.sha512(s);}
_RSASIGN_HASHHEXFUNC['md5'] =       function(s){return KJUR.crypto.Util.md5(s);};
_RSASIGN_HASHHEXFUNC['ripemd160'] = function(s){return KJUR.crypto.Util.ripemd160(s);};

//_RSASIGN_HASHHEXFUNC['sha1'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html
//_RSASIGN_HASHHEXFUNC['sha256'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html

var _RE_HEXDECONLY = new RegExp("");
_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");

// ========================================================================
// Signature Generation
// ========================================================================

function _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {
    var pmStrLen = keySize / 4;
    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];
    var sHashHex = hashFunc(s);

    var sHead = "0001";
    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;
    var sMid = "";
    var fLen = pmStrLen - sHead.length - sTail.length;
    for (var i = 0; i < fLen; i += 2) {
	sMid += "ff";
    }
    sPaddedMessageHex = sHead + sMid + sTail;
    return sPaddedMessageHex;
}

function _zeroPaddingOfSignature(hex, bitLength) {
    var s = "";
    var nZero = bitLength / 4 - hex.length;
    for (var i = 0; i < nZero; i++) {
	s = s + "0";
    }
    return s + hex;
}

/**
 * sign for a message string with RSA private key.<br/>
 * @name signString
 * @memberOf RSAKey#
 * @function
 * @param {String} s message string to be signed.
 * @param {String} hashAlg hash algorithm name for signing.<br/>
 * @return returns hexadecimal string of signature value.
 */
function _rsasign_signString(s, hashAlg) {
    //alert("this.n.bitLength() = " + this.n.bitLength());
    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);
    var biPaddedMessage = parseBigInt(hPM, 16);
    var biSign = this.doPrivate(biPaddedMessage);
    var hexSign = biSign.toString(16);
    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());
}

function _rsasign_signStringWithSHA1(s) {
    return _rsasign_signString.call(this, s, 'sha1');
}

function _rsasign_signStringWithSHA256(s) {
    return _rsasign_signString.call(this, s, 'sha256');
}

// PKCS#1 (PSS) mask generation function
function pss_mgf1_str(seed, len, hash) {
    var mask = '', i = 0;

    while (mask.length < len) {
        mask += hash(seed + String.fromCharCode.apply(String, [
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff]));
        i += 1;
    }

    return mask;
}

/**
 * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>
 * @name signStringPSS
 * @memberOf RSAKey#
 * @function
 * @param {String} s message string to be signed.
 * @param {String} hashAlg hash algorithm name for signing.<br/>
 * @return returns hexadecimal string of signature value.
 */
function _rsasign_signStringPSS(s, hashAlg, sLen) {
    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];
    var mHash = hashFunc(s);
    var hLen = mHash.length;
    var emBits = this.n.bitLength() - 1;
    var emLen = Math.ceil(emBits / 8);
    var i;

    if (sLen === -1) {
        sLen = hLen; // same has hash length
    } else if ((sLen === -2) || (sLen === undefined)) {
        sLen = emLen - hLen - 2; // maximum
    } else if (sLen < -2) {
        throw "invalid salt length";
    }

    if (emLen < (hLen + sLen + 2)) {
        throw "data too long";
    }

    var salt = '';

    if (sLen > 0) {
        salt = new Array(sLen);
        new SecureRandom().nextBytes(salt);
        salt = String.fromCharCode.apply(String, salt);
    }

    var H = hashFunc('\x00\x00\x00\x00\x00\x00\x00\x00' + mHash + salt);
    var PS = [];

    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {
        PS[i] = 0x00;
    }

    var DB = String.fromCharCode.apply(String, PS) + '\x01' + salt;
    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);
    var maskedDB = [];

    for (i = 0; i < DB.length; i += 1) {
        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;
    maskedDB[0] &= ~mask;

    for (i = 0; i < hLen; i++) {
        maskedDB.push(H.charCodeAt(i));
    }

    maskedDB.push(0xbc);

    return _zeroPaddingOfSignature(
            this.doPrivate(new BigInteger(maskedDB)).toString(16),
            this.n.bitLength());
}

// ========================================================================
// Signature Verification
// ========================================================================

function _rsasign_getDecryptSignatureBI(biSig, hN, hE) {
    var rsa = new RSAKey();
    rsa.setPublic(hN, hE);
    var biDecryptedSig = rsa.doPublic(biSig);
    return biDecryptedSig;
}

function _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {
    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);
    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');
    return hDigestInfo;
}

function _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {
    for (var algName in _RSASIGN_DIHEAD) {
	var head = _RSASIGN_DIHEAD[algName];
	var len = head.length;
	if (hDigestInfo.substring(0, len) == head) {
	    var a = [algName, hDigestInfo.substring(len)];
	    return a;
	}
    }
    return [];
}

function _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {
    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);
    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);
    if (digestInfoAry.length == 0) return false;
    var algName = digestInfoAry[0];
    var diHashValue = digestInfoAry[1];
    var ff = _RSASIGN_HASHHEXFUNC[algName];
    var msgHashValue = ff(sMsg);
    return (diHashValue == msgHashValue);
}

function _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {
    var biSig = parseBigInt(hSig, 16);
    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,
						  this.n.toString(16),
						  this.e.toString(16));
    return result;
}

/**
 * verifies a sigature for a message string with RSA public key.<br/>
 * @name verifyString
 * @memberOf RSAKey#
 * @function
 * @param {String} sMsg message string to be verified.
 * @param {String} hSig hexadecimal string of siganture.<br/>
 *                 non-hexadecimal charactors including new lines will be ignored.
 * @return returns 1 if valid, otherwise 0
 */
function _rsasign_verifyString(sMsg, hSig) {
    hSig = hSig.replace(_RE_HEXDECONLY, '');
    if (hSig.length != this.n.bitLength() / 4) return 0;
    hSig = hSig.replace(/[ \n]+/g, "");
    var biSig = parseBigInt(hSig, 16);
    var biDecryptedSig = this.doPublic(biSig);
    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');
    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);
  
    if (digestInfoAry.length == 0) return false;
    var algName = digestInfoAry[0];
    var diHashValue = digestInfoAry[1];
    var ff = _RSASIGN_HASHHEXFUNC[algName];
    var msgHashValue = ff(sMsg);
    return (diHashValue == msgHashValue);
}

/**
 * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>
 * @name verifyStringPSS
 * @memberOf RSAKey#
 * @function
 * @param {String} sMsg message string to be verified.
 * @param {String} hSig hexadecimal string of siganture.<br/>
 *                 non-hexadecimal charactors including new lines will be ignored.
 * @return returns 1 if valid, otherwise 0
 */
function _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {
    if (hSig.length !== this.n.bitLength() / 4) {
        return false;
    }

    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];
    var mHash = hashFunc(sMsg);
    var hLen = mHash.length;
    var emBits = this.n.bitLength() - 1;
    var emLen = Math.ceil(emBits / 8);
    var i;

    if (sLen === -1) {
        sLen = hLen; // same has hash length
    } else if ((sLen === -2) || (sLen === undefined)) {
        sLen = emLen - hLen - 2; // maximum
    } else if (sLen < -2) {
        throw "invalid salt length";
    }

    if (emLen < (hLen + sLen + 2)) {
        throw "data too long";
    }

    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();

    for (i = 0; i < em.length; i += 1) {
        em[i] &= 0xff;
    }

    while (em.length < emLen) {
        em.unshift(0);
    }

    if (em[emLen -1] !== 0xbc) {
        throw "encoded message does not end in 0xbc";
    }

    em = String.fromCharCode.apply(String, em);

    var maskedDB = em.substr(0, emLen - hLen - 1);
    var H = em.substr(maskedDB.length, hLen);

    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;

    if ((maskedDB.charCodeAt(0) & mask) !== 0) {
        throw "bits beyond keysize not zero";
    }

    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);
    var DB = [];

    for (i = 0; i < maskedDB.length; i += 1) {
        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    DB[0] &= ~mask;

    var checkLen = emLen - hLen - sLen - 2;

    for (i = 0; i < checkLen; i += 1) {
        if (DB[i] !== 0x00) {
            throw "leftmost octets not zero";
        }
    }

    if (DB[checkLen] !== 0x01) {
        throw "0x01 marker not found";
    }

    return H === hashFunc('\x00\x00\x00\x00\x00\x00\x00\x00' + mHash +
                          String.fromCharCode.apply(String, DB.slice(-sLen)));
}

RSAKey.prototype.signString = _rsasign_signString;
RSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;
RSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;
RSAKey.prototype.sign = _rsasign_signString;
RSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;
RSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;
RSAKey.prototype.signStringPSS = _rsasign_signStringPSS;
RSAKey.prototype.signPSS = _rsasign_signStringPSS;
RSAKey.SALT_LEN_HLEN = -1;
RSAKey.SALT_LEN_MAX = -2;

RSAKey.prototype.verifyString = _rsasign_verifyString;
RSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;
RSAKey.prototype.verify = _rsasign_verifyString;
RSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;
RSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;
RSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;
RSAKey.SALT_LEN_RECOVER = -2;

/**
 * @name RSAKey
 * @class key of RSA public key algorithm
 * @description Tom Wu's RSA Key class and extension
 */

module.exports = RSAKey

},{"./rsapem-1.1.js":9,"jsbn":54}],11:[function(require,module,exports){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
    // Shortcuts
    var C = require('./core.js');
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Initialization and round constants tables
    var H = [];
    var K = [];

    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }

            return true;
        }

        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }

        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                nPrime++;
            }

            n++;
        }
    }());

    // Reusable object
    var W = [];

    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = C_algo.SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];

            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var gamma0x = W[i - 15];
                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                   (gamma0x >>> 3);

                    var gamma1x = W[i - 2];
                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                   (gamma1x >>> 10);

                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }

                var ch  = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);

                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;

                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA256(message, key);
     */
    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);

module.exports = C

},{"./core.js":5}],12:[function(require,module,exports){
exports.Face = require('./js/face.js').Face;
exports.NDN = require('./js/face.js').NDN; // deprecated
exports.Closure = require('./js/closure.js').Closure;
exports.Name = require('./js/name.js').Name;
exports.ForwardingFlags = require('./js/forwarding-flags.js').ForwardingFlags;
exports.Interest = require('./js/interest.js').Interest;
exports.Exclude = require('./js/exclude.js').Exclude;
exports.Data = require('./js/data.js').Data;
exports.ContentObject = require('./js/data.js').ContentObject; // deprecated
exports.ContentType = require('./js/meta-info.js').ContentType;
exports.MetaInfo = require('./js/meta-info.js').MetaInfo;
exports.SignedInfo = require('./js/meta-info.js').SignedInfo; // deprecated
exports.Key = require('./js/key.js').Key;
exports.KeyLocator = require('./js/key-locator.js').KeyLocator;
exports.KeyName = require('./js/key-locator.js').KeyName;
exports.KeyLocatorType = require('./js/key-locator.js').KeyLocatorType;
exports.PublisherPublicKeyDigest = require('./js/publisher-public-key-digest.js').PublisherPublicKeyDigest;
exports.WireFormat = require('./js/encoding/wire-format.js').WireFormat;
exports.BinaryXmlWireFormat = require('./js/encoding/binary-xml-wire-format.js').BinaryXmlWireFormat;
exports.TlvWireFormat = require('./js/encoding/tlv-wire-format.js').TlvWireFormat;
exports.DataUtils = require('./js/encoding/data-utils.js').DataUtils;
exports.EncodingUtils = require('./js/encoding/encoding-utils.js').EncodingUtils;
exports.Blob = require('./js/util/blob.js').Blob;
exports.NameEnumeration = require('./js/util/name-enumeration.js').NameEnumeration;
exports.NDNTime = require('./js/util/ndn-time.js').NDNTime;
exports.globalKeyManager = require('./js/security/key-manager.js').globalKeyManager;
exports.ElementReader = require('./js/encoding/element-reader.js').ElementReader;
exports.customBuffer = require('./js/browserify.js').Buffer

},{"./js/browserify.js":14,"./js/closure.js":15,"./js/data.js":16,"./js/encoding/binary-xml-wire-format.js":20,"./js/encoding/data-utils.js":21,"./js/encoding/element-reader.js":23,"./js/encoding/encoding-utils.js":24,"./js/encoding/tlv-wire-format.js":26,"./js/encoding/wire-format.js":31,"./js/exclude.js":32,"./js/face.js":34,"./js/forwarding-flags.js":36,"./js/interest.js":37,"./js/key-locator.js":38,"./js/key.js":39,"./js/meta-info.js":41,"./js/name.js":42,"./js/publisher-public-key-digest.js":44,"./js/security/key-manager.js":45,"./js/util/blob.js":48,"./js/util/name-enumeration.js":50,"./js/util/ndn-time.js":52}],13:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.
exports.TcpTransport = require('./transport/web-socket-transport.js').WebSocketTransport;

},{"./transport/web-socket-transport.js":47}],14:[function(require,module,exports){
/** 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Wentao Shang
 * See COPYING for copyright and distribution information.
 */

// Library namespace
var ndn = ndn || {};

var exports = ndn;

var ASN1HEX = require('../contrib/securityLib/asn1hex-1.1.js')
var KJUR = require('../contrib/securityLib/crypto-1.0.js')
var RSAKey = require('../contrib/securityLib/rsasign-1.2.js')
var b64tohex = require('../contrib/securityLib/base64.js').b64tohex
// Factory method to create node.js compatible buffer objects
var customBuf = function customBuf(data, format) 
{
  var obj;

  if (typeof data == 'number')
    obj = new Uint8Array(data);
  else if (typeof data == 'string') {
    if (format == null || format == 'utf8') {
      var utf8 = customBuf.str2rstr_utf8(data);
      obj = new Uint8Array(utf8.length);
      for (var i = 0; i < utf8.length; i++)
        obj[i] = utf8.charCodeAt(i);
    } 
    else if (format == 'binary') {
      obj = new Uint8Array(data.length);
      for (var i = 0; i < data.length; i++)
        obj[i] = data.charCodeAt(i);
    } 
    else if (format == 'hex') {
      obj = new Uint8Array(Math.floor(data.length / 2));
      var i = 0;
      data.replace(/(..)/g, function(ss) {
        obj[i++] = parseInt(ss, 16);
      });
    } 
    else if (format == 'base64') {
      var hex = b64tohex(data);
      obj = new Uint8Array(Math.floor(hex.length / 2));
      var i = 0;
      hex.replace(/(..)/g, function(ss) {
        obj[i++] = parseInt(ss, 16);
      });
    } 
    else 
      throw new Error('Buffer: unknown encoding format ' + format);
  } 
  else if (typeof data == 'object' && (data instanceof Uint8Array || data instanceof customBuf)) {
    // The second argument is a boolean for "copy", default true.
    if (format == false)
      obj = data.subarray(0);
    else
      obj = new Uint8Array(data);
  }
  else if (typeof data == 'object' && data instanceof ArrayBuffer)
    // Copy.
    obj = new Uint8Array(data);
  else if (typeof data == 'object')
    // Assume component is a byte array.  We can't check instanceof Array because
    //   this doesn't work in JavaScript if the array comes from a different module.
    obj = new Uint8Array(data);
  else
    throw new Error('Buffer: unknown data type.');

  try {
    obj.__proto__ = customBuf.prototype;
  } catch(ex) {
    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);
  }

  obj.__proto__.toString = function(encoding) {
    if (encoding == null) {
      var ret = "";
      for (var i = 0; i < this.length; i++)
        ret += String.fromCharCode(this[i]);
      return ret;
    }

    var ret = "";
    for (var i = 0; i < this.length; i++)
      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);

    if (encoding == 'hex')
      return ret;
    else if (encoding == 'base64')
      return hex2b64(ret);
    else
      throw new Error('Buffer.toString: unknown encoding format ' + encoding);
  };

  obj.__proto__.slice = function(begin, end) {
    if (end !== undefined)
      return new customBuf(this.subarray(begin, end), false);
    else
      return new customBuf(this.subarray(begin), false);
  };

  obj.__proto__.copy = function(target, targetStart) {
    if (targetStart !== undefined)
      target.set(this, targetStart);
    else
      target.set(this);
  };

  return obj;
};

customBuf.prototype = Uint8Array.prototype;

customBuf.concat = function(arrays) 
{
  var totalLength = 0;
  for (var i = 0; i < arrays.length; ++i)
    totalLength += arrays[i].length;
    
  var result = new customBuf(totalLength);
  var offset = 0;
  for (var i = 0; i < arrays.length; ++i) {
    result.set(arrays[i], offset);
    offset += arrays[i].length;
  }
  return result;
};

customBuf.str2rstr_utf8 = function(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while (++i < input.length)
  {
    // Decode utf-16 surrogate pairs
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    // Encode output as utf-8
    if (x <= 0x7F)
      output += String.fromCharCode(x);
    else if (x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if (x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if (x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
};

// Factory method to create hasher objects
exports.createHash = function(alg) 
{
  if (alg != 'sha256')
    throw new Error('createHash: unsupported algorithm.');

  var obj = {};

  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});

  obj.update = function(buf) {
    this.md.updateHex(buf.toString('hex'));
  };

  obj.digest = function() {
    return new customBuf(this.md.digest(), 'hex');
  };

  return obj;
};

// Factory method to create RSA signer objects
exports.createSign = function(alg) 
{
  if (alg != 'RSA-SHA256')
    throw new Error('createSign: unsupported algorithm.');

  var obj = {};

  obj.arr = [];

  obj.update = function(buf) {
    this.arr.push(buf);
  };

  obj.sign = function(keypem) {
    var rsa = new RSAKey();
    rsa.readPrivateKeyFromPEMString(keypem);
    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});
    signer.initSign(rsa);
    for (var i = 0; i < this.arr.length; ++i)
      signer.updateHex(this.arr[i].toString('hex'));

    return new customBuf(signer.sign(), 'hex');
  };

  return obj;
};

// Factory method to create RSA verifier objects
exports.createVerify = function(alg) 
{
  if (alg != 'RSA-SHA256')
    throw new Error('createSign: unsupported algorithm.');

  var obj = {};
    
  obj.arr = [];

  obj.update = function(buf) {
    this.arr.push(buf);
  };

  var getSubjectPublicKeyPosFromHex = function(hPub) {  
    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0); 
    if (a.length != 2) 
      return -1;
    var pBitString = a[1];
    if (hPub.substring(pBitString, pBitString + 2) != '03') 
      return -1;
    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);
    if (hPub.substring(pBitStringV, pBitStringV + 2) != '00') 
      return -1;
    return pBitStringV + 2;
  };

  var readPublicDER = function(pub_der) {
    var hex = pub_der.toString('hex'); 
    var p = getSubjectPublicKeyPosFromHex(hex);
    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);
    if (a.length != 2) 
      return null;
    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);
    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);
    var rsaKey = new RSAKey();
    rsaKey.setPublic(hN, hE);
    return rsaKey;
  };

  obj.verify = function(keypem, sig) {
    var key = new ndn.Key();
    key.fromPemString(keypem);

    var rsa = readPublicDER(key.publicToDER());
    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});
    signer.initVerifyByPublicKey(rsa);
    for (var i = 0; i < this.arr.length; i++)
      signer.updateHex(this.arr[i].toString('hex'));
    var hSig = sig.toString('hex'); 
    return signer.verify(hSig);
  };

  return obj;
};

exports.randomBytes = function(size)
{
  // TODO: Use a cryptographic random number generator.
  var result = new customBuf(size);
  for (var i = 0; i < size; ++i)
    result[i] = Math.floor(Math.random() * 256);
  return result;
};

exports.Buffer = customBuf;

module.exports = exports;

},{"../contrib/securityLib/asn1hex-1.1.js":3,"../contrib/securityLib/base64.js":4,"../contrib/securityLib/crypto-1.0.js":6,"../contrib/securityLib/rsasign-1.2.js":10}],15:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * Provide the callback closure for the async communication methods in the Face class.
 * This is a port of Closure.py from PyNDN, written by: 
 * Derek Kulinski <takeda@takeda.tk>
 * Jeff Burke <jburke@ucla.edu>
 */

/**
 * A subclass of Closure is passed to expressInterest and registerPrefix.
 * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.
 * @constructor
 */
var Closure = function Closure() 
{
  // I don't think storing Face's closure is needed
  // and it creates a reference loop, as of now both
  // of those variables are never set -- Derek
  //
  // Use instance variables to return data to callback
  this.ndn_data = null;  // this holds the ndn_closure
  this.ndn_data_dirty = false; 
};

exports.Closure = Closure;

// Upcall result
Closure.RESULT_ERR               = -1; // upcall detected an error
Closure.RESULT_OK                =  0; // normal upcall return
Closure.RESULT_REEXPRESS         =  1; // reexpress the same interest again
Closure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest
Closure.RESULT_VERIFY            =  3; // force an unverified result to be verified
Closure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest
                                       //   with the key available in the local storage

// Upcall kind
Closure.UPCALL_FINAL              = 0; // handler is about to be deregistered
Closure.UPCALL_INTEREST           = 1; // incoming interest
Closure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered
Closure.UPCALL_CONTENT            = 3; // incoming verified content
Closure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out
Closure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified
Closure.UPCALL_CONTENT_BAD        = 6; // verification failed

/**
 * Override this in your subclass.
 * If you're getting strange errors in upcall()
 * check your code whether you're returning a value.
 */
Closure.prototype.upcall = function(kind, upcallInfo) 
{
  //dump('upcall ' + this + " " + kind + " " + upcallInfo + "\n");
  return Closure.RESULT_OK;
};

/**
 * An UpcallInfo is passed to Closure.upcall.
 * @constructor
 */
var UpcallInfo = function UpcallInfo(face, interest, matchedComps, data) 
{
  this.face = face;  // Face object (not used)
  this.ndn = face;   // deprecated
  this.interest = interest;  // Interest object
  this.matchedComps = matchedComps;  // int
  this.data = data;  // Data
  this.contentObject = data; // deprecated.  Include for backward compatibility.
};

UpcallInfo.prototype.toString = function() 
{
  var ret = "face = " + this.face;
  ret += "\nInterest = " + this.interest;
  ret += "\nmatchedComps = " + this.matchedComps;
  ret += "\nData: " + this.data;
  return ret;
};

exports.UpcallInfo = UpcallInfo;

},{}],16:[function(require,module,exports){
(function (Buffer){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an NDN Data object.
 */

var Blob = require('./util/blob.js').Blob;
var SignedBlob = require('./util/signed-blob.js').SignedBlob;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var DataUtils = require('./encoding/data-utils.js').DataUtils;
var Name = require('./name.js').Name;
var Signature = require('./signature.js').Signature;
var MetaInfo = require('./meta-info.js').MetaInfo;
var KeyLocator = require('./key-locator.js').KeyLocator;
var globalKeyManager = require('./security/key-manager.js').globalKeyManager;
var WireFormat = require('./encoding/wire-format.js').WireFormat;
var customBuf = require('./buffer.js').Buffer
/**
 * Create a new Data with the optional values.  There are 2 forms of constructor:
 * new Data([name] [, content]);
 * new Data(name, metaInfo [, content]);
 * 
 * @constructor
 * @param {Name} name
 * @param {MetaInfo} metaInfo
 * @param {Buffer} content
 */
var Data = function Data(name, metaInfoOrContent, arg3) 
{
  if (typeof name === 'string')
    this.name = new Name(name);
  else
    this.name = typeof name === 'object' && name instanceof Name ?
       new Name(name) : new Name();

  var metaInfo;
  var content;
  if (typeof metaInfoOrContent === 'object' && 
      metaInfoOrContent instanceof MetaInfo) {
    metaInfo = metaInfoOrContent;
    content = arg3;
  }
  else {
    metaInfo = null;
    content = metaInfoOrContent;
  }
    
  // Use signedInfo instead of metaInfo for backward compatibility.
  this.signedInfo = typeof metaInfo === 'object' && metaInfo instanceof MetaInfo ?
       new MetaInfo(metaInfo) : new MetaInfo();
  
  if (typeof content === 'string') 
    this.content = DataUtils.toNumbersFromString(content);
  else if (typeof content === 'object' && content instanceof Blob)
    this.content = content.buf();
  else 
    this.content = content;
  
  this.signature = new Signature();
  
  this.wireEncoding = SignedBlob();
};

exports.Data = Data;

/**
 * Get the data packet's name.
 * @returns {Name} The name.
 */
Data.prototype.getName = function() 
{
  return this.name;
};

/**
 * Get the data packet's meta info.
 * @returns {MetaInfo} The meta info.
 */
Data.prototype.getMetaInfo = function() 
{
  return this.signedInfo;
};

/**
 * Get the data packet's signature object.
 * @returns {Signature} The signature object.
 */
Data.prototype.getSignature = function() 
{
  return this.signature;
};

/**
 * Get the data packet's content.
 * @returns {Buffer} The content as a customBuf, which is null if unspecified.
 */
Data.prototype.getContent = function() 
{
  return this.content;
};

/**
 * Set name to a copy of the given Name.
 * @param {Name} name The Name which is copied.
 * @returns {Data} This Data so that you can chain calls to update values.
 */
Data.prototype.setName = function(name) 
{
  this.name = typeof name === 'object' && name instanceof Name ?
    new Name(name) : new Name();

  // The object has changed, so the wireEncoding is invalid.
  this.wireEncoding = SignedBlob();
  return this;
};

/**
 * Set metaInfo to a copy of the given MetaInfo.
 * @param {MetaInfo} metaInfo The MetaInfo which is copied.
 * @returns {Data} This Data so that you can chain calls to update values.
 */
Data.prototype.setMetaInfo = function(metaInfo) 
{
  this.signedInfo = typeof metaInfo === 'object' && metaInfo instanceof MetaInfo ?
    new MetaInfo(metaInfo) : new MetaInfo();

  // The object has changed, so the wireEncoding is invalid.
  this.wireEncoding = SignedBlob();
  return this;
};

/**
 * Set the signature to a copy of the given signature.
 * @param {Signature} signature The signature object which is cloned.
 * @returns {Data} This Data so that you can chain calls to update values.
 */
Data.prototype.setSignature = function(signature) 
{
  this.signature = typeof signature === 'object' && signature instanceof Signature ?
    signature.clone() : new Signature();

  // The object has changed, so the wireEncoding is invalid.
  this.wireEncoding = SignedBlob();
  return this;
};

/**
 * Set the content to the given value.
 * @param {type} content The array this is copied.
 * @returns {Data} This Data so that you can chain calls to update values.
 */
Data.prototype.setContent = function(content) 
{
  if (typeof content === 'string') 
    this.content = DataUtils.toNumbersFromString(content);
  else if (typeof content === 'object' && content instanceof Blob)
    this.content = content.buf();
  else 
    this.content = new customBuf(content);

  // The object has changed, so the wireEncoding is invalid.
  this.wireEncoding = SignedBlob();
  return this;
};

Data.prototype.sign = function(wireFormat) 
{
  var rs = require('buffer')
  var ss = require('./crypto.js')
  console.log(Buffer, ss, rs)
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
 
  if (this.getSignatureOrMetaInfoKeyLocator() == null ||
      this.getSignatureOrMetaInfoKeyLocator().getType() == null)
    this.getMetaInfo().setFields();
  
  if (this.wireEncoding == null || this.wireEncoding.isNull()) {
    // Need to encode to set wireEncoding.
    // Set an initial empty signature so that we can encode.
    this.getSignature().setSignature(new customBuf(128));
    this.wireEncode(wireFormat);
  }
  
  var rsa = require("./crypto.js").createSign('RSA-SHA256');
  rsa.update(this.wireEncoding.signedBuf());
    
  var sig = new customBuf(rsa.sign(globalKeyManager.privateKey));
  this.signature.signature = sig;
};

Data.prototype.verify = function(/*Key*/ key) 
{
  if (key == null || key.publicKeyPem == null)
    throw new Error('Cannot verify Data without a public key.');

  if (this.wireEncoding == null || this.wireEncoding.isNull())
    // Need to encode to set wireEncoding.
    this.wireEncode();
  var verifier = require('./crypto.js').createVerify('RSA-SHA256');
  verifier.update(this.wireEncoding.signedBuf());
  return verifier.verify(key.publicKeyPem, this.signature.signature);
};

Data.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };

/**
 * Encode this Data for a particular wire format.
 * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object 
 * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().
 * @returns {SignedBlob} The encoded buffer in a SignedBlob object.
 */
Data.prototype.wireEncode = function(wireFormat) 
{
  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  var result = wireFormat.encodeData(this);
  // TODO: Implement setDefaultWireEncoding with getChangeCount support.
  this.wireEncoding = new SignedBlob
    (result.encoding, result.signedPortionBeginOffset, 
     result.signedPortionEndOffset);
  return this.wireEncoding;
};

/**
 * Decode the input using a particular wire format and update this Data.
 * @param {Blob|Buffer} input The buffer with the bytes to decode.
 * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object 
 * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().
 */
Data.prototype.wireDecode = function(input, wireFormat) 
{
  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  // If input is a blob, get its buf().
  var decodeBuffer = typeof input === 'object' && input instanceof Blob ? 
                     input.buf() : input;
  var result = wireFormat.decodeData(this, decodeBuffer);
  // TODO: Implement setDefaultWireEncoding with getChangeCount support.
  // In the Blob constructor, set copy true, but if input is already a Blob, it 
  //   won't copy.
  this.wireEncoding = new SignedBlob
    (new Blob(input, true), result.signedPortionBeginOffset, 
     result.signedPortionEndOffset);
};

/**
 * If getSignature() has a key locator, return it.  Otherwise, use
 * the key locator from getMetaInfo() for backward compatibility and print
 * a warning to console.log that the key locator has moved to the Signature
 * object.  If neither has a key locator, return an empty key locator.
 * When we stop supporting the key locator in MetaInfo, this function is not
 * necessary and we will just use the key locator in the Signature.
 * @returns {KeyLocator} The key locator to use.
 */
Data.prototype.getSignatureOrMetaInfoKeyLocator = function()
{
  if (this.signature != null && this.signature.getKeyLocator() != null &&
      this.signature.getKeyLocator().getType() != null &&
      this.signature.getKeyLocator().getType() >= 0)
    // The application is using the key locator in the correct object.
    return this.signature.getKeyLocator();
  
  if (this.signedInfo != null && this.signedInfo.locator != null &&
      this.signedInfo.locator.type != null &&
      this.signedInfo.locator.type >= 0) {
    //console.log("WARNING: Temporarily using the key locator found in the MetaInfo - expected it in the Signature object.");
    //console.log("WARNING: In the future, the key locator in the Signature object will not be supported.");
    return this.signedInfo.locator;
  }
  
  // Return the empty key locator from the Signature object if possible.
  if (this.signature != null && this.signature.getKeyLocator() != null)
    return this.signature.getKeyLocator();
  else
    return new KeyLocator();
}

// Since binary-xml-wire-format.js includes this file, put these at the bottom to avoid problems with cycles of require.
var BinaryXmlWireFormat = require('./encoding/binary-xml-wire-format.js').BinaryXmlWireFormat;

/**
 * @deprecated Use BinaryXmlWireFormat.decodeData.
 */
Data.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) 
{
  BinaryXmlWireFormat.decodeData(this, decoder);
};

/**
 * @deprecated Use BinaryXmlWireFormat.encodeData.
 */
Data.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)
{
  BinaryXmlWireFormat.encodeData(this, encoder);
};

/**
 * @deprecated Use wireEncode.  If you need binary XML, use
 * wireEncode(BinaryXmlWireFormat.get()).
 */
Data.prototype.encode = function(wireFormat) 
{
  wireFormat = (wireFormat || BinaryXmlWireFormat.get());
  return wireFormat.encodeData(this).buf();
};

/**
 * @deprecated Use wireDecode.  If you need binary XML, use
 * wireDecode(input, BinaryXmlWireFormat.get()).
 */
Data.prototype.decode = function(input, wireFormat) 
{
  wireFormat = (wireFormat || BinaryXmlWireFormat.get());
  wireFormat.decodeData(this, input);
};

/**
 * @deprecated Use new Data.
 */
var ContentObject = function ContentObject(name, signedInfo, content) 
{
  // Call the base constructor.
  Data.call(this, name, signedInfo, content); 
}

ContentObject.prototype = new Data();

exports.ContentObject = ContentObject;

}).call(this,require("buffer").Buffer)
},{"./buffer.js":14,"./crypto.js":14,"./encoding/binary-xml-encoder.js":18,"./encoding/binary-xml-wire-format.js":20,"./encoding/data-utils.js":21,"./encoding/wire-format.js":31,"./key-locator.js":38,"./meta-info.js":41,"./name.js":42,"./security/key-manager.js":45,"./signature.js":46,"./util/blob.js":48,"./util/ndn-protoco-id-tags.js":51,"./util/signed-blob.js":53,"buffer":109}],17:[function(require,module,exports){
/**
 * This class is used to decode ndnb binary elements (blob, type/value pairs).
 * 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer
var NDNProtocolDTags = require('../util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var NDNTime = require('../util/ndn-time.js').NDNTime;
var DataUtils = require('./data-utils.js').DataUtils;
var DecodingException = require('./decoding-exception.js').DecodingException;
var LOG = require('../log.js').Log.LOG;

var XML_EXT = 0x00; 
  
var XML_TAG = 0x01; 
  
var XML_DTAG = 0x02; 
  
var XML_ATTR = 0x03; 
 
var XML_DATTR = 0x04; 
  
var XML_BLOB = 0x05; 
  
var XML_UDATA = 0x06; 
  
var XML_CLOSE = 0x0;

var XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; 
  

var XML_TT_BITS = 3;
var XML_TT_MASK = ((1 << XML_TT_BITS) - 1);
var XML_TT_VAL_BITS = XML_TT_BITS + 1;
var XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);
var XML_REG_VAL_BITS = 7;
var XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);
var XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80
var BYTE_MASK = 0xFF;
var LONG_BYTES = 8;
var LONG_BITS = 64;
  
var bits_11 = 0x0000007FF;
var bits_18 = 0x00003FFFF;
var bits_32 = 0x0FFFFFFFF;



//returns a string
tagToString = function(/*long*/ tagVal) 
{
  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {
    return NDNProtocolDTagsStrings[tagVal];
  } 
  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {
    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;
  }
  
  return null;
};

//returns a Long
stringToTag =  function(/*String*/ tagName) 
{
  // the slow way, but right now we don't care.... want a static lookup for the forward direction
  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {
    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)
      return i;
  }
  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {
    return NDNProtocolDTags.NDNProtocolDataUnit;
  }
  
  return null;
};

/**
 * @constructor
 */
var BinaryXMLDecoder = function BinaryXMLDecoder(input) 
{
  var MARK_LEN=512;
  var DEBUG_MAX_LEN =  32768;
  
  this.input = input;
  this.offset = 0;
  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.
  this.previouslyPeekedDTagStartOffset = -1;
};

exports.BinaryXMLDecoder = BinaryXMLDecoder;

/**
 * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.
   * Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 */
BinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)
{
  if (this.offset == this.previouslyPeekedDTagStartOffset) {
    // peekDTag already decoded this DTag.
    if (this.previouslyPeekedDTag != expectedTag)
      throw new DecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));

    // Fast forward past the header.
    this.offset = this.previouslyPeekedDTagEndOffset;
  }
  else {
    var typeAndValue = this.decodeTypeAndVal();
    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)
      throw new DecodingException(new Error("Header type is not a DTAG"));

    if (typeAndValue.val() != expectedTag)
      throw new DecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));
  }  
};

/**
 * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readStartElement = function(
    //String 
    startTag,
    //TreeMap<String, String> 
    attributes)
{
  //TypeAndVal 
  var tv = this.decodeTypeAndVal();
      
  if (null == tv)
    throw new DecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));
      
  //String 
  var decodedTag = null;
      
  if (tv.type() == XML_TAG) {
    // Tag value represents length-1 as tags can never be empty.
    var valval;
        
    if (typeof tv.val() == 'string')
      valval = (parseInt(tv.val())) + 1;
    else
      valval = (tv.val())+ 1;
        
    decodedTag = this.decodeUString(valval);
  } 
  else if (tv.type() == XML_DTAG)
    decodedTag = tv.val();
      
  if (null ==  decodedTag || decodedTag != startTag) {
    console.log('expecting '+ startTag + ' but got '+ decodedTag);
    throw new DecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));
  }
      
  // DKS: does not read attributes out of stream if caller doesn't
  // ask for them. Should possibly peek and skip over them regardless.
  // TODO: fix this
  if (null != attributes)
    readAttributes(attributes); 
};
  
/**
 * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readAttributes = function(
  // array of [attributeName, attributeValue] 
  attributes) 
{
  if (null == attributes)
    return;

  try {
    // Now need to get attributes.
    //TypeAndVal 
    var nextTV = this.peekTypeAndVal();

    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {
      // Decode this attribute. First, really read the type and value.
      //this.TypeAndVal 
      var thisTV = this.decodeTypeAndVal();

      //String 
      var attributeName = null;
      if (XML_ATTR == thisTV.type()) {
        // Tag value represents length-1 as attribute names cannot be empty.
        var valval ;
        if (typeof thisTV.val() == 'string')
          valval = (parseInt(thisTV.val())) + 1;
        else
          valval = (thisTV.val())+ 1;
        
        attributeName = this.decodeUString(valval);
      } 
      else if (XML_DATTR == thisTV.type()) {
        // DKS TODO are attributes same or different dictionary?
        attributeName = tagToString(thisTV.val());
        if (null == attributeName)
          throw new DecodingException(new Error("Unknown DATTR value" + thisTV.val()));
      }
      
      // Attribute values are always UDATA
      //String
      var attributeValue = this.decodeUString();

      attributes.push([attributeName, attributeValue]);
      nextTV = this.peekTypeAndVal();
    }
  } 
  catch (e) {
    throw new DecodingException(new Error("readStartElement", e));
  }
};

/**
 * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.peekStartElementAsString = function() 
{
  //String 
  var decodedTag = null;
  var previousOffset = this.offset;
  try {
    // Have to distinguish genuine errors from wrong tags. Could either use
    // a special exception subtype, or redo the work here.
    //this.TypeAndVal 
    var tv = this.decodeTypeAndVal();

    if (null != tv) {
      if (tv.type() == XML_TAG) {
        // Tag value represents length-1 as tags can never be empty.
        var valval ;
        if (typeof tv.val() == 'string')
          valval = (parseInt(tv.val())) + 1;
        else
          valval = (tv.val())+ 1;
        
        decodedTag = this.decodeUString(valval);
      }
      else if (tv.type() == XML_DTAG)
        decodedTag = tagToString(tv.val());          
    } // else, not a type and val, probably an end element. rewind and return false.
  } 
  catch (e) {
  } 
  finally {
    try {
      this.offset = previousOffset;
    } 
    catch (e) {
      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);
      throw new DecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));
    }
  }
  
  return decodedTag;
};

/**
 * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,
 * then set return true.  Do not update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {boolean} True if the tag is the expected tag, otherwise false.
 */
BinaryXMLDecoder.prototype.peekDTag = function(expectedTag)
{
  if (this.offset == this.previouslyPeekedDTagStartOffset)
    // We already decoded this DTag.
    return this.previouslyPeekedDTag == expectedTag;
  else {
    // First check if it is an element close (which cannot be the expected tag).  
    if (this.input[this.offset] == XML_CLOSE)
      return false;

    var saveOffset = this.offset;
    var typeAndValue = this.decodeTypeAndVal();
    // readElementStartDTag will use this to fast forward.
    this.previouslyPeekedDTagEndOffset = this.offset;
    // Restore the position.
    this.offset = saveOffset;

    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {
      this.previouslyPeekedDTagStartOffset = saveOffset;
      this.previouslyPeekedDTag = typeAndValue.val();

      return typeAndValue.val() == expectedTag;
    }
    else
      return false;
  }  
};

/**
 * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.peekStartElement = function(
    //String 
    startTag) 
{
  //String 
  if (typeof startTag == 'string') {
    var decodedTag = this.peekStartElementAsString();
    
    if (null !=  decodedTag && decodedTag == startTag)
      return true;

    return false;
  }
  else if (typeof startTag == 'number') {
    var decodedTag = this.peekStartElementAsLong();
    if (null !=  decodedTag && decodedTag == startTag)
      return true;

    return false;
  }
  else
    throw new DecodingException(new Error("SHOULD BE STRING OR NUMBER"));
};

/**
 * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.peekStartElementAsLong = function() 
{
  //Long
  var decodedTag = null;    
  var previousOffset = this.offset;
  
  try {
    // Have to distinguish genuine errors from wrong tags. Could either use
    // a special exception subtype, or redo the work here.
    //this.TypeAndVal
    var tv = this.decodeTypeAndVal();

    if (null != tv) {
      if (tv.type() == XML_TAG) {
        if (tv.val() + 1 > DEBUG_MAX_LEN)
          throw new DecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));

        var valval;
        if (typeof tv.val() == 'string')
          valval = (parseInt(tv.val())) + 1;
        else
          valval = (tv.val())+ 1;
        
        // Tag value represents length-1 as tags can never be empty.
        //String 
        var strTag = this.decodeUString(valval);
        
        decodedTag = stringToTag(strTag);
      } 
      else if (tv.type() == XML_DTAG)
        decodedTag = tv.val();          
    } // else, not a type and val, probably an end element. rewind and return false.

  } 
  catch (e) {  
  } 
  finally {
    try {
      //this.input.reset();
      this.offset = previousOffset;
    } catch (e) {
      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);
      throw new Error("Cannot reset stream! " + e.getMessage(), e);
    }
  }
  
  return decodedTag;
};

/**
 * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.
 * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a 
 * customBuf. However, if allowNull is true, then the item may be absent.
 * Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @param {boolean} allowNull True if the binary item may be missing.
 * @returns {Buffer} A customBuf which is a slice on the data inside the input buffer. However, 
 * if allowNull is true and the binary data item is absent, then return null.
 */
BinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)
{
  this.readElementStartDTag(expectedTag);
  return this.readBlob(allowNull);  
};

/**
 * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readBinaryElement = function(
    //long 
    startTag,
    //TreeMap<String, String> 
    attributes,
    //boolean
    allowNull) 
{
  this.readStartElement(startTag, attributes);
  return this.readBlob(allowNull);  
};

/**
 * Read one byte from the input starting at its offset, expecting it to be the element close.
 * Update the input's offset.
 */
BinaryXMLDecoder.prototype.readElementClose = function() 
{
  var next = this.input[this.offset++];     
  if (next != XML_CLOSE)
    throw new DecodingException(new Error("Expected end element, got: " + next));
};

/**
 * @deprecated Use readElementClose.
 */
BinaryXMLDecoder.prototype.readEndElement = function() 
{
  if (LOG > 4) console.log('this.offset is '+this.offset);
  
  var next = this.input[this.offset]; 
  
  this.offset++;
  
  if (LOG > 4) console.log('XML_CLOSE IS '+XML_CLOSE);
  if (LOG > 4) console.log('next is '+next);
  
  if (next != XML_CLOSE) {
    console.log("Expected end element, got: " + next);
    throw new DecodingException(new Error("Expected end element, got: " + next));
  }
};

//String  
BinaryXMLDecoder.prototype.readUString = function() 
{
  //String 
  var ustring = this.decodeUString();  
  this.readElementClose();
  return ustring;
};
  
/**
 * Read a blob as well as the end element. Returns a customBuf (or null for missing blob).
 * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,
 *   just read the end element and return null.
 */
BinaryXMLDecoder.prototype.readBlob = function(allowNull) 
{
  if (this.input[this.offset] == XML_CLOSE && allowNull) {
    this.readElementClose();
    return null;
  }
    
  var blob = this.decodeBlob();  
  this.readElementClose();
  return blob;
};

/**
 * Decode the header from the input starting at its offset, expecting the type to be 
 * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned 
 * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.
 * Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {NDNTime} The dateTime value.
 */
BinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)  
{
  var byteTimestamp = this.readBinaryDTagElement(expectedTag);
  byteTimestamp = DataUtils.toHex(byteTimestamp);
  byteTimestamp = parseInt(byteTimestamp, 16);
  
  var lontimestamp = (byteTimestamp/ 4096) * 1000;

  var timestamp = new NDNTime(lontimestamp);  
  if (null == timestamp)
    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));

  return timestamp;
};

/**
 * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readDateTime = function(
  //long 
  startTag)  
{
  var byteTimestamp = this.readBinaryElement(startTag);
  byteTimestamp = DataUtils.toHex(byteTimestamp);
  byteTimestamp = parseInt(byteTimestamp, 16);
  
  var lontimestamp = (byteTimestamp/ 4096) * 1000;

  if (LOG > 4) console.log('DECODED DATE WITH VALUE');
  if (LOG > 4) console.log(lontimestamp);
  
  //NDNTime 
  var timestamp = new NDNTime(lontimestamp);  
  if (null == timestamp)
    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));

  return timestamp;
};

BinaryXMLDecoder.prototype.decodeTypeAndVal = function() 
{
  
  /*int*/ var type = -1;
  /*long*/ var val = 0;
  /*boolean*/ var more = true;

  do {
    var next = this.input[this.offset ];
    if (next == null)
      // Quit the loop.
      return null; 
    
    if (next < 0)
      return null; 

    if (0 == next && 0 == val)
      return null;
    
    more = (0 == (next & XML_TT_NO_MORE));
    
    if  (more) {
      val = val << XML_REG_VAL_BITS;
      val |= (next & XML_REG_VAL_MASK);
    } 
    else {
      type = next & XML_TT_MASK;
      val = val << XML_TT_VAL_BITS;
      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);
    }
    
    this.offset++;
  } while (more);
  
  if (LOG > 4) console.log('TYPE is '+ type + ' VAL is '+ val);

  return new TypeAndVal(type, val);
};

//TypeAndVal
BinaryXMLDecoder.prototype.peekTypeAndVal = function() 
{
  //TypeAndVal 
  var tv = null;
  var previousOffset = this.offset;
  
  try {
    tv = this.decodeTypeAndVal();
  } 
  finally {
    this.offset = previousOffset;
  }
  
  return tv;
};

//Buffer
BinaryXMLDecoder.prototype.decodeBlob = function(
    //int 
    blobLength) 
{  
  if (null == blobLength) {
    //TypeAndVal
    var tv = this.decodeTypeAndVal();

    var valval ;
    if (typeof tv.val() == 'string')
      valval = (parseInt(tv.val()));
    else
      valval = (tv.val());
    
    return this.decodeBlob(valval);
  }
  
  //Buffer
  var bytes = new customBuf(this.input.slice(this.offset, this.offset+ blobLength));
  this.offset += blobLength;
  
  return bytes;
};

//String
BinaryXMLDecoder.prototype.decodeUString = function(
    //int 
    byteLength) 
{
  if (null == byteLength) {
    var tempStreamPosition = this.offset;
      
    //TypeAndVal 
    var tv = this.decodeTypeAndVal();
    
    if (LOG > 4) console.log('TV is '+tv);
    if (LOG > 4) console.log(tv);
    
    if (LOG > 4) console.log('Type of TV is '+typeof tv);
  
    // if we just have closers left, will get back null
    if (null == tv || XML_UDATA != tv.type()) {
      this.offset = tempStreamPosition;      
      return "";
    }
      
    return this.decodeUString(tv.val());
  }
  else {
    //Buffer 
    var stringBytes = this.decodeBlob(byteLength);
    
    // TODO: Should this parse as UTF8?
    return DataUtils.toString(stringBytes);    
  }
};

//OBject containg a pair of type and value
var TypeAndVal = function TypeAndVal(_type,_val) 
{
  this.t = _type;
  this.v = _val;
};

TypeAndVal.prototype.type = function() 
{
  return this.t;
};

TypeAndVal.prototype.val = function() 
{
  return this.v;
};

/**
 * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.
 * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {number} The parsed integer.
 */
BinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)
{
  return parseInt(this.readUTF8DTagElement(expectedTag));
};

/**
 * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readIntegerElement = function(
  //String 
  startTag) 
{
  //String 
  if (LOG > 4) console.log('READING INTEGER '+ startTag);
  if (LOG > 4) console.log('TYPE OF '+ typeof startTag);
  
  var strVal = this.readUTF8Element(startTag);
  
  return parseInt(strVal);
};

/**
 * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.
 * Then read one UDATA item and return a string. Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {string} The UDATA string.
 */
BinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)
{
  this.readElementStartDTag(expectedTag);
  return this.readUString();;
};

/**
 * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readUTF8Element = function(
    //String 
    startTag,
    //TreeMap<String, String> 
    attributes) 
{
  //throws Error where name == "DecodingException" 

  // can't use getElementText, can't get attributes
  this.readStartElement(startTag, attributes);
  //String 
  var strElementText = this.readUString();
  return strElementText;
};

/**
 * Set the offset into the input, used for the next read.
 * @param {number} offset The new offset.
 */
BinaryXMLDecoder.prototype.seek = function(offset) 
{
  this.offset = offset;
};

},{"../buffer.js":14,"../log.js":40,"../util/ndn-protoco-id-tags.js":51,"../util/ndn-time.js":52,"./data-utils.js":21,"./decoding-exception.js":22}],18:[function(require,module,exports){
/**
 * This class is used to encode ndnb binary elements (blob, type/value pairs).
 * 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */

var LOG = require('../log.js').Log.LOG;

var customBuf = require('../buffer.js').Buffer
var NDNProtocolDTags = require('../util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var DynamicBuffer = require('../util/dynamic-buffer.js').DynamicBuffer;
var DataUtils = require('./data-utils.js').DataUtils;
var LOG = require('../log.js').Log.LOG;

var XML_EXT = 0x00; 
  
var XML_TAG = 0x01; 
  
var XML_DTAG = 0x02; 
  
var XML_ATTR = 0x03; 
 
var XML_DATTR = 0x04; 
  
var XML_BLOB = 0x05; 
  
var XML_UDATA = 0x06; 
  
var XML_CLOSE = 0x0;

var XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; 


var XML_TT_BITS = 3;
var XML_TT_MASK = ((1 << XML_TT_BITS) - 1);
var XML_TT_VAL_BITS = XML_TT_BITS + 1;
var XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);
var XML_REG_VAL_BITS = 7;
var XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);
var XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80
var BYTE_MASK = 0xFF;
var LONG_BYTES = 8;
var LONG_BITS = 64;
  
var bits_11 = 0x0000007FF;
var bits_18 = 0x00003FFFF;
var bits_32 = 0x0FFFFFFFF;

/**
 * @constructor
 */
var BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength) 
{
  if (!initiaLength)
    initiaLength = 16;
  
  this.ostream = new DynamicBuffer(initiaLength);
  this.offset = 0;
  this.CODEC_NAME = "Binary";
};

exports.BinaryXMLEncoder = BinaryXMLEncoder;

/**
 * Encode utf8Content as utf8 and write to the output buffer as a UDATA.
 * @param {string} utf8Content The string to convert to utf8.
 */
BinaryXMLEncoder.prototype.writeUString = function(utf8Content) 
{
  this.encodeUString(utf8Content, XML_UDATA);
};

BinaryXMLEncoder.prototype.writeBlob = function(
    /*Buffer*/ binaryContent) 
{  
  if (LOG >3) console.log(binaryContent);
  
  this.encodeBlob(binaryContent, binaryContent.length);
};

/**
 * Write an element start header using DTAG with the tag to the output buffer.
 * @param {number} tag The DTAG tag.
 */
BinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)
{
  this.encodeTypeAndVal(XML_DTAG, tag);
};

/**
 * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLEncoder.prototype.writeStartElement = function(
  /*String*/ tag, 
  /*TreeMap<String,String>*/ attributes) 
{
  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);
  
  if (null == dictionaryVal)
    this.encodeUString(tag, XML_TAG);
  else
    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);
  
  if (null != attributes)
    this.writeAttributes(attributes); 
};

/**
 * Write an element close to the output buffer.
 */
BinaryXMLEncoder.prototype.writeElementClose = function() 
{
  this.ostream.ensureLength(this.offset + 1);
  this.ostream.array[this.offset] = XML_CLOSE;
  this.offset += 1;
};

/**
 * @deprecated Use writeElementClose.
 */
BinaryXMLEncoder.prototype.writeEndElement = function() 
{
  this.writeElementClose();
};

/**
 * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.
 */
BinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes) 
{
  if (null == attributes)
    return;

  // the keySet of a TreeMap is sorted.

  for (var i = 0; i< attributes.length;i++) {
    var strAttr = attributes[i].k;
    var strValue = attributes[i].v;

    var dictionaryAttr = stringToTag(strAttr);
    if (null == dictionaryAttr)
      // not in dictionary, encode as attr
      // compressed format wants length of tag represented as length-1
      // to save that extra bit, as tag cannot be 0 length.
      // encodeUString knows to do that.
      this.encodeUString(strAttr, XML_ATTR);
    else
      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);

    // Write value
    this.encodeUString(strValue);    
  }
};

//returns a string
stringToTag = function(/*long*/ tagVal) 
{
  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)
    return NDNProtocolDTagsStrings[tagVal];
  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)
    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;
  
  return null;
};

//returns a Long
tagToString =  function(/*String*/ tagName) 
{
  // the slow way, but right now we don't care.... want a static lookup for the forward direction
  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {
    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)
      return i;
  }
  
  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)
    return NDNProtocolDTags.NDNProtocolDataUnit;

  return null;
};

/**
 * Write an element start header using DTAG with the tag to the output buffer, then the content as explained below, 
 * then an element close.
 * @param {number} tag The DTAG tag.
 * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,
 * call writeUString.  Otherwise, call writeBlob.
 */
BinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)
{
  this.writeElementStartDTag(tag);
  
  if (typeof content === 'number')
    this.writeUString(content.toString());
  else if (typeof content === 'string')
    this.writeUString(content);
  else
    this.writeBlob(content);
  
  this.writeElementClose();
};

/**
 * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 * If Content is a string, then encode as utf8 and write UDATA.
 */
BinaryXMLEncoder.prototype.writeElement = function(
    //long 
    tag, 
    //byte[] 
    Content,
    //TreeMap<String, String> 
    attributes) 
{
  this.writeStartElement(tag, attributes);
  // Will omit if 0-length
  
  if (typeof Content === 'number') {
    if (LOG > 4) console.log('GOING TO WRITE THE NUMBER .charCodeAt(0) ' + Content.toString().charCodeAt(0));
    if (LOG > 4) console.log('GOING TO WRITE THE NUMBER ' + Content.toString());
    if (LOG > 4) console.log('type of number is ' + typeof Content.toString());
    
    this.writeUString(Content.toString());
  }
  else if (typeof Content === 'string') {
    if (LOG > 4) console.log('GOING TO WRITE THE STRING  ' + Content);
    if (LOG > 4) console.log('type of STRING is ' + typeof Content);
    
    this.writeUString(Content);
  }
  else {
    if (LOG > 4) console.log('GOING TO WRITE A BLOB  ' + Content);

    this.writeBlob(Content);
  }
  
  this.writeElementClose();
};

var TypeAndVal = function TypeAndVal(_type,_val) 
{
  this.type = _type;
  this.val = _val;  
};

BinaryXMLEncoder.prototype.encodeTypeAndVal = function(
    //int
    type, 
    //long 
    val) 
{  
  if (LOG > 4) console.log('Encoding type '+ type+ ' and value '+ val);
  
  if (LOG > 4) console.log('OFFSET IS ' + this.offset);
  
  if (type > XML_UDATA || type < 0 || val < 0)
    throw new Error("Tag and value must be positive, and tag valid.");
  
  // Encode backwards. Calculate how many bytes we need:
  var numEncodingBytes = this.numEncodingBytes(val);
  this.ostream.ensureLength(this.offset + numEncodingBytes);

  // Bottom 4 bits of val go in last byte with tag.
  this.ostream.array[this.offset + numEncodingBytes - 1] = 
    //(byte)
      (BYTE_MASK &
          (((XML_TT_MASK & type) | 
           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |
           XML_TT_NO_MORE); // set top bit for last byte
  val = val >>> XML_TT_VAL_BITS;
  
  // Rest of val goes into preceding bytes, 7 bits per byte, top bit
  // is "more" flag.
  var i = this.offset + numEncodingBytes - 2;
  while (0 != val && i >= this.offset) {
    this.ostream.array[i] = //(byte)
        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset
    val = val >>> XML_REG_VAL_BITS;
    --i;
  }
  
  if (val != 0)
    throw new Error("This should not happen: miscalculated encoding");

  this.offset+= numEncodingBytes;
  
  return numEncodingBytes;
};

/**
 * Encode ustring as utf8.
 */
BinaryXMLEncoder.prototype.encodeUString = function(
    //String 
    ustring, 
    //byte 
    type) 
{  
  if (null == ustring)
    return;
  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)
    return;
  
  if (LOG > 3) console.log("The string to write is ");
  if (LOG > 3) console.log(ustring);

  var strBytes = DataUtils.stringToUtf8Array(ustring);
  
  this.encodeTypeAndVal(type, 
            (((type == XML_TAG) || (type == XML_ATTR)) ?
                (strBytes.length-1) :
                strBytes.length));
  
  if (LOG > 3) console.log("THE string to write is ");
  
  if (LOG > 3) console.log(strBytes);
  
  this.writeString(strBytes);
  this.offset+= strBytes.length;
};


BinaryXMLEncoder.prototype.encodeBlob = function(
    //Buffer 
    blob, 
    //int 
    length) 
{
  if (null == blob)
    return;
  
  if (LOG > 4) console.log('LENGTH OF XML_BLOB IS '+length);
  
  this.encodeTypeAndVal(XML_BLOB, length);
  this.writeBlobArray(blob);
  this.offset += length;
};

var ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);
var ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);
var ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);

BinaryXMLEncoder.prototype.numEncodingBytes = function(
    //long
    x) 
{
  if (x <= ENCODING_LIMIT_1_BYTE) return (1);
  if (x <= ENCODING_LIMIT_2_BYTES) return (2);
  if (x <= ENCODING_LIMIT_3_BYTES) return (3);
  
  var numbytes = 1;
  
  // Last byte gives you XML_TT_VAL_BITS
  // Remainder each give you XML_REG_VAL_BITS
  x = x >>> XML_TT_VAL_BITS;
  while (x != 0) {
        numbytes++;
    x = x >>> XML_REG_VAL_BITS;
  }
  return (numbytes);
};

/**
 * Write an element start header using DTAG with the tag to the output buffer, then the dateTime
   * as a big endian BLOB converted to 4096 ticks per second, then an element close.
 * @param {number} tag The DTAG tag.
 * @param {NDNTime} dateTime
 */
BinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)
{  
  //parse to hex
  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;
  if (binarydate.length % 2 == 1)
    binarydate = '0' + binarydate;

  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));
};

/**
 * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLEncoder.prototype.writeDateTime = function(
    //String 
    tag, 
    //NDNTime 
    dateTime) 
{  
  //parse to hex
  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;
  if (binarydate.length % 2 == 1)
    binarydate = '0' + binarydate;

  this.writeElement(tag, DataUtils.toNumbers(binarydate));
};

// This does not update this.offset.
BinaryXMLEncoder.prototype.writeString = function(input) 
{
  if (typeof input === 'string') {
    if (LOG > 4) console.log('GOING TO WRITE A STRING');
    if (LOG > 4) console.log(input);
        
    this.ostream.ensureLength(this.offset + input.length);
    for (var i = 0; i < input.length; i++) {
      if (LOG > 4) console.log('input.charCodeAt(i)=' + input.charCodeAt(i));
      this.ostream.array[this.offset + i] = (input.charCodeAt(i));
    }
  }
  else
  {
    if (LOG > 4) console.log('GOING TO WRITE A STRING IN BINARY FORM');
    if (LOG > 4) console.log(input);
    
    this.writeBlobArray(input);
  }
};

BinaryXMLEncoder.prototype.writeBlobArray = function(
    //Buffer 
    blob) 
{  
  if (LOG > 4) console.log('GOING TO WRITE A BLOB');
    
  this.ostream.copy(blob, this.offset);
};

BinaryXMLEncoder.prototype.getReducedOstream = function() 
{
  return this.ostream.slice(0, this.offset);
};

},{"../buffer.js":14,"../log.js":40,"../util/dynamic-buffer.js":49,"../util/ndn-protoco-id-tags.js":51,"./data-utils.js":21}],19:[function(require,module,exports){
/**
 * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to 
 * determine its end.
 * 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var BinaryXMLDecoder = require('./binary-xml-decoder.js').BinaryXMLDecoder;
var DynamicBuffer = require('../util/dynamic-buffer.js').DynamicBuffer;

var XML_EXT = 0x00; 
var XML_TAG = 0x01; 
var XML_DTAG = 0x02; 
var XML_ATTR = 0x03; 
var XML_DATTR = 0x04; 
var XML_BLOB = 0x05; 
var XML_UDATA = 0x06;   
var XML_CLOSE = 0x0;

var XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; 

var XML_TT_BITS = 3;
var XML_TT_MASK = ((1 << XML_TT_BITS) - 1);
var XML_TT_VAL_BITS = XML_TT_BITS + 1;
var XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);
var XML_REG_VAL_BITS = 7;
var XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);
var XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80

/**
 * @constructor
 */
var BinaryXMLStructureDecoder = function BinaryXMLDecoder() 
{
  this.gotElementEnd = false;
  this.offset = 0;
  this.level = 0;
  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;
  this.headerLength = 0;
  this.useHeaderBuffer = false;
  this.headerBuffer = new DynamicBuffer(5);
  this.nBytesToRead = 0;
};

exports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;

BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;
BinaryXMLStructureDecoder.READ_BYTES = 1;

/**
 * Continue scanning input starting from this.offset.  If found the end of the element
 *   which started at offset 0 then return true, else false.
 * If this returns false, you should read more into input and call again.
 * You have to pass in input each time because the array could be reallocated.
 * This throws an exception for badly formed ndnb.
 */
BinaryXMLStructureDecoder.prototype.findElementEnd = function(
  // customBuf
  input)
{
  if (this.gotElementEnd)
    // Someone is calling when we already got the end.
    return true;

  var decoder = new BinaryXMLDecoder(input);
  
  while (true) {
    if (this.offset >= input.length)
      // All the cases assume we have some input.
      return false;
  
    switch (this.state) {
      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:               
        // First check for XML_CLOSE.
        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {
          ++this.offset;
          // Close the level.
          --this.level;
          if (this.level == 0) {
            // Finished.
            this.gotElementEnd = true;
            return true;
          }
          if (this.level < 0)
            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));
              
          // Get ready for the next header.
          this.startHeader();
          break;
        }
        
        var startingHeaderLength = this.headerLength;
        while (true) {
          if (this.offset >= input.length) {
            // We can't get all of the header bytes from this input. Save in headerBuffer.
            this.useHeaderBuffer = true;
            var nNewBytes = this.headerLength - startingHeaderLength;
            this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);
              
            return false;
          }
          var headerByte = input[this.offset++];
          ++this.headerLength;
          if (headerByte & XML_TT_NO_MORE)
            // Break and read the header.
            break;
        }
        
        var typeAndVal;
        if (this.useHeaderBuffer) {
          // Copy the remaining bytes into headerBuffer.
          nNewBytes = this.headerLength - startingHeaderLength;
          this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);

          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();
        }
        else {
          // We didn't have to use the headerBuffer.
          decoder.seek(this.offset - this.headerLength);
          typeAndVal = decoder.decodeTypeAndVal();
        }
        
        if (typeAndVal == null)
          throw new Error("BinaryXMLStructureDecoder: Can't read header starting at offset " +
                          (this.offset - this.headerLength));
        
        // Set the next state based on the type.
        var type = typeAndVal.t;
        if (type == XML_DATTR)
          // We already consumed the item. READ_HEADER_OR_CLOSE again.
          // ndnb has rules about what must follow an attribute, but we are just scanning.
          this.startHeader();
        else if (type == XML_DTAG || type == XML_EXT) {
          // Start a new level and READ_HEADER_OR_CLOSE again.
          ++this.level;
          this.startHeader();
        }
        else if (type == XML_TAG || type == XML_ATTR) {
          if (type == XML_TAG)
            // Start a new level and read the tag.
            ++this.level;
          // Minimum tag or attribute length is 1.
          this.nBytesToRead = typeAndVal.v + 1;
          this.state = BinaryXMLStructureDecoder.READ_BYTES;
          // ndnb has rules about what must follow an attribute, but we are just scanning.
        }
        else if (type == XML_BLOB || type == XML_UDATA) {
          this.nBytesToRead = typeAndVal.v;
          this.state = BinaryXMLStructureDecoder.READ_BYTES;
        }
        else
          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);
        break;
    
      case BinaryXMLStructureDecoder.READ_BYTES:
        var nRemainingBytes = input.length - this.offset;
        if (nRemainingBytes < this.nBytesToRead) {
          // Need more.
          this.offset += nRemainingBytes;
          this.nBytesToRead -= nRemainingBytes;
          return false;
        }
        // Got the bytes.  Read a new header or close.
        this.offset += this.nBytesToRead;
        this.startHeader();
        break;
    
      default:
        // We don't expect this to happen.
        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);
    }
  }
};

/**
 * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header
 */
BinaryXMLStructureDecoder.prototype.startHeader = function() 
{
  this.headerLength = 0;
  this.useHeaderBuffer = false;
  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;    
};

/**
 *  Set the offset into the input, used for the next read.
 */
BinaryXMLStructureDecoder.prototype.seek = function(offset) 
{
  this.offset = offset;
};

},{"../util/dynamic-buffer.js":49,"./binary-xml-decoder.js":17}],20:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var Blob = require('../util/blob.js').Blob;
var NDNProtocolDTags = require('../util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var BinaryXMLEncoder = require('./binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./binary-xml-decoder.js').BinaryXMLDecoder;
var WireFormat = require('./wire-format.js').WireFormat;
var Name = require('../name.js').Name;
var Exclude = require('../exclude.js').Exclude;
var Signature = require('../signature.js').Signature;
var MetaInfo = require('../meta-info.js').MetaInfo;
var PublisherPublicKeyDigest = require('../publisher-public-key-digest.js').PublisherPublicKeyDigest;
var DataUtils = require('./data-utils.js').DataUtils;
var KeyLocatorType = require('../key-locator.js').KeyLocatorType;

/**
 * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.
 * @constructor
 */
var BinaryXmlWireFormat = function BinaryXmlWireFormat() 
{
  // Inherit from WireFormat.
  WireFormat.call(this);
};

exports.BinaryXmlWireFormat = BinaryXmlWireFormat;

// Default object.
BinaryXmlWireFormat.instance = null;

/**
 * Encode interest as Binary XML and return the encoding.
 * @param {Interest} interest The Interest to encode.
 * @returns {Blob} A Blob containing the encoding.
 */
BinaryXmlWireFormat.prototype.encodeInterest = function(interest) 
{
  var encoder = new BinaryXMLEncoder();
  BinaryXmlWireFormat.encodeInterest(interest, encoder);  
  return new Blob(encoder.getReducedOstream(), false);  
};

/**
 * Decode input as a Binary XML interest and set the fields of the interest object. 
 * @param {Interest} interest The Interest object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 */
BinaryXmlWireFormat.prototype.decodeInterest = function(interest, input) 
{
  var decoder = new BinaryXMLDecoder(input);
  BinaryXmlWireFormat.decodeInterest(interest, decoder);
};

/**
 * Encode data as Binary XML and return the encoding and signed offsets.
 * @param {Data} data The Data object to encode.
 * @returns {object with (Blob, int, int)} An associative array with fields
 * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding 
 * is a Blob containing the encoding, signedPortionBeginOffset is the offset in 
 * the encoding of the beginning of the signed portion, and 
 * signedPortionEndOffset is the offset in the encoding of the end of the 
 * signed portion.
 */
BinaryXmlWireFormat.prototype.encodeData = function(data) 
{
  var encoder = new BinaryXMLEncoder(1500);
  var result = BinaryXmlWireFormat.encodeData(data, encoder);
  result.encoding = new Blob(encoder.getReducedOstream(), false);
  return result;
};

/**
 * @deprecated Use encodeData(data).
 */
BinaryXmlWireFormat.prototype.encodeContentObject = function(data)
{
  return this.encodeData(data);
};

/**
 * Decode input as a Binary XML data packet, set the fields in the data object, and return 
 * the signed offsets. 
 * @param {Data} data The Data object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 */
BinaryXmlWireFormat.prototype.decodeData = function(data, input) 
{
  var decoder = new BinaryXMLDecoder(input);
  return BinaryXmlWireFormat.decodeData(data, decoder);
};

/**
 * @deprecated Use decodeData(data, input).
 */
BinaryXmlWireFormat.prototype.decodeContentObject = function(data, input) 
{
  this.decodeData(data, input);
};

/**
 * Get a singleton instance of a BinaryXmlWireFormat.  Assuming that the default 
 * wire format was set with 
 * WireFormat.setDefaultWireFormat(BinaryXmlWireFormat.get()), you can check if 
 * this is the default wire encoding with
 * if WireFormat.getDefaultWireFormat() == BinaryXmlWireFormat.get().
 * @returns {BinaryXmlWireFormat} The singleton instance.
 */
BinaryXmlWireFormat.get = function()
{
  if (BinaryXmlWireFormat.instance === null)
    BinaryXmlWireFormat.instance = new BinaryXmlWireFormat();
  return BinaryXmlWireFormat.instance;
};

/**
 * Encode the interest by calling the operations on the encoder.
 * @param {Interest} interest
 * @param {BinaryXMLEncoder} encoder
 */
BinaryXmlWireFormat.encodeInterest = function(interest, encoder) 
{
  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);
    
  interest.name.to_ndnb(encoder);
  
  if (null != interest.minSuffixComponents) 
    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);  

  if (null != interest.maxSuffixComponents) 
    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);

  if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && 
      interest.getKeyLocator().getKeyData() != null &&
      interest.getKeyLocator().getKeyData().length > 0)
    // There is a KEY_LOCATOR_DIGEST. Use this instead of the publisherPublicKeyDigest.
    encoder.writeDTagElement
      (NDNProtocolDTags.PublisherPublicKeyDigest, 
       interest.getKeyLocator().getKeyData());
  else {
    if (null != interest.publisherPublicKeyDigest)
      interest.publisherPublicKeyDigest.to_ndnb(encoder);
  }
    
  if (null != interest.exclude)
    interest.exclude.to_ndnb(encoder);
    
  if (null != interest.childSelector) 
    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);

  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null) 
    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);
    
  if (null != interest.scope) 
    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);
    
  if (null != interest.interestLifetime) 
    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime, 
                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));
    
  if (null != interest.nonce)
    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);
    
  encoder.writeElementClose();
};

/**
 * Use the decoder to place the result in interest.
 * @param {Interest} interest
 * @param {BinaryXMLDecoder} decoder
 */
BinaryXmlWireFormat.decodeInterest = function(interest, decoder) 
{
  decoder.readElementStartDTag(NDNProtocolDTags.Interest);

  interest.name = new Name();
  interest.name.from_ndnb(decoder);

  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))
    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);
  else
    interest.minSuffixComponents = null;

  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents)) 
    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);
  else
    interest.maxSuffixComponents = null;
      
  // Initially clear the keyLocator.
  interest.getKeyLocator().clear();
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();
    interest.publisherPublicKeyDigest.from_ndnb(decoder);
  }
  else
    interest.publisherPublicKeyDigest = null;
  if (interest.publisherPublicKeyDigest != null &&
      interest.publisherPublicKeyDigest.publisherPublicKeyDigest != null &&
      interest.publisherPublicKeyDigest.publisherPublicKeyDigest.length > 0) {
    // We keep the deprecated publisherPublicKeyDigest for backwards 
    //   compatibility.  Also set the key locator.
    interest.getKeyLocator().setType(KeyLocatorType.KEY_LOCATOR_DIGEST);
    interest.getKeyLocator().setKeyData
      (interest.publisherPublicKeyDigest.publisherPublicKeyDigest);
  }

  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {
    interest.exclude = new Exclude();
    interest.exclude.from_ndnb(decoder);
  }
  else
    interest.exclude = null;
    
  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))
    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);
  else
    interest.childSelector = null;
    
  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))
    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);
  else
    interest.answerOriginKind = null;
    
  if (decoder.peekDTag(NDNProtocolDTags.Scope))
    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);
  else
    interest.scope = null;

  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))
    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt
               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;
  else
    interest.interestLifetime = null;              
    
  if (decoder.peekDTag(NDNProtocolDTags.Nonce))
    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);
  else
    interest.nonce = null;
    
  decoder.readElementClose();
};

/**
 * Encode the data by calling the operations on the encoder.
 * @param {Data} data
 * @param {BinaryXMLEncoder} encoder
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 */
BinaryXmlWireFormat.encodeData = function(data, encoder)  
{
  //TODO verify name, MetaInfo and Signature is present
  encoder.writeElementStartDTag(data.getElementLabel());

  if (null != data.signature) 
    data.signature.to_ndnb(encoder);
    
  var signedPortionBeginOffset = encoder.offset;

  if (null != data.name) 
    data.name.to_ndnb(encoder);
  
  if (null != data.signedInfo) 
    // Use getSignatureOrMetaInfoKeyLocator for the transition of moving
    //   the key locator from the MetaInfo to the Signauture object.
    data.signedInfo.to_ndnb(encoder, data.getSignatureOrMetaInfoKeyLocator());

  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);
  
  var signedPortionEndOffset = encoder.offset;
  
  encoder.writeElementClose();
  
  return { signedPortionBeginOffset: signedPortionBeginOffset, 
           signedPortionEndOffset: signedPortionEndOffset };  
};

/**
 * Use the decoder to place the result in data.
 * @param {Data} data
 * @param {BinaryXMLDecoder} decoder
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 */
BinaryXmlWireFormat.decodeData = function(data, decoder) 
{
  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT
  decoder.readElementStartDTag(data.getElementLabel());

  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {
    data.signature = new Signature();
    data.signature.from_ndnb(decoder);
  }
  else
    data.signature = null;
    
  var signedPortionBeginOffset = decoder.offset;

  data.name = new Name();
  data.name.from_ndnb(decoder);
    
  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {
    data.signedInfo = new MetaInfo();
    data.signedInfo.from_ndnb(decoder);
    if (data.signedInfo.locator != null && data.getSignature() != null)
      // Copy the key locator pointer to the Signature object for the transition 
      //   of moving the key locator from the MetaInfo to the Signature object.
      data.getSignature().keyLocator = data.signedInfo.locator;
  }
  else
    data.signedInfo = null;

  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);
    
  var signedPortionEndOffset = decoder.offset;
    
  decoder.readElementClose();
    
  return { signedPortionBeginOffset: signedPortionBeginOffset, 
           signedPortionEndOffset: signedPortionEndOffset };  
};

},{"../exclude.js":32,"../key-locator.js":38,"../meta-info.js":41,"../name.js":42,"../publisher-public-key-digest.js":44,"../signature.js":46,"../util/blob.js":48,"../util/ndn-protoco-id-tags.js":51,"./binary-xml-decoder.js":17,"./binary-xml-encoder.js":18,"./data-utils.js":21,"./wire-format.js":31}],21:[function(require,module,exports){
/**
 * This class contains utilities to help parse the data
 *
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer
console.log(customBuf)
 
/**
 * A DataUtils has static methods for converting data.
 * @constructor
 */


var DataUtils = function()
{
};

exports.DataUtils = new DataUtils();

/*
 * NOTE THIS IS CURRENTLY NOT BEING USED
 * 
 */

DataUtils.prototype.keyStr = "ABCDEFGHIJKLMNOP" +
                   "QRSTUVWXYZabcdef" +
                   "ghijklmnopqrstuv" +
                   "wxyz0123456789+/" +
                   "=";
               
/**
 * Raw String to Base 64
 */
DataUtils.prototype.stringtoBase64 = function stringtoBase64(input) 
{
   //input = escape(input);
   var output = "";
   var chr1, chr2, chr3 = "";
   var enc1, enc2, enc3, enc4 = "";
   var i = 0;

   do {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);

    enc1 = chr1 >> 2;
    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
    enc4 = chr3 & 63;

    if (isNaN(chr2))
       enc3 = enc4 = 64;
    else if (isNaN(chr3))
       enc4 = 64;

    output = output +
       DataUtils.keyStr.charAt(enc1) +
       DataUtils.keyStr.charAt(enc2) +
       DataUtils.keyStr.charAt(enc3) +
       DataUtils.keyStr.charAt(enc4);
    chr1 = chr2 = chr3 = "";
    enc1 = enc2 = enc3 = enc4 = "";
   } while (i < input.length);

   return output;
};

/**
 * Base 64 to Raw String 
 */
DataUtils.prototype.base64toString = function base64toString(input) 
{
  var output = "";
  var chr1, chr2, chr3 = "";
  var enc1, enc2, enc3, enc4 = "";
  var i = 0;

  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  var base64test = /[^A-Za-z0-9\+\/\=]/g;
  /* Test for invalid characters. */
  if (base64test.exec(input)) {
    alert("There were invalid base64 characters in the input text.\n" +
          "Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\n" +
          "Expect errors in decoding.");
  }
  
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

  do {
    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));
    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));
    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));
    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 != 64)
      output = output + String.fromCharCode(chr2);

    if (enc4 != 64)
      output = output + String.fromCharCode(chr3);

    chr1 = chr2 = chr3 = "";
    enc1 = enc2 = enc3 = enc4 = "";
  } while (i < input.length);

  return output;
};

/**
 * customBuf to Hex String
 */
DataUtils.prototype.toHex = function(buffer) 
{
  return buffer.toString('hex');
};

/**
 * Raw string to hex string.
 */
DataUtils.prototype.stringToHex = function(args) 
{
  var ret = "";
  for (var i = 0; i < args.length; ++i) {
    var value = args.charCodeAt(i);
    ret += (value < 16 ? "0" : "") + value.toString(16);
  }
  return ret;
};

/**
 * customBuf to raw string.
 */
DataUtils.prototype.toString = function(buffer) 
{
  return buffer.toString();
};

/**
 * Hex String to customBuf.
 */
DataUtils.prototype.toNumbers = function(str) 
{
  return new customBuf(str, 'hex');
};

/**
 * Hex String to raw string.
 */
DataUtils.prototype.hexToRawString = function(str) 
{
  if (typeof str =='string') {
  var ret = "";
  str.replace(/(..)/g, function(s) {
    ret += String.fromCharCode(parseInt(s, 16));
  });
  return ret;
  }
};

/**
 * Raw String to customBuf.
 */
DataUtils.prototype.toNumbersFromString = function(str) 
{
  return new customBuf(str, 'binary');
};

/**
 * Encode str as utf8 and return as customBuf.
 */
DataUtils.prototype.stringToUtf8Array = function(str) 
{
  return new customBuf(str, 'utf8');
};

/**
 * arrays is an array of customBuf. Return a new customBuf which is the concatenation of all.
 */
DataUtils.prototype.concatArrays = function(arrays) 
{
  return customBuf.concat(arrays);
};
 
// TODO: Take customBuf and use TextDecoder when available.
DataUtils.prototype.decodeUtf8 = function(utftext) 
{
  var string = "";
  var i = 0;
  var c = 0;
    var c1 = 0;
    var c2 = 0;
 
  while (i < utftext.length) {
    c = utftext.charCodeAt(i);
 
    if (c < 128) {
      string += String.fromCharCode(c);
      i++;
    }
    else if (c > 191 && c < 224) {
      c2 = utftext.charCodeAt(i + 1);
      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
      i += 2;
    }
    else {
      c2 = utftext.charCodeAt(i+1);
      var c3 = utftext.charCodeAt(i+2);
      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      i += 3;
    }
  }
 
  return string;
};

/**
 * Return true if a1 and a2 are the same length with equal elements.
 */
DataUtils.prototype.arraysEqual = function(a1, a2) 
{
  // A simple sanity check that it is an array.
  if (!a1.slice)
    throw new Error("DataUtils.arraysEqual: a1 is not an array");
  if (!a2.slice)
    throw new Error("DataUtils.arraysEqual: a2 is not an array");
    
  if (a1.length != a2.length)
    return false;
  
  for (var i = 0; i < a1.length; ++i) {
    if (a1[i] != a2[i])
      return false;
  }

  return true;
};

/**
 * Convert the big endian customBuf to an unsigned int.
 * Don't check for overflow.
 */
DataUtils.prototype.bigEndianToUnsignedInt = function(bytes) 
{
  var result = 0;
  for (var i = 0; i < bytes.length; ++i) {
    result <<= 8;
    result += bytes[i];
  }
  return result;
};

/**
 * Convert the int value to a new big endian customBuf and return.
 * If value is 0 or negative, return new customBuf(0). 
 */
DataUtils.prototype.nonNegativeIntToBigEndian = function(value) 
{
  value = Math.round(value);
  if (value <= 0)
    return new customBuf(0);
  
  // Assume value is not over 64 bits.
  var size = 8;
  var result = new customBuf(size);
  var i = 0;
  while (value != 0) {
    ++i;
    result[size - i] = value & 0xff;
    value >>= 8;
  }
  return result.slice(size - i, size);
};

/**
 * Modify array to randomly shuffle the elements.
 */
DataUtils.prototype.shuffle = function(array) 
{
  for (var i = array.length - 1; i >= 1; --i) {
    // j is from 0 to i.
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
};

},{"../buffer.js":14}],22:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * Create a new DecodingException wrapping the given error object.
 * Call with: throw new DecodingException(new Error("message")).
 * @constructor
 * @param {string} error The exception created with new Error.
 */
function DecodingException(error) 
{
  this.message = error.message;
  // Copy lineNumber, etc. from where new Error was called.
  for (var prop in error)
      this[prop] = error[prop];
}
DecodingException.prototype = new Error();
DecodingException.prototype.name = "DecodingException";

exports.DecodingException = DecodingException;

},{}],23:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var customBuf = require('../buffer.js').Buffer
var DataUtils = require('./data-utils.js').DataUtils;
var BinaryXMLStructureDecoder = require('./binary-xml-structure-decoder.js').BinaryXMLStructureDecoder;
var Tlv = require('./tlv/tlv.js').Tlv;
var TlvStructureDecoder = require('./tlv/tlv-structure-decoder.js').TlvStructureDecoder;
var LOG = require('../log.js').Log.LOG;

/**
 * A ElementReader lets you call onReceivedData multiple times which uses a
 * BinaryXMLStructureDecoder or TlvStructureDecoder to detect the end of a 
 * binary XML or TLV element and calls elementListener.onReceivedElement(element) 
 * with the element.  This handles the case where a single call to 
 * onReceivedData may contain multiple elements.
 * @constructor
 * @param {{onReceivedElement:function}} elementListener
 */
var ElementReader = function ElementReader(elementListener) 
{
  this.elementListener = elementListener;
  this.dataParts = [];
  this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();
  this.tlvStructureDecoder = new TlvStructureDecoder();
  this.useTlv = null;
};

exports.ElementReader = ElementReader;

ElementReader.prototype.onReceivedData = function(/* customBuf */ data) 
{
  // Process multiple objects in the data.
  while (true) {
    if (this.dataParts.length == 0) {
      // This is the beginning of an element.  Check whether it is binaryXML or TLV.
      if (data.length <= 0)
        // Wait for more data.
        return;
      
      // The type codes for TLV Interest and Data packets are chosen to not
      //   conflict with the first byte of a binary XML packet, so we can
      //   just look at the first byte.
      if (data[0] == Tlv.Interest || data[0] == Tlv.Data || data[0] == 0x80)
        this.useTlv = true;
      else
        // Binary XML.
        this.useTlv = false;
    }

    var gotElementEnd;
    var offset;
    if (this.useTlv) {
      // Scan the input to check if a whole TLV object has been read.
      this.tlvStructureDecoder.seek(0);
      gotElementEnd = this.tlvStructureDecoder.findElementEnd(data);
      offset = this.tlvStructureDecoder.getOffset();
    }
    else {
      // Scan the input to check if a whole Binary XML object has been read.
      this.binaryXmlStructureDecoder.seek(0);
      gotElementEnd = this.binaryXmlStructureDecoder.findElementEnd(data);
      offset = this.binaryXmlStructureDecoder.offset;
    }
    
    if (gotElementEnd) {
      // Got the remainder of an object.  Report to the caller.
      this.dataParts.push(data.slice(0, offset));
      var element = DataUtils.concatArrays(this.dataParts);
      this.dataParts = [];
      try {
        this.elementListener.onReceivedElement(element);
      } catch (ex) {
          console.log("ElementReader: ignoring exception from onReceivedElement: " , ex);
      }
  
      // Need to read a new object.
      data = data.slice(offset, data.length);
      this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();
      this.tlvStructureDecoder = new TlvStructureDecoder();
      if (data.length == 0)
        // No more data in the packet.
        return;
      
      // else loop back to decode.
    }
    else {
      // Save for a later call to concatArrays so that we only copy data once.
      this.dataParts.push(data);
      if (LOG > 3) console.log('Incomplete packet received. Length ' + data.length + '. Wait for more input.');
        return;
    }
  }    
};

},{"../buffer.js":14,"../log.js":40,"./binary-xml-structure-decoder.js":19,"./data-utils.js":21,"./tlv/tlv-structure-decoder.js":29,"./tlv/tlv.js":30}],24:[function(require,module,exports){
/**
 * This file contains utilities to help encode and decode NDN objects.
 * Copyright (C) 2013-2014 Regents of the University of California.
 * author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */

var DataUtils = require('./data-utils.js').DataUtils;
var BinaryXMLEncoder = require('./binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./binary-xml-decoder.js').BinaryXMLDecoder;
var Key = require('../key.js').Key;
var KeyLocatorType = require('../key-locator.js').KeyLocatorType;
var Interest = require('../interest.js').Interest;
var Data = require('../data.js').Data;
var FaceInstance = require('../face-instance.js').FaceInstance;
var ForwardingEntry = require('../forwarding-entry.js').ForwardingEntry;
var WireFormat = require('./wire-format.js').WireFormat;
var LOG = require('../log.js').Log.LOG;

/**
 * An EncodingUtils has static methods for encoding data.
 * @constructor
 */
var EncodingUtils = function EncodingUtils() 
{
};

exports.EncodingUtils = EncodingUtils;

EncodingUtils.encodeToHexInterest = function(interest, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  return DataUtils.toHex(interest.wireEncode(wireFormat).buf());
};

EncodingUtils.encodeToHexData = function(data, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  return DataUtils.toHex(data.wireEncode(wireFormat).buf());
};

/**
 * @deprecated Use EncodingUtils.encodeToHexData(data).
 */
EncodingUtils.encodeToHexContentObject = function(data, wireFormat) 
{
  return EncodingUtils.encodeToHexData(data, wireFormat);
}

EncodingUtils.encodeForwardingEntry = function(data) 
{
  var enc = new BinaryXMLEncoder();
  data.to_ndnb(enc);
  var bytes = enc.getReducedOstream();

  return bytes;
};

EncodingUtils.decodeHexFaceInstance = function(result) 
{  
  var numbers = DataUtils.toNumbers(result); 
  var decoder = new BinaryXMLDecoder(numbers);
  
  if (LOG > 3) console.log('DECODING HEX FACE INSTANCE  \n'+numbers);

  var faceInstance = new FaceInstance();
  faceInstance.from_ndnb(decoder);
  
  return faceInstance;
};

EncodingUtils.decodeHexInterest = function(input, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  var interest = new Interest();
  interest.wireDecode(DataUtils.toNumbers(input), wireFormat);
  return interest;
};

EncodingUtils.decodeHexData = function(input, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  var data = new Data();
  data.wireDecode(DataUtils.toNumbers(input), wireFormat);
  return data;
};

/**
 * @deprecated Use EncodingUtils.decodeHexData(input).
 */
EncodingUtils.decodeHexContentObject = function(input, wireFormat) 
{
  return EncodingUtils.decodeHexData(input, wireFormat);
}

EncodingUtils.decodeHexForwardingEntry = function(result) 
{
  var numbers = DataUtils.toNumbers(result);
  var decoder = new BinaryXMLDecoder(numbers);
  
  if (LOG > 3) console.log('DECODED HEX FORWARDING ENTRY \n'+numbers);
  
  var forwardingEntry = new ForwardingEntry();
  forwardingEntry.from_ndnb(decoder);
  return forwardingEntry;
};

/**
 * Decode the customBuf array which holds SubjectPublicKeyInfo and return an RSAKey.
 */
EncodingUtils.decodeSubjectPublicKeyInfo = function(array) 
{
  var hex = DataUtils.toHex(array).toLowerCase();
  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));
  var rsaKey = new RSAKey();
  rsaKey.setPublic(a[0], a[1]);
  return rsaKey;
}

/**
 * Return a user friendly HTML string with the contents of data.
 * This also outputs to console.log.
 */
EncodingUtils.dataToHtml = function(/* Data */ data) 
{
  var output ="";
      
  if (data == -1)
    output+= "NO CONTENT FOUND"
  else if (data == -2)
    output+= "CONTENT NAME IS EMPTY"
  else {
    if (data.name != null && data.name.components != null) {
      output+= "NAME: " + data.name.toUri();
        
      output+= "<br />";
      output+= "<br />";
    }
    if (data.content != null) {
      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.content != null) {
      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signature != null && data.signature.digestAlgorithm != null) {
      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signature != null && data.signature.witness != null) {
      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signature != null && data.signature.signature != null) {
      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {
      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.timestamp != null) {
      var d = new Date();
      d.setTime(data.signedInfo.timestamp.msec);
      
      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];
      
      output += "TimeStamp: "+d;
      output+= "<br />";
      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;
      
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {
      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {
      output += "keyLocator: ";
      if (data.signedInfo.locator.type == KeyLocatorType.KEY)
        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";
      else if (data.signedInfo.locator.type == KeyLocatorType.KEY_LOCATOR_DIGEST)
        output += "KeyLocatorDigest: " + DataUtils.toHex(data.signedInfo.locator.getKeyData()).toLowerCase() + "<br />";
      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)
        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";
      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)
        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";
      else
        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";      
    }
  }

  return output;
};

/**
 * @deprecated Use return EncodingUtils.dataToHtml(data).
 */
EncodingUtils.contentObjectToHtml = function(data) 
{
  return EncodingUtils.dataToHtml(data);
}

//
// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.
//

var encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }
var encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }
var encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }
var decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }
var decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }
var decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }
var decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }
var decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }
var contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }

/**
 * @deprecated Use interest.wireEncode().
 */
function encodeToBinaryInterest(interest) { return interest.wireEncode().buf(); }
/**
 * @deprecated Use data.wireEncode().
 */
function encodeToBinaryContentObject(data) { return data.wireEncode().buf(); }

},{"../data.js":16,"../face-instance.js":33,"../forwarding-entry.js":35,"../interest.js":37,"../key-locator.js":38,"../key.js":39,"../log.js":40,"./binary-xml-decoder.js":17,"./binary-xml-encoder.js":18,"./data-utils.js":21,"./wire-format.js":31}],25:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var crypto = require('../crypto.js');
var Blob = require('../util/blob.js').Blob;
var Tlv = require('./tlv/tlv.js').Tlv;
var TlvEncoder = require('./tlv/tlv-encoder.js').TlvEncoder;
var TlvDecoder = require('./tlv/tlv-decoder.js').TlvDecoder;
var WireFormat = require('./wire-format.js').WireFormat;
var Exclude = require('../exclude.js').Exclude;
var ContentType = require('../meta-info.js').ContentType;
var KeyLocatorType = require('../key-locator.js').KeyLocatorType;
var Signature = require('../signature.js').Signature;
var DecodingException = require('./decoding-exception.js').DecodingException;

/**
 * A Tlv0_1a2WireFormat implements the WireFormat interface for encoding and 
 * decoding with the NDN-TLV wire format, version 0.1a2
 * @constructor
 */
var Tlv0_1a2WireFormat = function Tlv0_1a2WireFormat() 
{
  // Inherit from WireFormat.
  WireFormat.call(this);
};

Tlv0_1a2WireFormat.prototype = new WireFormat();
Tlv0_1a2WireFormat.prototype.name = "Tlv0_1a2WireFormat";

exports.Tlv0_1a2WireFormat = Tlv0_1a2WireFormat;

// Default object.
Tlv0_1a2WireFormat.instance = null;

/**
 * Encode the interest using NDN-TLV and return a customBuf.
 * @param {Interest} interest The Interest object to encode.
 * @returns {Blob} A Blob containing the encoding.
 */
Tlv0_1a2WireFormat.prototype.encodeInterest = function(interest) 
{
  var encoder = new TlvEncoder();
  var saveLength = encoder.getLength();
  
  // Encode backwards.
  encoder.writeOptionalNonNegativeIntegerTlv
    (Tlv.InterestLifetime, interest.getInterestLifetimeMilliseconds());
  encoder.writeOptionalNonNegativeIntegerTlv(Tlv.Scope, interest.getScope());
  
  // Encode the Nonce as 4 bytes.
  if (interest.getNonce() == null || interest.getNonce().length == 0)
    // This is the most common case. Generate a nonce.
    encoder.writeBlobTlv(Tlv.Nonce, require("../crypto.js").randomBytes(4));
  else if (interest.getNonce().length < 4) {
    var nonce = customBuf(4);
    // Copy existing nonce bytes.
    interest.getNonce().copy(nonce);

    // Generate random bytes for remaining bytes in the nonce.
    for (var i = interest.getNonce().length; i < 4; ++i)
      nonce[i] = require("crypto").randomBytes(1)[0];

    encoder.writeBlobTlv(Tlv.Nonce, nonce);
  }
  else if (interest.getNonce().length == 4)
    // Use the nonce as-is.
    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce());
  else
    // Truncate.
    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce().slice(0, 4));
  
  Tlv0_1a2WireFormat.encodeSelectors(interest, encoder);
  Tlv0_1a2WireFormat.encodeName(interest.getName(), encoder);
  
  encoder.writeTypeAndLength(Tlv.Interest, encoder.getLength() - saveLength);
      
  return new Blob(encoder.getOutput(), false);
};

/**
 * Decode input as an NDN-TLV interest and set the fields of the interest 
 * object.  
 * @param {Interest} interest The Interest object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 */
Tlv0_1a2WireFormat.prototype.decodeInterest = function(interest, input) 
{
  var decoder = new TlvDecoder(input);

  var endOffset = decoder.readNestedTlvsStart(Tlv.Interest);
  Tlv0_1a2WireFormat.decodeName(interest.getName(), decoder);
  if (decoder.peekType(Tlv.Selectors, endOffset))
    Tlv0_1a2WireFormat.decodeSelectors(interest, decoder);
  // Require a Nonce, but don't force it to be 4 bytes.
  var nonce = decoder.readBlobTlv(Tlv.Nonce);
  interest.setScope(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.Scope, endOffset));
  interest.setInterestLifetimeMilliseconds
    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.InterestLifetime, endOffset));

  // Set the nonce last because setting other interest fields clears it.
  interest.setNonce(nonce);

  decoder.finishNestedTlvs(endOffset);
};

/**
 * Encode data as NDN-TLV and return the encoding and signed offsets.
 * @param {Data} data The Data object to encode.
 * @returns {object with (Blob, int, int)} An associative array with fields
 * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding 
 * is a Blob containing the encoding, signedPortionBeginOffset is the offset in 
 * the encoding of the beginning of the signed portion, and 
 * signedPortionEndOffset is the offset in the encoding of the end of the 
 * signed portion.
 */
Tlv0_1a2WireFormat.prototype.encodeData = function(data) 
{
  var encoder = new TlvEncoder(1500);
  var saveLength = encoder.getLength();
  
  // Encode backwards.
  // TODO: The library needs to handle other signature types than 
  //   SignatureSha256WithRsa.
  encoder.writeBlobTlv(Tlv.SignatureValue, data.getSignature().getSignature());
  var signedPortionEndOffsetFromBack = encoder.getLength();

  // Use getSignatureOrMetaInfoKeyLocator for the transition of moving
  //   the key locator from the MetaInfo to the Signauture object.
  Tlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue
    (data.getSignature(), encoder, data.getSignatureOrMetaInfoKeyLocator());
  encoder.writeBlobTlv(Tlv.Content, data.getContent());
  Tlv0_1a2WireFormat.encodeMetaInfo(data.getMetaInfo(), encoder);
  Tlv0_1a2WireFormat.encodeName(data.getName(), encoder);
  var signedPortionBeginOffsetFromBack = encoder.getLength();

  encoder.writeTypeAndLength(Tlv.Data, encoder.getLength() - saveLength);
  var signedPortionBeginOffset = 
    encoder.getLength() - signedPortionBeginOffsetFromBack;
  var signedPortionEndOffset = encoder.getLength() - signedPortionEndOffsetFromBack;

  return { encoding: new Blob(encoder.getOutput(), false),
           signedPortionBeginOffset: signedPortionBeginOffset, 
           signedPortionEndOffset: signedPortionEndOffset };  
};

/**
 * Decode input as an NDN-TLV data packet, set the fields in the data object, 
 * and return the signed offsets. 
 * @param {Data} data The Data object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 */
Tlv0_1a2WireFormat.prototype.decodeData = function(data, input) 
{
  var decoder = new TlvDecoder(input);

  var endOffset = decoder.readNestedTlvsStart(Tlv.Data);
  var signedPortionBeginOffset = decoder.getOffset();

  Tlv0_1a2WireFormat.decodeName(data.getName(), decoder);
  Tlv0_1a2WireFormat.decodeMetaInfo(data.getMetaInfo(), decoder);
  data.setContent(decoder.readBlobTlv(Tlv.Content));
  Tlv0_1a2WireFormat.decodeSignatureInfo(data, decoder);
  if (data.getSignature() != null && 
      data.getSignature().getKeyLocator() != null && 
      data.getMetaInfo() != null)
    // Copy the key locator pointer to the MetaInfo object for the transition of 
    //   moving the key locator from the MetaInfo to the Signature object.
    data.getMetaInfo().locator = data.getSignature().getKeyLocator();

  var signedPortionEndOffset = decoder.getOffset();
  // TODO: The library needs to handle other signature types than 
  //   SignatureSha256WithRsa.
  data.getSignature().setSignature(decoder.readBlobTlv(Tlv.SignatureValue));

  decoder.finishNestedTlvs(endOffset);
  return { signedPortionBeginOffset: signedPortionBeginOffset, 
           signedPortionEndOffset: signedPortionEndOffset };  
};

/**
 * Get a singleton instance of a Tlv1_0a2WireFormat.  To always use the
 * preferred version NDN-TLV, you should use TlvWireFormat.get().
 * @returns {Tlv0_1a2WireFormat} The singleton instance.
 */
Tlv0_1a2WireFormat.get = function()
{
  if (Tlv0_1a2WireFormat.instance === null)
    Tlv0_1a2WireFormat.instance = new Tlv0_1a2WireFormat();
  return Tlv0_1a2WireFormat.instance;
};

Tlv0_1a2WireFormat.encodeName = function(name, encoder)
{
  var saveLength = encoder.getLength();

  // Encode the components backwards.
  for (var i = name.size() - 1; i >= 0; --i)
    encoder.writeBlobTlv(Tlv.NameComponent, name.get(i).getValue());

  encoder.writeTypeAndLength(Tlv.Name, encoder.getLength() - saveLength);
};
        
Tlv0_1a2WireFormat.decodeName = function(name, decoder)
{
  name.clear();
  
  var endOffset = decoder.readNestedTlvsStart(Tlv.Name);      
  while (decoder.getOffset() < endOffset)
      name.append(decoder.readBlobTlv(Tlv.NameComponent));

  decoder.finishNestedTlvs(endOffset);
};

/**
 * Encode the interest selectors.  If no selectors are written, do not output a 
 * Selectors TLV.
 */
Tlv0_1a2WireFormat.encodeSelectors = function(interest, encoder)
{
  var saveLength = encoder.getLength();

  // Encode backwards.
  if (interest.getMustBeFresh())
    encoder.writeTypeAndLength(Tlv.MustBeFresh, 0);
  encoder.writeOptionalNonNegativeIntegerTlv(
    Tlv.ChildSelector, interest.getChildSelector());
  if (interest.getExclude().size() > 0)
    Tlv0_1a2WireFormat.encodeExclude(interest.getExclude(), encoder);
  
  if (interest.getKeyLocator().getType() != null)
    Tlv0_1a2WireFormat.encodeKeyLocator(interest.getKeyLocator(), encoder);
  else {
    // There is no keyLocator. If there is a publisherPublicKeyDigest, then 
    //   encode as KEY_LOCATOR_DIGEST. (When we remove the deprecated 
    //   publisherPublicKeyDigest, we don't need this.)
    if (null != interest.publisherPublicKeyDigest) {
      var savePublisherPublicKeyDigestLength = encoder.getLength();
      encoder.writeBlobTlv
        (Tlv.KeyLocatorDigest, 
         interest.publisherPublicKeyDigest.publisherPublicKeyDigest);
      encoder.writeTypeAndLength
        (Tlv.KeyLocator, encoder.getLength() - savePublisherPublicKeyDigestLength);
    }
  }
  
  encoder.writeOptionalNonNegativeIntegerTlv(
    Tlv.MaxSuffixComponents, interest.getMaxSuffixComponents());
  encoder.writeOptionalNonNegativeIntegerTlv(
    Tlv.MinSuffixComponents, interest.getMinSuffixComponents());

  // Only output the type and length if values were written.
  if (encoder.getLength() != saveLength)
    encoder.writeTypeAndLength(Tlv.Selectors, encoder.getLength() - saveLength);
};

Tlv0_1a2WireFormat.decodeSelectors = function(interest, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.Selectors);

  interest.setMinSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.MinSuffixComponents, endOffset));
  interest.setMaxSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.MaxSuffixComponents, endOffset));

  // Initially set publisherPublicKeyDigest to none.
  interest.publisherPublicKeyDigest = null;
  if (decoder.peekType(Tlv.KeyLocator, endOffset)) {
    Tlv0_1a2WireFormat.decodeKeyLocator(interest.getKeyLocator(), decoder);
    if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST) {
      // For backwards compatibility, also set the publisherPublicKeyDigest.
      interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();
      interest.publisherPublicKeyDigest.publisherPublicKeyDigest =
        interest.getKeyLocator().getKeyData();
    }
  }
  else
    interest.getKeyLocator().clear();

  if (decoder.peekType(Tlv.Exclude, endOffset))
    Tlv0_1a2WireFormat.decodeExclude(interest.getExclude(), decoder);
  else
    interest.getExclude().clear();

  interest.setChildSelector(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.ChildSelector, endOffset));
  interest.setMustBeFresh(decoder.readBooleanTlv(Tlv.MustBeFresh, endOffset));

  decoder.finishNestedTlvs(endOffset);
};
  
Tlv0_1a2WireFormat.encodeExclude = function(exclude, encoder)
{
  var saveLength = encoder.getLength();

  // TODO: Do we want to order the components (except for ANY)?
  // Encode the entries backwards.
  for (var i = exclude.size() - 1; i >= 0; --i) {
    var entry = exclude.get(i);

    if (entry == Exclude.ANY)
      encoder.writeTypeAndLength(Tlv.Any, 0);
    else
      encoder.writeBlobTlv(Tlv.NameComponent, entry.getValue());
  }
  
  encoder.writeTypeAndLength(Tlv.Exclude, encoder.getLength() - saveLength);
};
  
Tlv0_1a2WireFormat.decodeExclude = function(exclude, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.Exclude);

  exclude.clear();
  while (true) {
    if (decoder.peekType(Tlv.NameComponent, endOffset))
      exclude.appendComponent(decoder.readBlobTlv(Tlv.NameComponent));
    else if (decoder.readBooleanTlv(Tlv.Any, endOffset))
      exclude.appendAny();
    else
      // Else no more entries.
      break;
  }
  
  decoder.finishNestedTlvs(endOffset);
};

Tlv0_1a2WireFormat.encodeKeyLocator = function(keyLocator, encoder)
{
  var saveLength = encoder.getLength();

  // Encode backwards.
  if (keyLocator.getType() != null) {
    if (keyLocator.getType() == KeyLocatorType.KEYNAME)
      Tlv0_1a2WireFormat.encodeName(keyLocator.getKeyName(), encoder);
    else if (keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST &&
             keyLocator.getKeyData().length > 0)
      encoder.writeBlobTlv(Tlv.KeyLocatorDigest, keyLocator.getKeyData());
    else
      throw new Error("Unrecognized KeyLocatorType " + keyLocator.getType());
  }
  
  encoder.writeTypeAndLength(Tlv.KeyLocator, encoder.getLength() - saveLength);
};

Tlv0_1a2WireFormat.decodeKeyLocator = function(keyLocator, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.KeyLocator);

  keyLocator.clear();

  if (decoder.getOffset() == endOffset)
    // The KeyLocator is omitted, so leave the fields as none.
    return;

  if (decoder.peekType(Tlv.Name, endOffset)) {
    // KeyLocator is a Name.
    keyLocator.setType(KeyLocatorType.KEYNAME);
    Tlv0_1a2WireFormat.decodeName(keyLocator.getKeyName(), decoder);
  }
  else if (decoder.peekType(Tlv.KeyLocatorDigest, endOffset)) {
    // KeyLocator is a KeyLocatorDigest.
    keyLocator.setType(KeyLocatorType.KEY_LOCATOR_DIGEST);
    keyLocator.setKeyData(decoder.readBlobTlv(Tlv.KeyLocatorDigest));
  }
  else
    throw new DecodingException
      ("decodeKeyLocator: Unrecognized key locator type");

  decoder.finishNestedTlvs(endOffset);
};

/**
 * Encode the signature object in TLV, using the given keyLocator instead of the
 * locator in this object.
 * @param {Signature} signature The Signature object to encode.
 * @param {TlvEncoder} encoder The encoder.
 * @param {KeyLocator} keyLocator The key locator to use (from 
 * Data.getSignatureOrMetaInfoKeyLocator).
 */
Tlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue = function
  (signature, encoder, keyLocator)
{
  var saveLength = encoder.getLength();

  // Encode backwards.
  Tlv0_1a2WireFormat.encodeKeyLocator(keyLocator, encoder);
  encoder.writeNonNegativeIntegerTlv
    (Tlv.SignatureType, Tlv.SignatureType_SignatureSha256WithRsa);

  encoder.writeTypeAndLength(Tlv.SignatureInfo, encoder.getLength() - saveLength);
};

Tlv0_1a2WireFormat.decodeSignatureInfo = function(data, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.SignatureInfo);

  var signatureType = decoder.readNonNegativeIntegerTlv(Tlv.SignatureType);
  // TODO: The library needs to handle other signature types than 
  //     SignatureSha256WithRsa.
  if (signatureType == Tlv.SignatureType_SignatureSha256WithRsa) {
      var signature = {}
      signature.sig = Signature
      data.setSignature(signature.sig());
      // Modify data's signature object because if we create an object
      //   and set it, then data will have to copy all the fields.
      var signatureInfo = data.getSignature();
      Tlv0_1a2WireFormat.decodeKeyLocator
        (signatureInfo.getKeyLocator(), decoder);
  }
  else
      throw new DecodingException
       ("decodeSignatureInfo: unrecognized SignatureInfo type" + signatureType);

  decoder.finishNestedTlvs(endOffset);
};

Tlv0_1a2WireFormat.encodeMetaInfo = function(metaInfo, encoder)
{
  var saveLength = encoder.getLength();

  // Encode backwards.
  // TODO: finalBlockID should be a Name.Component, not customBuf.
  var finalBlockIdBuf = metaInfo.getFinalBlockID();
  if (finalBlockIdBuf != null && finalBlockIdBuf.length > 0) {
    // FinalBlockId has an inner NameComponent.
    var finalBlockIdSaveLength = encoder.getLength();
    encoder.writeBlobTlv(Tlv.NameComponent, finalBlockIdBuf);
    encoder.writeTypeAndLength
      (Tlv.FinalBlockId, encoder.getLength() - finalBlockIdSaveLength);
  }

  encoder.writeOptionalNonNegativeIntegerTlv
    (Tlv.FreshnessPeriod, metaInfo.getFreshnessPeriod());
  if (metaInfo.getType() != ContentType.BLOB) {
    // Not the default, so we need to encode the type.
    if (metaInfo.getType() == ContentType.LINK ||
        metaInfo.getType() == ContentType.KEY)
      // The ContentType enum is set up with the correct integer for 
      // each NDN-TLV ContentType.
      encoder.writeNonNegativeIntegerTlv(Tlv.ContentType, metaInfo.getType());
    else
      throw new Error("unrecognized TLV ContentType");
  }

  encoder.writeTypeAndLength(Tlv.MetaInfo, encoder.getLength() - saveLength);
};

Tlv0_1a2WireFormat.decodeMetaInfo = function(metaInfo, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.MetaInfo);  

  // The ContentType enum is set up with the correct integer for each 
  // NDN-TLV ContentType.  If readOptionalNonNegativeIntegerTlv returns
  // None, then setType will convert it to BLOB.
  metaInfo.setType(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.ContentType, endOffset));
  metaInfo.setFreshnessPeriod
    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.FreshnessPeriod, endOffset));
  if (decoder.peekType(Tlv.FinalBlockId, endOffset)) {
    var finalBlockIdEndOffset = decoder.readNestedTlvsStart(Tlv.FinalBlockId);
    metaInfo.setFinalBlockID(decoder.readBlobTlv(Tlv.NameComponent));
    decoder.finishNestedTlvs(finalBlockIdEndOffset);
  }
  else
    metaInfo.setFinalBlockID(null);

  decoder.finishNestedTlvs(endOffset);
};

},{"../crypto.js":14,"../exclude.js":32,"../key-locator.js":38,"../meta-info.js":41,"../signature.js":46,"../util/blob.js":48,"./decoding-exception.js":22,"./tlv/tlv-decoder.js":27,"./tlv/tlv-encoder.js":28,"./tlv/tlv.js":30,"./wire-format.js":31,"crypto":113}],26:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var WireFormat = require('./wire-format.js').WireFormat;
var Tlv0_1a2WireFormat = require('./tlv-0_1a2-wire-format.js').Tlv0_1a2WireFormat;

/**
 * A TlvWireFormat extends Tlv0_1a2WireFormat to override its methods to 
 * implement encoding and decoding using the preferred implementation of NDN-TLV.
 * @constructor
 */
var TlvWireFormat = function TlvWireFormat() 
{
  // Inherit from Tlv0_1a2WireFormat.
  Tlv0_1a2WireFormat.call(this);
};

TlvWireFormat.prototype = new Tlv0_1a2WireFormat();
TlvWireFormat.prototype.name = "TlvWireFormat";

exports.TlvWireFormat = TlvWireFormat;

// Default object.
TlvWireFormat.instance = null;

/**
 * Get a singleton instance of a TlvWireFormat.  Assuming that the default 
 * wire format was set with WireFormat.setDefaultWireFormat(TlvWireFormat.get()), 
 * you can check if this is the default wire encoding with
 * if WireFormat.getDefaultWireFormat() == TlvWireFormat.get().
 * @returns {TlvWireFormat} The singleton instance.
 */
TlvWireFormat.get = function()
{
  if (TlvWireFormat.instance === null)
    TlvWireFormat.instance = new TlvWireFormat();
  return TlvWireFormat.instance;
};

// On loading this module, make this the default wire format.
// This module will be loaded because WireFormat loads it.
WireFormat.setDefaultWireFormat(TlvWireFormat.get());

},{"./tlv-0_1a2-wire-format.js":25,"./wire-format.js":31}],27:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../../buffer.js').Buffer
var DecodingException = require('../decoding-exception.js').DecodingException;

/**
 * Create a new TlvDecoder for decoding the input in the NDN-TLV wire format.
 * @constructor
 * @param {Buffer} input The buffer with the bytes to decode.
 */
var TlvDecoder = function TlvDecoder(input)
{
  this.input = input;
  this.offset = 0;
};

exports.TlvDecoder = TlvDecoder;

/**
 * Decode VAR-NUMBER in NDN-TLV and return it. Update offset.
 * @returns {number} The decoded VAR-NUMBER.
 */
TlvDecoder.prototype.readVarNumber = function() 
{
  // Assume array values are in the range 0 to 255.
  var firstOctet = this.input[this.offset];
  this.offset += 1;
  if (firstOctet < 253)
    return firstOctet;
  else
    return this.readExtendedVarNumber(firstOctet);
};

/**
 * A private function to do the work of readVarNumber, given the firstOctet
 * which is >= 253.
 * @param {number} firstOctet The first octet which is >= 253, used to decode 
 * the remaining bytes.
 * @returns {number} The decoded VAR-NUMBER.
 */
TlvDecoder.prototype.readExtendedVarNumber = function(firstOctet) 
{
  // This is a private function so we know firstOctet >= 253.
  if (firstOctet == 253) {
    result = ((this.input[this.offset] << 8) +
           this.input[this.offset + 1]);
    this.offset += 2;
  }
  else if (firstOctet == 254) {
    result = ((this.input[this.offset] << 24) +
          (this.input[this.offset + 1] << 16) +
          (this.input[this.offset + 2] << 8) +
           this.input[this.offset + 3]);
    this.offset += 4;
  }
  else {
    result = ((this.input[this.offset] << 56) +
          (this.input[this.offset + 1] << 48) +
          (this.input[this.offset + 2] << 40) +
          (this.input[this.offset + 3] << 32) +
          (this.input[this.offset + 4] << 24) +
          (this.input[this.offset + 5] << 16) +
          (this.input[this.offset + 6] << 8) +
           this.input[this.offset + 7]);
    this.offset += 8;
  }
  
  return result;
};

/**
 * Decode the type and length from this's input starting at offset, expecting 
 * the type to be expectedType and return the length. Update offset.  Also make 
 * sure the decoded length does not exceed the number of bytes remaining in the 
 * input.
 * @param {number} expectedType The expected type.
 * @returns {number} The length of the TLV.
 * @throws DecodingException if (did not get the expected TLV type or the TLV length 
 * exceeds the buffer length.
 */
TlvDecoder.prototype.readTypeAndLength = function(expectedType) 
{
  var type = this.readVarNumber();
  if (type != expectedType)
    throw new DecodingException("Did not get the expected TLV type");

  var length = this.readVarNumber();
  if (this.offset + length > this.input.length)
    throw new DecodingException("TLV length exceeds the buffer length");

  return length;
};

/**
 * Decode the type and length from the input starting at offset, expecting the 
 * type to be expectedType.  Update offset.  Also make sure the decoded length 
 * does not exceed the number of bytes remaining in the input. Return the offset 
 * of the end of this parent TLV, which is used in decoding optional nested 
 * TLVs. After reading all nested TLVs, call finishNestedTlvs.
 * @param {number} expectedType The expected type.
 * @returns {number} The offset of the end of the parent TLV.
 * @throws DecodingException if did not get the expected TLV type or the TLV 
 * length exceeds the buffer length.
 */
TlvDecoder.prototype.readNestedTlvsStart = function(expectedType) 
{
  return this.readTypeAndLength(expectedType) + this.offset;
};

/**
 * Call this after reading all nested TLVs to skip any remaining unrecognized 
 * TLVs and to check if the offset after the final nested TLV matches the 
 * endOffset returned by readNestedTlvsStart.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @throws DecodingException if the TLV length does not equal the total length 
 * of the nested TLVs.
 */
TlvDecoder.prototype.finishNestedTlvs = function(endOffset) 
{
  // We expect offset to be endOffset, so check this first.
  if (this.offset == endOffset)
    return;

  // Skip remaining TLVs.
  while (this.offset < endOffset) {
    // Skip the type VAR-NUMBER.
    this.readVarNumber();
    // Read the length and update offset.
    var length = this.readVarNumber();
    this.offset += length;

    if (this.offset > this.input.length)
      throw new DecodingException("TLV length exceeds the buffer length");
  }
  
  if (this.offset != endOffset)
    throw new DecodingException
      ("TLV length does not equal the total length of the nested TLVs");
};

/**
 * Decode the type from this's input starting at offset, and if it is the 
 * expectedType, then return true, else false.  However, if this's offset is 
 * greater than or equal to endOffset, then return false and don't try to read 
 * the type. Do not update offset.
 * @param {number} expectedType The expected type.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @returns {boolean} true if the type of the next TLV is the expectedType, 
 *  otherwise false.
 */
TlvDecoder.prototype.peekType = function(expectedType, endOffset) 
{
  if (this.offset >= endOffset)
    // No more sub TLVs to look at.
    return false;
  else {
    var saveOffset = this.offset;
    var type = this.readVarNumber();
    // Restore offset.
    this.offset = saveOffset;

    return type == expectedType;
  }
};

/**
 * Decode a non-negative integer in NDN-TLV and return it. Update offset by 
 * length.
 * @param {number} length The number of bytes in the encoded integer.
 * @returns {number} The integer.
 * @throws DecodingException if length is an invalid length for a TLV 
 * non-negative integer.
 */
TlvDecoder.prototype.readNonNegativeInteger = function(length) 
{
  var result;
  if (length == 1)
    result = this.input[this.offset];
  else if (length == 2)
    result = ((this.input[this.offset] << 8) +
           this.input[this.offset + 1]);
  else if (length == 4)
    result = ((this.input[this.offset] << 24) +
          (this.input[this.offset + 1] << 16) +
          (this.input[this.offset + 2] << 8) +
           this.input[this.offset + 3]);
  else if (length == 8)
    result = ((this.input[this.offset] << 56) +
          (this.input[this.offset + 1] << 48) +
          (this.input[this.offset + 2] << 40) +
          (this.input[this.offset + 3] << 32) +
          (this.input[this.offset + 4] << 24) +
          (this.input[this.offset + 5] << 16) +
          (this.input[this.offset + 6] << 8) +
           this.input[this.offset + 7]);
  else
    throw new DecodingException("Invalid length for a TLV nonNegativeInteger");

  this.offset += length;
  return result;
};

/**
 * Decode the type and length from this's input starting at offset, expecting 
 * the type to be expectedType. Then decode a non-negative integer in NDN-TLV 
 * and return it.  Update offset.
 * @param {number} expectedType The expected type.
 * @returns {number} The integer.
 * @throws DecodingException if did not get the expected TLV type or can't 
 * decode the value.
 */
TlvDecoder.prototype.readNonNegativeIntegerTlv = function(expectedType) 
{
  var length = this.readTypeAndLength(expectedType);
  return this.readNonNegativeInteger(length);
};

/**
 * Peek at the next TLV, and if it has the expectedType then call 
 * readNonNegativeIntegerTlv and return the integer.  Otherwise, return null.  
 * However, if this's offset is greater than or equal to endOffset, then return 
 * null and don't try to read the type.
 * @param {number} expectedType The expected type.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @returns {number} The integer or null if the next TLV doesn't have the 
 * expected type.
 */
TlvDecoder.prototype.readOptionalNonNegativeIntegerTlv = function
  (expectedType, endOffset) 
{
  if (this.peekType(expectedType, endOffset))
    return this.readNonNegativeIntegerTlv(expectedType);
  else
    return null;
};

/**
 * Decode the type and length from this's input starting at offset, expecting 
 * the type to be expectedType. Then return an array of the bytes in the value.
 * Update offset.
 * @param {number} expectedType The expected type.
 * @returns {Buffer} The bytes in the value as a slice on the buffer.  This is
 * not a copy of the bytes in the input buffer.  If you need a copy, then you 
 * must make a copy of the return value.
 * @throws DecodingException if did not get the expected TLV type.
 */
TlvDecoder.prototype.readBlobTlv = function(expectedType) 
{
  var length = this.readTypeAndLength(expectedType);
  var result = this.input.slice(this.offset, this.offset + length);

  // readTypeAndLength already checked if length exceeds the input buffer.
  this.offset += length;
  return result;
};

/**
 * Peek at the next TLV, and if it has the expectedType then call readBlobTlv 
 * and return the value.  Otherwise, return null. However, if this's offset is 
 * greater than or equal to endOffset, then return null and don't try to read 
 * the type.
 * @param {number} expectedType The expected type.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @returns {Buffer} The bytes in the value as a slice on the buffer or null if 
 * the next TLV doesn't have the expected type.  This is not a copy of the bytes 
 * in the input buffer.  If you need a copy, then you must make a copy of the 
 * return value.
 */
TlvDecoder.prototype.readOptionalBlobTlv = function(expectedType, endOffset) 
{
  if (this.peekType(expectedType, endOffset))
    return this.readBlobTlv(expectedType);
  else
    return null;
};

/**
 * Peek at the next TLV, and if it has the expectedType then read a type and 
 * value, ignoring the value, and return true. Otherwise, return false.
 * However, if this's offset is greater than or equal to endOffset, then return 
 * false and don't try to read the type.
 * @param {number} expectedType The expected type.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @returns {boolean} true, or else false if the next TLV doesn't have the 
 * expected type.
 */
TlvDecoder.prototype.readBooleanTlv = function(expectedType, endOffset) 
{
  if (this.peekType(expectedType, endOffset)) {
    var length = this.readTypeAndLength(expectedType);
    // We expect the length to be 0, but update offset anyway.
    this.offset += length;
    return true;
  }
  else
    return false;
};

/**
 * Get the offset into the input, used for the next read.
 * @returns {number} The offset.
 */
TlvDecoder.prototype.getOffset = function() 
{
  return this.offset;
};

/**
 * Set the offset into the input, used for the next read.
 * @param {number} offset The new offset.
 */
TlvDecoder.prototype.seek = function(offset) 
{
  this.offset = offset;
};  

},{"../../buffer.js":14,"../decoding-exception.js":22}],28:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../../buffer.js').Buffer
var DynamicBuffer = require('../../util/dynamic-buffer.js').DynamicBuffer;

/**
 * Create a new TlvEncoder with an initialCapacity for the encoding buffer.
 * @constructor
 * @param {number} initialCapacity (optional) The initial capacity of the 
 * encoding buffer. If omitted, use a default value.
 */
var TlvEncoder = function TlvEncoder(initialCapacity)
{
  initialCapacity = initialCapacity || 16;
  this.output = new DynamicBuffer(initialCapacity);
  // length is the number of bytes that have been written to the back of 
  //  this.output.array.
  this.length = 0;
};

exports.TlvEncoder = TlvEncoder;

/**
 * Get the number of bytes that have been written to the output.  You can
 * save this number, write sub TLVs, then subtract the new length from this
 * to get the total length of the sub TLVs.
 * @returns {number} The number of bytes that have been written to the output.
 */
TlvEncoder.prototype.getLength = function()
{
  return this.length;
};

/**
 * Encode varNumber as a VAR-NUMBER in NDN-TLV and write it to this.output just 
 * before this.length from the back.  Advance this.length.
 * @param {number} varNumber The non-negative number to encode.
 */
TlvEncoder.prototype.writeVarNumber = function(varNumber)
{
  if (varNumber < 253) {
    this.length += 1;
    this.output.ensureLengthFromBack(this.length);
    this.output.array[this.output.array.length - this.length] = varNumber & 0xff;
  }
  else if (varNumber <= 0xffff) {
    this.length += 3;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset] = 253;
    this.output.array[offset + 1] = (varNumber >> 8) & 0xff;
    this.output.array[offset + 2] = varNumber & 0xff;
  }
  else if (varNumber <= 0xffffffff) {
    this.length += 5;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset] = 254;
    this.output.array[offset + 1] = (varNumber >> 24) & 0xff;
    this.output.array[offset + 2] = (varNumber >> 16) & 0xff;
    this.output.array[offset + 3] = (varNumber >> 8) & 0xff;
    this.output.array[offset + 4] = varNumber & 0xff;
  }
  else {
    this.length += 9;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset] = 255;
    this.output.array[offset + 1] = (varNumber >> 56) & 0xff;
    this.output.array[offset + 2] = (varNumber >> 48) & 0xff;
    this.output.array[offset + 3] = (varNumber >> 40) & 0xff;
    this.output.array[offset + 4] = (varNumber >> 32) & 0xff;
    this.output.array[offset + 5] = (varNumber >> 24) & 0xff;
    this.output.array[offset + 6] = (varNumber >> 16) & 0xff;
    this.output.array[offset + 7] = (varNumber >> 8) & 0xff;
    this.output.array[offset + 8] = varNumber & 0xff;
  }
};

/**
 * Encode the type and length as VAR-NUMBER and write to this.output just before 
 * this.length from the back.  Advance this.length.
 * @param {number} type The type of the TLV.
 * @param {number} length The non-negative length of the TLV.
 */
TlvEncoder.prototype.writeTypeAndLength = function(type, length)
{
  // Write backwards.
  this.writeVarNumber(length);
  this.writeVarNumber(type);
};

/**
 * Write the type, then the length of the encoded value then encode value as a 
 * non-negative integer and write it to this.output just before this.length from 
 * the back. Advance this.length.
 * @param {number} type The type of the TLV.
 * @param {number} value The non-negative integer to encode.
 */
TlvEncoder.prototype.writeNonNegativeIntegerTlv = function(type, value)
{
  if (value < 0)
    throw new Error("TLV integer value may not be negative");

  // JavaScript doesn't distinguish int from float, so round.
  value = Math.round(value)

  // Write backwards.
  var saveNBytes = this.length;
  if (value < 253) {
    this.length += 1;
    this.output.ensureLengthFromBack(this.length);
    this.output.array[this.output.array.length - this.length] = value & 0xff;
  }
  else if (value <= 0xffff) {
    this.length += 2;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset]     = (value >> 8) & 0xff;
    this.output.array[offset + 1] = value & 0xff;
  }
  else if (value <= 0xffffffff) {
    this.length += 4;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset]     = (value >> 24) & 0xff;
    this.output.array[offset + 1] = (value >> 16) & 0xff;
    this.output.array[offset + 2] = (value >> 8) & 0xff;
    this.output.array[offset + 3] = value & 0xff;
  }
  else {
    this.length += 8;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset]     = (value >> 56) & 0xff;
    this.output.array[offset + 1] = (value >> 48) & 0xff;
    this.output.array[offset + 2] = (value >> 40) & 0xff;
    this.output.array[offset + 3] = (value >> 32) & 0xff;
    this.output.array[offset + 4] = (value >> 24) & 0xff;
    this.output.array[offset + 5] = (value >> 16) & 0xff;
    this.output.array[offset + 6] = (value >> 8) & 0xff;
    this.output.array[offset + 7] = value & 0xff;
  }

  this.writeTypeAndLength(type, this.length - saveNBytes);
};

/**
 * If value is negative or null then do nothing, otherwise call 
 * writeNonNegativeIntegerTlv.
 * @param {number} type The type of the TLV.
 * @param {number} value If negative or None do nothing, otherwise the integer 
 *   to encode.
 */
TlvEncoder.prototype.writeOptionalNonNegativeIntegerTlv = function(type, value)
{
  if (value != null && value >= 0)
    this.writeNonNegativeIntegerTlv(type, value);
};

/**
 * Write the type, then the length of the buffer then the buffer value to 
 * this.output just before this.length from the back. Advance this.length.
 * @param {number} type The type of the TLV.
 * @param {Buffer} value The byte array with the bytes of the blob.  If value is
    null, then just write the type and length 0.
 */
TlvEncoder.prototype.writeBlobTlv = function(type, value)
{
  if (value == null) {
    this.writeTypeAndLength(type, 0);
    return;
  }

  // Write backwards, starting with the blob array.    
  this.length += value.length;
  this.output.copyFromBack(value, this.length);

  this.writeTypeAndLength(type, value.length);
};

/**
 * If the byte array is null or zero length then do nothing, otherwise call 
 * writeBlobTlv.
 * @param {number} type The type of the TLV.
 * @param {Buffer} value If null or zero length do nothing, otherwise the byte 
 * array with the bytes of the blob.
 */
TlvEncoder.prototype.writeOptionalBlobTlv = function(type, value)
{
  if (value != null && value.length > 0)
    this.writeBlobTlv(type, value);
};

/**
 * Get a slice of the encoded bytes.
 * @returns {Buffer} A slice backed by the encoding customBuf.
 */
TlvEncoder.prototype.getOutput = function()
{
  return this.output.array.slice(this.output.array.length - this.length);
};

},{"../../buffer.js":14,"../../util/dynamic-buffer.js":49}],29:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var TlvDecoder = require('./tlv-decoder.js').TlvDecoder;
var customBuf = require('../../buffer.js').Buffer
/**
 * Create and initialize a TlvStructureDecoder.
 */
var TlvStructureDecoder = function TlvStructureDecoder()
{
  this.gotElementEnd = false;
  this.offset = 0;
  this.state = TlvStructureDecoder.READ_TYPE;
  this.headerLength = 0;
  this.useHeaderBuffer = false;
  // 8 bytes is enough to hold the extended bytes in the length encoding 
  // where it is an 8-byte number.
  this.headerBuffer = new customBuf(8);
  this.nBytesToRead = 0;
};

exports.TlvStructureDecoder = TlvStructureDecoder;

TlvStructureDecoder.READ_TYPE =         0;
TlvStructureDecoder.READ_TYPE_BYTES =   1;
TlvStructureDecoder.READ_LENGTH =       2;
TlvStructureDecoder.READ_LENGTH_BYTES = 3;
TlvStructureDecoder.READ_VALUE_BYTES =  4;

/**
 * Continue scanning input starting from this.offset to find the element end.  
 * If the end of the element which started at offset 0 is found, this returns 
 * true and getOffset() is the length of the element.  Otherwise, this returns 
 * false which means you should read more into input and call again.
 * @param {Buffer} input The input buffer. You have to pass in input each time
 * because the buffer could be reallocated.
 * @returns {boolean} true if found the element end, false if not.
 */
TlvStructureDecoder.prototype.findElementEnd = function(input)
{
  if (this.gotElementEnd)
    // Someone is calling when we already got the end.
    return true;

  var decoder = new TlvDecoder(input);

  while (true) {
    if (this.offset >= input.length)
      // All the cases assume we have some input. Return and wait for more.
      return false;

    if (this.state == TlvStructureDecoder.READ_TYPE) {
      var firstOctet = input[this.offset];
      this.offset += 1;
      if (firstOctet < 253)
        // The value is simple, so we can skip straight to reading the length.
        this.state = TlvStructureDecoder.READ_LENGTH;
      else {
        // Set up to skip the type bytes.
        if (firstOctet == 253)
          this.nBytesToRead = 2;
        else if (firstOctet == 254)
          this.nBytesToRead = 4;
        else
          // value == 255.
          this.nBytesToRead = 8;

        this.state = TlvStructureDecoder.READ_TYPE_BYTES;
      }
    }
    else if (this.state == TlvStructureDecoder.READ_TYPE_BYTES) {
      var nRemainingBytes = input.length - this.offset;
      if (nRemainingBytes < this.nBytesToRead) {
        // Need more.
        this.offset += nRemainingBytes;
        this.nBytesToRead -= nRemainingBytes;
        return false;
      }

      // Got the type bytes. Move on to read the length.
      this.offset += this.nBytesToRead;
      this.state = TlvStructureDecoder.READ_LENGTH;
    }
    else if (this.state == TlvStructureDecoder.READ_LENGTH) {
      var firstOctet = input[this.offset];
      this.offset += 1;
      if (firstOctet < 253) {
        // The value is simple, so we can skip straight to reading 
        //  the value bytes.
        this.nBytesToRead = firstOctet;
        if (this.nBytesToRead == 0) {
          // No value bytes to read. We're finished.
          this.gotElementEnd = true;
          return true;
        }

        this.state = TlvStructureDecoder.READ_VALUE_BYTES;
      }
      else {
        // We need to read the bytes in the extended encoding of 
        //  the length.
        if (firstOctet == 253)
          this.nBytesToRead = 2;
        else if (firstOctet == 254)
          this.nBytesToRead = 4;
        else
          // value == 255.
          this.nBytesToRead = 8;

        // We need to use firstOctet in the next state.
        this.firstOctet = firstOctet;
        this.state = TlvStructureDecoder.READ_LENGTH_BYTES;
      }
    }
    else if (this.state == TlvStructureDecoder.READ_LENGTH_BYTES) {
      var nRemainingBytes = input.length - this.offset;
      if (!this.useHeaderBuffer && nRemainingBytes >= this.nBytesToRead) {
        // We don't have to use the headerBuffer. Set nBytesToRead.
        decoder.seek(this.offset);

        this.nBytesToRead = decoder.readExtendedVarNumber(this.firstOctet);
        // Update this.offset to the decoder's offset after reading.
        this.offset = decoder.getOffset();
      }
      else {
        this.useHeaderBuffer = true;

        var nNeededBytes = this.nBytesToRead - this.headerLength;
        if (nNeededBytes > nRemainingBytes) {
          // We can't get all of the header bytes from this input. 
          // Save in headerBuffer.
          if (this.headerLength + nRemainingBytes > this.headerBuffer.length)
            // We don't expect this to happen.
            throw new Error
              ("Cannot store more header bytes than the size of headerBuffer");
          input.slice(this.offset, this.offset + nRemainingBytes).copy
            (this.headerBuffer, this.headerLength);
          this.offset += nRemainingBytes;
          this.headerLength += nRemainingBytes;

          return false;
        }

        // Copy the remaining bytes into headerBuffer, read the 
        //   length and set nBytesToRead.
        if (this.headerLength + nNeededBytes > this.headerBuffer.length)
          // We don't expect this to happen.
          throw new Error
            ("Cannot store more header bytes than the size of headerBuffer");
        input.slice(this.offset, this.offset + nNeededBytes).copy
          (this.headerBuffer, this.headerLength);
        this.offset += nNeededBytes;

        // Use a local decoder just for the headerBuffer.
        var bufferDecoder = new TlvDecoder(this.headerBuffer);
        // Replace nBytesToRead with the length of the value.
        this.nBytesToRead = bufferDecoder.readExtendedVarNumber(this.firstOctet);
      }
      
      if (this.nBytesToRead == 0) {
        // No value bytes to read. We're finished.
        this.gotElementEnd = true;
        return true;
      }

      // Get ready to read the value bytes.
      this.state = TlvStructureDecoder.READ_VALUE_BYTES;
    }
    else if (this.state == TlvStructureDecoder.READ_VALUE_BYTES) {
      nRemainingBytes = input.length - this.offset;
      if (nRemainingBytes < this.nBytesToRead) {
        // Need more.
        this.offset += nRemainingBytes;
        this.nBytesToRead -= nRemainingBytes;
        return false;
      }

      // Got the bytes. We're finished.
      this.offset += this.nBytesToRead;
      this.gotElementEnd = true;
      return true;
    }
    else
      // We don't expect this to happen.
      throw new Error("findElementEnd: unrecognized state");
  }
};

/**
 * Get the current offset into the input buffer.
 * @returns {number} The offset.
 */
TlvStructureDecoder.prototype.getOffset = function()
{
  return this.offset;
};

/**
 * Set the offset into the input, used for the next read.
 * @param {number} offset The new offset.
 */
TlvStructureDecoder.prototype.seek = function(offset)
{
  this.offset = offset;
};

},{"../../buffer.js":14,"./tlv-decoder.js":27}],30:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * The Tlv class has static type codes for the NDN-TLV wire format.
 * @constructor
 */
var Tlv = function Tlv()
{
}

exports.Tlv = Tlv;

Tlv.Interest =         5;
Tlv.Data =             6;
Tlv.Name =             7;
Tlv.NameComponent =    8;
Tlv.Selectors =        9;
Tlv.Nonce =            10;
Tlv.Scope =            11;
Tlv.InterestLifetime = 12;
Tlv.MinSuffixComponents = 13;
Tlv.MaxSuffixComponents = 14;
Tlv.PublisherPublicKeyLocator = 15;
Tlv.Exclude =          16;
Tlv.ChildSelector =    17;
Tlv.MustBeFresh =      18;
Tlv.Any =              19;
Tlv.MetaInfo =         20;
Tlv.Content =          21;
Tlv.SignatureInfo =    22;
Tlv.SignatureValue =   23;
Tlv.ContentType =      24;
Tlv.FreshnessPeriod =  25;
Tlv.FinalBlockId =     26;
Tlv.SignatureType =    27;
Tlv.KeyLocator =       28;
Tlv.KeyLocatorDigest = 29;
Tlv.FaceInstance =     128;
Tlv.ForwardingEntry =  129;
Tlv.StatusResponse =   130;
Tlv.Action =           131;
Tlv.FaceID =           132;
Tlv.IPProto =          133;
Tlv.Host =             134;
Tlv.Port =             135;
Tlv.MulticastInterface = 136;
Tlv.MulticastTTL =     137;
Tlv.ForwardingFlags =  138;
Tlv.StatusCode =       139;
Tlv.StatusText =       140;

Tlv.SignatureType_DigestSha256 = 0;
Tlv.SignatureType_SignatureSha256WithRsa = 1;

},{}],31:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents Interest Objects
 */
var customBuf = require('../buffer.js').Buffer
/**
 * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like TlvWireFormat.
 * @constructor
 */
var WireFormat = function WireFormat() {
};

exports.WireFormat = WireFormat;

/**
 * Encode interest and return the encoding.  Your derived class should override.
 * @param {Interest} interest The Interest to encode.
 * @returns {Blob} A Blob containing the encoding.
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.encodeInterest = function(interest) 
{
  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * Decode input as an interest and set the fields of the interest object. 
 * Your derived class should override.
 * @param {Interest} interest The Interest object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.decodeInterest = function(interest, input) 
{
  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * Encode data and return the encoding and signed offsets. Your derived class 
 * should override.
 * @param {Data} data The Data object to encode.
 * @returns {object with (Blob, int, int)} An associative array with fields
 * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding 
 * is a Blob containing the encoding, signedPortionBeginOffset is the offset in 
 * the encoding of the beginning of the signed portion, and 
 * signedPortionEndOffset is the offset in the encoding of the end of the 
 * signed portion.
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.encodeData = function(data) 
{
  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * Decode input as a data packet, set the fields in the data object, and return 
 * the signed offsets.  Your derived class should override.
 * @param {Data} data The Data object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.decodeData = function(data, input) 
{
  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * Set the static default WireFormat used by default encoding and decoding 
 * methods.
 * @param wireFormat {a subclass of WireFormat} An object of a subclass of 
 * WireFormat.
 */
WireFormat.setDefaultWireFormat = function(wireFormat)
{
  WireFormat.defaultWireFormat = wireFormat;
};

/**
 * Return the default WireFormat used by default encoding and decoding methods 
 * which was set with setDefaultWireFormat.
 * @returns {a subclass of WireFormat} The WireFormat object.
 */
WireFormat.getDefaultWireFormat = function()
{
  return WireFormat.defaultWireFormat;
};

// Invoke TlvWireFormat to set the default format.
// Since tlv-wire-format.js includes this file, put this at the bottom 
// to avoid problems with cycles of require.
var TlvWireFormat = require('./tlv-wire-format.js').TlvWireFormat;

},{"../buffer.js":14,"./tlv-wire-format.js":26}],32:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an Interest Exclude.
 */

var customBuf = require('./buffer.js').Buffer
var Name = require('./name.js').Name;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var DataUtils = require('./encoding/data-utils.js').DataUtils;

/**
 * Create a new Exclude.
 * @constructor
 * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, customBuf component or Exclude.ANY.
 */
var Exclude = function Exclude(values) 
{ 
  this.values = [];
  
  if (typeof values === 'object' && values instanceof Exclude)
    // Copy the exclude.
    this.values = values.values.slice(0);
  else if (values) {
    for (var i = 0; i < values.length; ++i) {
      if (values[i] == Exclude.ANY)
        this.appendAny();
      else
        this.appendComponent(values[i]);
    }
  }
};

exports.Exclude = Exclude;

Exclude.ANY = "*";

/**
 * Get the number of entries.
 * @returns {number} The number of entries.
 */
Exclude.prototype.size = function() { return this.values.length; };

/**
 * Get the entry at the given index.
 * @param {number} i The index of the entry, starting from 0.
 * @returns {Exclude.ANY|Name.Component} Exclude.ANY or a Name.Component.
 */
Exclude.prototype.get = function(i) { return this.values[i]; };

/**
 * Append an Exclude.ANY element.
 * @returns This Exclude so that you can chain calls to append.
 */
Exclude.prototype.appendAny = function() 
{
  this.values.push(Exclude.ANY);
  return this;
};

/**
 * Append a component entry, copying from component.
 * @param {Name.Component|Buffer} component
 * @returns This Exclude so that you can chain calls to append.
 */
Exclude.prototype.appendComponent = function(component) 
{
  this.values.push(new Name.Component(component));
  return this;
};

/**
 * Clear all the entries.
 */
Exclude.prototype.clear = function() 
{
  this.values = [];
};

Exclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) 
{
  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);

  while (true) {
    if (decoder.peekDTag(NDNProtocolDTags.Component))
      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));
    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {
      decoder.readElementStartDTag(NDNProtocolDTags.Any);
      decoder.readElementClose();
      this.appendAny();
    }
    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {
      // Skip the Bloom and treat it as Any.
      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);
      this.appendAny();
    }
    else
      break;
  }
    
  decoder.readElementClose();
};

Exclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  
{
  if (this.values == null || this.values.length == 0)
    return;

  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);
    
  // TODO: Do we want to order the components (except for ANY)?
  for (var i = 0; i < this.values.length; ++i) {
    if (this.values[i] == Exclude.ANY) {
      encoder.writeElementStartDTag(NDNProtocolDTags.Any);
      encoder.writeElementClose();
    }
    else
      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());
  }

  encoder.writeElementClose();
};

/**
 * Return a string with elements separated by "," and Exclude.ANY shown as "*". 
 */
Exclude.prototype.toUri = function() 
{
  if (this.values == null || this.values.length == 0)
    return "";

  var result = "";
  for (var i = 0; i < this.values.length; ++i) {
    if (i > 0)
      result += ",";
        
    if (this.values[i] == Exclude.ANY)
      result += "*";
    else
      result += Name.toEscapedString(this.values[i].getValue());
  }
  return result;
};

/**
 * Return true if the component matches any of the exclude criteria.
 */
Exclude.prototype.matches = function(/*Buffer*/ component) 
{
  if (typeof component == 'object' && component instanceof Name.Component)
    component = component.getValue();

  for (var i = 0; i < this.values.length; ++i) {
    if (this.values[i] == Exclude.ANY) {
      var lowerBound = null;
      if (i > 0)
        lowerBound = this.values[i - 1];
      
      // Find the upper bound, possibly skipping over multiple ANY in a row.
      var iUpperBound;
      var upperBound = null;
      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {
        if (this.values[iUpperBound] != Exclude.ANY) {
          upperBound = this.values[iUpperBound];
          break;
        }
      }
      
      // If lowerBound != null, we already checked component equals lowerBound on the last pass.
      // If upperBound != null, we will check component equals upperBound on the next pass.
      if (upperBound != null) {
        if (lowerBound != null) {
          if (Exclude.compareComponents(component, lowerBound) > 0 &&
              Exclude.compareComponents(component, upperBound) < 0)
            return true;
        }
        else {
          if (Exclude.compareComponents(component, upperBound) < 0)
            return true;
        }
          
        // Make i equal iUpperBound on the next pass.
        i = iUpperBound - 1;
      }
      else {
        if (lowerBound != null) {
            if (Exclude.compareComponents(component, lowerBound) > 0)
              return true;
        }
        else
          // this.values has only ANY.
          return true;
      }
    }
    else {
      if (DataUtils.arraysEqual(component, this.values[i].getValue()))
        return true;
    }
  }
  
  return false;
};

/**
 * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.
 * A component is less if it is shorter, otherwise if equal length do a byte comparison.
 */
Exclude.compareComponents = function(component1, component2) 
{
  if (typeof component1 == 'object' && component1 instanceof Name.Component)
    component1 = component1.getValue();
  if (typeof component2 == 'object' && component2 instanceof Name.Component)
    component2 = component2.getValue();

  if (component1.length < component2.length)
    return -1;
  if (component1.length > component2.length)
    return 1;
  
  for (var i = 0; i < component1.length; ++i) {
    if (component1[i] < component2[i])
      return -1;
    if (component1[i] > component2[i])
      return 1;
  }

  return 0;
};

},{"./buffer.js":14,"./encoding/binary-xml-decoder.js":17,"./encoding/binary-xml-encoder.js":18,"./encoding/data-utils.js":21,"./name.js":42,"./util/ndn-protoco-id-tags.js":51}],33:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Face Instances
 */

var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var PublisherPublicKeyDigest = require('./publisher-public-key-digest.js').PublisherPublicKeyDigest;

/**
 * @constructor
 */
var FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,
    multicastTTL, freshnessSeconds) 
{
  this.action = action;
  this.publisherPublicKeyDigest = publisherPublicKeyDigest;
  this.faceID = faceID;
  this.ipProto = ipProto;
  this.host = host;
  this.Port = port;
  this.multicastInterface =multicastInterface;
  this.multicastTTL =multicastTTL;
  this.freshnessSeconds = freshnessSeconds;
};

exports.FaceInstance = FaceInstance;

FaceInstance.NetworkProtocol = { TCP:6, UDP:17};

/**
 * Used by NetworkObject to decode the object from a network stream.
 */
FaceInstance.prototype.from_ndnb = function(
  //XMLDecoder 
  decoder) 
{
  decoder.readElementStartDTag(this.getElementLabel());
  
  if (decoder.peekDTag(NDNProtocolDTags.Action))   
    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();
    this.publisherPublicKeyDigest.from_ndnb(decoder);
  }
  if (decoder.peekDTag(NDNProtocolDTags.FaceID))
    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);
  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {
    //int
    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);
    
    this.ipProto = null;
    
    if (FaceInstance.NetworkProtocol.TCP == pI)
      this.ipProto = FaceInstance.NetworkProtocol.TCP;
    else if (FaceInstance.NetworkProtocol.UDP == pI)
      this.ipProto = FaceInstance.NetworkProtocol.UDP;
    else
      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);
  }
  
  if (decoder.peekDTag(NDNProtocolDTags.Host))
    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);
  if (decoder.peekDTag(NDNProtocolDTags.Port))
    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port); 
  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))
    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface); 
  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))
    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL); 
  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))
    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); 

  decoder.readElementClose();
};

/**
 * Used by NetworkObject to encode the object to a network stream.
 */
FaceInstance.prototype.to_ndnb = function(
  //XMLEncoder
  encoder) 
{
  encoder.writeElementStartDTag(this.getElementLabel());
  
  if (null != this.action && this.action.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  
  if (null != this.publisherPublicKeyDigest)
    this.publisherPublicKeyDigest.to_ndnb(encoder);
  if (null != this.faceID)
    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);
  if (null != this.ipProto)
    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);
  if (null != this.host && this.host.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);  
  if (null != this.Port)
    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);
  if (null != this.multicastInterface && this.multicastInterface.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);
  if (null !=  this.multicastTTL)
    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);
  if (null != this.freshnessSeconds)
    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);

  encoder.writeElementClose();         
};

FaceInstance.prototype.getElementLabel = function() 
{
  return NDNProtocolDTags.FaceInstance;
};


},{"./publisher-public-key-digest.js":44,"./util/ndn-protoco-id-tags.js":51}],34:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang
 * See COPYING for copyright and distribution information.
 * This class represents the top-level object for communicating with an NDN host.
 */

var customBuf = require('./buffer.js').Buffer
var crypto = require('./crypto.js');
var DataUtils = require('./encoding/data-utils.js').DataUtils;
var Name = require('./name.js').Name;
var Interest = require('./interest.js').Interest;
var Data = require('./data.js').Data;
var MetaInfo = require('./meta-info.js').MetaInfo;
var ForwardingEntry = require('./forwarding-entry.js').ForwardingEntry;
var TlvWireFormat = require('./encoding/tlv-wire-format.js').TlvWireFormat;
var BinaryXmlWireFormat = require('./encoding/binary-xml-wire-format.js').BinaryXmlWireFormat;
var Tlv = require('./encoding/tlv/tlv.js').Tlv;
var TlvDecoder = require('./encoding/tlv/tlv-decoder.js').TlvDecoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var Key = require('./key.js').Key;
var KeyLocatorType = require('./key-locator.js').KeyLocatorType;
var ForwardingFlags = require('./forwarding-flags.js').ForwardingFlags;
var Closure = require('./closure.js').Closure;
var UpcallInfo = require('./closure.js').UpcallInfo;
var TcpTransport = require('./transport/tcp-transport.js').TcpTransport;
var LOG = require('./log.js').Log.LOG;

/**
 * Create a new Face with the given settings.
 * This throws an exception if Face.supported is false.
 * @constructor
 * @param {Object} settings if not null, an associative array with the following defaults:
 * {
 *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.
 *              OR function() { return new TcpTransport(); },       // If in Node.js.
 *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.
 *   host: null, // If null, use getHostAndPort when connecting.
 *   port: 9696, // If in the browser.
 *      OR 6363, // If in Node.js.
 *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },
 *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },
 *   verify: false // If false, don't verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.
 * }
 */
var Face = function Face(settings) 
{
  if (!Face.supported)
    throw new Error("The necessary JavaScript support is not available on this platform.");
    
  settings = (settings || {});
  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.
  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });
  this.transport = getTransport();
  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);
  this.host = (settings.host !== undefined ? settings.host : null);
  this.port = (settings.port || (typeof WebSocketTransport != 'undefined' ? 9696 : 6363));
  this.readyStatus = Face.UNOPEN;
  this.verify = (settings.verify !== undefined ? settings.verify : false);
  // Event handler
  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });
  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });
  this.ndndid = null;
};

exports.Face = Face;

Face.UNOPEN = 0;  // created but not opened yet
Face.OPENED = 1;  // connection to ndnd opened
Face.CLOSED = 2;  // connection to ndnd closed

/**
 * Return true if necessary JavaScript support is available, else log an error and return false.
 */
Face.getSupported = function() 
{
  try {
    var dummy = new customBuf(1).slice(0, 1);
  } 
  catch (ex) {
    console.log("NDN not available: customBuf not supported. " + ex);
    return false;
  }
    
  return true;
};

Face.supported = Face.getSupported();

Face.ndndIdFetcher = new Name('/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY');

Face.prototype.createRoute = function(host, port) 
{
  this.host=host;
  this.port=port;
};

Face.KeyStore = new Array();

var KeyStoreEntry = function KeyStoreEntry(name, rsa, time) 
{
  this.keyName = name;  // KeyName
  this.rsaKey = rsa;    // RSA key
  this.timeStamp = time;  // Time Stamp
};

Face.addKeyEntry = function(/* KeyStoreEntry */ keyEntry) 
{
  var result = Face.getKeyByName(keyEntry.keyName);
  if (result == null) 
    Face.KeyStore.push(keyEntry);
  else
    result = keyEntry;
};

Face.getKeyByName = function(/* KeyName */ name) 
{
  var result = null;
  
  for (var i = 0; i < Face.KeyStore.length; i++) {
    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {
      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)
        result = Face.KeyStore[i];
    }
  }
    
  return result;
};

Face.prototype.close = function() 
{
  if (this.readyStatus != Face.OPENED)
    throw new Error('Cannot close because Face connection is not opened.');

  this.readyStatus = Face.CLOSED;
  this.transport.close();
};

// For fetching data
Face.PITTable = new Array();

/**
 * @constructor
 */
var PITEntry = function PITEntry(interest, closure) 
{
  this.interest = interest;  // Interest
  this.closure = closure;    // Closure
  this.timerID = -1;  // Timer ID
};

/**
 * Return the entry from Face.PITTable where the name conforms to the interest selectors, and
 * the interest name is the longest that matches name.
 */

/**
 * Find all entries from Face.PITTable where the name conforms to the entry's 
 * interest selectors, remove the entries from the table, cancel their timeout
 * timers and return them.
 * @param {Name} name The name to find the interest for (from the incoming data
 * packet).
 * @returns {Array<PITEntry>} The matching entries from Face.PITTable, or [] if 
 * none are found.
 */
Face.extractEntriesForExpressedInterest = function(name) 
{
  var result = [];
    
  // Go backwards through the list so we can erase entries.
  for (var i = Face.PITTable.length - 1; i >= 0; --i) {
    var entry = Face.PITTable[i];
    if (entry.interest.matchesName(name)) {
      // Cancel the timeout timer.
      clearTimeout(entry.timerID);

      result.push(entry);
      Face.PITTable.splice(i, 1);
    }
  }

  return result;
};

// For publishing data
Face.registeredPrefixTable = new Array();

/**
 * @constructor
 */
var RegisteredPrefix = function RegisteredPrefix(prefix, closure) 
{
  this.prefix = prefix;        // String
  this.closure = closure;  // Closure
};

/**
 * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.
 * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).
 * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.
 */
function getEntryForRegisteredPrefix(name) 
{
  var iResult = -1;
  
  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {
    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " , Face.registeredPrefixTable[i].prefix , " matches " , name);
    if (Face.registeredPrefixTable[i].prefix.match(name)) {
      if (iResult < 0 || 
          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())
        // Update to the longer match.
        iResult = i;
    }
  }
  
  if (iResult >= 0)
    return Face.registeredPrefixTable[iResult];
  else
    return null;
}

/**
 * Return a function that selects a host at random from hostList and returns { host: host, port: port }.
 * If no more hosts remain, return null.
 */
Face.makeShuffledGetHostAndPort = function(hostList, port) 
{
  // Make a copy.
  hostList = hostList.slice(0, hostList.length);
  DataUtils.shuffle(hostList);

  return function() {
    if (hostList.length == 0)
      return null;
      
    return { host: hostList.splice(0, 1)[0], port: port };
  };
};

/**
 * Send the interest through the transport, read the entire response and call onData. 
 * If the interest times out according to interest lifetime, call onTimeout (if not omitted).
 * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):
 * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from
 * a name and optional interest template:
 * expressInterest(name [, template], onData [, onTimeout]).
 * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.
 * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.
 * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:
 *   interest is the interest given to expressInterest,
 *   data is the received Data object.
 * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime, 
 *   this calls onTimeout(interest) where:
 *   interest is the interest given to expressInterest.
 * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).
 * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest. 
 * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).
 */
Face.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4) 
{
  // There are several overloaded versions of expressInterest, each shown inline below.

  // expressInterest(Name name, Closure closure);                      // deprecated
  // expressInterest(Name name, Closure closure,   Interest template); // deprecated
  if (arg2 && arg2.upcall && typeof arg2.upcall == 'function') {
    // Assume arg2 is the deprecated use with Closure.
    if (arg3)
      this.expressInterestWithClosure(interestOrName, arg2, arg3);
    else
      this.expressInterestWithClosure(interestOrName, arg2);
    return;
  }
  
  var interest;
  var onData;
  var onTimeout;
  // expressInterest(Interest interest, function onData);
  // expressInterest(Interest interest, function onData, function onTimeout);
  if (typeof interestOrName == 'object' && interestOrName instanceof Interest) {
    // Just use a copy of the interest.
    interest = new Interest(interestOrName);
    onData = arg2;
    onTimeout = (arg3 ? arg3 : function() {});
  }
  else {
    // The first argument is a name. Make the interest from the name and possible template.
    interest = new Interest(interestOrName);
    // expressInterest(Name name, Interest template, function onData); 
    // expressInterest(Name name, Interest template, function onData, function onTimeout); 
    if (arg2 && typeof arg2 == 'object' && arg2 instanceof Interest) {
      var template = arg2;
      interest.minSuffixComponents = template.minSuffixComponents;
      interest.maxSuffixComponents = template.maxSuffixComponents;
      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;
      interest.exclude = template.exclude;
      interest.childSelector = template.childSelector;
      interest.answerOriginKind = template.answerOriginKind;
      interest.scope = template.scope;
      interest.interestLifetime = template.interestLifetime;

      onData = arg3;
      onTimeout = (arg4 ? arg4 : function() {});
    }
    // expressInterest(Name name, function onData); 
    // expressInterest(Name name, function onData,   function onTimeout); 
    else {
      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.
      onData = arg2;
      onTimeout = (arg3 ? arg3 : function() {});
    }
  }
  
  // Make a Closure from the callbacks so we can use expressInterestWithClosure.
  // TODO: Convert the PIT to use callbacks, not a closure.
  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout));
}

Face.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {
  // Inherit from Closure.
  Closure.call(this);
  
  this.onData = onData;
  this.onTimeout = onTimeout;
  this.onInterest = onInterest;
  this.prefix = prefix;
  this.transport = transport;
};

Face.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {
  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)
    this.onData(upcallInfo.interest, upcallInfo.data);
  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)
    this.onTimeout(upcallInfo.interest);
  else if (kind == Closure.UPCALL_INTEREST)
    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.
    this.onInterest(this.prefix, upcallInfo.interest, this.transport)
  
  return Closure.RESULT_OK;
};

/**
 * A private method to encode name as an Interest and send the it to host:port, read the entire response and call
 * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),
 *                 new UpcallInfo(this, interest, 0, data)). 
 * @deprecated Use expressInterest with callback functions, not Closure.
 * @param {Name} name Encode name as an Interest using the template (if supplied).
 * @param {Closure} closure
 * @param {Interest} template If not null, use its attributes.
 */
Face.prototype.expressInterestWithClosure = function(name, closure, template) 
{
  var interest = new Interest(name);
  if (template != null) {
    interest.minSuffixComponents = template.minSuffixComponents;
    interest.maxSuffixComponents = template.maxSuffixComponents;
    interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;
    interest.exclude = template.exclude;
    interest.childSelector = template.childSelector;
    interest.answerOriginKind = template.answerOriginKind;
    interest.scope = template.scope;
    interest.interestLifetime = template.interestLifetime;
  }
  else
    interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.
  
  if (this.host == null || this.port == null) {
    if (this.getHostAndPort == null)
      console.log('ERROR: host OR port NOT SET');
    else {
      var thisNDN = this;
      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });
    }
  }
  else
    this.reconnectAndExpressInterest(interest, closure);
};

/**
 * If the host and port are different than the ones in this.transport, then call
 *   this.transport.connect to change the connection (or connect for the first time).
 * Then call expressInterestHelper.
 */
Face.prototype.reconnectAndExpressInterest = function(interest, closure) 
{
  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {
    var thisNDN = this;
    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });
    this.readyStatus = Face.OPENED;
  }
  else
    this.expressInterestHelper(interest, closure);
};

/**
 * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call
 *   this.transport.send to send the interest.
 */
Face.prototype.expressInterestHelper = function(interest, closure) 
{
  var binaryInterest = interest.wireEncode();
  var thisNDN = this;    
  //TODO: check local content store first
  if (closure != null) {
    var pitEntry = new PITEntry(interest, closure);
    // TODO: This needs to be a single thread-safe transaction on a global object.
    Face.PITTable.push(pitEntry);
    closure.pitEntry = pitEntry;

    // Set interest timer.
    var timeoutMilliseconds = (interest.interestLifetime || 4000);
    var timeoutCallback = function() {
      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());
        
      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express
      //   the interest because we don't want to match it in the mean time.
      // TODO: Make this a thread-safe operation on the global PITTable.
      var index = Face.PITTable.indexOf(pitEntry);
      if (index >= 0) 
        Face.PITTable.splice(index, 1);
        
      // Raise closure callback
      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {
        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());
        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);
        Face.PITTable.push(pitEntry);
        thisNDN.transport.send(binaryInterest.buf());
      }
    };
  
    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);
  }

  this.transport.send(binaryInterest.buf());
};

/**
 * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.
 * This uses the form:
 * registerPrefix(name, onInterest, onRegisterFailed [, flags]).
 * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.
 * @param {Name} prefix The Name prefix.
 * @param {function} onInterest When an interest is received which matches the name prefix, this calls 
 * onInterest(prefix, interest, transport) where:
 *   prefix is the prefix given to registerPrefix.
 *   interest is the received interest.
 *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().
 * @param {function} onRegisterFailed If failed to retrieve the connected hub's ID or failed to register the prefix, 
 * this calls onRegisterFailed(prefix) where:
 *   prefix is the prefix given to registerPrefix.
 * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.  
 * If omitted, use the default flags defined by the default ForwardingFlags constructor.
 */
Face.prototype.registerPrefix = function(prefix, arg2, arg3, arg4) 
{
  // There are several overloaded versions of registerPrefix, each shown inline below.

  // registerPrefix(Name prefix, Closure closure);            // deprecated
  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated
  if (arg2 && arg2.upcall && typeof arg2.upcall == 'function') {
    // Assume arg2 is the deprecated use with Closure.
    if (arg3)
      this.registerPrefixWithClosure(prefix, arg2, arg3);
    else
      this.registerPrefixWithClosure(prefix, arg2);
    return;
  }

  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);
  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);
  var onInterest = arg2;
  var onRegisterFailed = (arg3 ? arg3 : function() {});
  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());
  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport), 
                                 intFlags, onRegisterFailed);
}

/**
 * A private method to register the prefix with the host, receive the data and call
 * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)). 
 * @deprecated Use registerPrefix with callback functions, not Closure.
 * @param {Name} prefix
 * @param {Closure} closure
 * @param {number} intFlags
 * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix) 
 * if registration fails.
 */
Face.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed) 
{
  intFlags = intFlags | 3;
  var thisNDN = this;
  var onConnected = function() {
    if (thisNDN.ndndid == null) {
      // Fetch ndndid first, then register.
      var interest = new Interest(Face.ndndIdFetcher);
      interest.interestLifetime = 4000; // milliseconds
      if (LOG > 3) console.log('Expressing interest for ndndid from ndnd.');
      thisNDN.reconnectAndExpressInterest
        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));
    }
    else  
      thisNDN.registerPrefixHelper(prefix, closure, flags, onRegisterFailed);
  };

  if (this.host == null || this.port == null) {
    if (this.getHostAndPort == null)
      console.log('ERROR: host OR port NOT SET');
    else
      this.connectAndExecute(onConnected);
  }
  else
    onConnected();
};

/**
 * This is a closure to receive the Data for Face.ndndIdFetcher and call
 *   registerPrefixHelper(prefix, callerClosure, flags).
 */
Face.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed) 
{
  // Inherit from Closure.
  Closure.call(this);
    
  this.face = face;
  this.prefix = prefix;
  this.callerClosure = callerClosure;
  this.flags = flags;
  this.onRegisterFailed = onRegisterFailed;
};

Face.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo) 
{
  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");
    if (this.onRegisterFailed)
      this.onRegisterFailed(this.prefix);
    return Closure.RESULT_OK;
  }
  if (!(kind == Closure.UPCALL_CONTENT ||
        kind == Closure.UPCALL_CONTENT_UNVERIFIED))
    // The upcall is not for us.  Don't expect this to happen.
    return Closure.RESULT_ERR;
       
  if (LOG > 3) console.log('Got ndndid from ndnd.');
  // Get the digest of the public key in the data packet content.
  var hash = require("./crypto.js").createHash('sha256');
  hash.update(upcallInfo.data.getContent());
  this.face.ndndid = new customBuf(hash.digest());
  if (LOG > 3) console.log(this.face.ndndid);
  
  this.face.registerPrefixHelper
    (this.prefix, this.callerClosure, this.flags, this.onRegisterFailed);
    
  return Closure.RESULT_OK;
};
/**
 * This is a closure to receive the response Data packet from the register 
 * prefix interest sent to the connected NDN hub. If this gets a bad response
 * or a timeout, call onRegisterFailed.
 */
Face.RegisterResponseClosure = function RegisterResponseClosure
  (prefix, onRegisterFailed) 
{
  // Inherit from Closure.
  Closure.call(this);
    
  this.prefix = prefix;
  this.onRegisterFailed = onRegisterFailed;
};

Face.RegisterResponseClosure.prototype.upcall = function(kind, upcallInfo) 
{
  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
    if (this.onRegisterFailed)
      this.onRegisterFailed(this.prefix);
    return Closure.RESULT_OK;
  }
  if (!(kind == Closure.UPCALL_CONTENT ||
        kind == Closure.UPCALL_CONTENT_UNVERIFIED))
    // The upcall is not for us.  Don't expect this to happen.
    return Closure.RESULT_ERR;
       
  var expectedName = new Name("/ndnx/.../selfreg");
  // Got a response. Do a quick check of expected name components.
  if (upcallInfo.data.getName().size() < 4 ||
      !upcallInfo.data.getName().get(0).equals(expectedName.get(0)) ||
      !upcallInfo.data.getName().get(2).equals(expectedName.get(2))) {
    this.onRegisterFailed(this.prefix);
    return;
  }
  
  // Otherwise, silently succeed.  
  return Closure.RESULT_OK;
};

/**
 * Do the work of registerPrefix once we know we are connected with a ndndid.
 */
Face.prototype.registerPrefixHelper = function
  (prefix, closure, flags, onRegisterFailed) 
{
  var fe = new ForwardingEntry('selfreg', prefix, null, null, flags, null);
    
  // Always encode as BinaryXml until we support TLV for ForwardingEntry.
  var encoder = new BinaryXMLEncoder();
  fe.to_ndnb(encoder);
  var bytes = encoder.getReducedOstream();
    
  var si = new MetaInfo();
  si.setFields();
    
  // Set the name to a random value so that each request is unique.
  var data = new Data(new Name().append(require("crypto").randomBytes(4)), si, bytes); 
  // Always encode as BinaryXml until we support TLV for ForwardingEntry.
  data.sign(BinaryXmlWireFormat.get());
  var coBinary = data.wireEncode(BinaryXmlWireFormat.get());;
    
  var nodename = this.ndndid;
  var interestName = new Name(['ndnx', nodename, 'selfreg', coBinary]);

  var interest = new Interest(interestName);
  interest.setInterestLifetimeMilliseconds(4000.0);
  interest.setScope(1);
  if (LOG > 3) console.log('Send Interest registration packet.');
      
  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));
    
  this.reconnectAndExpressInterest
    (interest, new Face.RegisterResponseClosure(prefix, onRegisterFailed));
};

/**
 * This is called when an entire binary XML element is received, such as a Data or Interest.
 * Look up in the PITTable and call the closure callback.
 */
Face.prototype.onReceivedElement = function(element) 
{
  if (LOG > 3) console.log('Complete element received. Length ' + element.length + '. Start decoding.');
  // First, decode as Interest or Data.
  var interest = null;
  var data = null;
  // The type codes for TLV Interest and Data packets are chosen to not
  //   conflict with the first byte of a binary XML packet, so we can
  //   just look at the first byte.
  if (element[0] == Tlv.Interest || element[0] == Tlv.Data) {
    if (LOG > 3) console.log('Detected Tlv element', element, TlvWireFormat.get())
    var decoder = new TlvDecoder(element);  
    if (decoder.peekType(Tlv.Interest, element.length)) {
      interest = new Interest();
      interest.wireDecode(element, TlvWireFormat.get());
    }
    else if (decoder.peekType(Tlv.Data, element.length)) {
      data = new Data();
      data.wireDecode(element, TlvWireFormat.get());
    }
  }
  else {
    if (LOG > 3) console.log('assumed BinaryXML')
    // Binary XML.
    var decoder = new BinaryXMLDecoder(element);
    if (decoder.peekDTag(NDNProtocolDTags.Interest)) {
      interest = new Interest();
      interest.wireDecode(element, BinaryXmlWireFormat.get());
    }
    else if (decoder.peekDTag(NDNProtocolDTags.Data)) {
      data = new Data();
      data.wireDecode(element, BinaryXmlWireFormat.get());
    }
  }

  // Now process as Interest or Data.
  if (interest !== null) {
    if (LOG > 3) console.log('Interest packet received.', interest);
        setTimeout(function(){console.log(interest)}, 300)
    var entry = getEntryForRegisteredPrefix(interest.name);
    if (entry != null) {
      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());
      var info = new UpcallInfo(this, interest, 0, null);
      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);
      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null) 
        this.transport.send(info.data.wireEncode().buf());
    }        
  } 
  else if (data !== null) {
    if (LOG > 3) console.log('Data packet received.');
        
    var pendingInterests = Face.extractEntriesForExpressedInterest(data.name);
    // Process each matching PIT entry (if any).
    for (var i = 0; i < pendingInterests.length; ++i) {
      var pitEntry = pendingInterests[i];
      var currentClosure = pitEntry.closure;
                    
      if (this.verify == false) {
        // Pass content up without verifying the signature
        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));
        continue;
      }
        
      // Key verification
            
      // Recursive key fetching & verification closure
      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {
        this.data = content;  // unverified data packet object
        this.closure = closure;  // closure corresponding to the data
        this.keyName = key;  // name of current key to be fetched
            
        Closure.call(this);
      };
            
      var thisNDN = this;
      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {
        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
          console.log("In KeyFetchClosure.upcall: interest time out.");
          console.log(this.keyName.contentName.toUri());
        } 
        else if (kind == Closure.UPCALL_CONTENT) {
          var rsakey = new Key();
          rsakey.readDerPublicKey(upcallInfo.data.content);
          var verified = data.verify(rsakey);
                
          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;
          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));
                
          // Store key in cache
          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());
          Face.addKeyEntry(keyEntry);
        } 
        else if (kind == Closure.UPCALL_CONTENT_BAD)
          console.log("In KeyFetchClosure.upcall: signature verification failed");
      };
            
      if (data.signedInfo && data.signedInfo.locator && data.signature) {
        if (LOG > 3) console.log("Key verification...");
        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();
              
        var wit = null;
        if (data.signature.witness != null)
            //SWT: deprecate support for Witness decoding and Merkle hash tree verification
            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));
          
        var keylocator = data.signedInfo.locator;
        if (keylocator.type == KeyLocatorType.KEYNAME) {
          if (LOG > 3) console.log("KeyLocator contains KEYNAME");
                
          if (keylocator.keyName.contentName.match(data.name)) {
            if (LOG > 3) console.log("Content is key itself");
                  
            var rsakey = new Key();
            rsakey.readDerPublicKey(data.content);
            var verified = data.verify(rsakey);
            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;
              
            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));

            // SWT: We don't need to store key here since the same key will be stored again in the closure.
          } 
          else {
            // Check local key store
            var keyEntry = Face.getKeyByName(keylocator.keyName);
            if (keyEntry) {
              // Key found, verify now
              if (LOG > 3) console.log("Local key cache hit");
              var rsakey = keyEntry.rsaKey;
              var verified = data.verify(rsakey);
              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;

              // Raise callback
              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));
            } 
            else {
              // Not found, fetch now
              if (LOG > 3) console.log("Fetch key according to keylocator");
              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);
              // TODO: Use expressInterest with callbacks, not Closure.
              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);
            }
          }
        } 
        else if (keylocator.type == KeyLocatorType.KEY) {
          if (LOG > 3) console.log("Keylocator contains KEY");
                
          var rsakey = new Key();
          rsakey.readDerPublicKey(keylocator.publicKey);
          var verified = data.verify(rsakey);
              
          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;
          // Raise callback
          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));

          // Since KeyLocator does not contain key name for this key,
          // we have no way to store it as a key entry in KeyStore.
        } 
        else {
          var cert = keylocator.certificate;
          console.log("KeyLocator contains CERT");
          console.log(cert);                
          // TODO: verify certificate
        }
      }
    }
  } 
};

/**
 * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host
 *   is not alive.  Get a host and port, connect, then execute onConnected().
 */
Face.prototype.connectAndExecute = function(onConnected) 
{
  var hostAndPort = this.getHostAndPort();
  if (hostAndPort == null) {
    console.log('ERROR: No more hosts from getHostAndPort');
    this.host = null;
    return;
  }

  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {
    console.log('ERROR: The host returned by getHostAndPort is not alive: ' + this.host + ":" + this.port);
    return;
  }
        
  this.host = hostAndPort.host;
  this.port = hostAndPort.port;   
  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);
    
  // Fetch any content.
  var interest = new Interest(new Name("/"));
  interest.interestLifetime = 4000; // milliseconds    

  var thisNDN = this;
  var timerID = setTimeout(function() {
    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);
      // Try again.
      thisNDN.connectAndExecute(onConnected);
  }, 3000);
  
  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));
};

/**
 * This is called by the Transport when the connection is closed by the remote host.
 */
Face.prototype.closeByTransport = function() 
{
  this.readyStatus = Face.CLOSED;
  this.onclose();
};

Face.ConnectClosure = function ConnectClosure(face, onConnected, timerID) 
{
  // Inherit from Closure.
  Closure.call(this);
    
  this.face = face;
  this.onConnected = onConnected;
  this.timerID = timerID;
};

Face.ConnectClosure.prototype.upcall = function(kind, upcallInfo) 
{
  if (!(kind == Closure.UPCALL_CONTENT ||
        kind == Closure.UPCALL_CONTENT_UNVERIFIED))
    // The upcall is not for us.
    return Closure.RESULT_ERR;
        
  // The host is alive, so cancel the timeout and continue with onConnected().
  clearTimeout(this.timerID);

    // Call Face.onopen after success
  this.face.readyStatus = Face.OPENED;
  this.face.onopen();

  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);
  this.onConnected();

  return Closure.RESULT_OK;
};

/**
 * @deprecated Use new Face.
 */
var NDN = function NDN(settings) 
{
  // Call the base constructor.
  Face.call(this, settings); 
}

// Use dummy functions so that the Face constructor will not try to set its own defaults.                                      
NDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });

exports.NDN = NDN;

NDN.supported = Face.supported;
NDN.UNOPEN = Face.UNOPEN;
NDN.OPENED = Face.OPENED;
NDN.CLOSED = Face.CLOSED;

},{"./buffer.js":14,"./closure.js":15,"./crypto.js":14,"./data.js":16,"./encoding/binary-xml-decoder.js":17,"./encoding/binary-xml-encoder.js":18,"./encoding/binary-xml-wire-format.js":20,"./encoding/data-utils.js":21,"./encoding/tlv-wire-format.js":26,"./encoding/tlv/tlv-decoder.js":27,"./encoding/tlv/tlv.js":30,"./forwarding-entry.js":35,"./forwarding-flags.js":36,"./interest.js":37,"./key-locator.js":38,"./key.js":39,"./log.js":40,"./meta-info.js":41,"./name.js":42,"./transport/tcp-transport.js":13,"./util/ndn-protoco-id-tags.js":51,"crypto":113}],35:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Forwarding Entries
 */

var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var PublisherPublicKeyDigest = require('./publisher-public-key-digest.js').PublisherPublicKeyDigest;
var Name = require('./name.js').Name;

/**
 * Create a new ForwardingEntry with the optional arguments.
 * @constructor
 * @param {String} action
 * @param {Name} prefixName
 * @param {PublisherPublicKeyDigest} ndndId
 * @param {number} faceID
 * @param {number} flags
 * @param {number} lifetime in seconds
 */
var ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime) 
{
  this.action = action;
  this.prefixName = prefixName;
  this.ndndID = ndndId;
  this.faceID = faceID;
  this.flags = flags;
  this.lifetime = lifetime;
};

exports.ForwardingEntry = ForwardingEntry;

ForwardingEntry.ACTIVE         = 1;
ForwardingEntry.CHILD_INHERIT  = 2;
ForwardingEntry.ADVERTISE      = 4;
ForwardingEntry.LAST           = 8;
ForwardingEntry.CAPTURE       = 16;
ForwardingEntry.LOCAL         = 32;
ForwardingEntry.TAP           = 64;
ForwardingEntry.CAPTURE_OK   = 128;

ForwardingEntry.prototype.from_ndnb = function(
  //XMLDecoder 
  decoder) 
  //throws DecodingException
{
  decoder.readElementStartDTag(this.getElementLabel());
  if (decoder.peekDTag(NDNProtocolDTags.Action))
    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action); 
  if (decoder.peekDTag(NDNProtocolDTags.Name)) {
    this.prefixName = new Name();
    this.prefixName.from_ndnb(decoder) ;
  }
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    this.NdndId = new PublisherPublicKeyDigest();
    this.NdndId.from_ndnb(decoder);
  }
  if (decoder.peekDTag(NDNProtocolDTags.FaceID))
    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID); 
  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))
    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags); 
  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))
    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); 

  decoder.readElementClose();
};

ForwardingEntry.prototype.to_ndnb = function(
  //XMLEncoder 
  encoder) 
{
  encoder.writeElementStartDTag(this.getElementLabel());
  if (null != this.action && this.action.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  
  if (null != this.prefixName)
    this.prefixName.to_ndnb(encoder);
  if (null != this.NdndId)
    this.NdndId.to_ndnb(encoder);
  if (null != this.faceID)
    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);
  if (null != this.flags)
    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);
  if (null != this.lifetime)
    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);

  encoder.writeElementClose();         
};

ForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }

},{"./name.js":42,"./publisher-public-key-digest.js":44,"./util/ndn-protoco-id-tags.js":51}],36:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var ForwardingEntry = require('./forwarding-entry.js').ForwardingEntry;

/**
 * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for
 * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding
 * bits are changed, amended or deprecated.
 * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.
 */
var ForwardingFlags = function ForwardingFlags() 
{
  this.active = true;
  this.childInherit = true;
  this.advertise = false;
  this.last = false;
  this.capture = false;
  this.local = false;
  this.tap = false;
  this.captureOk = false;
}

exports.ForwardingFlags = ForwardingFlags;

/**
 * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.
 * @returns {number} An integer with the bits set.
 */
ForwardingFlags.prototype.getForwardingEntryFlags = function()
{
  var result = 0;
  
  if (this.active)
    result |= ForwardingEntry.ACTIVE;
  if (this.childInherit)
    result |= ForwardingEntry.CHILD_INHERIT;
  if (this.advertise)
    result |= ForwardingEntry.ADVERTISE;
  if (this.last)
    result |= ForwardingEntry.LAST;
  if (this.capture)
    result |= ForwardingEntry.CAPTURE;
  if (this.local)
    result |= ForwardingEntry.LOCAL;
  if (this.tap)
    result |= ForwardingEntry.TAP;
  if (this.captureOk)
    result |= ForwardingEntry.CAPTURE_OK;
  
  return result;
};

/**
 * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.
 * @param {number} forwardingEntryFlags An integer with the bits set.
 */
ForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)
{
  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);
  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);
  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);
  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);
  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);
  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);
  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);
  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);
};

/**
 * Get the value of the "active" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getActive = function() { return this.active; };

/**
 * Get the value of the "childInherit" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };

/**
 * Get the value of the "advertise" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };

/**
 * Get the value of the "last" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getLast = function() { return this.last; };

/**
 * Get the value of the "capture" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getCapture = function() { return this.capture; };

/**
 * Get the value of the "local" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getLocal = function() { return this.local; };

/**
 * Get the value of the "tap" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getTap = function() { return this.tap; };

/**
 * Get the value of the "captureOk" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };

/**
 * Set the value of the "active" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setActive = function(value) { this.active = value; };

/**
 * Set the value of the "childInherit" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };

/**
 * Set the value of the "advertise" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };

/**
 * Set the value of the "last" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setLast = function(value) { this.last = value; };

/**
 * Set the value of the "capture" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };

/**
 * Set the value of the "local" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setLocal = function(value) { this.local = value; };

/**
 * Set the value of the "tap" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setTap = function(value) { this.tap = value; };

/**
 * Set the value of the "captureOk" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };

},{"./forwarding-entry.js":35}],37:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents Interest Objects
 */

var Blob = require('./util/blob.js').Blob;
var Name = require('./name.js').Name;
var Exclude = require('./exclude.js').Exclude;
var PublisherPublicKeyDigest = require('./publisher-public-key-digest.js').PublisherPublicKeyDigest;
var KeyLocator = require('./key-locator.js').KeyLocator;
var WireFormat = require('./encoding/wire-format.js').WireFormat;
var customBuf = require('./buffer.js').Buffer
var LOG = require('./log.js').LOG
/**
 * Create a new Interest with the optional values.
 * 
 * @constructor
 * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the
 * other arguments.  Otherwise this is the optional name for the new Interest.
 * @param {number} minSuffixComponents
 * @param {number} maxSuffixComponents
 * @param {Buffer} publisherPublicKeyDigest
 * @param {Exclude} exclude
 * @param {number} childSelector
 * @param {number} answerOriginKind
 * @param {number} scope
 * @param {number} interestLifetimeMilliseconds in milliseconds
 * @param {Buffer} nonce
 */
var Interest = function Interest
   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude, 
    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce) 
{
  if (typeof nameOrInterest === 'object' && nameOrInterest instanceof Interest) {
    // Special case: this is a copy constructor.  Ignore all but the first argument.
    var interest = nameOrInterest;
    if (interest.name)
      // Copy the name.
      this.name = new Name(interest.name);
    this.maxSuffixComponents = interest.maxSuffixComponents;
    this.minSuffixComponents = interest.minSuffixComponents;

    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;
    this.keyLocator = new KeyLocator(interest.keyLocator);
    this.exclude = new Exclude(interest.exclude);
    this.childSelector = interest.childSelector;
    this.answerOriginKind = interest.answerOriginKind;
    this.scope = interest.scope;
    this.interestLifetime = interest.interestLifetime;
    if (interest.nonce)
      // Copy.
      this.nonce = new customBuf(interest.nonce);    
  }  
  else {
    this.name = typeof nameOrInterest === 'object' && nameOrInterest instanceof Name ?
                new Name(nameOrInterest) : new Name();
    this.maxSuffixComponents = maxSuffixComponents;
    this.minSuffixComponents = minSuffixComponents;

    this.publisherPublicKeyDigest = publisherPublicKeyDigest;
    this.keyLocator = new KeyLocator();
    this.exclude = typeof exclude === 'object' && exclude instanceof Exclude ?
                   new Exclude(exclude) : new Exclude();
    this.childSelector = childSelector;
    this.answerOriginKind = answerOriginKind;
    this.scope = scope;
    this.interestLifetime = interestLifetimeMilliseconds;
    if (nonce)
      // Copy and make sure it is a customBuf.
      this.nonce = new customBuf(nonce);
  }
};

exports.Interest = Interest;

Interest.RECURSIVE_POSTFIX = "*";

Interest.CHILD_SELECTOR_LEFT = 0;
Interest.CHILD_SELECTOR_RIGHT = 1;

Interest.ANSWER_NO_CONTENT_STORE = 0;
Interest.ANSWER_CONTENT_STORE = 1;
Interest.ANSWER_GENERATED = 2;
Interest.ANSWER_STALE = 4;    // Stale answer OK
Interest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"

Interest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;

/**
 * Return true if this.name.match(name) and the name conforms to the interest selectors.
 * @param {Name} name
 * @returns {boolean}
 */
Interest.prototype.matchesName = function(/*Name*/ name) 
{
  if (!this.name.match(name))
    return false;
    
  if (this.minSuffixComponents != null &&
      // Add 1 for the implicit digest.
      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))
    return false;
  if (this.maxSuffixComponents != null &&
      // Add 1 for the implicit digest.
      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))
    return false;
  if (this.exclude != null && name.size() > this.name.size() &&
      this.exclude.matches(name.components[this.name.size()]))
    return false;
    
  return true;
};

/**
 * @deprecated Use matchesName.
 */
Interest.prototype.matches_name = function(/*Name*/ name) 
{
  return this.matchesName(name);
};

/**
 * Return a new Interest with the same fields as this Interest.  
 */
Interest.prototype.clone = function() 
{
  return new Interest
     (this.name, this.minSuffixComponents, this.maxSuffixComponents, 
      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind, 
      this.scope, this.interestLifetime, this.nonce);
};

/**
 * Get the interest Name.
 * @returns {Name} The name.  The name size() may be 0 if not specified.
 */
Interest.prototype.getName = function() { return this.name; };

/**
 * Get the min suffix components.
 * @returns number} The min suffix components, or null if not specified.
 */
Interest.prototype.getMinSuffixComponents = function() 
{ 
  return this.minSuffixComponents; 
};

/**
 * Get the max suffix components.
 * @returns {number} The max suffix components, or null if not specified.
 */
Interest.prototype.getMaxSuffixComponents = function() 
{ 
  return this.maxSuffixComponents; 
};

/**
 * Get the interest key locator.
 * @returns {KeyLocator} The key locator. If its getType() is null, 
 * then the key locator is not specified.
 */
Interest.prototype.getKeyLocator = function() 
{ 
  return this.keyLocator; 
};

/**
 * Get the exclude object.
 * @returns {Exclude} The exclude object. If the exclude size() is zero, then
 * the exclude is not specified.
 */
Interest.prototype.getExclude = function() { return this.exclude; };

/**
 * Get the child selector.
 * @returns {number} The child selector, or null if not specified.
 */
Interest.prototype.getChildSelector = function() 
{ 
  return this.childSelector; 
};

/**
 * @deprecated Use getMustBeFresh.
 */
Interest.prototype.getAnswerOriginKind = function() 
{ 
  return this.answerOriginKind; 
};
  
  /**
   * Return true if the content must be fresh.
   * @return true if must be fresh, otherwise false.
   */
  
/**
 * Get the must be fresh flag. If not specified, the default is true.
 * @returns {boolean} The must be fresh flag.
 */
Interest.prototype.getMustBeFresh = function() 
{
  if (this.answerOriginKind == null || this.answerOriginKind < 0)
    return true;
  else
    return (this.answerOriginKind & Interest.ANSWER_STALE) == 0;
};

/**
 * Return the nonce value from the incoming interest.  If you change any of the 
 * fields in this Interest object, then the nonce value is cleared.
 * @returns {Buffer} The nonce, or null if not specified.
 */
Interest.prototype.getNonce = function() { return this.nonce; };

/**
 * Get the interest scope.
 * @returns {number} The scope, or null if not specified.
 */
Interest.prototype.getScope = function() { return this.scope; };

/**
 * Get the interest lifetime.
 * @returns {number} The interest lifetime in milliseconds, or null if not 
 * specified.
 */
Interest.prototype.getInterestLifetimeMilliseconds = function() 
{ 
  return this.interestLifetime; 
};

Interest.prototype.setName = function(name)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.name = typeof name === 'object' && name instanceof Interest ?
              new Name(name) : new Name();
};
                
Interest.prototype.setMinSuffixComponents = function(minSuffixComponents)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.minSuffixComponents = minSuffixComponents;
};

Interest.prototype.setMaxSuffixComponents = function(maxSuffixComponents)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.maxSuffixComponents = maxSuffixComponents;
};

/**
 * Set this interest to use a copy of the given exclude object. Note: You can 
 * also change this interest's exclude object modifying the object from 
 * getExclude().
 * @param {Exclude} exclude The exlcude object that is copied.
 */
Interest.prototype.setExclude = function(exclude)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.exclude = typeof exclude === 'object' && exclude instanceof Exclude ?
                 new Exclude(exclude) : new Exclude();
};

Interest.prototype.setChildSelector = function(childSelector)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.childSelector = childSelector;
};

/**
 * @deprecated Use setMustBeFresh.
 */
Interest.prototype.setAnswerOriginKind = function(answerOriginKind)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.answerOriginKind = answerOriginKind;
};

/**
 * Set the MustBeFresh flag.
 * @param {boolean} mustBeFresh True if the content must be fresh, otherwise false.
 */
Interest.prototype.setMustBeFresh = function(mustBeFresh)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  if (this.answerOriginKind == null || this.answerOriginKind < 0) {
    // It is is already the default where MustBeFresh is true. 
    if (!mustBeFresh)
      // Set answerOriginKind_ so that getMustBeFresh returns false.
      this.answerOriginKind = Interest.ANSWER_STALE; 
  }
  else {
    if (mustBeFresh)
      // Clear the stale bit.
      this.answerOriginKind &= ~Interest.ANSWER_STALE;
    else
      // Set the stale bit.
      this.answerOriginKind |= Interest.ANSWER_STALE;
  }
};

Interest.prototype.setScope = function(scope)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.scope = scope;
};

Interest.prototype.setInterestLifetimeMilliseconds = function(interestLifetimeMilliseconds)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.interestLifetime = interestLifetimeMilliseconds;
};

/**
 * @deprecated You should let the wire encoder generate a random nonce 
 * internally before sending the interest.
 */
Interest.prototype.setNonce = function(nonce)
{
  if (nonce)
    // Copy and make sure it is a customBuf.
    this.nonce = new customBuf(nonce);
  else
    this.nonce = null;
};

/**
 * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and
 * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".
 * @returns {string} The URI string.
 * @note This is an experimental feature.  See the API docs for more detail at
 * http://named-data.net/doc/ndn-ccl-api/interest.html#interest-touri-method .
 */
Interest.prototype.toUri = function() 
{  
  var selectors = "";
  
  if (this.minSuffixComponents != null)
    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;
  if (this.maxSuffixComponents != null)
    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;
  if (this.childSelector != null)
    selectors += "&ndn.ChildSelector=" + this.childSelector;
  if (this.answerOriginKind != null)
    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;
  if (this.scope != null)
    selectors += "&ndn.Scope=" + this.scope;
  if (this.interestLifetime != null)
    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;
  if (this.publisherPublicKeyDigest != null)
    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);
  if (this.nonce != null)
    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);
  if (this.exclude != null && this.exclude.size() > 0)
    selectors += "&ndn.Exclude=" + this.exclude.toUri();

  var result = this.name.toUri();
  if (selectors != "")
    // Replace the first & with ?.
    result += "?" + selectors.substr(1);
  
  return result;
};

/**
 * Encode this Interest for a particular wire format.
 * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object 
 * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().
 * @returns {Blob} The encoded buffer in a Blob object.
 */
Interest.prototype.wireEncode = function(wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  return wireFormat.encodeInterest(this);
};

/**
 * Decode the input using a particular wire format and update this Interest.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object 
 * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().
 */
Interest.prototype.wireDecode = function(input, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  // If input is a blob, get its buf().
  if (LOG > 3 ) console.log('decoding input to interes', input)
  var decodeBuffer = typeof input === 'object' && input instanceof Blob ? 
                     input.buf() : input;
  wireFormat.decodeInterest(this, decodeBuffer);
};

// Since binary-xml-wire-format.js includes this file, put these at the bottom 
// to avoid problems with cycles of require.
var BinaryXmlWireFormat = require('./encoding/binary-xml-wire-format.js').BinaryXmlWireFormat;

/**
 * @deprecated Use wireDecode(input, BinaryXmlWireFormat.get()).
 */
Interest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) 
{
  BinaryXmlWireFormat.decodeInterest(this, decoder);
};

/**
 * @deprecated Use wireEncode(BinaryXmlWireFormat.get()).
 */
Interest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder) 
{
  BinaryXmlWireFormat.encodeInterest(this, encoder);
};

/**
 * @deprecated Use wireEncode.  If you need binary XML, use
 * wireEncode(BinaryXmlWireFormat.get()).
 */
Interest.prototype.encode = function(wireFormat) 
{
  return this.wireEncode(BinaryXmlWireFormat.get()).buf();
};

/**
 * @deprecated Use wireDecode.  If you need binary XML, use
 * wireDecode(input, BinaryXmlWireFormat.get()).
 */
Interest.prototype.decode = function(input, wireFormat) 
{
  this.wireDecode(input, BinaryXmlWireFormat.get())
};

},{"./buffer.js":14,"./encoding/binary-xml-wire-format.js":20,"./encoding/wire-format.js":31,"./exclude.js":32,"./key-locator.js":38,"./log.js":40,"./name.js":42,"./publisher-public-key-digest.js":44,"./util/blob.js":48}],38:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an NDN KeyLocator object.
 */

var Name = require('./name.js').Name;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var PublisherID = require('./publisher-id.js').PublisherID;
var customBuf = require('./buffer.js').Buffer
var LOG = require('./log.js').Log.LOG;

/**
 * KeyLocator
 */
var KeyLocatorType = {
  KEYNAME: 1,
  KEY_LOCATOR_DIGEST: 2,
  KEY: 3,
  CERTIFICATE: 4
};

exports.KeyLocatorType = KeyLocatorType;

/**
 * @constructor
 */
var KeyLocator = function KeyLocator(input,type) 
{ 
  if (typeof input === 'object' && input instanceof KeyLocator) {
    // Copy from the input KeyLocator.
    this.type = input.type;
    this.keyName = new KeyName();
    if (input.keyName != null) {
      this.keyName.contentName = input.keyName.contentName == null ? 
        null : new Name(input.keyName.contentName);
      this.keyName.publisherID = input.keyName.publisherID;
    }
    this.keyData = input.keyData == null ? null : new customBuf(input.keyData);
    this.publicKey = input.publicKey == null ? null : new customBuf(input.publicKey);
    this.certificate = input.certificate == null ? null : new customBuf(input.certificate);
  }
  else {
    this.type = type;
    this.keyName = new KeyName();

    if (type == KeyLocatorType.KEYNAME)
      this.keyName = input;
    else if (type == KeyLocatorType.KEY_LOCATOR_DIGEST)
      this.keyData = new customBuf(input);
    else if (type == KeyLocatorType.KEY) {
      this.keyData = new customBuf(input);
      // Set for backwards compatibility.
      this.publicKey = this.keyData;
    }
    else if (type == KeyLocatorType.CERTIFICATE) {
      this.keyData = new customBuf(input);
      // Set for backwards compatibility.
      this.certificate = this.keyData;
    }
  }
};

exports.KeyLocator = KeyLocator;

/**
 * Get the key locator type. If KeyLocatorType.KEYNAME, you may also
 * getKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you may also
 * getKeyData() to get the digest.
 * @returns {number} The key locator type, or null if not specified.
 */
KeyLocator.prototype.getType = function() { return this.type; };

/**
 * Get the key name.  This is meaningful if getType() is KeyLocatorType.KEYNAME.
 * @returns {Name} The key name. If not specified, the Name is empty.
 */
KeyLocator.prototype.getKeyName = function() 
{ 
  if (this.keyName == null)
    this.keyName = new KeyName();
  if (this.keyName.contentName == null)
    this.keyName.contentName = new Name();
  
  return this.keyName.contentName;
};

/**
 * Get the key data. If getType() is KeyLocatorType.KEY_LOCATOR_DIGEST, this is 
 * the digest bytes. If getType() is KeyLocatorType.KEY, this is the DER 
 * encoded public key. If getType() is KeyLocatorType.CERTIFICATE, this is the 
 * DER encoded certificate. 
 * @returns {Buffer} The key data, or null if not specified.
 */
KeyLocator.prototype.getKeyData = function() 
{ 
  if (this.type == KeyLocatorType.KEY)
    return this.publicKey;
  else if (this.type == KeyLocatorType.CERTIFICATE)
    return this.certificate;
  else
    return this.keyData;
};

/**
 * Set the key locator type.  If KeyLocatorType.KEYNAME, you must also
 * setKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you must also
 * setKeyData() to the digest.
 * @param {number} type The key locator type.  If null, the type is unspecified.
 */
KeyLocator.prototype.setType = function(type) { this.type = type; }; 

/**
 * Set key name to a copy of the given Name.  This is the name if getType() 
 * is KeyLocatorType.KEYNAME.
 * @param {Name} name The key name which is copied.
 */
KeyLocator.prototype.setKeyName = function(name) 
{ 
  if (this.keyName == null)
    this.keyName = new KeyName();
  
  this.keyName.contentName = typeof name === 'object' && name instanceof Name ?
                             new Name(name) : new Name(); 
}; 

/**
 * Set the key data to the given value. This is the digest bytes if getType() is 
 * KeyLocatorType.KEY_LOCATOR_DIGEST.
 * @param {Buffer} keyData The array with the key data bytes.
 */
KeyLocator.prototype.setKeyData = function(keyData)
{
  var value = keyData;
  if (value != null)
    // Make a copy.
    value = new customBuf(value);
  
  this.keyData = value;
  // Set for backwards compatibility.
  this.publicKey = value;
  this.certificate = value;
};

/**
 * Clear the keyData and set the type to none.
 */
KeyLocator.prototype.clear = function() 
{
  this.type = null;
  this.keyName = null;
  this.keyData = null;
  this.publicKey = null;
  this.certificate = null;
};

KeyLocator.prototype.from_ndnb = function(decoder) {

  decoder.readElementStartDTag(this.getElementLabel());

  if (decoder.peekDTag(NDNProtocolDTags.Key)) 
  {
    try {
      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);
      // This is a DER-encoded SubjectPublicKeyInfo.
      
      //TODO FIX THIS, This should create a Key Object instead of keeping bytes

      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);
      this.type = KeyLocatorType.KEY;    

      if (LOG > 4) console.log('PUBLIC KEY FOUND: '+ this.publicKey);
    } 
    catch (e) {
      throw new Error("Cannot parse key: ", e);
    } 

    if (null == this.publicKey)
      throw new Error("Cannot parse key: ");
  } 
  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {
    try {
      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);
      
      /*
       * Certificates not yet working
       */
      
      this.certificate = encodedCert;
      this.type = KeyLocatorType.CERTIFICATE;

      if (LOG > 4) console.log('CERTIFICATE FOUND: '+ this.certificate);      
    } 
    catch (e) {
      throw new Error("Cannot decode certificate: " +  e);
    }
    if (null == this.certificate)
      throw new Error("Cannot parse certificate! ");
  } else  {
    this.type = KeyLocatorType.KEYNAME;
    
    this.keyName = new KeyName();
    this.keyName.from_ndnb(decoder);
  }
  decoder.readElementClose();
};  

KeyLocator.prototype.to_ndnb = function(encoder) 
{
  if (LOG > 4) console.log('type is is ' + this.type);

  if (this.type == KeyLocatorType.KEY_LOCATOR_DIGEST)
    // encodeSignedInfo already encoded this as the publisherPublicKeyDigest,
    //   so do nothing here.
    return;

  encoder.writeElementStartDTag(this.getElementLabel());
  
  if (this.type == KeyLocatorType.KEY) {
    if (LOG > 5) console.log('About to encode a public key' +this.publicKey);
    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);  
  } 
  else if (this.type == KeyLocatorType.CERTIFICATE) {  
    try {
      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);
    } 
    catch (e) {
      throw new Error("CertificateEncodingException attempting to write key locator: " + e);
    }    
  } 
  else if (this.type == KeyLocatorType.KEYNAME)
    this.keyName.to_ndnb(encoder);

  encoder.writeElementClose();
};

KeyLocator.prototype.getElementLabel = function() 
{
  return NDNProtocolDTags.KeyLocator; 
};

/**
 * KeyName is only used by KeyLocator.
 * @constructor
 */
var KeyName = function KeyName() 
{
  this.contentName = new Name();  //contentName
  this.publisherID = this.publisherID;  //publisherID
};

exports.KeyName = KeyName;

KeyName.prototype.from_ndnb = function(decoder) 
{
  decoder.readElementStartDTag(this.getElementLabel());

  this.contentName = new Name();
  this.contentName.from_ndnb(decoder);
  
  if (LOG > 4) console.log('KEY NAME FOUND: ');
  
  if (PublisherID.peek(decoder)) {
    this.publisherID = new PublisherID();
    this.publisherID.from_ndnb(decoder);
  }
  
  decoder.readElementClose();
};

KeyName.prototype.to_ndnb = function(encoder)
{
  encoder.writeElementStartDTag(this.getElementLabel());
  
  this.contentName.to_ndnb(encoder);
  if (null != this.publisherID)
    this.publisherID.to_ndnb(encoder);

  encoder.writeElementClose();       
};
  
KeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };


},{"./buffer.js":14,"./log.js":40,"./name.js":42,"./publisher-id.js":43,"./util/ndn-protoco-id-tags.js":51}],39:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Key Objects
 */
var customBuf = require('./buffer.js').Buffer
var LOG = require('./log.js').Log.LOG;

/**
 * @constructor
 */
/**
 * Key
 */
var Key = function Key() 
{
  this.publicKeyDer = null;     // customBuf
  this.publicKeyDigest = null;  // customBuf
  this.publicKeyPem = null;     // String
  this.privateKeyPem = null;    // String
};

exports.Key = Key;

/**
 * Helper functions to read Key fields
 * TODO: generateRSA()
 */

Key.prototype.publicToDER = function() 
{
  return this.publicKeyDer;  // customBuf
};

Key.prototype.privateToDER = function() 
{
  // Remove the '-----XXX-----' from the beginning and the end of the key
  // and also remove any \n in the key string
  var lines = this.privateKeyPem.split('\n');
  priKey = "";
  for (var i = 1; i < lines.length - 1; i++)
    priKey += lines[i];
  
  return new customBuf(priKey, 'base64');    
};

Key.prototype.publicToPEM = function() 
{
  return this.publicKeyPem;
};

Key.prototype.privateToPEM = function() 
{
  return this.privateKeyPem;
};

Key.prototype.getKeyID = function() 
{
  return this.publicKeyDigest;
};

exports.Key = Key;

Key.prototype.readDerPublicKey = function(/*Buffer*/pub_der) 
{
  if (LOG > 4) console.log("Encode DER public key:\n" + pub_der.toString('hex'));

  this.publicKeyDer = pub_der;

  var hash = require("./crypto.js").createHash('sha256');
  hash.update(this.publicKeyDer);
  this.publicKeyDigest = new customBuf(hash.digest());
    
  var keyStr = pub_der.toString('base64'); 
  var keyPem = "-----BEGIN PUBLIC KEY-----\n";
  for (var i = 0; i < keyStr.length; i += 64)
  keyPem += (keyStr.substr(i, 64) + "\n");
  keyPem += "-----END PUBLIC KEY-----";
  this.publicKeyPem = keyPem;

  if (LOG > 4) console.log("Convert public key to PEM format:\n" + this.publicKeyPem);
};

/**
 * Load RSA key pair from PEM-encoded strings.
 * Will throw an Error if both 'pub' and 'pri' are null.
 */
Key.prototype.fromPemString = function(pub, pri) 
{
  if (pub == null && pri == null)
    throw new Error('Cannot create Key object if both public and private PEM string is empty.');

  // Read public key
  if (pub != null) {
    this.publicKeyPem = pub;
    if (LOG > 4) console.log("Key.publicKeyPem: \n" + this.publicKeyPem);
  
    // Remove the '-----XXX-----' from the beginning and the end of the public key
    // and also remove any \n in the public key string
    var lines = pub.split('\n');
    pub = "";
    for (var i = 1; i < lines.length - 1; i++)
      pub += lines[i];
    this.publicKeyDer = new customBuf(pub, 'base64');
    if (LOG > 4) console.log("Key.publicKeyDer: \n" + this.publicKeyDer.toString('hex'));
  
    var hash = require("./crypto.js").createHash('sha256');
    hash.update(this.publicKeyDer);
    this.publicKeyDigest = new customBuf(hash.digest());
    if (LOG > 4) console.log("Key.publicKeyDigest: \n" + this.publicKeyDigest.toString('hex'));
  }
    
  // Read private key
  if (pri != null) {
    this.privateKeyPem = pri;
    if (LOG > 4) console.log("Key.privateKeyPem: \n" + this.privateKeyPem);
  }
};

Key.prototype.fromPem = Key.prototype.fromPemString;

/**
 * Static method that create a Key object.
 * Parameter 'obj' is a JSON object that has two properties:
 *   pub: the PEM string for the public key
 *   pri: the PEM string for the private key
 * Will throw an Error if both obj.pub and obj.pri are null.
 */
Key.createFromPEM = function(obj) 
{
    var key = new Key();
    key.fromPemString(obj.pub, obj.pri);
    return key;
};

},{"./buffer.js":14,"./crypto.js":14,"./log.js":40}],40:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * The Log class holds the global static variable LOG.
 */
var Log = function Log() 
{
}

exports.Log = Log;

/**
 * LOG is the level for logging debugging statements.  0 means no log messages. 
 * @type Number
 */
Log.LOG = 0;

},{}],41:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an NDN Data MetaInfo object.
 */

var customBuf = require('./buffer.js').Buffer
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var Blob = require('./util/blob.js').Blob;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var KeyLocator = require('./key-locator.js').KeyLocator;
var KeyLocatorType = require('./key-locator.js').KeyLocatorType;
var Name = require('./name.js').Name;
var PublisherPublicKeyDigest = require('./publisher-public-key-digest.js').PublisherPublicKeyDigest;
var NDNTime = require('./util/ndn-time.js').NDNTime;
var globalKeyManager = require('./security/key-manager.js').globalKeyManager;
var LOG = require('./log.js').Log.LOG;

var ContentType = {
  BLOB:0,
  // ContentType DATA is deprecated.  Use ContentType.BLOB .
  DATA:0, 
  LINK:1, 
  KEY: 2, 
  // ContentType ENCR, GONE and NACK are not supported in NDN-TLV encoding and are deprecated.
  ENCR:3, 
  GONE:4, 
  NACK:5
};

exports.ContentType = ContentType;

/**
 * Create a new MetaInfo with the optional values.
 * @constructor
 */
var MetaInfo = function MetaInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID, skipSetFields) 
{
  if (typeof publisherOrMetaInfo === 'object' && 
      publisherOrMetaInfo instanceof MetaInfo) {
    // Copy values.
    var metaInfo = publisherOrMetaInfo;
    this.publisher = metaInfo.publisher;
    this.timestamp = metaInfo.timestamp;
    this.type = metaInfo.type;
    this.locator = metaInfo.locator == null ? 
      new KeyLocator() : new KeyLocator(metaInfo.locator);
    this.freshnessSeconds = metaInfo.freshnessSeconds;
    this.finalBlockID = metaInfo.finalBlockID;
  }
  else {
    this.publisher = publisherOrMetaInfo; //publisherPublicKeyDigest
    this.timestamp = timestamp; // NDN Time
    this.type = type; // ContentType
    this.locator = locator == null ? new KeyLocator() : new KeyLocator(locator);
    this.freshnessSeconds = freshnessSeconds; // Integer
    this.finalBlockID = finalBlockID; //byte array

    if (!skipSetFields)
      this.setFields();
  }
};

exports.MetaInfo = MetaInfo;

/**
 * Get the content type.
 * @returns {an int from ContentType} The content type.
 */
MetaInfo.prototype.getType = function()
{
  return this.type;
};

/**
 * Get the freshness period.
 * @returns {number} The freshness period in milliseconds, or null if not 
 * specified.
 */
MetaInfo.prototype.getFreshnessPeriod = function()
{
  // Use attribute freshnessSeconds for backwards compatibility.
  if (this.freshnessSeconds == null || this.freshnessSeconds < 0)
    return null;
  else
    // Convert to milliseconds.
    return this.freshnessSeconds * 1000.0;
};

/**
 * Get the final block ID.
 * @returns {Buffer} The final block ID or null if not specified.
 */
MetaInfo.prototype.getFinalBlockID = function()
{
  // TODO: finalBlockID should be a Name.Component, not customBuf.
  return this.finalBlockID;
};

/**
 * Set the content type.
 * @param {an int from ContentType} type The content type.  If null, this 
 * uses ContentType.BLOB.
 */
MetaInfo.prototype.setType = function(type)
{
  this.type = type == null || type < 0 ? ContentType.BLOB : type;
};

/**
 * Set the freshness period.
 * @param {type} freshnessPeriod The freshness period in milliseconds, or null
 * for not specified.
 */
MetaInfo.prototype.setFreshnessPeriod = function(freshnessPeriod)
{
  // Use attribute freshnessSeconds for backwards compatibility.
  if (freshnessPeriod == null || freshnessPeriod < 0)
    this.freshnessSeconds = null;
  else
    // Convert from milliseconds.
    this.freshnessSeconds = freshnessPeriod / 1000.0;
};

MetaInfo.prototype.setFinalBlockID = function(finalBlockID)
{
  // TODO: finalBlockID should be a Name.Component, not customBuf.
  if (finalBlockID == null)
    this.finalBlockID = null;
  else if (typeof finalBlockID === 'object' && finalBlockID instanceof Blob)
    this.finalBlockID = finalBlockID.buf();
  else if (typeof finalBlockID === 'object' && finalBlockID instanceof Name.Component)
    this.finalBlockID = finalBlockID.getValue();
  else 
    this.finalBlockID = new customBuf(finalBlockID);
};

MetaInfo.prototype.setFields = function() 
{
  var key = globalKeyManager.getKey();
  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());

  var d = new Date();
    
  var time = d.getTime();  

  this.timestamp = new NDNTime(time);
    
  if (LOG > 4) console.log('TIME msec is');

  if (LOG > 4) console.log(this.timestamp.msec);

  //DATA
  this.type = ContentType.BLOB;
  
  if (LOG > 4) console.log('PUBLIC KEY TO WRITE TO DATA PACKET IS ');
  if (LOG > 4) console.log(key.publicToDER().toString('hex'));

  this.locator = new KeyLocator(key.getKeyID(), KeyLocatorType.KEY_LOCATOR_DIGEST);
};

MetaInfo.prototype.from_ndnb = function(decoder) 
{
  decoder.readElementStartDTag(this.getElementLabel());
  
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    if (LOG > 4) console.log('DECODING PUBLISHER KEY');
    this.publisher = new PublisherPublicKeyDigest();
    this.publisher.from_ndnb(decoder);
  }

  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {
    if (LOG > 4) console.log('DECODING TIMESTAMP');
    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);
  }

  if (decoder.peekDTag(NDNProtocolDTags.Type)) {
    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);
    
    if (LOG > 4) console.log('Binary Type of of Signed Info is '+binType);

    this.type = binType;
    
    //TODO Implement type of Key Reading
    if (null == this.type)
      throw new Error("Cannot parse signedInfo type: bytes.");
  } 
  else
    this.type = ContentType.DATA; // default
  
  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {
    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);
    if (LOG > 4) console.log('FRESHNESS IN SECONDS IS '+ this.freshnessSeconds);
  }
  
  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {
    if (LOG > 4) console.log('DECODING FINAL BLOCKID');
    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);
  }
  
  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {
    if (LOG > 4) console.log('DECODING KEY LOCATOR');
    this.locator = new KeyLocator();
    this.locator.from_ndnb(decoder);
  }
      
  decoder.readElementClose();
};

/**
 * Encode this MetaInfo in ndnb, using the given keyLocator instead of the
 * locator in this object.
 * @param {BinaryXMLEncoder} encoder The encoder.
 * @param {KeyLocator} keyLocator The key locator to use (from 
 * Data.getSignatureOrMetaInfoKeyLocator).
 */
MetaInfo.prototype.to_ndnb = function(encoder, keyLocator)  {
  if (!this.validate())
    throw new Error("Cannot encode : field values missing.");

  encoder.writeElementStartDTag(this.getElementLabel());
  
  if (null != this.publisher) {
    // We have a publisherPublicKeyDigest, so use it.
    if (LOG > 3) console.log('ENCODING PUBLISHER KEY' + this.publisher.publisherPublicKeyDigest);
    this.publisher.to_ndnb(encoder);
  }
  else {
    if (null != keyLocator &&
        keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && 
        keyLocator.getKeyData() != null &&
        keyLocator.getKeyData().length > 0)
      // We have a TLV-style KEY_LOCATOR_DIGEST, so encode as the
      //   publisherPublicKeyDigest.
      encoder.writeDTagElement
        (NDNProtocolDTags.PublisherPublicKeyDigest, keyLocator.getKeyData());
  }

  if (null != this.timestamp)
    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);
  
  if (null != this.type && this.type != 0)
    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);
  
  if (null != this.freshnessSeconds)
    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);

  if (null != this.finalBlockID)
    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);

  if (null != keyLocator)
    keyLocator.to_ndnb(encoder);

  encoder.writeElementClose();       
};
  
MetaInfo.prototype.valueToType = function() 
{
  return null;  
};

MetaInfo.prototype.getElementLabel = function() { 
  return NDNProtocolDTags.SignedInfo;
};

MetaInfo.prototype.validate = function() 
{
  // We don't do partial matches any more, even though encoder/decoder
  // is still pretty generous.
  if (null == this.timestamp)
    return false;
  return true;
};

/**
 * @deprecated Use new MetaInfo.
 */
var SignedInfo = function SignedInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID) 
{
  // Call the base constructor.
  MetaInfo.call(this, publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID); 
}

// Set skipSetFields true since we only need the prototype functions.
SignedInfo.prototype = new MetaInfo(null, null, null, null, null, null, true);

exports.SignedInfo = SignedInfo;

},{"./buffer.js":14,"./encoding/binary-xml-decoder.js":17,"./encoding/binary-xml-encoder.js":18,"./key-locator.js":38,"./log.js":40,"./name.js":42,"./publisher-public-key-digest.js":44,"./security/key-manager.js":45,"./util/blob.js":48,"./util/ndn-protoco-id-tags.js":51,"./util/ndn-time.js":52}],42:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents a Name as an array of components where each is a byte array.
 */
 
var Blob = require('./util/blob.js').Blob;
var DataUtils = require('./encoding/data-utils.js').DataUtils;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var customBuf = require('./buffer.js').Buffer
var LOG = require('./log.js').Log.LOG;

/**
 * Create a new Name from components.
 * 
 * @constructor
 * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.  
 * Otherwise it is an array of components which are appended according to Name.append, so
 * convert each and store it as an array of customBuf.  If a component is a string, encode as utf8.
 */
var Name = function Name(components) 
{
  if (typeof components == 'string') {    
    if (LOG > 3) console.log('Content Name String ' + components);
    this.components = Name.createNameArray(components);
  }
  else if (typeof components === 'object') {    
    this.components = [];
    if (components instanceof Name)
      this.append(components);
    else {
      for (var i = 0; i < components.length; ++i)
        this.append(components[i]);
    }
  }
  else if (components == null)
    this.components = [];
  else
    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");
};

exports.Name = Name;

/**
 * 
 * @constructor
 * Create a new Name.Component with a copy of the given value.
 * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don't unescape).
 */
Name.Component = function NameComponent(value) 
{
  if (typeof value === 'string')
    this.value = DataUtils.stringToUtf8Array(value);
  else if (typeof value === 'object' && value instanceof Name.Component)
    this.value = new customBuf(value.value);
  else if (typeof value === 'object' && value instanceof Blob)
    this.value = new customBuf(value.buf());
  else if (typeof value === 'object' && value instanceof customBuf)
    this.value = new customBuf(value);
  else if (typeof value === 'object' && typeof ArrayBuffer !== 'undefined' &&  value instanceof ArrayBuffer) {
    // Make a copy.  Don't use ArrayBuffer.slice since it isn't always supported.                                                      
    this.value = new customBuf(new ArrayBuffer(value.byteLength));
    this.value.set(new customBuf(value));
  }
  else if (typeof value === 'object')
    // Assume value is a byte array.  We can't check instanceof Array because
    //   this doesn't work in JavaScript if the array comes from a different module.
    this.value = new customBuf(value);
  else 
    throw new Error("Name.Component constructor: Invalid type");
}

/**
 * Get the component value.
 * @returns {Buffer} The component value.
 */
Name.Component.prototype.getValue = function() 
{
  return this.value;
}

/**
 * Convert this component value to a string by escaping characters according to the NDN URI Scheme.
 * This also adds "..." to a value with zero or more ".".
 * @returns {string} The escaped string.
 */
Name.Component.prototype.toEscapedString = function() 
{
  return Name.toEscapedString(this.value);
}

/**
 * Check if this is the same component as other.
 * @param {Name.Component} other The other Component to compare with.
 * @returns {Boolean} true if the components are equal, otherwise false.
 */
Name.Component.prototype.equals = function(other) 
{
  return DataUtils.arraysEqual(this.value, other.value);
}

/**
 * @deprecated Use toUri.
 */
Name.prototype.getName = function() 
{
  return this.toUri();
};

/** Parse uri as a URI and return an array of customBuf components.
 */
Name.createNameArray = function(uri) 
{
  uri = uri.trim();
  if (uri.length <= 0)
    return [];

  var iColon = uri.indexOf(':');
  if (iColon >= 0) {
    // Make sure the colon came before a '/'.
    var iFirstSlash = uri.indexOf('/');
    if (iFirstSlash < 0 || iColon < iFirstSlash)
      // Omit the leading protocol such as ndn:
      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();
  }
    
  if (uri[0] == '/') {
    if (uri.length >= 2 && uri[1] == '/') {
      // Strip the authority following "//".
      var iAfterAuthority = uri.indexOf('/', 2);
      if (iAfterAuthority < 0)
        // Unusual case: there was only an authority.
        return [];
      else
        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();
    }
    else
      uri = uri.substr(1, uri.length - 1).trim();
  }

  var array = uri.split('/');
    
  // Unescape the components.
  for (var i = 0; i < array.length; ++i) {
    var value = Name.fromEscapedString(array[i]);
        
    if (value == null) {
      // Ignore the illegal componenent.  This also gets rid of a trailing '/'.
      array.splice(i, 1);
      --i;  
      continue;
    }
    else
      array[i] = new Name.Component(value);
  }

  return array;
};

Name.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)  
{
  decoder.readElementStartDTag(this.getElementLabel());
    
  this.components = [];

  while (decoder.peekDTag(NDNProtocolDTags.Component))
    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));
    
  decoder.readElementClose();
};

Name.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  
{    
  if (this.components == null) 
    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");

  encoder.writeElementStartDTag(this.getElementLabel());
  var count = this.size();
  for (var i=0; i < count; i++)
    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());
  
  encoder.writeElementClose();
};

Name.prototype.getElementLabel = function() 
{
  return NDNProtocolDTags.Name;
};

/**
 * Convert the component to a customBuf and append to this Name.
 * Return this Name object to allow chaining calls to add.
 * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don't unescape).
 * @returns {Name}
 */
Name.prototype.append = function(component) 
{
  if (typeof component == 'object' && component instanceof Name) {
    var components;
    if (component == this)
      // special case, when we need to create a copy
      components = this.components.slice(0, this.components.length);
    else
      components = component.components;
      
    for (var i = 0; i < components.length; ++i)
      this.components.push(new Name.Component(components[i]));
  }
  else
    // Just use the Name.Component constructor.
    this.components.push(new Name.Component(component));

  return this;
};

/**
 * @deprecated Use append.
 */
Name.prototype.add = function(component)
{
  return this.append(component);
};

/**
 * Clear all the components.
 */
Name.prototype.clear = function()
{
  this.components = [];  
};

/**
 * Return the escaped name string according to "NDNx URI Scheme".
 * @returns {String}
 */
Name.prototype.toUri = function() 
{  
  if (this.size() == 0)
    return "/";
    
  var result = "";
  
  for (var i = 0; i < this.size(); ++i)
    result += "/"+ Name.toEscapedString(this.components[i].getValue());
  
  return result;  
};

/**
 * @deprecated Use toUri.
 */
Name.prototype.to_uri = function() 
{
  return this.toUri();
};

/**
 * Append a component with the encoded segment number.
 * @param {number} segment The segment number.
 * @returns {Name} This name so that you can chain calls to append.
 */
Name.prototype.appendSegment = function(segment) 
{
  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(segment);
  // Put a 0 byte in front.
  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);
  segmentNumberComponent[0] = 0;
  segmentNumberBigEndian.copy(segmentNumberComponent, 1);

  this.components.push(new Name.Component(segmentNumberComponent));
  return this;
};

/**
 * Append a component with the encoded version number.
 * Note that this encodes the exact value of version without converting from a 
 * time representation.
 * @param {number} version The version number.
 * @returns {Name} This name so that you can chain calls to append.
 */
Name.prototype.appendVersion = function(version) 
{
  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(version);
  // Put a 0 byte in front.
  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);
  segmentNumberComponent[0] = 0xfD;
  segmentNumberBigEndian.copy(segmentNumberComponent, 1);

  this.components.push(new Name.Component(segmentNumberComponent));
  return this;
};

/**
 * @deprecated Use appendSegment.
 */
Name.prototype.addSegment = function(number) 
{
  return this.appendSegment(number);
};

/**
 * Get a new name, constructed as a subset of components.
 * @param {number} iStartComponent The index if the first component to get.
 * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,
 * return components starting at iStartComponent until the end of the name.
 * @returns {Name} A new name.
 */
Name.prototype.getSubName = function(iStartComponent, nComponents)
{
  if (nComponents == undefined)
    nComponents = this.components.length - iStartComponent;
  
  var result = new Name();

  var iEnd = iStartComponent + nComponents;
  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)
    result.components.push(this.components[i]);

  return result;  
};

/**
 * Return a new Name with the first nComponents components of this Name.
 * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up
 * to name.size() - N. For example getPrefix(-1) returns the name without the final component.
 * @returns {Name} A new name.
 */
Name.prototype.getPrefix = function(nComponents) 
{
  if (nComponents < 0)
    return this.getSubName(0, this.components.length + nComponents);
  else
    return this.getSubName(0, nComponents);
};

/**
 * @brief Get prefix of the name, containing less minusComponents right components
 * @param minusComponents number of components to cut from the back
 */
Name.prototype.cut = function(minusComponents) 
{
  return new Name(this.components.slice(0, this.components.length - minusComponents));
};

/**
 * Return the number of name components.
 * @returns {number}
 */
Name.prototype.size = function() 
{
  return this.components.length;
};

/**
 * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().
 * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component
 * at size() - (-i).
 * @returns {Name.Component}
 */
Name.prototype.get = function(i) 
{
  if (i >= 0) {
    if (i >= this.components.length)
      throw new Error("Name.get: Index is out of bounds");

    return new Name.Component(this.components[i]);
  }
  else {
    // Negative index.
    if (i < -this.components.length)
      throw new Error("Name.get: Index is out of bounds");

    return new Name.Component(this.components[this.components.length - (-i)]);
  }
};

/**
 * @deprecated Use size().
 */
Name.prototype.getComponentCount = function() 
{
  return this.components.length;
};

/**
 * @deprecated To get just the component value, use get(i).getValue().
 */
Name.prototype.getComponent = function(i) 
{
  return new customBuf(this.components[i].getValue());
};

/**
 * The "file name" in a name is the last component that isn't blank and doesn't start with one of the
 *   special marker octets (for version, etc.).  Return the index in this.components of
 *   the file name, or -1 if not found.
 */
Name.prototype.indexOfFileName = function() 
{
  for (var i = this.size() - 1; i >= 0; --i) {
    var component = this.components[i].getValue();
    if (component.length <= 0)
      continue;
        
    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 || 
        (component[0] >= 0xF5 && component[0] <= 0xFF))
      continue;
        
    return i;
  }
    
  return -1;
};

/**
 * Return true if this Name has the same components as name.
 */
Name.prototype.equals = function(name) 
{
  if (this.components.length != name.components.length)
    return false;
    
  // Start from the last component because they are more likely to differ.
  for (var i = this.components.length - 1; i >= 0; --i) {
    if (!this.components[i].equals(name.components[i]))
      return false;
  }
    
  return true;
};

/**
 * @deprecated Use equals.
 */
Name.prototype.equalsName = function(name)
{
  return this.equals(name);
};

/**
 * Find the last component in name that has a ContentDigest and return the digest value as customBuf, 
 *   or null if not found.  See Name.getComponentContentDigestValue.
 */
Name.prototype.getContentDigestValue = function() 
{
  for (var i = this.size() - 1; i >= 0; --i) {
    var digestValue = Name.getComponentContentDigestValue(this.components[i]);
    if (digestValue != null)
      return digestValue;
  }
    
  return null;
};

/**
 * If component is a ContentDigest, return the digest value as a customBuf slice (don't modify!).
 * If not a ContentDigest, return null.
 * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.
 */
Name.getComponentContentDigestValue = function(component) 
{
  if (typeof component == 'object' && component instanceof Name.Component)
    component = component.getValue();

  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length; 
  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.
  if (component.length == digestComponentLength &&
      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length), 
                            Name.ContentDigestPrefix) &&
      DataUtils.arraysEqual(component.slice
         (component.length - Name.ContentDigestSuffix.length, component.length),
                            Name.ContentDigestSuffix))
   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);
 else
   return null;
};

// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB. 
Name.ContentDigestPrefix = new customBuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);
Name.ContentDigestSuffix = new customBuf([0x00]);


/**
 * Return value as an escaped string according to "NDNx URI Scheme".
 * We can't use encodeURIComponent because that doesn't encode all the characters we want to.
 * @param {Buffer|Name.Component} component The value or Name.Component to escape.
 * @returns {string} The escaped string.
 */
Name.toEscapedString = function(value) 
{
  if (typeof value == 'object' && value instanceof Name.Component)
    value = value.getValue();
  
  var result = "";
  var gotNonDot = false;
  for (var i = 0; i < value.length; ++i) {
    if (value[i] != 0x2e) {
      gotNonDot = true;
      break;
    }
  }
  if (!gotNonDot) {
    // Special case for component of zero or more periods.  Add 3 periods.
    result = "...";
    for (var i = 0; i < value.length; ++i)
      result += ".";
  }
  else {
    for (var i = 0; i < value.length; ++i) {
      var x = value[i];
      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)
      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||
          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d || 
          x == 0x2e || x == 0x5f)
        result += String.fromCharCode(x);
      else
        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();
    }
  }
  return result;
};

/**
 * Return a customBuf byte array by decoding the escapedString according to "NDNx URI Scheme".
 * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.
 * @param {string} escapedString The escaped string to decode.
 * @returns {Buffer} The byte array, or null which means to skip the component in the name.
 */
Name.fromEscapedString = function(escapedString) 
{
  var value = unescape(escapedString.trim());
        
  if (value.match(/[^.]/) == null) {
    // Special case for value of only periods.  
    if (value.length <= 2)
      // Zero, one or two periods is illegal.  Ignore this componenent to be
      //   consistent with the C implementation.
      return null;
    else
      // Remove 3 periods.
      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));
  }
  else
    return DataUtils.toNumbersFromString(value);
};

/**
 * Return true if the N components of this name are the same as the first N components of the given name.
 * @param {Name} name The name to check.
 * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.
 */
Name.prototype.match = function(name) 
{
  var i_name = this.components;
  var o_name = name.components;

  // This name is longer than the name we are checking it against.
  if (i_name.length > o_name.length)
    return false;

  // Check if at least one of given components doesn't match.
  for (var i = 0; i < i_name.length; ++i) {
    if (!i_name[i].equals(o_name[i]))
      return false;
  }

  return true;
};

},{"./buffer.js":14,"./encoding/binary-xml-decoder.js":17,"./encoding/binary-xml-encoder.js":18,"./encoding/data-utils.js":21,"./log.js":40,"./util/blob.js":48,"./util/ndn-protoco-id-tags.js":51}],43:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Publisher and PublisherType Objects
 */

var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var NDNProtocolDTagsStrings = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTagsStrings;
var DecodingException = require('./encoding/decoding-exception.js').DecodingException;

/**
 * @constructor
 */
var PublisherType = function PublisherType(tag) 
{
  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;
  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;
  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;
  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;

  this.Tag = tag;
}; 

/**
 * @constructor
 */
var PublisherID = function PublisherID() 
{
  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";
  this.PUBLISHER_ID_LEN = 256/8;
    
  //TODO, implement publisherID creation and key creation

  //TODO implement generatePublicKeyDigest
  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray
    
  //TODO implement generate key
  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);
  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type   
};

exports.PublisherID = PublisherID;

PublisherID.prototype.from_ndnb = function(decoder) 
{    
  // We have a choice here of one of 4 binary element types.
  var nextTag = PublisherID.peekAndGetNextDTag(decoder);
    
  this.publisherType = new PublisherType(nextTag); 
    
  if (nextTag < 0)
    throw new Error("Invalid publisher ID, got unexpected type");

  this.publisherID = decoder.readBinaryDTagElement(nextTag);
  if (null == this.publisherID)
    throw new DecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));
};

PublisherID.prototype.to_ndnb = function(encoder) 
{
  if (!this.validate())
    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");

  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);
};

/**
 * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.
 * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.
 * @returns {number} The PublisherID DTag or -1 if it is not one of them.
 */
PublisherID.peekAndGetNextDTag = function(decoder) 
{
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))
    return             NDNProtocolDTags.PublisherPublicKeyDigest;
  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))
    return             NDNProtocolDTags.PublisherCertificateDigest;
  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))
    return             NDNProtocolDTags.PublisherIssuerKeyDigest;
  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))
    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;
  
  return -1;
};
  
PublisherID.peek = function(/* XMLDecoder */ decoder) 
{
  return PublisherID.peekAndGetNextDTag(decoder) >= 0;
};

PublisherID.prototype.getElementLabel = function()
{ 
  return this.publisherType.Tag;
};

PublisherID.prototype.validate = function() 
{
  return null != id() && null != type();
};

},{"./encoding/decoding-exception.js":22,"./util/ndn-protoco-id-tags.js":51}],44:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents PublisherPublicKeyDigest Objects
 */

var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var LOG = require('./log.js').Log.LOG;

/**
 * @constructor
 */
var PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd) 
{ 
 this.PUBLISHER_ID_LEN = 512/8;
 this.publisherPublicKeyDigest = pkd;
};

exports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;

PublisherPublicKeyDigest.prototype.from_ndnb = function(decoder) 
{
  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());
    
  if (LOG > 4) console.log('Publisher public key digest is ' + this.publisherPublicKeyDigest);

  if (null == this.publisherPublicKeyDigest)
    throw new Error("Cannot parse publisher key digest.");
    
  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)

  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {
    if (LOG > 0)
      console.log('LENGTH OF PUBLISHER ID IS WRONG! Expected ' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);
      
    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;    
  }
};

PublisherPublicKeyDigest.prototype.to_ndnb= function(encoder) 
{
  //TODO Check that the ByteArray for the key is present
  if (!this.validate())
    throw new Error("Cannot encode : field values missing.");

  if (LOG > 3) console.log('PUBLISHER KEY DIGEST IS'+this.publisherPublicKeyDigest);
  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);
};
  
PublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };

PublisherPublicKeyDigest.prototype.validate = function() 
{
    return null != this.publisherPublicKeyDigest;
};

},{"./log.js":40,"./util/ndn-protoco-id-tags.js":51}],45:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */

var Key = require('../key.js').Key;

/**
 * @constructor
 */
var KeyManager = function KeyManager()
{
  this.certificate = 
  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +
  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +
  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +
  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +
  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +
  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +
  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +
  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +
  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";

  // Public Key
    this.publicKey = 
  "-----BEGIN PUBLIC KEY-----\n" +
  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\n" +
  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\n" +
  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\n" +
  "WFwYKClbU5XrShd3nwIDAQAB\n" +
  "-----END PUBLIC KEY-----";
  // Private Key
    this.privateKey = 
  "-----BEGIN RSA PRIVATE KEY-----\n" +
  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\n" +
  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\n" +
  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\n" +
  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\n" +
  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\n" +
  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\n" +
  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\n" +
  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\n" +
  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\n" +
  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\n" +
  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\n" +
  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\n" +
  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\n" +
  "-----END RSA PRIVATE KEY-----";
  
  this.key = null;
};

/**
 * Return a Key object for the keys in this KeyManager.  This creates the Key on the first
 * call and returns a cached copy after that.
 * @returns {Key}
 */
KeyManager.prototype.getKey = function()
{
  if (this.key === null) {
    this.key = new Key();
    this.key.fromPemString(this.publicKey, this.privateKey);
  }
  
  return this.key;
}

var globalKeyManager = globalKeyManager || new KeyManager();
exports.globalKeyManager = globalKeyManager;

},{"../key.js":39}],46:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an NDN Data Signature object.
 */

var Blob = require('./util/blob.js').Blob;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var KeyLocator = require('./key-locator.js').KeyLocator;
var customBuf = require('./buffer.js').Buffer
var LOG = require('./log.js').Log.LOG;

/**
 * Create a new Signature with the optional values.
 * @constructor
 */
var Signature = function Signature(witnessOrSignatureObject, signature, digestAlgorithm) 
{
  if (typeof witnessOrSignatureObject === 'object' && 
      witnessOrSignatureObject instanceof Signature) {
    // Copy the values.
    this.keyLocator = new KeyLocator(witnessOrSignatureObject.keyLocator);
    this.signature = witnessOrSignatureObject.signature;
    // witness is deprecated.
    this.witness = witnessOrSignatureObject.witness;
    // digestAlgorithm is deprecated.
    this.digestAlgorithm = witnessOrSignatureObject.digestAlgorithm;
  }
  else {
    this.keyLocator = new KeyLocator();
    this.signature = signature;
    // witness is deprecated.
    this.witness = witnessOrSignatureObject;
    // digestAlgorithm is deprecated.
    this.digestAlgorithm = digestAlgorithm;
  }
};

exports.Signature = Signature;

/**
 * Create a new Signature which is a copy of this object.
 * @returns {Signature} A new object which is a copy of this object.
 */
Signature.prototype.clone = function()
{
  return new Signature(this);
};

/**
 * Get the key locator.
 * @returns {KeyLocator} The key locator.
 */
Signature.prototype.getKeyLocator = function()
{
  return this.keyLocator;
};

/**
 * Get the data packet's signature bytes.
 * @returns {Buffer} The signature bytes.
 */
Signature.prototype.getSignature = function()
{
  return this.signature;
};

/**
 * Set the key locator to a copy of the given keyLocator.
 * @param {KeyLocator} keyLocator The KeyLocator to copy.
 */
Signature.prototype.setKeyLocator = function(keyLocator)
{
  this.keyLocator = typeof keyLocator === 'object' && keyLocator instanceof KeyLocator ?
                    new KeyLocator(keyLocator) : new KeyLocator();
};
  
/**
 * Set the data packet's signature bytes.
 * @param {type} signature
 */
Signature.prototype.setSignature = function(signature)
{
  if (signature == null)
    this.signature = null;
  else if (typeof signature === 'object' && signature instanceof Blob)
    this.signature = new customBuf(signature.buf());
  else
    this.signature = new customBuf(signature);
};

Signature.prototype.from_ndnb = function(decoder) 
{
  decoder.readElementStartDTag(this.getElementLabel());
    
  if (LOG > 4) console.log('STARTED DECODING SIGNATURE');
    
  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {
    if (LOG > 4) console.log('DIGIEST ALGORITHM FOUND');
    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm); 
  }
  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {
    if (LOG > 4) console.log('WITNESS FOUND');
    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness); 
  }
    
  //FORCE TO READ A SIGNATURE

  if (LOG > 4) console.log('SIGNATURE FOUND');
  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);

  decoder.readElementClose();
};

Signature.prototype.to_ndnb = function(encoder) 
{      
  if (!this.validate())
    throw new Error("Cannot encode: field values missing.");
  
  encoder.writeElementStartDTag(this.getElementLabel());
  
  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))
    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));
  
  if (null != this.witness)
    // needs to handle null witness
    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);

  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);

  encoder.writeElementClose();       
};

Signature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };

Signature.prototype.validate = function() 
{
  return null != this.signature;
};

},{"./buffer.js":14,"./encoding/binary-xml-decoder.js":17,"./encoding/binary-xml-encoder.js":18,"./key-locator.js":38,"./log.js":40,"./util/blob.js":48,"./util/ndn-protoco-id-tags.js":51}],47:[function(require,module,exports){
/** 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Wentao Shang
 * See COPYING for copyright and distribution information.
 */

var customBuf = require('../buffer.js').Buffer
var ElementReader = require('../encoding/element-reader.js').ElementReader;
var DataUtils = require('../encoding/data-utils.js').DataUtils;
var LOG = require('../log.js').Log.LOG;


function makeShuffledGetHostAndPort (hostList, port)
{
  // Make a copy.
  hostList = hostList.slice(0, hostList.length);
  DataUtils.shuffle(hostList);

  return function() {
    if (hostList.length == 0)
      return null;

    return { host: hostList.splice(0, 1)[0], port: port };
  };
};


/**
 * @constructor
 */
var WebSocketTransport = function WebSocketTransport() 
{    
  if (!WebSocket)
    throw new Error("WebSocket support is not available on this platform.");
    
  this.ws = null;
  this.connectedHost = null; // Read by Face.
  this.connectedPort = null; // Read by Face.
  this.elementReader = null;
  this.defaultGetHostAndPort = makeShuffledGetHostAndPort
    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu", 
      "E.ws.ndn.ucla.edu", "F.ws.ndn.ucla.edu", "G.ws.ndn.ucla.edu", "H.ws.ndn.ucla.edu", 
      "I.ws.ndn.ucla.edu", "J.ws.ndn.ucla.edu", "K.ws.ndn.ucla.edu", "L.ws.ndn.ucla.edu", 
      "M.ws.ndn.ucla.edu", "N.ws.ndn.ucla.edu"],
     9696);
};

exports.WebSocketTransport = WebSocketTransport;

/**
 * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost
 *   and connectedPort.  Once connected, call onopenCallback().
 * Listen on the port to read an entire binary XML encoded element and call
 *    face.onReceivedElement(element).
 */
WebSocketTransport.prototype.connect = function(face, onopenCallback) 
{
  this.close();
  
  this.ws = new WebSocket('ws:' + face.host + ':' + face.port);
  if (LOG > 0) console.log('ws connection created.');
    this.connectedHost = face.host;
    this.connectedPort = face.port;
  
  this.ws.binaryType = "arraybuffer";
  
  this.elementReader = new ElementReader(face);
  var self = this;
  this.ws.onmessage = function(ev) {
    var result = ev.data;
    //console.log('RecvHandle called.');
      
    if (result == null || result == undefined || result == "") {
      console.log('INVALID ANSWER');
    } 
    else if (result instanceof ArrayBuffer) {
      var bytearray = new customBuf(result);
          
      if (LOG > 3) console.log('BINARY RESPONSE IS ' + bytearray.toString('hex'));
      
      try {
        // Find the end of the binary XML element and call face.onReceivedElement.
        self.elementReader.onReceivedData(bytearray);
      } catch (ex) {
        console.log("NDN.ws.onmessage exception: " + ex);
        return;
      }
    }
  }
  
  this.ws.onopen = function(ev) {
    if (LOG > 3) console.log(ev);
    if (LOG > 3) console.log('ws.onopen: WebSocket connection opened.');
    if (LOG > 3) console.log('ws.onopen: ReadyState: ' + this.readyState);
    // Face.registerPrefix will fetch the ndndid when needed.

    onopenCallback();
  }
  
  this.ws.onerror = function(ev) {
    console.log('ws.onerror: ReadyState: ' + this.readyState);
    console.log(ev);
    console.log('ws.onerror: WebSocket error: ' + ev.data);
  }
  
  this.ws.onclose = function(ev) {
    console.log('ws.onclose: WebSocket connection closed.');
    self.ws = null;
    
    // Close Face when WebSocket is closed
    face.readyStatus = 2; //Face.CLOSED
    face.onclose();
    //console.log("NDN.onclose event fired.");
  }
};

/**
 * Send the Uint8Array data.
 */
WebSocketTransport.prototype.send = function(data) 
{
  if (this.ws != null) {
    // If we directly use data.buffer to feed ws.send(), 
    // WebSocket may end up sending a packet with 10000 bytes of data.
    // That is, WebSocket will flush the entire buffer
    // regardless of the offset of the Uint8Array. So we have to create
    // a new Uint8Array buffer with just the right size and copy the 
    // content from binaryInterest to the new buffer.
    //    ---Wentao
    var bytearray = new Uint8Array(data.length);
    bytearray.set(data);
    this.ws.send(bytearray.buffer);
    if (LOG > 3) console.log('ws.send() returned.');
  }
  else
    console.log('WebSocket connection is not established.');
};

/**
 * Close the connection.
 */
WebSocketTransport.prototype.close = function()
{
  if (this.ws != null)
    delete this.ws;
}


},{"../buffer.js":14,"../encoding/data-utils.js":21,"../encoding/element-reader.js":23,"../log.js":40}],48:[function(require,module,exports){
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer
/**
 * A Blob holds an immutable byte array implemented as a customBuf.  This should be 
 * treated like a string which is a pointer to an immutable string. (It is OK to 
 * pass a pointer to the string because the new owner cant change the bytes of 
 * the string.)  Blob does not inherit from customBuf. Instead you must call buf() 
 * to get the byte array which reminds you that you should not change the 
 * contents.  Also remember that buf() can return null.
 * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take 
 * another pointer to the customBuf without copying. If value is a customBuf or byte 
 * array, copy to create a new customBuf.  If omitted, buf() will return null.
 * @param {boolean} copy (optional) (optional) If true, copy the contents of 
 * value into a new customBuf.  If false, just use the existing value without 
 * copying. If omitted, then copy the contents (unless value is already a Blob).
 * IMPORTANT: If copy is false, if you keep a pointer to the value then you must
 * treat the value as immutable and promise not to change it.
 */
var Blob = function Blob(value, copy) 
{
  if (copy == null)
    copy = true;
  
  if (value == null)
    this.buffer = null;
  else if (typeof value === 'object' && value instanceof Blob)
    // Use the existing buffer.  Don't need to check for copy.
    this.buffer = value.buffer;
  else {
    if (typeof value === 'string')
      // Convert from a string to utf-8 byte encoding.
      this.buffer = new customBuf(value, 'utf8');
    else {
      if (copy)
        // We are copying, so just make another customBuf.
        this.buffer = new customBuf(value);
      else {
        if (typeof value === 'object' && value instanceof customBuf)
          // We can use as-is.
          this.buffer = value;
        else
          // We need a customBuf, so copy.
          this.buffer = new customBuf(value);
      }
    }
  }
};

exports.Blob = Blob;

/**
 * Return the length of the immutable byte array.
 * @returns {number} The length of the array.  If buf() is null, return 0.
 */
Blob.prototype.size = function()
{
  if (this.buffer != null)
    return this.buffer.length;
  else
    return 0;
};

/**
 * Return the immutable byte array.  DO NOT change the contents of the customBuf.  
 * If you need to change it, make a copy.
 * @returns {Buffer} The customBuf holding the immutable byte array, or null.
 */
Blob.prototype.buf = function()
{
  return this.buffer;
};

/**
 * Return true if the array is null, otherwise false.
 * @returns {boolean} True if the array is null.
 */
Blob.prototype.isNull = function()
{
  return this.buffer == null;
};

/**
 * Return the hex representation of the bytes in the byte array.
 * @returns {string} The hex string.
 */
Blob.prototype.toHex = function() 
{  
  if (this.buffer == null)
    return "";
  else
    return this.buffer.toString('hex');
};

},{"../buffer.js":14}],49:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * Encapsulate a customBuf and support dynamic reallocation.
 */
var customBuf = require('../buffer.js').Buffer
/**
 * Create a DynamicBuffer where this.array is a customBuf of size length.
 * To access the array, use this.array or call slice.
 * @constructor
 * @param {number} length the initial length of the array.  If null, use a default.
 */
var DynamicBuffer = function DynamicBuffer(length) 
{
  if (!length)
    length = 16;
    
  this.array = new customBuf(length);
};

exports.DynamicBuffer = DynamicBuffer;

/**
 * Ensure that this.array has the length, reallocate and copy if necessary.
 * Update the length of this.array which may be greater than length.
 * @param {number} length The minimum length for the array.
 */
DynamicBuffer.prototype.ensureLength = function(length) 
{
  if (this.array.length >= length)
    return;
    
  // See if double is enough.
  var newLength = this.array.length * 2;
  if (length > newLength)
    // The needed length is much greater, so use it.
    newLength = length;
    
  var newArray = new customBuf(newLength);
  this.array.copy(newArray);
  this.array = newArray;
};

/**
 * Copy the value to this.array at offset, reallocating if necessary. 
 * @param {Buffer} value The buffer to copy.
 * @param {number} offset The offset in the buffer to start copying into.
 */
DynamicBuffer.prototype.copy = function(value, offset) 
{
  this.ensureLength(value.length + offset);
    
  if (typeof value == 'object' && value instanceof customBuf)
    value.copy(this.array, offset);
  else
    // Need to make value a customBuf to copy.
    new customBuf(value).copy(this.array, offset);
};

/**
 * Ensure that this.array has the length. If necessary, reallocate the array
 *   and shift existing data to the back of the new array.
 * Update the length of this.array which may be greater than length.
 * @param {number} length The minimum length for the array.
 */
DynamicBuffer.prototype.ensureLengthFromBack = function(length) 
{
  if (this.array.length >= length)
    return;
    
  // See if double is enough.
  var newLength = this.array.length * 2;
  if (length > newLength)
    // The needed length is much greater, so use it.
    newLength = length;
    
  var newArray = new customBuf(newLength);
  // Copy to the back of newArray.
  this.array.copy(newArray, newArray.length - this.array.length);
  this.array = newArray;
};

/**
 * First call ensureLengthFromBack to make sure the bytearray has
 * offsetFromBack bytes, then copy value into the array starting
 * offsetFromBack bytes from the back of the array.
 * @param {Buffer} value The buffer to copy.
 * @param {offsetFromBack} offset The offset from the back of the array to start
 * copying.
 */
DynamicBuffer.prototype.copyFromBack = function(value, offsetFromBack) 
{
  this.ensureLengthFromBack(offsetFromBack);

  if (typeof value == 'object' && value instanceof customBuf)
    value.copy(this.array, this.array.length - offsetFromBack);
  else
    // Need to make value a customBuf to copy.
    new customBuf(value).copy(this.array, this.array.length - offsetFromBack);
};

/**
 * Return this.array.slice(begin, end);
 * @param {number} begin The begin index for the slice.
 * @param {number} end The end index for the slice.
 * @returns {Buffer} The buffer slice.
 */
DynamicBuffer.prototype.slice = function(begin, end) 
{
  return this.array.slice(begin, end);
};

},{"../buffer.js":14}],50:[function(require,module,exports){
(function (Buffer){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer
var DataUtils = require('../encoding/data-utils.js').DataUtils;
var BinaryXMLDecoder = require('../encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var NDNProtocolDTags = require('./ndn-protoco-id-tags.js').NDNProtocolDTags;
var Name = require('../name.js').Name;

/**
 * Create a context for getting the response from the name enumeration command, as neede by getComponents.
 * (To do name enumeration, call the static method NameEnumeration.getComponents.)
 * @param {Face} face The Face object for using expressInterest.
 * @param {function} onComponents The onComponents callback given to getComponents.
 */
var NameEnumeration = function NameEnumeration(face, onComponents) 
{
  this.face = face;
  this.onComponents = onComponents;
  this.contentParts = [];
  
  var self = this;
  this.onData = function(interest, data) { self.processData(data); };
  this.onTimeout = function(interest) { self.processTimeout(); };
};

exports.NameEnumeration = NameEnumeration;

/**
 * Use the name enumeration protocol to get the child components of the name prefix.
 * @param {Face} face The Face object for using expressInterest.
 * @param {Name} name The name prefix for finding the child components.
 * @param {function} onComponents On getting the response, this calls onComponents(components) where
 * components is an array of customBuf name components.  If there is no response, this calls onComponents(null). 
 */
NameEnumeration.getComponents = function(face, prefix, onComponents)
{
  var command = new Name(prefix);
  // Add %C1.E.be
  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])
  
  var enumeration = new NameEnumeration(face, onComponents);
  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);
};

/**
 * Parse the response from the name enumeration command and call this.onComponents.
 * @param {Data} data
 */
NameEnumeration.prototype.processData = function(data) 
{
  try {
    if (!NameEnumeration.endsWithSegmentNumber(data.name))
      // We don't expect a name without a segment number.  Treat it as a bad packet.
      this.onComponents(null);
    else {
      var segmentNumber = DataUtils.bigEndianToUnsignedInt
          (data.name.get(data.name.size() - 1).getValue());

      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.
      var expectedSegmentNumber = this.contentParts.length;
      if (segmentNumber != expectedSegmentNumber)
        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.
        this.face.expressInterest
          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);
      else {
        // Save the content and check if we are finished.
        this.contentParts.push(data.content);

        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {
          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);
          if (segmentNumber == finalSegmentNumber) {
            // We are finished.  Parse and return the result.
            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));
            return;
          }
        }

        // Fetch the next segment.
        this.face.expressInterest
          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);
      }
    }
  } catch (ex) {
    console.log("NameEnumeration: ignoring exception: " + ex);
  }
};

/**
 * Just call onComponents(null).
 */
NameEnumeration.prototype.processTimeout = function()
{
  try {
    this.onComponents(null);
  } catch (ex) {
    console.log("NameEnumeration: ignoring exception: " + ex);
  }
};

/**
 * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.
 * @param {Uint8Array} content The content to parse.
 * @returns {Array<Buffer>} The array of components.
 */
NameEnumeration.parseComponents = function(content)
{
  var components = [];
  var decoder = new BinaryXMLDecoder(content);
  
  decoder.readElementStartDTag(NDNProtocolDTags.Collection);
 
  while (decoder.peekDTag(NDNProtocolDTags.Link)) {
    decoder.readElementStartDTag(NDNProtocolDTags.Link);    
    decoder.readElementStartDTag(NDNProtocolDTags.Name);
    
    components.push(new customBuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));
    
    decoder.readElementClose();  
    decoder.readElementClose();  
  }

  decoder.readElementClose();
  return components;
};

/**
 * Check if the last component in the name is a segment number.
 * TODO: Move to Name class.
 * @param {Name} name
 * @returns {Boolean} True if the name ends with a segment number, otherwise false.
 */
NameEnumeration.endsWithSegmentNumber = function(name) {
  return name.components != null && name.size() >= 1 &&
         name.get(name.size() - 1).getValue().length >= 1 &&
         name.get(name.size() - 1).getValue()[0] == 0;
};

}).call(this,require("buffer").Buffer)
},{"../buffer.js":14,"../encoding/binary-xml-decoder.js":17,"../encoding/data-utils.js":21,"../name.js":42,"./ndn-protoco-id-tags.js":51,"buffer":109}],51:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class contains all NDNx tags
 */


var NDNProtocolDTags = {

  /**
   * Note if you add one of these, add it to the reverse string map as well.
   * Emphasize getting the work done at compile time over trying to make something
   * flexible and developer error-proof.
   */

   Any : 13,
   Name : 14,
   Component : 15,
   Certificate : 16,
   Collection : 17,
   CompleteName : 18,
   Content : 19,
   SignedInfo : 20,
   ContentDigest : 21,
   ContentHash : 22,
   Count : 24,
   Header : 25,
   Interest : 26,  /* 20090915 */
   Key : 27,
   KeyLocator : 28,
   KeyName : 29,
   Length : 30,
   Link : 31,
   LinkAuthenticator : 32,
   NameComponentCount : 33,  /* DeprecatedInInterest */
   RootDigest : 36,
   Signature : 37,
   Start : 38,
   Timestamp : 39,
   Type : 40,
   Nonce : 41,
   Scope : 42,
   Exclude : 43,
   Bloom : 44,
   BloomSeed : 45,
   AnswerOriginKind : 47,
   InterestLifetime : 48,
   Witness : 53,
   SignatureBits : 54,
   DigestAlgorithm : 55,
   BlockSize : 56,
   FreshnessSeconds : 58,
   FinalBlockID : 59,
   PublisherPublicKeyDigest : 60,
   PublisherCertificateDigest : 61,
   PublisherIssuerKeyDigest : 62,
   PublisherIssuerCertificateDigest : 63,
   Data : 64,  /* 20090915 */
   WrappedKey : 65,
   WrappingKeyIdentifier : 66,
   WrapAlgorithm : 67,
   KeyAlgorithm : 68,
   Label : 69,
   EncryptedKey : 70,
   EncryptedNonceKey : 71,
   WrappingKeyName : 72,
   Action : 73,
   FaceID : 74,
   IPProto : 75,
   Host : 76,
   Port : 77,
   MulticastInterface : 78,
   ForwardingFlags : 79,
   FaceInstance : 80,
   ForwardingEntry : 81,
   MulticastTTL : 82,
   MinSuffixComponents : 83,
   MaxSuffixComponents : 84,
   ChildSelector : 85,
   RepositoryInfo : 86,
   Version : 87,
   RepositoryVersion : 88,
   GlobalPrefix : 89,
   LocalName : 90,
   Policy : 91,
   Namespace : 92,
   GlobalPrefixName : 93,
   PolicyVersion : 94,
   KeyValueSet : 95,
   KeyValuePair : 96,
   IntegerValue : 97,
   DecimalValue : 98,
   StringValue : 99,
   BinaryValue : 100,
   NameValue : 101,
   Entry : 102,
   ACL : 103,
   ParameterizedName : 104,
   Prefix : 105,
   Suffix : 106,
   Root : 107,
   ProfileName : 108,
   Parameters : 109,
   InfoString : 110,
  // 111 unallocated
   StatusResponse : 112,
   StatusCode : 113,
   StatusText : 114,

  // Sync protocol
   SyncNode : 115,
   SyncNodeKind : 116,
   SyncNodeElement : 117,
   SyncVersion : 118,
   SyncNodeElements : 119,
   SyncContentHash : 120,
   SyncLeafCount : 121,
   SyncTreeDepth : 122,
   SyncByteCount : 123,
   ConfigSlice : 124,
   ConfigSliceList : 125,
   ConfigSliceOp : 126,

  // Remember to keep in sync with schema/tagnames.csvsdict
   NDNProtocolDataUnit : 17702112,
   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"
};

exports.NDNProtocolDTags = NDNProtocolDTags;

var NDNProtocolDTagsStrings = [
  null, null, null, null, null, null, null, null, null, null, null,
  null, null,
  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",
  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",
  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",
  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",
  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",
  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",
  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",
  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",
  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",
  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",
  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",
  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",
  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",
  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",
  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",
  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",
  "InfoString", null,
    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",
    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",
    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];

exports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;

},{}],52:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents NDNTime Objects
 */

var LOG = require('../log.js').Log.LOG;

/**
 * @constructor
 */
var NDNTime = function NDNTime(input) 
{
  this.NANOS_MAX = 999877929;
  
  if (typeof input =='number')
    this.msec = input;
  else {
    if (LOG > 1) console.log('UNRECOGNIZED TYPE FOR TIME');
  }
};

exports.NDNTime = NDNTime;

NDNTime.prototype.getJavascriptDate = function() 
{
  var d = new Date();
  d.setTime(this.msec);
  return d
};  

},{"../log.js":40}],53:[function(require,module,exports){
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer
var Blob = require('./blob.js').Blob;

/**
 * A SignedBlob extends Blob to keep the offsets of a signed portion (e.g., the 
 * bytes of Data packet). This inherits from Blob, including Blob.size and Blob.buf.
 * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take 
 * another pointer to the customBuf without copying. If value is a customBuf or byte 
 * array, copy to create a new customBuf.  If omitted, buf() will return null.
 * @param {number} signedPortionBeginOffset (optional) The offset in the 
 * encoding of the beginning of the signed portion. If omitted, set to 0.
 * @param {number} signedPortionEndOffset (optional) The offset in the encoding 
 * of the end of the signed portion. If omitted, set to 0.
 */
var SignedBlob = function SignedBlob(value, signedPortionBeginOffset, signedPortionEndOffset) 
{
  // Call the base constructor.
  Blob.call(this, value);
  
  if (this.buffer == null) {
    this.signedPortionBeginOffset = 0;
    this.signedPortionEndOffset = 0;
  }
  else if (typeof value === 'object' && value instanceof SignedBlob) {
    // Copy the SignedBlob, allowing override for offsets.
    this.signedPortionBeginOffset = signedPortionBeginOffset == null ? 
      value.signedPortionBeginOffset : signedPortionBeginOffset;
    this.signedPortionEndOffset = signedPortionEndOffset == null ? 
      value.signedPortionEndOffset : signedPortionEndOffset;
  }
  else {
    this.signedPortionBeginOffset = signedPortionBeginOffset || 0;
    this.signedPortionEndOffset = signedPortionEndOffset || 0;
  }
  
  if (this.buffer == null)
    this.signedBuffer = null;
  else
    this.signedBuffer = this.buffer.slice
      (this.signedPortionBeginOffset, this.signedPortionEndOffset);
};

SignedBlob.prototype = new Blob();
SignedBlob.prototype.name = "SignedBlob";

exports.SignedBlob = SignedBlob;

/**
 * Return the length of the signed portion of the immutable byte array.
 * @returns {number} The length of the signed portion.  If signedBuf() is null, 
 * return 0.
 */
SignedBlob.prototype.signedSize = function()
{
  if (this.signedBuffer != null)
    return this.signedBuffer.length;
  else
    return 0;
};

/**
 * Return a the signed portion of the immutable byte array.
 * @returns {Buffer} A slice into the customBuf which is the signed portion.  
 * If the pointer to the array is null, return null.
 */
SignedBlob.prototype.signedBuf = function()
{
  if (this.signedBuffer != null)
    return this.signedBuffer;
  else
    return null;
};

/**
 * Return the offset in the array of the beginning of the signed portion.
 * @returns {number} The offset in the array.
 */
SignedBlob.prototype.getSignedPortionBeginOffset = function()
{
  return this.signedPortionBeginOffset;
};

/**
 * Return the offset in the array of the end of the signed portion.
 * @returns {number} The offset in the array.
 */
SignedBlob.prototype.getSignedPortionEndOffset = function()
{
  return this.signedPortionEndOffset;
};

},{"../buffer.js":14,"./blob.js":48}],54:[function(require,module,exports){
(function(){
    
    // Copyright (c) 2005  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Basic JavaScript BN library - subset useful for RSA encryption.

    // Bits per digit
    var dbits;

    // JavaScript engine analysis
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary&0xffffff)==0xefcafe);

    // (public) Constructor
    function BigInteger(a,b,c) {
      if(a != null)
        if("number" == typeof a) this.fromNumber(a,b,c);
        else if(b == null && "string" != typeof a) this.fromString(a,256);
        else this.fromString(a,b);
    }

    // return new, unset BigInteger
    function nbi() { return new BigInteger(null); }

    // am: Compute w_j += (x*this_i), propagate carries,
    // c is initial carry, returns final carry.
    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
    // We need to select the fastest one that works in this environment.

    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    function am1(i,x,w,j,c,n) {
      while(--n >= 0) {
        var v = x*this[i++]+w[j]+c;
        c = Math.floor(v/0x4000000);
        w[j++] = v&0x3ffffff;
      }
      return c;
    }
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    function am2(i,x,w,j,c,n) {
      var xl = x&0x7fff, xh = x>>15;
      while(--n >= 0) {
        var l = this[i]&0x7fff;
        var h = this[i++]>>15;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
        w[j++] = l&0x3fffffff;
      }
      return c;
    }
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    function am3(i,x,w,j,c,n) {
      var xl = x&0x3fff, xh = x>>14;
      while(--n >= 0) {
        var l = this[i]&0x3fff;
        var h = this[i++]>>14;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
        c = (l>>28)+(m>>14)+xh*h;
        w[j++] = l&0xfffffff;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    }
    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
      BigInteger.prototype.am = am1;
      dbits = 26;
    }
    else { // Mozilla/Netscape seems to prefer am3
      BigInteger.prototype.am = am3;
      dbits = 28;
    }

    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1<<dbits)-1);
    BigInteger.prototype.DV = (1<<dbits);

    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2,BI_FP);
    BigInteger.prototype.F1 = BI_FP-dbits;
    BigInteger.prototype.F2 = 2*dbits-BI_FP;

    // Digit conversions
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr,vv;
    rr = "0".charCodeAt(0);
    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

    function int2char(n) { return BI_RM.charAt(n); }
    function intAt(s,i) {
      var c = BI_RC[s.charCodeAt(i)];
      return (c==null)?-1:c;
    }

    // (protected) copy this to r
    function bnpCopyTo(r) {
      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }

    // (protected) set from integer value x, -DV <= x < DV
    function bnpFromInt(x) {
      this.t = 1;
      this.s = (x<0)?-1:0;
      if(x > 0) this[0] = x;
      else if(x < -1) this[0] = x+DV;
      else this.t = 0;
    }

    // return bigint initialized to value
    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

    // (protected) set from string and radix
    function bnpFromString(s,b) {
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 256) k = 8; // byte array
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else { this.fromRadix(s,b); return; }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while(--i >= 0) {
        var x = (k==8)?s[i]&0xff:intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-") mi = true;
          continue;
        }
        mi = false;
        if(sh == 0)
          this[this.t++] = x;
        else if(sh+k > this.DB) {
          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
          this[this.t++] = (x>>(this.DB-sh));
        }
        else
          this[this.t-1] |= x<<sh;
        sh += k;
        if(sh >= this.DB) sh -= this.DB;
      }
      if(k == 8 && (s[0]&0x80) != 0) {
        this.s = -1;
        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
      }
      this.clamp();
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) clamp off excess high words
    function bnpClamp() {
      var c = this.s&this.DM;
      while(this.t > 0 && this[this.t-1] == c) --this.t;
    }

    // (public) return string representation in given radix
    function bnToString(b) {
      if(this.s < 0) return "-"+this.negate().toString(b);
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1<<k)-1, d, m = false, r = "", i = this.t;
      var p = this.DB-(i*this.DB)%k;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
        while(i >= 0) {
          if(p < k) {
            d = (this[i]&((1<<p)-1))<<(k-p);
            d |= this[--i]>>(p+=this.DB-k);
          }
          else {
            d = (this[i]>>(p-=k))&km;
            if(p <= 0) { p += this.DB; --i; }
          }
          if(d > 0) m = true;
          if(m) r += int2char(d);
        }
      }
      return m?r:"0";
    }

    // (public) -this
    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

    // (public) |this|
    function bnAbs() { return (this.s<0)?this.negate():this; }

    // (public) return + if this > a, - if this < a, 0 if equal
    function bnCompareTo(a) {
      var r = this.s-a.s;
      if(r != 0) return r;
      var i = this.t;
      r = i-a.t;
      if(r != 0) return (this.s<0)?-r:r;
      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
      return 0;
    }

    // returns bit length of the integer x
    function nbits(x) {
      var r = 1, t;
      if((t=x>>>16) != 0) { x = t; r += 16; }
      if((t=x>>8) != 0) { x = t; r += 8; }
      if((t=x>>4) != 0) { x = t; r += 4; }
      if((t=x>>2) != 0) { x = t; r += 2; }
      if((t=x>>1) != 0) { x = t; r += 1; }
      return r;
    }

    // (public) return the number of bits in "this"
    function bnBitLength() {
      if(this.t <= 0) return 0;
      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
    }

    // (protected) r = this << n*DB
    function bnpDLShiftTo(n,r) {
      var i;
      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
      for(i = n-1; i >= 0; --i) r[i] = 0;
      r.t = this.t+n;
      r.s = this.s;
    }

    // (protected) r = this >> n*DB
    function bnpDRShiftTo(n,r) {
      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
      r.t = Math.max(this.t-n,0);
      r.s = this.s;
    }

    // (protected) r = this << n
    function bnpLShiftTo(n,r) {
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<cbs)-1;
      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
      for(i = this.t-1; i >= 0; --i) {
        r[i+ds+1] = (this[i]>>cbs)|c;
        c = (this[i]&bm)<<bs;
      }
      for(i = ds-1; i >= 0; --i) r[i] = 0;
      r[ds] = c;
      r.t = this.t+ds+1;
      r.s = this.s;
      r.clamp();
    }

    // (protected) r = this >> n
    function bnpRShiftTo(n,r) {
      r.s = this.s;
      var ds = Math.floor(n/this.DB);
      if(ds >= this.t) { r.t = 0; return; }
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<bs)-1;
      r[0] = this[ds]>>bs;
      for(var i = ds+1; i < this.t; ++i) {
        r[i-ds-1] |= (this[i]&bm)<<cbs;
        r[i-ds] = this[i]>>bs;
      }
      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
      r.t = this.t-ds;
      r.clamp();
    }

    // (protected) r = this - a
    function bnpSubTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]-a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c -= a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c -= a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = (c<0)?-1:0;
      if(c < -1) r[i++] = this.DV+c;
      else if(c > 0) r[i++] = c;
      r.t = i;
      r.clamp();
    }

    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    function bnpMultiplyTo(a,r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i+y.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
      r.s = 0;
      r.clamp();
      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
    }

    // (protected) r = this^2, r != this (HAC 14.16)
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2*x.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < x.t-1; ++i) {
        var c = x.am(i,x[i],r,2*i,0,1);
        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
          r[i+x.t] -= x.DV;
          r[i+x.t+1] = 1;
        }
      }
      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
      r.s = 0;
      r.clamp();
    }

    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    function bnpDivRemTo(m,q,r) {
      var pm = m.abs();
      if(pm.t <= 0) return;
      var pt = this.abs();
      if(pt.t < pm.t) {
        if(q != null) q.fromInt(0);
        if(r != null) this.copyTo(r);
        return;
      }
      if(r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
      else { pm.copyTo(y); pt.copyTo(r); }
      var ys = y.t;
      var y0 = y[ys-1];
      if(y0 == 0) return;
      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
      y.dlShiftTo(j,t);
      if(r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t,r);
      }
      BigInteger.ONE.dlShiftTo(ys,t);
      t.subTo(y,y);  // "negative" y so we can replace sub with am later
      while(y.t < ys) y[y.t++] = 0;
      while(--j >= 0) {
        // Estimate quotient digit
        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
          y.dlShiftTo(j,t);
          r.subTo(t,r);
          while(r[i] < --qd) r.subTo(t,r);
        }
      }
      if(q != null) {
        r.drShiftTo(ys,q);
        if(ts != ms) BigInteger.ZERO.subTo(q,q);
      }
      r.t = ys;
      r.clamp();
      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
      if(ts < 0) BigInteger.ZERO.subTo(r,r);
    }

    // (public) this mod a
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a,null,r);
      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
      return r;
    }

    // Modular reduction using "classic" algorithm
    function Classic(m) { this.m = m; }
    function cConvert(x) {
      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) { return x; }
    function cReduce(x) { x.divRemTo(this.m,null,x); }
    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;

    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    function bnpInvDigit() {
      if(this.t < 1) return 0;
      var x = this[0];
      if((x&1) == 0) return 0;
      var y = x&3;       // y == 1/x mod 2^2
      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
      // last step - calculate inverse mod DV directly;
      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
      // we really want the negative inverse, and -DV < y < DV
      return (y>0)?this.DV-y:-y;
    }

    // Montgomery reduction
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp&0x7fff;
      this.mph = this.mp>>15;
      this.um = (1<<(m.DB-15))-1;
      this.mt2 = 2*m.t;
    }

    // xR mod m
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t,r);
      r.divRemTo(this.m,null,r);
      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
      return r;
    }

    // x/R mod m
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }

    // x = x/R mod m (HAC 14.32)
    function montReduce(x) {
      while(x.t <= this.mt2) // pad x so am has enough room later
        x[x.t++] = 0;
      for(var i = 0; i < this.m.t; ++i) {
        // faster way of calculating u0 = x[i]*mp mod DV
        var j = x[i]&0x7fff;
        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
        // use am to combine the multiply-shift-add into one call
        j = i+this.m.t;
        x[j] += this.m.am(0,u0,x,i,0,this.m.t);
        // propagate carry
        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
      }
      x.clamp();
      x.drShiftTo(this.m.t,x);
      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = "x^2/R mod m"; x != r
    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = "xy/R mod m"; x,y != r
    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;

    // (protected) true iff this is even
    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    function bnpExp(e,z) {
      if(e > 0xffffffff || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
      g.copyTo(r);
      while(--i >= 0) {
        z.sqrTo(r,r2);
        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
        else { var t = r; r = r2; r2 = t; }
      }
      return z.revert(r);
    }

    // (public) this^e % m, 0 <= e < 2^32
    function bnModPowInt(e,m) {
      var z;
      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
      return this.exp(e,z);
    }

    // protected
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;

    // public
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;

    // "constants"
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);

    // Copyright (c) 2005-2009  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Extended JavaScript BN functions, required for RSA private ops.

    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
    // Version 1.2: square() API, isProbablePrime fix

    // (public)
    function bnClone() { var r = nbi(); this.copyTo(r); return r; }

    // (public) return value as integer
    function bnIntValue() {
      if(this.s < 0) {
        if(this.t == 1) return this[0]-this.DV;
        else if(this.t == 0) return -1;
      }
      else if(this.t == 1) return this[0];
      else if(this.t == 0) return 0;
      // assumes 16 < DB < 32
      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
    }

    // (public) return value as byte
    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

    // (public) return value as short (assumes DB>=16)
    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

    // (protected) return x s.t. r^x < DV
    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

    // (public) 0 if this == 0, 1 if this > 0
    function bnSigNum() {
      if(this.s < 0) return -1;
      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
      else return 1;
    }

    // (protected) convert to radix string
    function bnpToRadix(b) {
      if(b == null) b = 10;
      if(this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b,cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d,y,z);
      while(y.signum() > 0) {
        r = (a+z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d,y,z);
      }
      return z.intValue().toString(b) + r;
    }

    // (protected) convert from radix string
    function bnpFromRadix(s,b) {
      this.fromInt(0);
      if(b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
      for(var i = 0; i < s.length; ++i) {
        var x = intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w = b*w+x;
        if(++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w,0);
          j = 0;
          w = 0;
        }
      }
      if(j > 0) {
        this.dMultiply(Math.pow(b,j));
        this.dAddOffset(w,0);
      }
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) alternate constructor
    function bnpFromNumber(a,b,c) {
      if("number" == typeof b) {
        // new BigInteger(int,int,RNG)
        if(a < 2) this.fromInt(1);
        else {
          this.fromNumber(a,c);
          if(!this.testBit(a-1))	// force MSB set
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
          if(this.isEven()) this.dAddOffset(1,0); // force odd
          while(!this.isProbablePrime(b)) {
            this.dAddOffset(2,0);
            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
          }
        }
      }
      else {
        // new BigInteger(int,RNG)
        var x = new Array(), t = a&7;
        x.length = (a>>3)+1;
        b.nextBytes(x);
        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
        this.fromString(x,256);
      }
    }

    // (public) convert to bigendian byte array
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB-(i*this.DB)%8, d, k = 0;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
          r[k++] = d|(this.s<<(this.DB-p));
        while(i >= 0) {
          if(p < 8) {
            d = (this[i]&((1<<p)-1))<<(8-p);
            d |= this[--i]>>(p+=this.DB-8);
          }
          else {
            d = (this[i]>>(p-=8))&0xff;
            if(p <= 0) { p += this.DB; --i; }
          }
          if((d&0x80) != 0) d |= -256;
          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
          if(k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }

    function bnEquals(a) { return(this.compareTo(a)==0); }
    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

    // (protected) r = this op a (bitwise)
    function bnpBitwiseTo(a,op,r) {
      var i, f, m = Math.min(a.t,this.t);
      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
      if(a.t < this.t) {
        f = a.s&this.DM;
        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
        r.t = this.t;
      }
      else {
        f = this.s&this.DM;
        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
        r.t = a.t;
      }
      r.s = op(this.s,a.s);
      r.clamp();
    }

    // (public) this & a
    function op_and(x,y) { return x&y; }
    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

    // (public) this | a
    function op_or(x,y) { return x|y; }
    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

    // (public) this ^ a
    function op_xor(x,y) { return x^y; }
    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

    // (public) this & ~a
    function op_andnot(x,y) { return x&~y; }
    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

    // (public) ~this
    function bnNot() {
      var r = nbi();
      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }

    // (public) this << n
    function bnShiftLeft(n) {
      var r = nbi();
      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
      return r;
    }

    // (public) this >> n
    function bnShiftRight(n) {
      var r = nbi();
      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
      return r;
    }

    // return index of lowest 1-bit in x, x < 2^31
    function lbit(x) {
      if(x == 0) return -1;
      var r = 0;
      if((x&0xffff) == 0) { x >>= 16; r += 16; }
      if((x&0xff) == 0) { x >>= 8; r += 8; }
      if((x&0xf) == 0) { x >>= 4; r += 4; }
      if((x&3) == 0) { x >>= 2; r += 2; }
      if((x&1) == 0) ++r;
      return r;
    }

    // (public) returns index of lowest 1-bit (or -1 if none)
    function bnGetLowestSetBit() {
      for(var i = 0; i < this.t; ++i)
        if(this[i] != 0) return i*this.DB+lbit(this[i]);
      if(this.s < 0) return this.t*this.DB;
      return -1;
    }

    // return number of 1 bits in x
    function cbit(x) {
      var r = 0;
      while(x != 0) { x &= x-1; ++r; }
      return r;
    }

    // (public) return number of set bits
    function bnBitCount() {
      var r = 0, x = this.s&this.DM;
      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
      return r;
    }

    // (public) true iff nth bit is set
    function bnTestBit(n) {
      var j = Math.floor(n/this.DB);
      if(j >= this.t) return(this.s!=0);
      return((this[j]&(1<<(n%this.DB)))!=0);
    }

    // (protected) this op (1<<n)
    function bnpChangeBit(n,op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r,op,r);
      return r;
    }

    // (public) this | (1<<n)
    function bnSetBit(n) { return this.changeBit(n,op_or); }

    // (public) this & ~(1<<n)
    function bnClearBit(n) { return this.changeBit(n,op_andnot); }

    // (public) this ^ (1<<n)
    function bnFlipBit(n) { return this.changeBit(n,op_xor); }

    // (protected) r = this + a
    function bnpAddTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]+a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c += a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c += a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = (c<0)?-1:0;
      if(c > 0) r[i++] = c;
      else if(c < -1) r[i++] = this.DV+c;
      r.t = i;
      r.clamp();
    }

    // (public) this + a
    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

    // (public) this - a
    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

    // (public) this * a
    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

    // (public) this^2
    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

    // (public) this / a
    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

    // (public) this % a
    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

    // (public) [this/a,this%a]
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a,q,r);
      return new Array(q,r);
    }

    // (protected) this *= n, this >= 0, 1 < n < DV
    function bnpDMultiply(n) {
      this[this.t] = this.am(0,n-1,this,0,0,this.t);
      ++this.t;
      this.clamp();
    }

    // (protected) this += n << w words, this >= 0
    function bnpDAddOffset(n,w) {
      if(n == 0) return;
      while(this.t <= w) this[this.t++] = 0;
      this[w] += n;
      while(this[w] >= this.DV) {
        this[w] -= this.DV;
        if(++w >= this.t) this[this.t++] = 0;
        ++this[w];
      }
    }

    // A "null" reducer
    function NullExp() {}
    function nNop(x) { return x; }
    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
    function nSqrTo(x,r) { x.squareTo(r); }

    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;

    // (public) this^e
    function bnPow(e) { return this.exp(e,new NullExp()); }

    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    function bnpMultiplyLowerTo(a,n,r) {
      var i = Math.min(this.t+a.t,n);
      r.s = 0; // assumes a,this >= 0
      r.t = i;
      while(i > 0) r[--i] = 0;
      var j;
      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
      r.clamp();
    }

    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    function bnpMultiplyUpperTo(a,n,r) {
      --n;
      var i = r.t = this.t+a.t-n;
      r.s = 0; // assumes a,this >= 0
      while(--i >= 0) r[i] = 0;
      for(i = Math.max(n-this.t,0); i < a.t; ++i)
        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
      r.clamp();
      r.drShiftTo(1,r);
    }

    // Barrett modular reduction
    function Barrett(m) {
      // setup Barrett
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }

    function barrettConvert(x) {
      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
      else if(x.compareTo(this.m) < 0) return x;
      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
    }

    function barrettRevert(x) { return x; }

    // x = x mod m (HAC 14.42)
    function barrettReduce(x) {
      x.drShiftTo(this.m.t-1,this.r2);
      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
      x.subTo(this.r2,x);
      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = x^2 mod m; x != r
    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = x*y mod m; x,y != r
    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;

    // (public) this^e % m (HAC 14.85)
    function bnModPow(e,m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if(i <= 0) return r;
      else if(i < 18) k = 1;
      else if(i < 48) k = 3;
      else if(i < 144) k = 4;
      else if(i < 768) k = 5;
      else k = 6;
      if(i < 8)
        z = new Classic(m);
      else if(m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);

      // precomputation
      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
      g[1] = z.convert(this);
      if(k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1],g2);
        while(n <= km) {
          g[n] = nbi();
          z.mulTo(g2,g[n-2],g[n]);
          n += 2;
        }
      }

      var j = e.t-1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e[j])-1;
      while(j >= 0) {
        if(i >= k1) w = (e[j]>>(i-k1))&km;
        else {
          w = (e[j]&((1<<(i+1))-1))<<(k1-i);
          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
        }

        n = k;
        while((w&1) == 0) { w >>= 1; --n; }
        if((i -= n) < 0) { i += this.DB; --j; }
        if(is1) {	// ret == 1, don't bother squaring or multiplying it
          g[w].copyTo(r);
          is1 = false;
        }
        else {
          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
          z.mulTo(r2,g[w],r);
        }

        while(j >= 0 && (e[j]&(1<<i)) == 0) {
          z.sqrTo(r,r2); t = r; r = r2; r2 = t;
          if(--i < 0) { i = this.DB-1; --j; }
        }
      }
      return z.revert(r);
    }

    // (public) gcd(this,a) (HAC 14.54)
    function bnGCD(a) {
      var x = (this.s<0)?this.negate():this.clone();
      var y = (a.s<0)?a.negate():a.clone();
      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if(g < 0) return x;
      if(i < g) g = i;
      if(g > 0) {
        x.rShiftTo(g,x);
        y.rShiftTo(g,y);
      }
      while(x.signum() > 0) {
        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
        if(x.compareTo(y) >= 0) {
          x.subTo(y,x);
          x.rShiftTo(1,x);
        }
        else {
          y.subTo(x,y);
          y.rShiftTo(1,y);
        }
      }
      if(g > 0) y.lShiftTo(g,y);
      return y;
    }

    // (protected) this % n, n < 2^26
    function bnpModInt(n) {
      if(n <= 0) return 0;
      var d = this.DV%n, r = (this.s<0)?n-1:0;
      if(this.t > 0)
        if(d == 0) r = this[0]%n;
        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
      return r;
    }

    // (public) 1/this % m (HAC 14.61)
    function bnModInverse(m) {
      var ac = m.isEven();
      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while(u.signum() != 0) {
        while(u.isEven()) {
          u.rShiftTo(1,u);
          if(ac) {
            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
            a.rShiftTo(1,a);
          }
          else if(!b.isEven()) b.subTo(m,b);
          b.rShiftTo(1,b);
        }
        while(v.isEven()) {
          v.rShiftTo(1,v);
          if(ac) {
            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
            c.rShiftTo(1,c);
          }
          else if(!d.isEven()) d.subTo(m,d);
          d.rShiftTo(1,d);
        }
        if(u.compareTo(v) >= 0) {
          u.subTo(v,u);
          if(ac) a.subTo(c,a);
          b.subTo(d,b);
        }
        else {
          v.subTo(u,v);
          if(ac) c.subTo(a,c);
          d.subTo(b,d);
        }
      }
      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if(d.compareTo(m) >= 0) return d.subtract(m);
      if(d.signum() < 0) d.addTo(m,d); else return d;
      if(d.signum() < 0) return d.add(m); else return d;
    }

    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
    var lplim = (1<<26)/lowprimes[lowprimes.length-1];

    // (public) test primality with certainty >= 1-.5^t
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
        for(i = 0; i < lowprimes.length; ++i)
          if(x[0] == lowprimes[i]) return true;
        return false;
      }
      if(x.isEven()) return false;
      i = 1;
      while(i < lowprimes.length) {
        var m = lowprimes[i], j = i+1;
        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while(i < j) if(m%lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t);
    }

    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if(k <= 0) return false;
      var r = n1.shiftRight(k);
      t = (t+1)>>1;
      if(t > lowprimes.length) t = lowprimes.length;
      var a = nbi();
      for(var i = 0; i < t; ++i) {
        //Pick bases at random, instead of starting at 2
        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
        var y = a.modPow(r,this);
        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while(j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2,this);
            if(y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if(y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }

    // protected
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;

    // public
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

    // JSBN-specific extension
    BigInteger.prototype.square = bnSquare;

    // BigInteger interfaces not implemented in jsbn:

    // BigInteger(int signum, byte[] magnitude)
    // double doubleValue()
    // float floatValue()
    // int hashCode()
    // long longValue()
    // static BigInteger valueOf(long val)
    if (typeof exports !== 'undefined') {
        exports = module.exports = BigInteger;
    } else {
        this.BigInteger = BigInteger;
    }
    
}).call(this);
},{}],55:[function(require,module,exports){
var ndn = require('ndn-lib');
var ElementReader = ndn.ElementReader;
var ndnbuf = ndn.customBuffer;
var Name = ndn.Name
var Data = ndn.Data
var local = {}

local.transport = function (port) {
  this.port = port
};

console.log(ndnbuf)
/**
 * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost
 *   and connectedPort.  Once connected, call onopenCallback().
 * Listen on the port to read an entire binary XML encoded element and call
 *    face.onReceivedElement(element).
 */
local.transport.prototype.connect = function(face, onopenCallback)
{
  console.log(ndn, ElementReader)
  this.elementReader = new ElementReader(face);
  var self = this;
  this.port.onmessage = function(ev) {
    console.log('RecvHandle called on local face', ev);

    if (ev.data == null || ev.data == undefined || ev.data == "") {
      console.log('INVALID ANSWER');
    }
    else if (ev.data instanceof ArrayBuffer) {
      var bytearray = new ndnbuf(ev.data);


      try {
        // Find the end of the binary XML element and call face.onReceivedElement.
        self.elementReader.onReceivedData(bytearray);
      } catch (ex) {
        console.log("NDN.ws.onmessage exception: " + ex);
        return;
      }
      // garbage collect arraybuffer
      //var ms = new MessageChannel()
      //ms.port1.postMessage(ev.data, [ev.data])
    }
  };

  onopenCallback();

};

/**
 * Send the Uint8Array data.
 */
local.transport.prototype.send = function(data)
{
  if (true) {
        // If we directly use data.buffer to feed ws.send(),
        // WebSocket may end up sending a packet with 10000 bytes of data.
        // That is, WebSocket will flush the entire buffer
        // regardless of the offset of the Uint8Array. So we have to create
        // a new Uint8Array buffer with just the right size and copy the
        // content from binaryInterest to the new buffer.
        //    ---Wentao
        var bytearray = new Uint8Array(data.length);
        bytearray.set(data);
        this.port.postMessage(bytearray.buffer);

        //garbage collect
        //var ms = new MessageChannel();
        //ms.port1.postMessage(bytearray.buffer, [bytearray.buffer])
        //ms.port1.postMessage(data.buffer, [data.buffer])
    console.log('local.send() returned.');
  }
  else
    console.log('local connection is not established.');
};

module.exports = local;

},{"ndn-lib":65}],56:[function(require,module,exports){
module.exports=require(3)
},{"jsbn":107}],57:[function(require,module,exports){
module.exports=require(4)
},{}],58:[function(require,module,exports){
module.exports=require(5)
},{}],59:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./sha256.js":64,"jsbn":107}],60:[function(require,module,exports){
module.exports=require(7)
},{"jsbn":107}],61:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"./rsa.js":60,"jsbn":107}],62:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./asn1hex-1.1.js":56,"./base64.js":57,"./rsa2.js":61}],63:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"./rsapem-1.1.js":62,"jsbn":107}],64:[function(require,module,exports){
module.exports=require(11)
},{"./core.js":58}],65:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./js/browserify.js":67,"./js/closure.js":68,"./js/data.js":69,"./js/encoding/binary-xml-wire-format.js":73,"./js/encoding/data-utils.js":74,"./js/encoding/element-reader.js":76,"./js/encoding/encoding-utils.js":77,"./js/encoding/tlv-wire-format.js":79,"./js/encoding/wire-format.js":84,"./js/exclude.js":85,"./js/face.js":87,"./js/forwarding-flags.js":89,"./js/interest.js":90,"./js/key-locator.js":91,"./js/key.js":92,"./js/meta-info.js":94,"./js/name.js":95,"./js/publisher-public-key-digest.js":97,"./js/security/key-manager.js":98,"./js/util/blob.js":101,"./js/util/name-enumeration.js":103,"./js/util/ndn-time.js":105}],66:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./transport/web-socket-transport.js":100}],67:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"../contrib/securityLib/asn1hex-1.1.js":56,"../contrib/securityLib/base64.js":57,"../contrib/securityLib/crypto-1.0.js":59,"../contrib/securityLib/rsasign-1.2.js":63}],68:[function(require,module,exports){
module.exports=require(15)
},{}],69:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./buffer.js":67,"./crypto.js":67,"./encoding/binary-xml-encoder.js":71,"./encoding/binary-xml-wire-format.js":73,"./encoding/data-utils.js":74,"./encoding/wire-format.js":84,"./key-locator.js":91,"./meta-info.js":94,"./name.js":95,"./security/key-manager.js":98,"./signature.js":99,"./util/blob.js":101,"./util/ndn-protoco-id-tags.js":104,"./util/signed-blob.js":106,"buffer":109}],70:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"../buffer.js":67,"../log.js":93,"../util/ndn-protoco-id-tags.js":104,"../util/ndn-time.js":105,"./data-utils.js":74,"./decoding-exception.js":75}],71:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"../buffer.js":67,"../log.js":93,"../util/dynamic-buffer.js":102,"../util/ndn-protoco-id-tags.js":104,"./data-utils.js":74}],72:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"../util/dynamic-buffer.js":102,"./binary-xml-decoder.js":70}],73:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"../exclude.js":85,"../key-locator.js":91,"../meta-info.js":94,"../name.js":95,"../publisher-public-key-digest.js":97,"../signature.js":99,"../util/blob.js":101,"../util/ndn-protoco-id-tags.js":104,"./binary-xml-decoder.js":70,"./binary-xml-encoder.js":71,"./data-utils.js":74,"./wire-format.js":84}],74:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"../buffer.js":67}],75:[function(require,module,exports){
module.exports=require(22)
},{}],76:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"../buffer.js":67,"../log.js":93,"./binary-xml-structure-decoder.js":72,"./data-utils.js":74,"./tlv/tlv-structure-decoder.js":82,"./tlv/tlv.js":83}],77:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"../data.js":69,"../face-instance.js":86,"../forwarding-entry.js":88,"../interest.js":90,"../key-locator.js":91,"../key.js":92,"../log.js":93,"./binary-xml-decoder.js":70,"./binary-xml-encoder.js":71,"./data-utils.js":74,"./wire-format.js":84}],78:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"../crypto.js":67,"../exclude.js":85,"../key-locator.js":91,"../meta-info.js":94,"../signature.js":99,"../util/blob.js":101,"./decoding-exception.js":75,"./tlv/tlv-decoder.js":80,"./tlv/tlv-encoder.js":81,"./tlv/tlv.js":83,"./wire-format.js":84,"crypto":113}],79:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./tlv-0_1a2-wire-format.js":78,"./wire-format.js":84}],80:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"../../buffer.js":67,"../decoding-exception.js":75}],81:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"../../buffer.js":67,"../../util/dynamic-buffer.js":102}],82:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"../../buffer.js":67,"./tlv-decoder.js":80}],83:[function(require,module,exports){
module.exports=require(30)
},{}],84:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"../buffer.js":67,"./tlv-wire-format.js":79}],85:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./buffer.js":67,"./encoding/binary-xml-decoder.js":70,"./encoding/binary-xml-encoder.js":71,"./encoding/data-utils.js":74,"./name.js":95,"./util/ndn-protoco-id-tags.js":104}],86:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./publisher-public-key-digest.js":97,"./util/ndn-protoco-id-tags.js":104}],87:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./buffer.js":67,"./closure.js":68,"./crypto.js":67,"./data.js":69,"./encoding/binary-xml-decoder.js":70,"./encoding/binary-xml-encoder.js":71,"./encoding/binary-xml-wire-format.js":73,"./encoding/data-utils.js":74,"./encoding/tlv-wire-format.js":79,"./encoding/tlv/tlv-decoder.js":80,"./encoding/tlv/tlv.js":83,"./forwarding-entry.js":88,"./forwarding-flags.js":89,"./interest.js":90,"./key-locator.js":91,"./key.js":92,"./log.js":93,"./meta-info.js":94,"./name.js":95,"./transport/tcp-transport.js":66,"./util/ndn-protoco-id-tags.js":104,"crypto":113}],88:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./name.js":95,"./publisher-public-key-digest.js":97,"./util/ndn-protoco-id-tags.js":104}],89:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./forwarding-entry.js":88}],90:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./buffer.js":67,"./encoding/binary-xml-wire-format.js":73,"./encoding/wire-format.js":84,"./exclude.js":85,"./key-locator.js":91,"./log.js":93,"./name.js":95,"./publisher-public-key-digest.js":97,"./util/blob.js":101}],91:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./buffer.js":67,"./log.js":93,"./name.js":95,"./publisher-id.js":96,"./util/ndn-protoco-id-tags.js":104}],92:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./buffer.js":67,"./crypto.js":67,"./log.js":93}],93:[function(require,module,exports){
module.exports=require(40)
},{}],94:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"./buffer.js":67,"./encoding/binary-xml-decoder.js":70,"./encoding/binary-xml-encoder.js":71,"./key-locator.js":91,"./log.js":93,"./name.js":95,"./publisher-public-key-digest.js":97,"./security/key-manager.js":98,"./util/blob.js":101,"./util/ndn-protoco-id-tags.js":104,"./util/ndn-time.js":105}],95:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./buffer.js":67,"./encoding/binary-xml-decoder.js":70,"./encoding/binary-xml-encoder.js":71,"./encoding/data-utils.js":74,"./log.js":93,"./util/blob.js":101,"./util/ndn-protoco-id-tags.js":104}],96:[function(require,module,exports){
module.exports=require(43)
},{"./encoding/decoding-exception.js":75,"./util/ndn-protoco-id-tags.js":104}],97:[function(require,module,exports){
module.exports=require(44)
},{"./log.js":93,"./util/ndn-protoco-id-tags.js":104}],98:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../key.js":92}],99:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"./buffer.js":67,"./encoding/binary-xml-decoder.js":70,"./encoding/binary-xml-encoder.js":71,"./key-locator.js":91,"./log.js":93,"./util/blob.js":101,"./util/ndn-protoco-id-tags.js":104}],100:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"../buffer.js":67,"../encoding/data-utils.js":74,"../encoding/element-reader.js":76,"../log.js":93}],101:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"../buffer.js":67}],102:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"../buffer.js":67}],103:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"../buffer.js":67,"../encoding/binary-xml-decoder.js":70,"../encoding/data-utils.js":74,"../name.js":95,"./ndn-protoco-id-tags.js":104,"buffer":109}],104:[function(require,module,exports){
module.exports=require(51)
},{}],105:[function(require,module,exports){
module.exports=require(52)
},{"../log.js":93}],106:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"../buffer.js":67,"./blob.js":101}],107:[function(require,module,exports){
module.exports=require(54)
},{}],108:[function(require,module,exports){
var utils = {}
  , ndn = require('ndn-lib')
var Data = ndn.Data
var Name = ndn.Name
var SignedInfo = ndn.SignedInfo
var ndnbuf = ndn.customBuffer
var DataUtils = ndn.DataUtils

utils.chunkArbitraryData = function(opts) {
  var ndnArray = [];
  //console.log(name)
  if (opts.type == 'object') {
    var string = JSON.stringify(opts.thing);
  } else if (typeof opts.data == 'string') {
    var string = data;
  } else if (typeof opts.data == 'file') {
    //console.log('no handlers yet for datatype: ', typeof data);
    return;
  };
  var name = new ndn.Name(opts.uri)
  if (opts.version != false) {
    utils.appendVersion(name, opts.version)
  }
  var stringArray = string.match(/.{1,4000}/g);
  var segmentNames = [];
  for (i = 0; i < stringArray.length; i++) {
    segmentNames[i] = new Name(name).appendSegment(i)
    var co = new Data(segmentNames[i], new SignedInfo(), new ndnbuf(stringArray[i]));
    co.signedInfo.setFields()
    co.signedInfo.finalBlockID = utils.initSegment(stringArray.length - 1)
    console.log(co.signedInfo.finalBlockID)
    if (opts.freshness != undefined) {
      co.signedInfo.freshnessSeconds = fresh
    }
    co.sign()
    ndnArray[i] = co.wireEncode()
  };

  return {array:ndnArray, name: name};

};

utils.initSegment = function(seg) {
    if (seg == null || seg == 0)
	  return (new ndnbuf('00', 'hex'));

    var segStr = seg.toString(16);

    if (segStr.length % 2 == 1)
	segStr = '0' + segStr;

    segStr = '00' + segStr;
    return (new ndnbuf(segStr, 'hex'));
};

utils.getAllPrefixes = function(name) {
  var uriArray = [];
  for (i = 0 ; i < name.components.length + 1 ; i++) {
    var uri = name.getPrefix(i).toUri()
    uriArray.push(uri);
  };
  return uriArray;
};

utils.isFirstSegment = function(name) {
    return name.components != null && name.components.length >= 1 &&
        name.components[name.components.length - 1].value.length == 1 &&
        name.components[name.components.length - 1].value[0] == 0;
};

utils.isLastSegment = function(name, co) {

    return DataUtils.arraysEqual(name.components[name.components.length - 1].value, co.signedInfo.finalBlockID);
}

utils.normalizeUri = function(name) {
  //console.log(name)
  if (!endsWithSegmentNumber(name)) {
    normalizedName = name;
    requestedSegment = 0
  } else if (!isFirstSegment(name)) {
    normalizedName = name.getPrefix(name.components.length - 1);
    requestedSegment = DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value);
  } else {
    normalizedName = name.getPrefix(name.components.length - 1) ;
    requestedSegment = 0;
  };
  var returns = [normalizedName, requestedSegment];
  return returns;
};

utils.getSegmentInteger = function(name) {
  if (name.components != null && name.components.length >= 1 &&
  name.components[name.components.length - 1].value.length >= 1 &&
  name.components[name.components.length - 1].value[0] == 0) {
    return DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value)
  } else {
    return 0;
  }
};

utils.normalizeNameToObjectStore = function(name) {
  var throwaway = utils.getNameWithoutCommandMarker(name);

  if (!utils.endsWithSegmentNumber(throwaway)) {
    return throwaway.appendSegment(0).toUri();
  } else if (!utils.isFirstSegment(throwaway)) {
    return throwaway.getPrefix(name.components.length - 1).appendSegment(0).toUri();
  } else {
    return throwaway.toUri();
  };
};

utils.endsWithSegmentNumber = function(name) {
    return name.components != null && name.components.length >= 1 &&
        name.components[name.components.length - 1].value.length >= 1 &&
        name.components[name.components.length - 1].value[0] == 0;
}

utils.nameHasCommandMarker = function(name) {
  for (var i = name.size() - 1; i >= 0; --i) {
    var component = name.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] == 0xC1) {
      return true
    };
  }

  return false;
};

utils.getCommandMarker = function(name) {
  //console.log(name)
  for (var i = name.size() - 1; i >= 0; --i) {
    var component = name.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] == 0xC1 && component[2] != 0x4E) {
      return name.components[i].toEscapedString()
    };
  }
};

utils.getNameWithoutCommandMarker = function(name) {
  var strippedName = new Name('');

  for (var i = 0 ; i < name.size(); i++) {
    var component = name.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] != 0xC1) {
      strippedName.append(name.components[i]);
    };
  };
  return strippedName;
};


utils.getSuffix = function(name, p) {
    return new Name(name.components.slice(p));
};

utils.appendVersion = function(name, date) {
    console.log(date)
    if (date) {
      if (date instanceof Date) {
        var d = date.getTime()

      } else if (typeof date == "number")
        var d = new Date().setTime(date)
    } else {
      var d = new Date().getTime();
    };

    var time = d.toString(16);
    if (time.length % 2 == 1) {
	    time = '0' + time;
    };
    time = 'fd' + time;
    var binTime = new ndnbuf(time, 'hex');
    //console.log(binTime)
    return name.append(binTime);
};

utils.timeToVersion = function(date) {
  if (date instanceof Date) {
    var d = date.getTime
  } else {
    var d = date;
  };
  var time = d.toString(16);
  if (time.length % 2 == 1) {
    time = '0' + time;
  };
  time = 'fd' + time;
  var binTime = new ndnbuf(time, 'hex');
  return (new Name.Component(binTime).toEscapedString())

};

utils.versionToTime = function(version) {
  time = 0
  array = DataUtils.toNumbers(DataUtils.toHex(version))
  //console.log(array)
  for (i = 1; i < array.length ; i++) {
    time = time + (array[i] * Math.pow(2, (7 - i)));
    //console.log(time)
  };
  return time
};



utils.setNonce = function(interest) {
  var bytes = [0xc1, 0x2e, 0x4e, 0x00];
  for (var n = 8; n > 0; n--) {
	  bytes.push(Math.floor(Math.random() * 256));
	  //console.log(bytes)
  }
  var buf = new ndnbuf(bytes);
  interest.nonce = buf;
}

module.exports = utils;

},{"ndn-lib":12}],109:[function(require,module,exports){
/**
 * The buffer module from node.js, for the browser.
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install buffer`
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
  if (typeof Uint8Array !== 'function' || typeof ArrayBuffer !== 'function')
    return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Bug in Firefox 4-29, now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof Uint8Array === 'function' &&
      subject instanceof Uint8Array) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array === 'function') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment the Uint8Array *instance* (not the class!) with Buffer methods
 */
function augment (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":110,"ieee754":111}],110:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],111:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],112:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":109}],113:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":114,"./rng":115,"./sha":116,"./sha256":117,"buffer":109}],114:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":112}],115:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],116:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":112}],117:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":112}]},{},[2])