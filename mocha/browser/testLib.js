(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":2,"ieee754":3}],2:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],3:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],4:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":1}],5:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,"buffer":1}],6:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":4}],7:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],8:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":4}],9:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":4}],10:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],11:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');
var url = require('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }
    
    if (!params.scheme) params.scheme = window.location.protocol.split(':')[0];
    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.scheme == 'https' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":12,"events":10,"url":29}],12:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var Base64 = require('Base64');
var inherits = require('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.scheme || 'http') + '://'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

},{"./response":13,"Base64":14,"inherits":15,"stream":22}],13:[function(require,module,exports){
var Stream = require('stream');
var util = require('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":22,"util":31}],14:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],15:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],16:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],17:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],18:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],19:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],20:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":18,"./encode":19}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var inherits = require('inherits');
var setImmediate = require('process/browser.js').nextTick;
var Readable = require('./readable.js');
var Writable = require('./writable.js');

inherits(Duplex, Readable);

Duplex.prototype.write = Writable.prototype.write;
Duplex.prototype.end = Writable.prototype.end;
Duplex.prototype._write = Writable.prototype._write;

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  var self = this;
  setImmediate(function () {
    self.end();
  });
}

},{"./readable.js":25,"./writable.js":27,"inherits":15,"process/browser.js":23}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('./readable.js');
Stream.Writable = require('./writable.js');
Stream.Duplex = require('./duplex.js');
Stream.Transform = require('./transform.js');
Stream.PassThrough = require('./passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"./duplex.js":21,"./passthrough.js":24,"./readable.js":25,"./transform.js":26,"./writable.js":27,"events":10,"inherits":15}],23:[function(require,module,exports){
module.exports=require(16)
},{}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./transform.js');
var inherits = require('inherits');
inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./transform.js":26,"inherits":15}],25:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('./index.js');
var Buffer = require('buffer').Buffer;
var setImmediate = require('process/browser.js').nextTick;
var StringDecoder;

var inherits = require('inherits');
inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, function (x) {
      return self.emit.apply(self, ev, x);
    });
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require("/home/ryan/.local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./index.js":22,"/home/ryan/.local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":16,"buffer":1,"events":10,"inherits":15,"process/browser.js":23,"string_decoder":28}],26:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./duplex.js');
var inherits = require('inherits');
inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./duplex.js":21,"inherits":15}],27:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var isUint8Array = typeof Uint8Array !== 'undefined'
  ? function (x) { return x instanceof Uint8Array }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'Uint8Array'
  }
;
var isArrayBuffer = typeof ArrayBuffer !== 'undefined'
  ? function (x) { return x instanceof ArrayBuffer }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'ArrayBuffer'
  }
;

var inherits = require('inherits');
var Stream = require('./index.js');
var setImmediate = require('process/browser.js').nextTick;
var Buffer = require('buffer').Buffer;

inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (!Buffer.isBuffer(chunk) && isUint8Array(chunk))
    chunk = new Buffer(chunk);
  if (isArrayBuffer(chunk) && typeof Uint8Array !== 'undefined')
    chunk = new Buffer(new Uint8Array(chunk));
  
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./index.js":22,"buffer":1,"inherits":15,"process/browser.js":23}],28:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

},{"buffer":1}],29:[function(require,module,exports){
/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(delims),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = rest.indexOf('@');
    if (atSign !== -1) {
      var auth = rest.slice(0, atSign);

      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        if (auth.indexOf(nonAuthChars[i]) !== -1) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }

      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = decodeURIComponent(auth);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = rest.indexOf(nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = Object.keys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = out.hostname[0] === '[' &&
        out.hostname[out.hostname.length - 1] === ']';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else if (!ipv6Hostname) {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = out.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      out.hostname = newOut.join('.');
    }

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;

    // strip [ and ] from the hostname
    if (ipv6Hostname) {
      out.hostname = out.hostname.substr(1, out.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = obj.protocol || '',
      pathname = obj.pathname || '',
      hash = obj.hash || '',
      host = false,
      query = '';

  if (obj.host !== undefined) {
    host = auth + obj.host;
  } else if (obj.hostname !== undefined) {
    host = auth + (obj.hostname.indexOf(':') === -1 ?
        obj.hostname :
        '[' + obj.hostname + ']');
    if (obj.port) {
      host += ':' + obj.port;
    }
  }

  if (obj.query && typeof obj.query === 'object' &&
      Object.keys(obj.query).length) {
    query = querystring.stringify(obj.query);
  }

  var search = obj.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && source.host.indexOf('@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && source.host.indexOf('@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      out.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

}());

},{"punycode":17,"querystring":20}],30:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],31:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("/home/ryan/.local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":30,"/home/ryan/.local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":16,"inherits":15}],32:[function(require,module,exports){
(function (Buffer){
var io = {}
  , telehashTransport = require('ndn-telehashTransport')


io.worker = new Worker(window.URL.createObjectURL(new Blob([';(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module \'"+n+"\'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){\nself.window = ""\n\nvar channelTransport = require(\'ndn-messageChannelTransport\')\n  , io = require("./ndn-io.js");\n\nvar fetchResponder = function(uri, success, thingOrObj, firstCo) {\n  if (success == true) {\n    self.postMessage({responseTo: "fetch", success: true, uri: uri, thing: thingOrObj, firstCo: firstCo})\n  } else {\n    self.postMessage({responseTo: "fetch", success: false, uri: uri});\n  }\n}\n\nonmessage = function(e){\n  console.log(e.data)\n  if (e.data.cert){\n    io.importPKI(e.data.cert,  e.data.priPem, e.data.pubPem)\n  } else if (e.data.command) {\n    if (e.data.command == "fetch") {\n      io.fetch(e.data, fetchResponder)\n    } else if (e.data.command == "publish") {\n      io.publish(e.data)\n    } else if (e.data.command == "mirror") {\n      io.mirror(e.data.uri)\n    } else if (e.data.command == "makeEncoded"){\n      io.makeEncoded(e.data, function(id, encoded) {self.postMessage({responseTo: "makeEncoded", id: id, encoded: encoded})})\n    } else if (e.data.command == "getHashName") {\n      self.postMessage({\n        responseTo: "getHashName",\n        hashName: io.getHashname()\n      })\n    } else if (e.data.command == "tangle") {\n      function ack() {\n        self.postMessage({\n          responseTo: "tangle",\n          success: true\n        })\n      }\n      if (e.data.transport == "local"){\n        console.log("tangling with local transport", e)\n        io.initFace(channelTransport, e.ports[0], ack)\n      } else if (e.data.transport == "websocket"){\n        io.initFace("websocket", {host: e.data.host, port: e.data.port}, ack)\n      } else if (e.data.transport == "telehash") {\n        io.initFace("telehash", {hashname: e.data.hashname}, ack)\n      }\n    }\n\n  }\n}\n\n\n\n\n\n},{"./ndn-io.js":2,"ndn-messageChannelTransport":3}],2:[function(require,module,exports){\nvar io = {}\n  , ndn = require("ndn-lib")\n  , utils = require(\'ndn-utils\')\n  , messageChannelTransport = require("ndn-messageChannelTransport")\n  , self\n\nio.initBuffer = []\nvar keyManager = function() {\n\n  this.certificate = null\n  this.publicKey = null\n  this.privateKey = null\n\n  this.key = null;\n};\nkeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new ndn.Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n\n  return this.key;\n}\n\nndn.globalKeyMangager =  new keyManager()\n\nio.remoteTangle = function(){}\n\nio.initFace = function(transportClass, portStreamOrWebSocket, ack){\n  console.log(transportClass, portStreamOrWebSocket, ack)\n  if ((typeof transportClass == "string") && (transportClass == "websocket" || "tcp")){\n    io.face = new ndn.Face({host:portStreamOrWebSocket.host, port: portStreamOrWebSocket.port})\n  } else {\n    console.log("local local")\n    io.face = new ndn.Face({host:1337, port:1337, getTransport:function(){return new messageChannelTransport.transport(portStreamOrWebSocket)}})\n  }\n  io.face.transport.connect(io.face, function(){\n    console.log("io face connected")\n    if (io.initBuffer.length > 0){\n      for (var i = 0; i < io.initBuffer.length; i++){\n        var action = io.initBuffer[i]\n        if (action.type = "expressInterest")\n          io.face.expressInterest(action.interest, action.onData, action.onTimeout)\n      }\n    }\n    ack()\n  })\n}\n\nio.telehashTangle = function(opts){\n\n  io.initFace(null, opts.hashname, function(){})\n\n}\n\nio.importPKI = function(cert, priPem, pubPem) {\n  ndn.globalKeyManager.certificate = cert\n  ndn.globalKeyManager.publicKey = pubPem\n  ndn.globalKeyManager.privateKey = priPem\n}\n\nio.getHashname = function() {\n  return ndn.globalKeyManager.getKey().publicKeyDigest.toString(\'hex\');\n}\n\nio.addNextHop = function(uri, cb) {\n  var d, enc, inst, name, onData, onInterest, onTimeout, param;\n\n  console.log("registering own face\'");\n\n  name = new ndn.Name("localhost/nfd/fib/add-nexthop");\n\n  param = {\n    uri: uri\n  };\n\n\n  console.log("nexthop uri:", param.uri);\n\n  d = new ndn.Data(new ndn.Name(\'\'), new ndn.SignedInfo(), JSON.stringify(param));\n\n  d.signedInfo.setFields();\n\n  d.sign();\n\n  enc = d.wireEncode();\n\n  name.append(enc.buffer);\n\n  inst = new ndn.Interest(name);\n\n  onInterest = function(prefix, interest, transport) {\n    if (interest.name.components[2].toEscapedString() === "sitemap") {\n      return pagehandler.pages(function(e, sitemap) {\n        d = new ndn.Data(interest.name, new ndn.SignedInfo(), JSON.stringify(sitemap));\n        d.signedInfo.setFields();\n        d.sign();\n        enc = d.wireEncode();\n        return transport.send(enc.buffer);\n      });\n    }\n  };\n\n  onData = function(interest, data, something) {\n    var registeredPrefix;\n    if (data.content.toString() === "success")  {\n      cb()\n    }\n  };\n\n  onTimeout = function(name, interest, something) {\n    return console.log(\'timeout for add nexthop\', name, interest, something);\n  };\n\n  io.face.expressInterest(inst, onData, onTimeout);\n\n}\n\nio.mirror = function(uri){\n    var onTimeout = function (interest) {\n      console.log("timeout", interest);\n    };\n    var onData = function(data) {\n      console.log(data)\n    };\n    //console.log(name.toUri())\n    var command = new ndn.Name(uri)\n    command.append(new ndn.Name.Component([0xc1, 0x2e, 0x52, 0x2e, 0x73, 0x77]))\n    var interest = new ndn.Interest(command)\n    interest.interestLifetime = 4000\n    utils.setNonce(interest)\n    //console.log("did this time correctly?", command.toUri())\n    io.face.expressInterest(interest, onData, onTimeout);\n}\n\nio.makeEncoded = function(data, responder) {\n  var d = new ndn.Data(new ndn.Name(data.uri), new ndn.SignedInfo(), data.bytes)\n  d.signedInfo.setFields()\n  d.sign()\n  var encoded = d.encode()\n  responder(data.id, encoded)\n\n}\nio.fetch = function(opts, responder) {\n  console.log(opts)\n  var interestsInFlight = 0;\n  var windowSize = 4;\n  var t0 = new Date().getTime()\n  var segmentRequested = [];\n  var whenNotGottenTriggered = false\n\n  var name = new ndn.Name(opts.uri)\n\n  if (opts.version) {\n    utils.appendVersion(name, opts.version);\n  }\n\n\n  var contentArray = [];\n\n  var recievedSegments = 0;\n\n  segmentRequested[interestsInFlight] = 0;\n\n  var masterInterest = new ndn.Interest(name)\n\n\n  if (opts.selectors != undefined) {\n    if (opts.selectors.publisherPublicKeyDigest != undefined) {\n      masterInterest.publisherPublicKeyDigest = new ndn.PublisherPublicKeyDigest(opts.selectors.publisherPublicKeyDigest);\n    }\n    if (opts.selectors.exclude != undefined) {\n      var comps = []\n      for (var i = 0; i < opts.selectors.exclude.length; i++) {\n        comps[i] = new ndn.Name.Component(opts.selectors.exclude[i])\n      }\n      masterInterest.exclude = new ndn.Exclude(comps)\n    }\n    if (opts.selectors.interestLifetime != undefined) {\n      masterInterest.interestLifetime = opts.selectors.interestLifetime;\n    } else {\n      masterInterest.interestLifetime = 4000;\n    }\n\n  } else {\n    masterInterest.setInterestLifetimeMilliseconds(600);\n  }\n\n  var interest = new ndn.Interest(masterInterest);\n\n  //console.log(interest.interestLifetime)\n\n  var firstCo;\n  var onData = function(interest, co) {\n    interestsInFlight--;\n    //console.log(interest)\n\n    var segmentNumber = utils.getSegmentInteger(co.name)\n    if (segmentNumber == 0) {\n      firstCo = co\n    }\n    var finalSegmentNumber = 1 + ndn.DataUtils.bigEndianToUnsignedInt(co.signedInfo.finalBlockID);\n    //console.log(segmentNumber, co.name.toUri());\n    if (contentArray[segmentNumber] == undefined) {\n      if (opts.type == \'object\') {\n        contentArray[segmentNumber] = (ndn.DataUtils.toString(co.content));\n      } else if (opts.type == \'blob\' || \'file\'){\n        contentArray[segmentNumber] = co.content;\n      }\n\n      recievedSegments++;\n    }\n\n    //console.log(recievedSegments, finalSegmentNumber, interestsInFlight);\n    if (recievedSegments == finalSegmentNumber) {\n        //console.log(\'got all segment\', contentArray.length);\n        var t1 = new Date().getTime()\n        console.log(t1 - t0)\n        if (opts.type == "object") {\n          assembleObject(name);\n        } else if (opts.type == "blob" || "file") {\n          assembleBlob(name)\n        };\n\n    } else {\n      if (interestsInFlight < windowSize) {\n        for (var i = 0; i < finalSegmentNumber; i++) {\n          if ((contentArray[i] == undefined) && (segmentRequested[i] == undefined)) {\n            var newInterest = new ndn.Interest(new ndn.Name(co.name.getPrefix(-1).appendSegment(i)))\n            newInterest.setInterestLifetimeMilliseconds(600)\n            io.face.expressInterest(newInterest, onData, onTimeout)\n            segmentRequested[i] = 0;\n            interestsInFlight++\n            if (interestsInFlight == windowSize) {\n              //stop iterating\n              i = finalSegmentNumber;\n            };\n          };\n        };\n      };\n    };\n  };\n  var onTimeout = function(interest) {\n    var seg = utils.getSegmentInteger(interest.name)\n    if (segmentRequested[seg] < 4) {\n      segmentRequested[seg]++\n      var newInterest = new ndn.Interest(interest);\n      console.log(masterInterest.interestLifetime)\n      newInterest.setInterestLifetimeMilliseconds(masterInterest.interestLifetime)\n      io.face.expressInterest(newInterest, onData, onTimeout)\n\n    } else if ((whenNotGottenTriggered == false)) {\n      whenNotGottenTriggered = true;\n      console.log(segmentRequested)\n      responder(opts.uri, false)\n    }\n  };\n\n  var assembleBlob = function(name) {\n    var mime = name.components[2].toEscapedString() + \'/\' + name.components[3].toEscapedString()\n    var blob = new Blob(contentArray, {type: mime})\n    responder(opts.uri, true, blob, firstCo)\n  };\n\n  var assembleObject = function(name) {\n    var string = "";\n    for (var i = 0; i < contentArray.length; i++) {\n      string += contentArray[i];\n    };\n    var obj = JSON.parse(string);\n    responder(opts.uri, true, obj, firstCo)\n  };\n\n\n\n  //console.log(interest.name.toUri())\n  if (io.face == undefined){\n    io.initBuffer.push({type: "expressInterest", interest: interest, onData: onData, onTimeout: onTimeout})\n  } else {\n\n    io.face.expressInterest(interest, onData, onTimeout);\n  }\n\n\n};\n\nio.publishFile = function(opts) {\n  //console.log( opts.thing)\n  var chunkSize = 1050,\n      fileSize = (opts.thing.size - 1),\n      totalSegments = Math.ceil(opts.thing.size / chunkSize),\n      name = new ndn.Name(opts.uri)\n\n\n  function getSlice(file, segment, transport) {\n    //console.log(file)\n    var fr = new FileReader(),\n        chunks = totalSegments,\n        start = segment * chunkSize,\n        end = start + chunkSize >= file.size ? file.size : start + chunkSize,\n        blob = file.slice(start,end);\n\n    fr.onloadend = function(e) {\n      var buff = new ndn.ndnbuf(e.target.result),\n          segmentName = (new ndn.Name(name)).appendSegment(segment),\n          data = new ndn.Data(segmentName, new ndn.SignedInfo(), buff),\n          encodedData;\n\n        data.signedInfo.setFields();\n        data.signedInfo.finalBlockID = utils.initSegment(totalSegments - 1);\n        data.sign();\n        encodedData = data.encode();\n\n        transport.send(encodedData);\n        var ms = new MessageChannel()\n        ms.port1.postMessage(e.target.result, [e.target.result])\n        //ms.port1.postMessage(buff.buffer, [buff.buffer])\n        if (segment == totalSegments -1) {\n          //remove closure from registeredPrefixTable\n          for (var i = 0; i < ndn.Face.registeredPrefixTable.length; i++) {\n            if (ndn.Face.registeredPrefixTable[i].prefix.match(new ndn.Name(name))) {\n              ndn.Face.registeredPrefixTable.splice(i,1);\n            }\n          }\n        }\n    };\n    //console.log("about to read as array buffer")\n    fr.readAsArrayBuffer(blob, (end - start))\n\n\n  };\n  //console.log(\'y u crashing?\')\n  function onInterest(prefix, interest, transport) {\n    //console.log("onInterest called.", opts);\n    if (!utils.endsWithSegmentNumber(interest.name)) {\n      interest.name.appendSegment(0);\n    };\n    var segment = ndn.DataUtils.bigEndianToUnsignedInt(interest.name.components[interest.name.components.length - 1].value);\n\n    getSlice(opts.thing, segment, transport)\n\n  };\n  //console.log(\'when u crashing?\')\n  function sendWriteCommand() {\n    var onTimeout = function (interest) {\n      console.log("timeout", interest);\n    };\n    var onData = function(data) {\n      console.log(data)\n    };\n    //console.log(name.toUri())\n    var command = name.getPrefix(- 1).append(new ndn.Name.Component([0xc1, 0x2e, 0x52, 0x2e, 0x73, 0x77])).append(utils.getSuffix(name, name.components.length - 1 ))\n    var interest = new ndn.Interest(command)\n    interest.interestLifetime = 4000\n    utils.setNonce(interest)\n    //console.log("did this time correctly?", command.toUri())\n    io.face.expressInterest(interest, onData, onTimeout);\n\n  };\n  var prefix = name\n  //console.log(name.toUri())\n  var closure = new ndn.Face.CallbackClosure(null, null, onInterest, prefix, io.face.transport);\n  ndn.Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n  console.log("publish defined")\n  setTimeout(sendWriteCommand, 0)\n\n};\n\nio.publishObject = function(opts, successcb, failcb) {\n  var returns = utils.chunkArbitraryData(opts)\n  var name = returns.name\n  var ndnArray = returns.array\n\n  var onInterest = function(prefix, interest, transport) {\n    var requestedSegment = utils.getSegmentInteger(interest.name)\n    console.log("got object interest!!!!", ndnArray[requestedSegment])\n    transport.send(ndnArray[requestedSegment].buffer)\n  };\n  var prefix = name\n\n  function sendWriteCommand() {\n    var onTimeout = function (interest) {\n      console.log("timeout", interest.toUri());\n      io.face.expressInterest(interest, onData, onTimeout);\n    };\n    var onData = function(interest, data) {\n      console.log("got data in writecommand interest " + interest.name.toUri())\n      if (data.content.toString() == "content stored"){\n        successcb()\n      }\n    };\n    var closure = new ndn.Face.CallbackClosure(null, null, onInterest, prefix, io.face.transport);\n    ndn.Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n    var command = name.getPrefix(- 1).append(new ndn.Name.Component([0xc1, 0x2e, 0x52, 0x2e, 0x73, 0x77])).append(utils.getSuffix(name, name.components.length - 1 ))\n    console.log(command.toUri())\n    var interest = new ndn.Interest(command)\n    console.log(interest.toUri())\n    interest.setInterestLifetimeMilliseconds(10000)\n    console.log("did this time correctly?" + interest.name.toUri())\n    io.face.expressInterest(interest, onData, onTimeout);\n\n  };\n  setTimeout(sendWriteCommand, 0)\n};\n\nio.publish = function (opts) {\n  console.log(JSON.stringify(opts))\n  function afterNextHopAdded(){\n    if (opts.type== "object") {\n      io.publishObject(opts)\n    } else if (opts.type == "file" || "blob" ) {\n      io.publishFile(opts)\n    }\n  }\n  io.addNextHop(opts.uri, afterNextHopAdded)\n\n}\n\nfunction cb() {\n  var keyName = new ndn.Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\')\n  var inst = new ndn.Interest(keyName)\n\n}\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n\nmodule.exports = io;\n\n},{"ndn-lib":4,"ndn-messageChannelTransport":3,"ndn-utils":5}],3:[function(require,module,exports){\nvar ndn = require(\'ndn-lib\');\nvar ElementReader = ndn.ElementReader;\nvar ndnbuf = ndn.customBuffer;\nvar Name = ndn.Name\nvar Data = ndn.Data\nvar local = {}\n\nlocal.transport = function (port) {\n  this.port = port\n};\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nlocal.transport.prototype.connect = function(face, onopenCallback)\n{\n  console.log(ndn, ElementReader)\n  this.elementReader = new ElementReader(face);\n  var self = this;\n  this.port.onmessage = function(ev) {\n    console.log(\'RecvHandle called on local face\', ev);\n\n    if (ev.data == null || ev.data == undefined || ev.data == "") {\n      console.log(\'INVALID ANSWER\');\n    }\n    else if (ev.data instanceof ArrayBuffer) {\n      var bytearray = new ndnbuf(ev.data);\n      console.log(ev.data)\n      console.log(bytearray)\n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n      // garbage collect arraybuffer\n      //var ms = new MessageChannel()\n      //ms.port1.postMessage(ev.data, [ev.data])\n    }\n  };\n\n  onopenCallback();\n\n};\n\n/**\n * Send the Uint8Array data.\n */\nlocal.transport.prototype.send = function(data)\n{\n  if (true) {\n        // If we directly use data.buffer to feed ws.send(),\n        // WebSocket may end up sending a packet with 10000 bytes of data.\n        // That is, WebSocket will flush the entire buffer\n        // regardless of the offset of the Uint8Array. So we have to create\n        // a new Uint8Array buffer with just the right size and copy the\n        // content from binaryInterest to the new buffer.\n        //    ---Wentao\n        console.log("localtransport.port.postMessage", data)\n        this.port.postMessage(data);\n\n        //garbage collect\n        //var ms = new MessageChannel();\n        //ms.port1.postMessage(bytearray.buffer, [bytearray.buffer])\n        //ms.port1.postMessage(data.buffer, [data.buffer])\n    console.log(\'local.send() returned.\');\n  }\n  else\n    console.log(\'local connection is not established.\');\n};\n\nmodule.exports = local;\n\n},{"ndn-lib":6}],4:[function(require,module,exports){\n(function(){exports.Face = require(\'./js/face.js\').Face;\nexports.NDN = require(\'./js/face.js\').NDN; // deprecated\nexports.Closure = require(\'./js/closure.js\').Closure;\nexports.Name = require(\'./js/name.js\').Name;\nexports.ForwardingFlags = require(\'./js/forwarding-flags.js\').ForwardingFlags;\nexports.Interest = require(\'./js/interest.js\').Interest;\nexports.Exclude = require(\'./js/exclude.js\').Exclude;\nexports.Data = require(\'./js/data.js\').Data;\nexports.ContentObject = require(\'./js/data.js\').ContentObject; // deprecated\nexports.ContentType = require(\'./js/meta-info.js\').ContentType;\nexports.MetaInfo = require(\'./js/meta-info.js\').MetaInfo;\nexports.SignedInfo = require(\'./js/meta-info.js\').SignedInfo; // deprecated\nexports.Key = require(\'./js/key.js\').Key;\nexports.KeyLocator = require(\'./js/key-locator.js\').KeyLocator;\nexports.KeyName = require(\'./js/key-locator.js\').KeyName;\nexports.KeyLocatorType = require(\'./js/key-locator.js\').KeyLocatorType;\nexports.PublisherPublicKeyDigest = require(\'./js/publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nexports.WireFormat = require(\'./js/encoding/wire-format.js\').WireFormat;\nexports.BinaryXmlWireFormat = require(\'./js/encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nexports.TlvWireFormat = require(\'./js/encoding/tlv-wire-format.js\').TlvWireFormat;\nexports.TlvDecoder = require(\'./js/encoding/tlv/tlv-decoder.js\').TlvDecoder;\nexports.Tlv = require(\'./js/encoding/tlv/tlv.js\').Tlv\nexports.DataUtils = require(\'./js/encoding/data-utils.js\').DataUtils;\nexports.EncodingUtils = require(\'./js/encoding/encoding-utils.js\').EncodingUtils;\nexports.Blob = require(\'./js/util/blob.js\').Blob;\nexports.NameEnumeration = require(\'./js/util/name-enumeration.js\').NameEnumeration;\nexports.NDNTime = require(\'./js/util/ndn-time.js\').NDNTime;\nexports.globalKeyManager = require(\'./js/security/key-manager.js\').globalKeyManager;\nexports.ElementReader = require(\'./js/encoding/element-reader.js\').ElementReader;\nexports.customBuffer = require(\'./js/browserify.js\').Buffer\n\n})()\n},{"./js/browserify.js":30,"./js/closure.js":8,"./js/data.js":13,"./js/encoding/binary-xml-wire-format.js":19,"./js/encoding/data-utils.js":23,"./js/encoding/element-reader.js":29,"./js/encoding/encoding-utils.js":24,"./js/encoding/tlv-wire-format.js":20,"./js/encoding/tlv/tlv-decoder.js":21,"./js/encoding/tlv/tlv.js":22,"./js/encoding/wire-format.js":18,"./js/exclude.js":12,"./js/face.js":7,"./js/forwarding-flags.js":10,"./js/interest.js":11,"./js/key-locator.js":16,"./js/key.js":15,"./js/meta-info.js":14,"./js/name.js":9,"./js/publisher-public-key-digest.js":17,"./js/security/key-manager.js":28,"./js/util/blob.js":25,"./js/util/name-enumeration.js":26,"./js/util/ndn-time.js":27}],8:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Provide the callback closure for the async communication methods in the Face class.\n * This is a port of Closure.py from PyNDN, written by: \n * Derek Kulinski <takeda@takeda.tk>\n * Jeff Burke <jburke@ucla.edu>\n */\n\n/**\n * A subclass of Closure is passed to expressInterest and registerPrefix.\n * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.\n * @constructor\n */\nvar Closure = function Closure() \n{\n  // I don\'t think storing Face\'s closure is needed\n  // and it creates a reference loop, as of now both\n  // of those variables are never set -- Derek\n  //\n  // Use instance variables to return data to callback\n  this.ndn_data = null;  // this holds the ndn_closure\n  this.ndn_data_dirty = false; \n};\n\nexports.Closure = Closure;\n\n// Upcall result\nClosure.RESULT_ERR               = -1; // upcall detected an error\nClosure.RESULT_OK                =  0; // normal upcall return\nClosure.RESULT_REEXPRESS         =  1; // reexpress the same interest again\nClosure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest\nClosure.RESULT_VERIFY            =  3; // force an unverified result to be verified\nClosure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest\n                                       //   with the key available in the local storage\n\n// Upcall kind\nClosure.UPCALL_FINAL              = 0; // handler is about to be deregistered\nClosure.UPCALL_INTEREST           = 1; // incoming interest\nClosure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered\nClosure.UPCALL_CONTENT            = 3; // incoming verified content\nClosure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out\nClosure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified\nClosure.UPCALL_CONTENT_BAD        = 6; // verification failed\n\n/**\n * Override this in your subclass.\n * If you\'re getting strange errors in upcall()\n * check your code whether you\'re returning a value.\n */\nClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  //dump(\'upcall \' + this + " " + kind + " " + upcallInfo + "\\n");\n  return Closure.RESULT_OK;\n};\n\n/**\n * An UpcallInfo is passed to Closure.upcall.\n * @constructor\n */\nvar UpcallInfo = function UpcallInfo(face, interest, matchedComps, data) \n{\n  this.face = face;  // Face object (not used)\n  this.ndn = face;   // deprecated\n  this.interest = interest;  // Interest object\n  this.matchedComps = matchedComps;  // int\n  this.data = data;  // Data\n  this.contentObject = data; // deprecated.  Include for backward compatibility.\n};\n\nUpcallInfo.prototype.toString = function() \n{\n  var ret = "face = " + this.face;\n  ret += "\\nInterest = " + this.interest;\n  ret += "\\nmatchedComps = " + this.matchedComps;\n  ret += "\\nData: " + this.data;\n  return ret;\n};\n\nexports.UpcallInfo = UpcallInfo;\n\n},{}],22:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Tlv class has static type codes for the NDN-TLV wire format.\n * @constructor\n */\nvar Tlv = function Tlv()\n{\n}\n\nexports.Tlv = Tlv;\n\nTlv.Interest =         5;\nTlv.Data =             6;\nTlv.Name =             7;\nTlv.NameComponent =    8;\nTlv.Selectors =        9;\nTlv.Nonce =            10;\nTlv.Scope =            11;\nTlv.InterestLifetime = 12;\nTlv.MinSuffixComponents = 13;\nTlv.MaxSuffixComponents = 14;\nTlv.PublisherPublicKeyLocator = 15;\nTlv.Exclude =          16;\nTlv.ChildSelector =    17;\nTlv.MustBeFresh =      18;\nTlv.Any =              19;\nTlv.MetaInfo =         20;\nTlv.Content =          21;\nTlv.SignatureInfo =    22;\nTlv.SignatureValue =   23;\nTlv.ContentType =      24;\nTlv.FreshnessPeriod =  25;\nTlv.FinalBlockId =     26;\nTlv.SignatureType =    27;\nTlv.KeyLocator =       28;\nTlv.KeyLocatorDigest = 29;\nTlv.FaceInstance =     128;\nTlv.ForwardingEntry =  129;\nTlv.StatusResponse =   130;\nTlv.Action =           131;\nTlv.FaceID =           132;\nTlv.IPProto =          133;\nTlv.Host =             134;\nTlv.Port =             135;\nTlv.MulticastInterface = 136;\nTlv.MulticastTTL =     137;\nTlv.ForwardingFlags =  138;\nTlv.StatusCode =       139;\nTlv.StatusText =       140;\n\nTlv.SignatureType_DigestSha256 = 0;\nTlv.SignatureType_SignatureSha256WithRsa = 1;\n\n},{}],6:[function(require,module,exports){\n(function(){exports.Face = require(\'./js/face.js\').Face;\nexports.NDN = require(\'./js/face.js\').NDN; // deprecated\nexports.Closure = require(\'./js/closure.js\').Closure;\nexports.Name = require(\'./js/name.js\').Name;\nexports.ForwardingFlags = require(\'./js/forwarding-flags.js\').ForwardingFlags;\nexports.Interest = require(\'./js/interest.js\').Interest;\nexports.Exclude = require(\'./js/exclude.js\').Exclude;\nexports.Data = require(\'./js/data.js\').Data;\nexports.ContentObject = require(\'./js/data.js\').ContentObject; // deprecated\nexports.ContentType = require(\'./js/meta-info.js\').ContentType;\nexports.MetaInfo = require(\'./js/meta-info.js\').MetaInfo;\nexports.SignedInfo = require(\'./js/meta-info.js\').SignedInfo; // deprecated\nexports.Key = require(\'./js/key.js\').Key;\nexports.KeyLocator = require(\'./js/key-locator.js\').KeyLocator;\nexports.KeyName = require(\'./js/key-locator.js\').KeyName;\nexports.KeyLocatorType = require(\'./js/key-locator.js\').KeyLocatorType;\nexports.PublisherPublicKeyDigest = require(\'./js/publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nexports.WireFormat = require(\'./js/encoding/wire-format.js\').WireFormat;\nexports.BinaryXmlWireFormat = require(\'./js/encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nexports.TlvWireFormat = require(\'./js/encoding/tlv-wire-format.js\').TlvWireFormat;\nexports.TlvDecoder = require(\'./js/encoding/tlv/tlv-decoder.js\').TlvDecoder;\nexports.Tlv = require(\'./js/encoding/tlv/tlv.js\').Tlv\nexports.DataUtils = require(\'./js/encoding/data-utils.js\').DataUtils;\nexports.EncodingUtils = require(\'./js/encoding/encoding-utils.js\').EncodingUtils;\nexports.Blob = require(\'./js/util/blob.js\').Blob;\nexports.NameEnumeration = require(\'./js/util/name-enumeration.js\').NameEnumeration;\nexports.NDNTime = require(\'./js/util/ndn-time.js\').NDNTime;\nexports.globalKeyManager = require(\'./js/security/key-manager.js\').globalKeyManager;\nexports.ElementReader = require(\'./js/encoding/element-reader.js\').ElementReader;\nexports.customBuffer = require(\'./js/browserify.js\').Buffer\n\n})()\n},{"./js/browserify.js":54,"./js/closure.js":32,"./js/data.js":37,"./js/encoding/binary-xml-wire-format.js":43,"./js/encoding/data-utils.js":47,"./js/encoding/element-reader.js":53,"./js/encoding/encoding-utils.js":48,"./js/encoding/tlv-wire-format.js":44,"./js/encoding/tlv/tlv-decoder.js":45,"./js/encoding/tlv/tlv.js":46,"./js/encoding/wire-format.js":42,"./js/exclude.js":36,"./js/face.js":31,"./js/forwarding-flags.js":34,"./js/interest.js":35,"./js/key-locator.js":40,"./js/key.js":39,"./js/meta-info.js":38,"./js/name.js":33,"./js/publisher-public-key-digest.js":41,"./js/security/key-manager.js":52,"./js/util/blob.js":49,"./js/util/name-enumeration.js":50,"./js/util/ndn-time.js":51}],5:[function(require,module,exports){\nvar utils = {}\n  , ndn = require(\'ndn-lib\')\nvar Data = ndn.Data\nvar Name = ndn.Name\nvar SignedInfo = ndn.SignedInfo\nvar ndnbuf = ndn.customBuffer\nvar DataUtils = ndn.DataUtils\n\nutils.chunkArbitraryData = function(opts) {\n  var ndnArray = [];\n  //console.log(name)\n  if (opts.type == \'object\') {\n    var string = JSON.stringify(opts.thing);\n  }\n  var name = new ndn.Name(opts.uri)\n  if (opts.version != false) {\n    utils.appendVersion(name, opts.version)\n  }\n  var stringArray = string.match(/.{1,1300}/g);\n  var segmentNames = [];\n  for (i = 0; i < stringArray.length; i++) {\n    segmentNames[i] = new Name(name).appendSegment(i)\n    var co = new Data(segmentNames[i], new SignedInfo(), stringArray[i]);\n    co.signedInfo.setFields()\n    co.signedInfo.finalBlockID = utils.initSegment(stringArray.length - 1)\n\n    if (opts.freshness != undefined) {\n      co.signedInfo.setFreshnessPeriod(opts.freshness)\n    }\n    co.sign()\n    ndnArray[i] = co.wireEncode()\n  };\n\n  return {array:ndnArray, name: name};\n\n};\n\nutils.initSegment = function(seg) {\n    if (seg == null || seg == 0)\n\t  return (new ndnbuf(\'00\', \'hex\'));\n\n    var segStr = seg.toString(16);\n\n    if (segStr.length % 2 == 1)\n\tsegStr = \'0\' + segStr;\n\n    segStr = \'00\' + segStr;\n    return (new ndnbuf(segStr, \'hex\'));\n};\n\nutils.getAllPrefixes = function(name) {\n  var uriArray = [];\n  for (i = 0 ; i < name.components.length + 1 ; i++) {\n    var uri = name.getPrefix(i).toUri()\n    uriArray.push(uri);\n  };\n  return uriArray;\n};\n\nutils.isFirstSegment = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length == 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n};\n\nutils.isLastSegment = function(name, co) {\n\n    return DataUtils.arraysEqual(name.components[name.components.length - 1].value, co.signedInfo.finalBlockID);\n}\n\nutils.normalizeUri = function(name) {\n  //console.log(name)\n  if (!endsWithSegmentNumber(name)) {\n    normalizedName = name;\n    requestedSegment = 0\n  } else if (!isFirstSegment(name)) {\n    normalizedName = name.getPrefix(name.components.length - 1);\n    requestedSegment = DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value);\n  } else {\n    normalizedName = name.getPrefix(name.components.length - 1) ;\n    requestedSegment = 0;\n  };\n  var returns = [normalizedName, requestedSegment];\n  return returns;\n};\n\nutils.getSegmentInteger = function(name) {\n  if (name.components != null && name.components.length >= 1 &&\n  name.components[name.components.length - 1].value.length >= 1 &&\n  name.components[name.components.length - 1].value[0] == 0) {\n    return DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value)\n  } else {\n    return 0;\n  }\n};\n\nutils.normalizeNameToObjectStore = function(name) {\n  var throwaway = utils.getNameWithoutCommandMarker(name);\n\n  if (!utils.endsWithSegmentNumber(throwaway)) {\n    return throwaway.appendSegment(0).toUri();\n  } else if (!utils.isFirstSegment(throwaway)) {\n    return throwaway.getPrefix(name.components.length - 1).appendSegment(0).toUri();\n  } else {\n    return throwaway.toUri();\n  };\n};\n\nutils.endsWithSegmentNumber = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length >= 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n}\n\nutils.nameHasCommandMarker = function(name) {\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1) {\n      return true\n    };\n  }\n\n  return false;\n};\n\nutils.getCommandMarker = function(name) {\n  //console.log(name)\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1 && component[2] != 0x4E) {\n      return name.components[i].toEscapedString()\n    };\n  }\n};\n\nutils.getNameWithoutCommandMarker = function(name) {\n  var strippedName = new Name(\'\');\n\n  for (var i = 0 ; i < name.size(); i++) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] != 0xC1) {\n      strippedName.append(name.components[i]);\n    };\n  };\n  return strippedName;\n};\n\n\nutils.getSuffix = function(name, p) {\n    return new Name(name.components.slice(p));\n};\n\nutils.appendVersion = function(name, date) {\n    console.log(date)\n    if (date) {\n      if (date instanceof Date) {\n        var d = date.getTime()\n\n      } else if (typeof date == "number")\n        var d = new Date().setTime(date)\n    } else {\n      var d = new Date().getTime();\n    };\n\n    var time = d.toString(16);\n    if (time.length % 2 == 1) {\n\t    time = \'0\' + time;\n    };\n    time = \'fd\' + time;\n    var binTime = new ndnbuf(time, \'hex\');\n    //console.log(binTime)\n    return name.append(binTime);\n};\n\nutils.timeToVersion = function(date) {\n  if (date instanceof Date) {\n    var d = date.getTime\n  } else {\n    var d = date;\n  };\n  var time = d.toString(16);\n  if (time.length % 2 == 1) {\n    time = \'0\' + time;\n  };\n  time = \'fd\' + time;\n  var binTime = new ndnbuf(time, \'hex\');\n  return (new Name.Component(binTime).toEscapedString())\n\n};\n\nutils.versionToTime = function(version) {\n  time = 0\n  array = DataUtils.toNumbers(DataUtils.toHex(version))\n  //console.log(array)\n  for (i = 1; i < array.length ; i++) {\n    time = time + (array[i] * Math.pow(2, (7 - i)));\n    //console.log(time)\n  };\n  return time\n};\n\n\n\nutils.setNonce = function(interest) {\n  var bytes = [0xc1, 0x2e, 0x4e, 0x00];\n  for (var n = 8; n > 0; n--) {\n\t  bytes.push(Math.floor(Math.random() * 256));\n\t  //console.log(bytes)\n  }\n  var buf = new ndnbuf(bytes);\n  interest.nonce = buf;\n}\n\nmodule.exports = utils;\n\n},{"ndn-lib":55}],7:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang\n * See COPYING for copyright and distribution information.\n * This class represents the top-level object for communicating with an NDN host.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar crypto = require(\'./crypto.js\');\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Interest = require(\'./interest.js\').Interest;\nvar Data = require(\'./data.js\').Data;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\nvar TlvWireFormat = require(\'./encoding/tlv-wire-format.js\').TlvWireFormat;\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nvar Tlv = require(\'./encoding/tlv/tlv.js\').Tlv;\nvar TlvDecoder = require(\'./encoding/tlv/tlv-decoder.js\').TlvDecoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Key = require(\'./key.js\').Key;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar ForwardingFlags = require(\'./forwarding-flags.js\').ForwardingFlags;\nvar Closure = require(\'./closure.js\').Closure;\nvar UpcallInfo = require(\'./closure.js\').UpcallInfo;\nvar TcpTransport = require(\'./transport/tcp-transport.js\').TcpTransport;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Face with the given settings.\n * This throws an exception if Face.supported is false.\n * @constructor\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.\n *              OR function() { return new TcpTransport(); },       // If in Node.js.\n *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.\n *   host: null, // If null, use getHostAndPort when connecting.\n *   port: 9696, // If in the browser.\n *      OR 6363, // If in Node.js.\n *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },\n *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },\n *   verify: false // If false, don\'t verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.\n * }\n */\nvar Face = function Face(settings)\n{\n  if (!Face.supported)\n    throw new Error("The necessary JavaScript support is not available on this platform.");\n\n  settings = (settings || {});\n  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.\n  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });\n  this.transport = getTransport();\n  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);\n  this.host = (settings.host !== undefined ? settings.host : null);\n  this.port = (settings.port || (typeof WebSocketTransport != \'undefined\' ? 9696 : 6363));\n  this.readyStatus = Face.UNOPEN;\n  this.verify = (settings.verify !== undefined ? settings.verify : false);\n  // Event handler\n  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });\n  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });\n  this.ndndid = null;\n};\n\nexports.Face = Face;\n\nFace.UNOPEN = 0;  // created but not opened yet\nFace.OPENED = 1;  // connection to ndnd opened\nFace.CLOSED = 2;  // connection to ndnd closed\n\n/**\n * Return true if necessary JavaScript support is available, else log an error and return false.\n */\nFace.getSupported = function()\n{\n  try {\n    var dummy = new customBuf(1).slice(0, 1);\n  }\n  catch (ex) {\n    console.log("NDN not available: customBuf not supported. " + ex);\n    return false;\n  }\n\n  return true;\n};\n\nFace.supported = Face.getSupported();\n\nFace.ndndIdFetcher = new Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\');\n\nFace.prototype.createRoute = function(host, port)\n{\n  this.host=host;\n  this.port=port;\n};\n\nFace.KeyStore = new Array();\n\nvar KeyStoreEntry = function KeyStoreEntry(name, rsa, time)\n{\n  this.keyName = name;  // KeyName\n  this.rsaKey = rsa;    // RSA key\n  this.timeStamp = time;  // Time Stamp\n};\n\nFace.addKeyEntry = function(/* KeyStoreEntry */ keyEntry)\n{\n  var result = Face.getKeyByName(keyEntry.keyName);\n  if (result == null)\n    Face.KeyStore.push(keyEntry);\n  else\n    result = keyEntry;\n};\n\nFace.getKeyByName = function(/* KeyName */ name)\n{\n  var result = null;\n\n  for (var i = 0; i < Face.KeyStore.length; i++) {\n    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {\n      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)\n        result = Face.KeyStore[i];\n    }\n  }\n\n  return result;\n};\n\nFace.prototype.close = function()\n{\n  if (this.readyStatus != Face.OPENED)\n    throw new Error(\'Cannot close because Face connection is not opened.\');\n\n  this.readyStatus = Face.CLOSED;\n  this.transport.close();\n};\n\n// For fetching data\nFace.PITTable = new Array();\n\n/**\n * @constructor\n */\nvar PITEntry = function PITEntry(interest, closure)\n{\n  this.interest = interest;  // Interest\n  this.closure = closure;    // Closure\n  this.timerID = -1;  // Timer ID\n};\n\n/**\n * Return the entry from Face.PITTable where the name conforms to the interest selectors, and\n * the interest name is the longest that matches name.\n */\n\n/**\n * Find all entries from Face.PITTable where the name conforms to the entry\'s\n * interest selectors, remove the entries from the table, cancel their timeout\n * timers and return them.\n * @param {Name} name The name to find the interest for (from the incoming data\n * packet).\n * @returns {Array<PITEntry>} The matching entries from Face.PITTable, or [] if\n * none are found.\n */\nFace.extractEntriesForExpressedInterest = function(name)\n{\n  var result = [];\n\n  // Go backwards through the list so we can erase entries.\n  for (var i = Face.PITTable.length - 1; i >= 0; --i) {\n    var entry = Face.PITTable[i];\n    if (entry.interest.matchesName(name)) {\n      // Cancel the timeout timer.\n      clearTimeout(entry.timerID);\n\n      result.push(entry);\n      Face.PITTable.splice(i, 1);\n    }\n  }\n\n  return result;\n};\n\n// For publishing data\nFace.registeredPrefixTable = new Array();\n\n/**\n * @constructor\n */\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n/**\n * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.\n * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).\n * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.\n */\nfunction getEntryForRegisteredPrefix(name)\n{\n  var iResult = -1;\n\n  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {\n    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " , Face.registeredPrefixTable[i].prefix , " matches " , name);\n    if (Face.registeredPrefixTable[i].prefix.match(name)) {\n      if (iResult < 0 ||\n          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())\n        // Update to the longer match.\n        iResult = i;\n    }\n  }\n\n  if (iResult >= 0)\n    return Face.registeredPrefixTable[iResult];\n  else\n    return null;\n}\n\n/**\n * Return a function that selects a host at random from hostList and returns { host: host, port: port }.\n * If no more hosts remain, return null.\n */\nFace.makeShuffledGetHostAndPort = function(hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n/**\n * Send the interest through the transport, read the entire response and call onData.\n * If the interest times out according to interest lifetime, call onTimeout (if not omitted).\n * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):\n * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from\n * a name and optional interest template:\n * expressInterest(name [, template], onData [, onTimeout]).\n * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.\n * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.\n * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:\n *   interest is the interest given to expressInterest,\n *   data is the received Data object.\n * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime,\n *   this calls onTimeout(interest) where:\n *   interest is the interest given to expressInterest.\n * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).\n * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest.\n * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).\n */\nFace.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of expressInterest, each shown inline below.\n\n  // expressInterest(Name name, Closure closure);                      // deprecated\n  // expressInterest(Name name, Closure closure,   Interest template); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    if (arg3) {\n      var template = arg3;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n    }\n    else\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n\n    this.expressInterestWithClosure(interest, arg2);\n    return;\n  }\n\n  var interest;\n  var onData;\n  var onTimeout;\n  // expressInterest(Interest interest, function onData);\n  // expressInterest(Interest interest, function onData, function onTimeout);\n  if (typeof interestOrName == \'object\' && interestOrName instanceof Interest) {\n    // Just use a copy of the interest.\n    interest = new Interest(interestOrName);\n    onData = arg2;\n    onTimeout = (arg3 ? arg3 : function() {});\n  }\n  else {\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    // expressInterest(Name name, Interest template, function onData);\n    // expressInterest(Name name, Interest template, function onData, function onTimeout);\n    if (arg2 && typeof arg2 == \'object\' && arg2 instanceof Interest) {\n      var template = arg2;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n\n      onData = arg3;\n      onTimeout = (arg4 ? arg4 : function() {});\n    }\n    // expressInterest(Name name, function onData);\n    // expressInterest(Name name, function onData,   function onTimeout);\n    else {\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n      onData = arg2;\n      onTimeout = (arg3 ? arg3 : function() {});\n    }\n  }\n\n  // Make a Closure from the callbacks so we can use expressInterestWithClosure.\n  // TODO: Convert the PIT to use callbacks, not a closure.\n  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout), interest);\n}\n\nFace.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.onData = onData;\n  this.onTimeout = onTimeout;\n  this.onInterest = onInterest;\n  this.prefix = prefix;\n  this.transport = transport;\n};\n\nFace.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {\n  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)\n    this.onData(upcallInfo.interest, upcallInfo.data);\n  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)\n    this.onTimeout(upcallInfo.interest);\n  else if (kind == Closure.UPCALL_INTEREST)\n    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.\n    this.onInterest(this.prefix, upcallInfo.interest, this.transport)\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * A private method to send the the interest to host:port, read the entire response and call\n * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),\n *                 new UpcallInfo(this, interest, 0, data)).\n * @deprecated Use expressInterest with callback functions, not Closure.\n * @param {Interest} the interest, already processed with a template (if supplied).\n * @param {Closure} closure\n */\nFace.prototype.expressInterestWithClosure = function(interest, closure)\n{\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else {\n      var thisNDN = this;\n      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });\n    }\n  }\n  else\n    this.reconnectAndExpressInterest(interest, closure);\n};\n\n/**\n * If the host and port are different than the ones in this.transport, then call\n *   this.transport.connect to change the connection (or connect for the first time).\n * Then call expressInterestHelper.\n */\nFace.prototype.reconnectAndExpressInterest = function(interest, closure)\n{\n  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {\n    var thisNDN = this;\n    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });\n    this.readyStatus = Face.OPENED;\n  }\n  else\n    this.expressInterestHelper(interest, closure);\n};\n\n/**\n * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call\n *   this.transport.send to send the interest.\n */\nFace.prototype.expressInterestHelper = function(interest, closure)\n{\n  var binaryInterest = interest.wireEncode();\n  var thisNDN = this;\n  //TODO: check local content store first\n  if (closure != null) {\n    var pitEntry = new PITEntry(interest, closure);\n    // TODO: This needs to be a single thread-safe transaction on a global object.\n    Face.PITTable.push(pitEntry);\n    closure.pitEntry = pitEntry;\n\n    // Set interest timer.\n    var timeoutMilliseconds = (interest.interestLifetime || 4000);\n    var timeoutCallback = function() {\n      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());\n\n      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express\n      //   the interest because we don\'t want to match it in the mean time.\n      // TODO: Make this a thread-safe operation on the global PITTable.\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0)\n        Face.PITTable.splice(index, 1);\n\n      // Raise closure callback\n      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {\n        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());\n        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n        Face.PITTable.push(pitEntry);\n        thisNDN.transport.send(binaryInterest.buf());\n      }\n    };\n\n    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n  }\n\n  this.transport.send(binaryInterest.buf());\n};\n\n/**\n * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.\n * This uses the form:\n * registerPrefix(name, onInterest, onRegisterFailed [, flags]).\n * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.\n * @param {Name} prefix The Name prefix.\n * @param {function} onInterest When an interest is received which matches the name prefix, this calls\n * onInterest(prefix, interest, transport) where:\n *   prefix is the prefix given to registerPrefix.\n *   interest is the received interest.\n *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().\n * @param {function} onRegisterFailed If failed to retrieve the connected hub\'s ID or failed to register the prefix,\n * this calls onRegisterFailed(prefix) where:\n *   prefix is the prefix given to registerPrefix.\n * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.\n * If omitted, use the default flags defined by the default ForwardingFlags constructor.\n */\nFace.prototype.registerPrefix = function(prefix, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of registerPrefix, each shown inline below.\n\n  // registerPrefix(Name prefix, Closure closure);            // deprecated\n  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.registerPrefixWithClosure(prefix, arg2, arg3);\n    else\n      this.registerPrefixWithClosure(prefix, arg2);\n    return;\n  }\n\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);\n  var onInterest = arg2;\n  var onRegisterFailed = (arg3 ? arg3 : function() {});\n  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());\n  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport),\n                                 intFlags, onRegisterFailed);\n}\n\n/**\n * A private method to register the prefix with the host, receive the data and call\n * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)).\n * @deprecated Use registerPrefix with callback functions, not Closure.\n * @param {Name} prefix\n * @param {Closure} closure\n * @param {number} intFlags\n * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix)\n * if registration fails.\n */\nFace.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed)\n{\n  intFlags = intFlags | 3;\n  var thisNDN = this;\n  var onConnected = function() {\n    if (thisNDN.ndndid == null) {\n      // Fetch ndndid first, then register.\n      var interest = new Interest(Face.ndndIdFetcher);\n      interest.interestLifetime = 4000; // milliseconds\n      if (LOG > 3) console.log(\'Expressing interest for ndndid from ndnd.\');\n      thisNDN.reconnectAndExpressInterest\n        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));\n    }\n    else\n      thisNDN.registerPrefixHelper(prefix, closure, flags, onRegisterFailed);\n  };\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else\n      this.connectAndExecute(onConnected);\n  }\n  else\n    onConnected();\n};\n\n/**\n * This is a closure to receive the Data for Face.ndndIdFetcher and call\n *   registerPrefixHelper(prefix, callerClosure, flags).\n */\nFace.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.prefix = prefix;\n  this.callerClosure = callerClosure;\n  this.flags = flags;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n\n  if (LOG > 3) console.log(\'Got ndndid from ndnd.\');\n  // Get the digest of the public key in the data packet content.\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(upcallInfo.data.getContent());\n  this.face.ndndid = new customBuf(DataUtils.toNumbersIfString(hash.digest()));\n  if (LOG > 3) console.log(this.face.ndndid);\n\n  this.face.registerPrefixHelper\n    (this.prefix, this.callerClosure, this.flags, this.onRegisterFailed);\n\n  return Closure.RESULT_OK;\n};\n/**\n * This is a closure to receive the response Data packet from the register\n * prefix interest sent to the connected NDN hub. If this gets a bad response\n * or a timeout, call onRegisterFailed.\n */\nFace.RegisterResponseClosure = function RegisterResponseClosure\n  (prefix, onRegisterFailed)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.prefix = prefix;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.RegisterResponseClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n\n  var expectedName = new Name("/ndnx/.../selfreg");\n  // Got a response. Do a quick check of expected name components.\n  if (upcallInfo.data.getName().size() < 4 ||\n      !upcallInfo.data.getName().get(0).equals(expectedName.get(0)) ||\n      !upcallInfo.data.getName().get(2).equals(expectedName.get(2))) {\n    this.onRegisterFailed(this.prefix);\n    return;\n  }\n\n  // Otherwise, silently succeed.\n  return Closure.RESULT_OK;\n};\n\n/**\n * Do the work of registerPrefix once we know we are connected with a ndndid.\n */\nFace.prototype.registerPrefixHelper = function\n  (prefix, closure, flags, onRegisterFailed)\n{\n  var fe = new ForwardingEntry(\'selfreg\', prefix, null, null, flags, null);\n\n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  var encoder = new BinaryXMLEncoder();\n  fe.to_ndnb(encoder);\n  var bytes = encoder.getReducedOstream();\n\n  var si = new MetaInfo();\n  si.setFields();\n\n  // Set the name to a random value so that each request is unique.\n  var data = new Data(new Name().append(require("crypto").randomBytes(4)), si, bytes);\n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  data.sign(BinaryXmlWireFormat.get());\n  var coBinary = data.wireEncode(BinaryXmlWireFormat.get());;\n\n  var nodename = this.ndndid;\n  var interestName = new Name([\'ndnx\', nodename, \'selfreg\', coBinary]);\n\n  var interest = new Interest(interestName);\n  interest.setInterestLifetimeMilliseconds(4000.0);\n  interest.setScope(1);\n  if (LOG > 3) console.log(\'Send Interest registration packet.\');\n\n  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n  this.reconnectAndExpressInterest\n    (interest, new Face.RegisterResponseClosure(prefix, onRegisterFailed));\n};\n\n/**\n * This is called when an entire binary XML element is received, such as a Data or Interest.\n * Look up in the PITTable and call the closure callback.\n */\nFace.prototype.onReceivedElement = function(element)\n{\n  if (LOG > 3) console.log(\'Complete element received. Length \' + element.length + \'. Start decoding.\');\n  // First, decode as Interest or Data.\n  var interest = null;\n  var data = null;\n  // The type codes for TLV Interest and Data packets are chosen to not\n  //   conflict with the first byte of a binary XML packet, so we can\n  //   just look at the first byte.\n  if (element[0] == Tlv.Interest || element[0] == Tlv.Data) {\n    if (LOG > 3) console.log(\'Detected Tlv element\', element, TlvWireFormat.get())\n    var decoder = new TlvDecoder(element);\n    if (decoder.peekType(Tlv.Interest, element.length)) {\n      interest = new Interest();\n      interest.wireDecode(element, TlvWireFormat.get());\n    }\n    else if (decoder.peekType(Tlv.Data, element.length)) {\n      data = new Data();\n      data.wireDecode(element, TlvWireFormat.get());\n    }\n  }\n  else {\n    if (LOG > 3) console.log(\'assumed BinaryXML\')\n    // Binary XML.\n    var decoder = new BinaryXMLDecoder(element);\n    if (decoder.peekDTag(NDNProtocolDTags.Interest)) {\n      interest = new Interest();\n      interest.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Data)) {\n      data = new Data();\n      data.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n  }\n\n  // Now process as Interest or Data.\n  if (interest !== null) {\n    if (LOG > 3) console.log(\'Interest packet received.\');\n    var entry = getEntryForRegisteredPrefix(interest.name);\n    if (entry != null) {\n      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());\n      var info = new UpcallInfo(this, interest, 0, null);\n      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);\n      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null)\n        this.transport.send(info.data.wireEncode().buf());\n    }\n  }\n  else if (data !== null) {\n    if (LOG > 3) console.log(\'Data packet received.\');\n\n    var pendingInterests = Face.extractEntriesForExpressedInterest(data.name);\n    // Process each matching PIT entry (if any).\n    for (var i = 0; i < pendingInterests.length; ++i) {\n      var pitEntry = pendingInterests[i];\n      var currentClosure = pitEntry.closure;\n\n      if (this.verify == false) {\n        // Pass content up without verifying the signature\n        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));\n        continue;\n      }\n\n      // Key verification\n\n      // Recursive key fetching & verification closure\n      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {\n        this.data = content;  // unverified data packet object\n        this.closure = closure;  // closure corresponding to the data\n        this.keyName = key;  // name of current key to be fetched\n\n        Closure.call(this);\n      };\n\n      var thisNDN = this;\n      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {\n        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n          console.log("In KeyFetchClosure.upcall: interest time out.");\n          console.log(this.keyName.contentName.toUri());\n        }\n        else if (kind == Closure.UPCALL_CONTENT) {\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(upcallInfo.data.content);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));\n\n          // Store key in cache\n          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());\n          Face.addKeyEntry(keyEntry);\n        }\n        else if (kind == Closure.UPCALL_CONTENT_BAD)\n          console.log("In KeyFetchClosure.upcall: signature verification failed");\n      };\n\n      if (data.signedInfo && data.signedInfo.locator && data.signature) {\n        if (LOG > 3) console.log("Key verification...");\n        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();\n\n        var wit = null;\n        if (data.signature.witness != null)\n            //SWT: deprecate support for Witness decoding and Merkle hash tree verification\n            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n        var keylocator = data.signedInfo.locator;\n        if (keylocator.type == KeyLocatorType.KEYNAME) {\n          if (LOG > 3) console.log("KeyLocator contains KEYNAME");\n\n          if (keylocator.keyName.contentName.match(data.name)) {\n            if (LOG > 3) console.log("Content is key itself");\n\n            var rsakey = new Key();\n            rsakey.readDerPublicKey(data.content);\n            var verified = data.verify(rsakey);\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n            // SWT: We don\'t need to store key here since the same key will be stored again in the closure.\n          }\n          else {\n            // Check local key store\n            var keyEntry = Face.getKeyByName(keylocator.keyName);\n            if (keyEntry) {\n              // Key found, verify now\n              if (LOG > 3) console.log("Local key cache hit");\n              var rsakey = keyEntry.rsaKey;\n              var verified = data.verify(rsakey);\n              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n              // Raise callback\n              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n            }\n            else {\n              // Not found, fetch now\n              if (LOG > 3) console.log("Fetch key according to keylocator");\n              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);\n              // TODO: Use expressInterest with callbacks, not Closure.\n              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);\n            }\n          }\n        }\n        else if (keylocator.type == KeyLocatorType.KEY) {\n          if (LOG > 3) console.log("Keylocator contains KEY");\n\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(keylocator.publicKey);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          // Raise callback\n          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n          // Since KeyLocator does not contain key name for this key,\n          // we have no way to store it as a key entry in KeyStore.\n        }\n        else {\n          var cert = keylocator.certificate;\n          console.log("KeyLocator contains CERT");\n          console.log(cert);\n          // TODO: verify certificate\n        }\n      }\n    }\n  }\n};\n\n/**\n * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host\n *   is not alive.  Get a host and port, connect, then execute onConnected().\n */\nFace.prototype.connectAndExecute = function(onConnected)\n{\n  var hostAndPort = this.getHostAndPort();\n  if (hostAndPort == null) {\n    console.log(\'ERROR: No more hosts from getHostAndPort\');\n    this.host = null;\n    return;\n  }\n\n  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {\n    console.log(\'ERROR: The host returned by getHostAndPort is not alive: \' + this.host + ":" + this.port);\n    return;\n  }\n\n  this.host = hostAndPort.host;\n  this.port = hostAndPort.port;\n  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);\n\n  // Fetch any content.\n  var interest = new Interest(new Name("/"));\n  interest.interestLifetime = 4000; // milliseconds\n\n  var thisNDN = this;\n  var timerID = setTimeout(function() {\n    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);\n      // Try again.\n      thisNDN.connectAndExecute(onConnected);\n  }, 3000);\n\n  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));\n};\n\n/**\n * This is called by the Transport when the connection is closed by the remote host.\n */\nFace.prototype.closeByTransport = function()\n{\n  this.readyStatus = Face.CLOSED;\n  this.onclose();\n};\n\nFace.ConnectClosure = function ConnectClosure(face, onConnected, timerID)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.onConnected = onConnected;\n  this.timerID = timerID;\n};\n\nFace.ConnectClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.\n    return Closure.RESULT_ERR;\n\n  // The host is alive, so cancel the timeout and continue with onConnected().\n  clearTimeout(this.timerID);\n\n    // Call Face.onopen after success\n  this.face.readyStatus = Face.OPENED;\n  this.face.onopen();\n\n  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);\n  this.onConnected();\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * @deprecated Use new Face.\n */\nvar NDN = function NDN(settings)\n{\n  // Call the base constructor.\n  Face.call(this, settings);\n}\n\n// Use dummy functions so that the Face constructor will not try to set its own defaults.\nNDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });\n\nexports.NDN = NDN;\n\nNDN.supported = Face.supported;\nNDN.UNOPEN = Face.UNOPEN;\nNDN.OPENED = Face.OPENED;\nNDN.CLOSED = Face.CLOSED;\n\n})()\n},{"./buffer.js":30,"./closure.js":8,"./crypto.js":30,"./data.js":13,"./encoding/binary-xml-decoder.js":58,"./encoding/binary-xml-encoder.js":59,"./encoding/binary-xml-wire-format.js":19,"./encoding/data-utils.js":23,"./encoding/tlv-wire-format.js":20,"./encoding/tlv/tlv-decoder.js":21,"./encoding/tlv/tlv.js":22,"./forwarding-entry.js":57,"./forwarding-flags.js":10,"./interest.js":11,"./key-locator.js":16,"./key.js":15,"./log.js":62,"./meta-info.js":14,"./name.js":9,"./transport/tcp-transport.js":61,"./util/ndn-protoco-id-tags.js":60,"crypto":56}],9:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents a Name as an array of components where each is a byte array.\n */\n \nvar Blob = require(\'./util/blob.js\').Blob;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Name from components.\n * \n * @constructor\n * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.  \n * Otherwise it is an array of components which are appended according to Name.append, so\n * convert each and store it as an array of customBuf.  If a component is a string, encode as utf8.\n */\nvar Name = function Name(components) \n{\n  if (typeof components == \'string\') {    \n    if (LOG > 3) console.log(\'Content Name String \' + components);\n    this.components = Name.createNameArray(components);\n  }\n  else if (typeof components === \'object\') {    \n    this.components = [];\n    if (components instanceof Name)\n      this.append(components);\n    else {\n      for (var i = 0; i < components.length; ++i)\n        this.append(components[i]);\n    }\n  }\n  else if (components == null)\n    this.components = [];\n  else\n    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");\n};\n\nexports.Name = Name;\n\n/**\n * \n * @constructor\n * Create a new Name.Component with a copy of the given value.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don\'t unescape).\n */\nName.Component = function NameComponent(value) \n{\n  if (typeof value === \'string\')\n    this.value = DataUtils.stringToUtf8Array(value);\n  else if (typeof value === \'object\' && value instanceof Name.Component)\n    this.value = new customBuf(value.value);\n  else if (typeof value === \'object\' && value instanceof Blob)\n    this.value = new customBuf(value.buf());\n  else if (typeof value === \'object\' && value instanceof customBuf)\n    this.value = new customBuf(value);\n  else if (typeof value === \'object\' && typeof ArrayBuffer !== \'undefined\' &&  value instanceof ArrayBuffer) {\n    // Make a copy.  Don\'t use ArrayBuffer.slice since it isn\'t always supported.                                                      \n    this.value = new customBuf(new ArrayBuffer(value.byteLength));\n    this.value.set(new customBuf(value));\n  }\n  else if (typeof value === \'object\')\n    // Assume value is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    this.value = new customBuf(value);\n  else if (!value)\n    this.value = new customBuf(0);\n  else \n    throw new Error("Name.Component constructor: Invalid type");\n}\n\n/**\n * Get the component value.\n * @returns {Buffer} The component value.\n */\nName.Component.prototype.getValue = function() \n{\n  return this.value;\n}\n\n/**\n * Convert this component value to a string by escaping characters according to the NDN URI Scheme.\n * This also adds "..." to a value with zero or more ".".\n * @returns {string} The escaped string.\n */\nName.Component.prototype.toEscapedString = function() \n{\n  return Name.toEscapedString(this.value);\n}\n\n/**\n * Check if this is the same component as other.\n * @param {Name.Component} other The other Component to compare with.\n * @returns {Boolean} true if the components are equal, otherwise false.\n */\nName.Component.prototype.equals = function(other) \n{\n  return DataUtils.arraysEqual(this.value, other.value);\n}\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.getName = function() \n{\n  return this.toUri();\n};\n\n/** Parse uri as a URI and return an array of customBuf components.\n */\nName.createNameArray = function(uri) \n{\n  uri = uri.trim();\n  if (uri.length <= 0)\n    return [];\n\n  var iColon = uri.indexOf(\':\');\n  if (iColon >= 0) {\n    // Make sure the colon came before a \'/\'.\n    var iFirstSlash = uri.indexOf(\'/\');\n    if (iFirstSlash < 0 || iColon < iFirstSlash)\n      // Omit the leading protocol such as ndn:\n      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();\n  }\n    \n  if (uri[0] == \'/\') {\n    if (uri.length >= 2 && uri[1] == \'/\') {\n      // Strip the authority following "//".\n      var iAfterAuthority = uri.indexOf(\'/\', 2);\n      if (iAfterAuthority < 0)\n        // Unusual case: there was only an authority.\n        return [];\n      else\n        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();\n    }\n    else\n      uri = uri.substr(1, uri.length - 1).trim();\n  }\n\n  var array = uri.split(\'/\');\n    \n  // Unescape the components.\n  for (var i = 0; i < array.length; ++i) {\n    var value = Name.fromEscapedString(array[i]);\n        \n    if (value == null) {\n      // Ignore the illegal componenent.  This also gets rid of a trailing \'/\'.\n      array.splice(i, 1);\n      --i;  \n      continue;\n    }\n    else\n      array[i] = new Name.Component(value);\n  }\n\n  return array;\n};\n\nName.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)  \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  this.components = [];\n\n  while (decoder.peekDTag(NDNProtocolDTags.Component))\n    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    \n  decoder.readElementClose();\n};\n\nName.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{    \n  if (this.components == null) \n    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  var count = this.size();\n  for (var i=0; i < count; i++)\n    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());\n  \n  encoder.writeElementClose();\n};\n\nName.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.Name;\n};\n\n/**\n * Convert the component to a customBuf and append to this Name.\n * Return this Name object to allow chaining calls to add.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don\'t unescape).\n * @returns {Name}\n */\nName.prototype.append = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name) {\n    var components;\n    if (component == this)\n      // special case, when we need to create a copy\n      components = this.components.slice(0, this.components.length);\n    else\n      components = component.components;\n      \n    for (var i = 0; i < components.length; ++i)\n      this.components.push(new Name.Component(components[i]));\n  }\n  else\n    // Just use the Name.Component constructor.\n    this.components.push(new Name.Component(component));\n\n  return this;\n};\n\n/**\n * @deprecated Use append.\n */\nName.prototype.add = function(component)\n{\n  return this.append(component);\n};\n\n/**\n * Clear all the components.\n */\nName.prototype.clear = function()\n{\n  this.components = [];  \n};\n\n/**\n * Return the escaped name string according to "NDNx URI Scheme".\n * @returns {String}\n */\nName.prototype.toUri = function() \n{  \n  if (this.size() == 0)\n    return "/";\n    \n  var result = "";\n  \n  for (var i = 0; i < this.size(); ++i)\n    result += "/"+ Name.toEscapedString(this.components[i].getValue());\n  \n  return result;  \n};\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.to_uri = function() \n{\n  return this.toUri();\n};\n\n/**\n * Append a component with the encoded segment number.\n * @param {number} segment The segment number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendSegment = function(segment) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(segment);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * Append a component with the encoded version number.\n * Note that this encodes the exact value of version without converting from a \n * time representation.\n * @param {number} version The version number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendVersion = function(version) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(version);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0xfD;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * @deprecated Use appendSegment.\n */\nName.prototype.addSegment = function(number) \n{\n  return this.appendSegment(number);\n};\n\n/**\n * Get a new name, constructed as a subset of components.\n * @param {number} iStartComponent The index if the first component to get.\n * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,\n * return components starting at iStartComponent until the end of the name.\n * @returns {Name} A new name.\n */\nName.prototype.getSubName = function(iStartComponent, nComponents)\n{\n  if (nComponents == undefined)\n    nComponents = this.components.length - iStartComponent;\n  \n  var result = new Name();\n\n  var iEnd = iStartComponent + nComponents;\n  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)\n    result.components.push(this.components[i]);\n\n  return result;  \n};\n\n/**\n * Return a new Name with the first nComponents components of this Name.\n * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up\n * to name.size() - N. For example getPrefix(-1) returns the name without the final component.\n * @returns {Name} A new name.\n */\nName.prototype.getPrefix = function(nComponents) \n{\n  if (nComponents < 0)\n    return this.getSubName(0, this.components.length + nComponents);\n  else\n    return this.getSubName(0, nComponents);\n};\n\n/**\n * @brief Get prefix of the name, containing less minusComponents right components\n * @param minusComponents number of components to cut from the back\n */\nName.prototype.cut = function(minusComponents) \n{\n  return new Name(this.components.slice(0, this.components.length - minusComponents));\n};\n\n/**\n * Return the number of name components.\n * @returns {number}\n */\nName.prototype.size = function() \n{\n  return this.components.length;\n};\n\n/**\n * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().\n * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component\n * at size() - (-i).\n * @returns {Name.Component}\n */\nName.prototype.get = function(i) \n{\n  if (i >= 0) {\n    if (i >= this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[i]);\n  }\n  else {\n    // Negative index.\n    if (i < -this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[this.components.length - (-i)]);\n  }\n};\n\n/**\n * @deprecated Use size().\n */\nName.prototype.getComponentCount = function() \n{\n  return this.components.length;\n};\n\n/**\n * @deprecated To get just the component value, use get(i).getValue().\n */\nName.prototype.getComponent = function(i) \n{\n  return new customBuf(this.components[i].getValue());\n};\n\n/**\n * The "file name" in a name is the last component that isn\'t blank and doesn\'t start with one of the\n *   special marker octets (for version, etc.).  Return the index in this.components of\n *   the file name, or -1 if not found.\n */\nName.prototype.indexOfFileName = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var component = this.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n        \n    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 || \n        (component[0] >= 0xF5 && component[0] <= 0xFF))\n      continue;\n        \n    return i;\n  }\n    \n  return -1;\n};\n\n/**\n * Return true if this Name has the same components as name.\n */\nName.prototype.equals = function(name) \n{\n  if (this.components.length != name.components.length)\n    return false;\n    \n  // Start from the last component because they are more likely to differ.\n  for (var i = this.components.length - 1; i >= 0; --i) {\n    if (!this.components[i].equals(name.components[i]))\n      return false;\n  }\n    \n  return true;\n};\n\n/**\n * @deprecated Use equals.\n */\nName.prototype.equalsName = function(name)\n{\n  return this.equals(name);\n};\n\n/**\n * Find the last component in name that has a ContentDigest and return the digest value as customBuf, \n *   or null if not found.  See Name.getComponentContentDigestValue.\n */\nName.prototype.getContentDigestValue = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var digestValue = Name.getComponentContentDigestValue(this.components[i]);\n    if (digestValue != null)\n      return digestValue;\n  }\n    \n  return null;\n};\n\n/**\n * If component is a ContentDigest, return the digest value as a customBuf slice (don\'t modify!).\n * If not a ContentDigest, return null.\n * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.\n */\nName.getComponentContentDigestValue = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length; \n  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.\n  if (component.length == digestComponentLength &&\n      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length), \n                            Name.ContentDigestPrefix) &&\n      DataUtils.arraysEqual(component.slice\n         (component.length - Name.ContentDigestSuffix.length, component.length),\n                            Name.ContentDigestSuffix))\n   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);\n else\n   return null;\n};\n\n// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB. \nName.ContentDigestPrefix = new customBuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);\nName.ContentDigestSuffix = new customBuf([0x00]);\n\n\n/**\n * Return value as an escaped string according to "NDNx URI Scheme".\n * We can\'t use encodeURIComponent because that doesn\'t encode all the characters we want to.\n * @param {Buffer|Name.Component} component The value or Name.Component to escape.\n * @returns {string} The escaped string.\n */\nName.toEscapedString = function(value) \n{\n  if (typeof value == \'object\' && value instanceof Name.Component)\n    value = value.getValue();\n  \n  var result = "";\n  var gotNonDot = false;\n  for (var i = 0; i < value.length; ++i) {\n    if (value[i] != 0x2e) {\n      gotNonDot = true;\n      break;\n    }\n  }\n  if (!gotNonDot) {\n    // Special case for component of zero or more periods.  Add 3 periods.\n    result = "...";\n    for (var i = 0; i < value.length; ++i)\n      result += ".";\n  }\n  else {\n    for (var i = 0; i < value.length; ++i) {\n      var x = value[i];\n      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)\n      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||\n          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d || \n          x == 0x2e || x == 0x5f)\n        result += String.fromCharCode(x);\n      else\n        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();\n    }\n  }\n  return result;\n};\n\n/**\n * Return a customBuf byte array by decoding the escapedString according to "NDNx URI Scheme".\n * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.\n * @param {string} escapedString The escaped string to decode.\n * @returns {Buffer} The byte array, or null which means to skip the component in the name.\n */\nName.fromEscapedString = function(escapedString) \n{\n  var value = unescape(escapedString.trim());\n        \n  if (value.match(/[^.]/) == null) {\n    // Special case for value of only periods.  \n    if (value.length <= 2)\n      // Zero, one or two periods is illegal.  Ignore this componenent to be\n      //   consistent with the C implementation.\n      return null;\n    else\n      // Remove 3 periods.\n      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));\n  }\n  else\n    return DataUtils.toNumbersFromString(value);\n};\n\n/**\n * Return true if the N components of this name are the same as the first N components of the given name.\n * @param {Name} name The name to check.\n * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.\n */\nName.prototype.match = function(name) \n{\n  var i_name = this.components;\n  var o_name = name.components;\n\n  // This name is longer than the name we are checking it against.\n  if (i_name.length > o_name.length)\n    return false;\n\n  // Check if at least one of given components doesn\'t match.\n  for (var i = 0; i < i_name.length; ++i) {\n    if (!i_name[i].equals(o_name[i]))\n      return false;\n  }\n\n  return true;\n};\n\n})()\n},{"./buffer.js":30,"./encoding/binary-xml-decoder.js":58,"./encoding/binary-xml-encoder.js":59,"./encoding/data-utils.js":23,"./log.js":62,"./util/blob.js":25,"./util/ndn-protoco-id-tags.js":60}],10:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\n\n/**\n * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for\n * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding\n * bits are changed, amended or deprecated.\n * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.\n */\nvar ForwardingFlags = function ForwardingFlags() \n{\n  this.active = true;\n  this.childInherit = true;\n  this.advertise = false;\n  this.last = false;\n  this.capture = false;\n  this.local = false;\n  this.tap = false;\n  this.captureOk = false;\n}\n\nexports.ForwardingFlags = ForwardingFlags;\n\n/**\n * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.\n * @returns {number} An integer with the bits set.\n */\nForwardingFlags.prototype.getForwardingEntryFlags = function()\n{\n  var result = 0;\n  \n  if (this.active)\n    result |= ForwardingEntry.ACTIVE;\n  if (this.childInherit)\n    result |= ForwardingEntry.CHILD_INHERIT;\n  if (this.advertise)\n    result |= ForwardingEntry.ADVERTISE;\n  if (this.last)\n    result |= ForwardingEntry.LAST;\n  if (this.capture)\n    result |= ForwardingEntry.CAPTURE;\n  if (this.local)\n    result |= ForwardingEntry.LOCAL;\n  if (this.tap)\n    result |= ForwardingEntry.TAP;\n  if (this.captureOk)\n    result |= ForwardingEntry.CAPTURE_OK;\n  \n  return result;\n};\n\n/**\n * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.\n * @param {number} forwardingEntryFlags An integer with the bits set.\n */\nForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)\n{\n  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);\n  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);\n  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);\n  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);\n  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);\n  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);\n  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);\n  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);\n};\n\n/**\n * Get the value of the "active" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getActive = function() { return this.active; };\n\n/**\n * Get the value of the "childInherit" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };\n\n/**\n * Get the value of the "advertise" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };\n\n/**\n * Get the value of the "last" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLast = function() { return this.last; };\n\n/**\n * Get the value of the "capture" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCapture = function() { return this.capture; };\n\n/**\n * Get the value of the "local" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLocal = function() { return this.local; };\n\n/**\n * Get the value of the "tap" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getTap = function() { return this.tap; };\n\n/**\n * Get the value of the "captureOk" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };\n\n/**\n * Set the value of the "active" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setActive = function(value) { this.active = value; };\n\n/**\n * Set the value of the "childInherit" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };\n\n/**\n * Set the value of the "advertise" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };\n\n/**\n * Set the value of the "last" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLast = function(value) { this.last = value; };\n\n/**\n * Set the value of the "capture" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };\n\n/**\n * Set the value of the "local" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLocal = function(value) { this.local = value; };\n\n/**\n * Set the value of the "tap" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setTap = function(value) { this.tap = value; };\n\n/**\n * Set the value of the "captureOk" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };\n\n},{"./forwarding-entry.js":57}],11:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar Name = require(\'./name.js\').Name;\nvar Exclude = require(\'./exclude.js\').Exclude;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').LOG\n/**\n * Create a new Interest with the optional values.\n * \n * @constructor\n * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the\n * other arguments.  Otherwise this is the optional name for the new Interest.\n * @param {number} minSuffixComponents\n * @param {number} maxSuffixComponents\n * @param {Buffer} publisherPublicKeyDigest\n * @param {Exclude} exclude\n * @param {number} childSelector\n * @param {number} answerOriginKind\n * @param {number} scope\n * @param {number} interestLifetimeMilliseconds in milliseconds\n * @param {Buffer} nonce\n */\nvar Interest = function Interest\n   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude, \n    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce) \n{\n  if (typeof nameOrInterest === \'object\' && nameOrInterest instanceof Interest) {\n    // Special case: this is a copy constructor.  Ignore all but the first argument.\n    var interest = nameOrInterest;\n    if (interest.name)\n      // Copy the name.\n      this.name = new Name(interest.name);\n    this.maxSuffixComponents = interest.maxSuffixComponents;\n    this.minSuffixComponents = interest.minSuffixComponents;\n\n    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator(interest.keyLocator);\n    this.exclude = new Exclude(interest.exclude);\n    this.childSelector = interest.childSelector;\n    this.answerOriginKind = interest.answerOriginKind;\n    this.scope = interest.scope;\n    this.interestLifetime = interest.interestLifetime;\n    if (interest.nonce)\n      // Copy.\n      this.nonce = new customBuf(interest.nonce);    \n  }  \n  else {\n    this.name = typeof nameOrInterest === \'object\' && nameOrInterest instanceof Name ?\n                new Name(nameOrInterest) : new Name();\n    this.maxSuffixComponents = maxSuffixComponents;\n    this.minSuffixComponents = minSuffixComponents;\n\n    this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator();\n    this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                   new Exclude(exclude) : new Exclude();\n    this.childSelector = childSelector;\n    this.answerOriginKind = answerOriginKind;\n    this.scope = scope;\n    this.interestLifetime = interestLifetimeMilliseconds;\n    if (nonce)\n      // Copy and make sure it is a customBuf.\n      this.nonce = new customBuf(nonce);\n  }\n};\n\nexports.Interest = Interest;\n\nInterest.RECURSIVE_POSTFIX = "*";\n\nInterest.CHILD_SELECTOR_LEFT = 0;\nInterest.CHILD_SELECTOR_RIGHT = 1;\n\nInterest.ANSWER_NO_CONTENT_STORE = 0;\nInterest.ANSWER_CONTENT_STORE = 1;\nInterest.ANSWER_GENERATED = 2;\nInterest.ANSWER_STALE = 4;    // Stale answer OK\nInterest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"\n\nInterest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;\n\n/**\n * Return true if this.name.match(name) and the name conforms to the interest selectors.\n * @param {Name} name\n * @returns {boolean}\n */\nInterest.prototype.matchesName = function(/*Name*/ name) \n{\n  if (!this.name.match(name))\n    return false;\n    \n  if (this.minSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))\n    return false;\n  if (this.maxSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))\n    return false;\n  if (this.exclude != null && name.size() > this.name.size() &&\n      this.exclude.matches(name.components[this.name.size()]))\n    return false;\n    \n  return true;\n};\n\n/**\n * @deprecated Use matchesName.\n */\nInterest.prototype.matches_name = function(/*Name*/ name) \n{\n  return this.matchesName(name);\n};\n\n/**\n * Return a new Interest with the same fields as this Interest.  \n */\nInterest.prototype.clone = function() \n{\n  return new Interest\n     (this.name, this.minSuffixComponents, this.maxSuffixComponents, \n      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind, \n      this.scope, this.interestLifetime, this.nonce);\n};\n\n/**\n * Get the interest Name.\n * @returns {Name} The name.  The name size() may be 0 if not specified.\n */\nInterest.prototype.getName = function() { return this.name; };\n\n/**\n * Get the min suffix components.\n * @returns number} The min suffix components, or null if not specified.\n */\nInterest.prototype.getMinSuffixComponents = function() \n{ \n  return this.minSuffixComponents; \n};\n\n/**\n * Get the max suffix components.\n * @returns {number} The max suffix components, or null if not specified.\n */\nInterest.prototype.getMaxSuffixComponents = function() \n{ \n  return this.maxSuffixComponents; \n};\n\n/**\n * Get the interest key locator.\n * @returns {KeyLocator} The key locator. If its getType() is null, \n * then the key locator is not specified.\n */\nInterest.prototype.getKeyLocator = function() \n{ \n  return this.keyLocator; \n};\n\n/**\n * Get the exclude object.\n * @returns {Exclude} The exclude object. If the exclude size() is zero, then\n * the exclude is not specified.\n */\nInterest.prototype.getExclude = function() { return this.exclude; };\n\n/**\n * Get the child selector.\n * @returns {number} The child selector, or null if not specified.\n */\nInterest.prototype.getChildSelector = function() \n{ \n  return this.childSelector; \n};\n\n/**\n * @deprecated Use getMustBeFresh.\n */\nInterest.prototype.getAnswerOriginKind = function() \n{ \n  return this.answerOriginKind; \n};\n  \n  /**\n   * Return true if the content must be fresh.\n   * @return true if must be fresh, otherwise false.\n   */\n  \n/**\n * Get the must be fresh flag. If not specified, the default is true.\n * @returns {boolean} The must be fresh flag.\n */\nInterest.prototype.getMustBeFresh = function() \n{\n  if (this.answerOriginKind == null || this.answerOriginKind < 0)\n    return true;\n  else\n    return (this.answerOriginKind & Interest.ANSWER_STALE) == 0;\n};\n\n/**\n * Return the nonce value from the incoming interest.  If you change any of the \n * fields in this Interest object, then the nonce value is cleared.\n * @returns {Buffer} The nonce, or null if not specified.\n */\nInterest.prototype.getNonce = function() { return this.nonce; };\n\n/**\n * Get the interest scope.\n * @returns {number} The scope, or null if not specified.\n */\nInterest.prototype.getScope = function() { return this.scope; };\n\n/**\n * Get the interest lifetime.\n * @returns {number} The interest lifetime in milliseconds, or null if not \n * specified.\n */\nInterest.prototype.getInterestLifetimeMilliseconds = function() \n{ \n  return this.interestLifetime; \n};\n\nInterest.prototype.setName = function(name)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.name = typeof name === \'object\' && name instanceof Interest ?\n              new Name(name) : new Name();\n};\n                \nInterest.prototype.setMinSuffixComponents = function(minSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.minSuffixComponents = minSuffixComponents;\n};\n\nInterest.prototype.setMaxSuffixComponents = function(maxSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.maxSuffixComponents = maxSuffixComponents;\n};\n\n/**\n * Set this interest to use a copy of the given exclude object. Note: You can \n * also change this interest\'s exclude object modifying the object from \n * getExclude().\n * @param {Exclude} exclude The exlcude object that is copied.\n */\nInterest.prototype.setExclude = function(exclude)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                 new Exclude(exclude) : new Exclude();\n};\n\nInterest.prototype.setChildSelector = function(childSelector)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.childSelector = childSelector;\n};\n\n/**\n * @deprecated Use setMustBeFresh.\n */\nInterest.prototype.setAnswerOriginKind = function(answerOriginKind)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.answerOriginKind = answerOriginKind;\n};\n\n/**\n * Set the MustBeFresh flag.\n * @param {boolean} mustBeFresh True if the content must be fresh, otherwise false.\n */\nInterest.prototype.setMustBeFresh = function(mustBeFresh)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  if (this.answerOriginKind == null || this.answerOriginKind < 0) {\n    // It is is already the default where MustBeFresh is true. \n    if (!mustBeFresh)\n      // Set answerOriginKind_ so that getMustBeFresh returns false.\n      this.answerOriginKind = Interest.ANSWER_STALE; \n  }\n  else {\n    if (mustBeFresh)\n      // Clear the stale bit.\n      this.answerOriginKind &= ~Interest.ANSWER_STALE;\n    else\n      // Set the stale bit.\n      this.answerOriginKind |= Interest.ANSWER_STALE;\n  }\n};\n\nInterest.prototype.setScope = function(scope)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.scope = scope;\n};\n\nInterest.prototype.setInterestLifetimeMilliseconds = function(interestLifetimeMilliseconds)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.interestLifetime = interestLifetimeMilliseconds;\n};\n\n/**\n * @deprecated You should let the wire encoder generate a random nonce \n * internally before sending the interest.\n */\nInterest.prototype.setNonce = function(nonce)\n{\n  if (nonce)\n    // Copy and make sure it is a customBuf.\n    this.nonce = new customBuf(nonce);\n  else\n    this.nonce = null;\n};\n\n/**\n * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and\n * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".\n * @returns {string} The URI string.\n * @note This is an experimental feature.  See the API docs for more detail at\n * http://named-data.net/doc/ndn-ccl-api/interest.html#interest-touri-method .\n */\nInterest.prototype.toUri = function() \n{  \n  var selectors = "";\n  \n  if (this.minSuffixComponents != null)\n    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;\n  if (this.maxSuffixComponents != null)\n    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;\n  if (this.childSelector != null)\n    selectors += "&ndn.ChildSelector=" + this.childSelector;\n  if (this.answerOriginKind != null)\n    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;\n  if (this.scope != null)\n    selectors += "&ndn.Scope=" + this.scope;\n  if (this.interestLifetime != null)\n    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;\n  if (this.publisherPublicKeyDigest != null)\n    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  if (this.nonce != null)\n    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);\n  if (this.exclude != null && this.exclude.size() > 0)\n    selectors += "&ndn.Exclude=" + this.exclude.toUri();\n\n  var result = this.name.toUri();\n  if (selectors != "")\n    // Replace the first & with ?.\n    result += "?" + selectors.substr(1);\n  \n  return result;\n};\n\n/**\n * Encode this Interest for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {Blob} The encoded buffer in a Blob object.\n */\nInterest.prototype.wireEncode = function(wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return wireFormat.encodeInterest(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Interest.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nInterest.prototype.wireDecode = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  if (LOG > 3 ) console.log(\'decoding input to interes\', input)\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ? \n                     input.buf() : input;\n  wireFormat.decodeInterest(this, decodeBuffer);\n};\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom \n// to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  BinaryXmlWireFormat.decodeInterest(this, decoder);\n};\n\n/**\n * @deprecated Use wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder) \n{\n  BinaryXmlWireFormat.encodeInterest(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.encode = function(wireFormat) \n{\n  return this.wireEncode(BinaryXmlWireFormat.get()).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.decode = function(input, wireFormat) \n{\n  this.wireDecode(input, BinaryXmlWireFormat.get())\n};\n\n})()\n},{"./buffer.js":30,"./encoding/binary-xml-wire-format.js":19,"./encoding/wire-format.js":18,"./exclude.js":12,"./key-locator.js":16,"./log.js":62,"./name.js":9,"./publisher-public-key-digest.js":17,"./util/blob.js":25}],12:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an Interest Exclude.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\n\n/**\n * Create a new Exclude.\n * @constructor\n * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, customBuf component or Exclude.ANY.\n */\nvar Exclude = function Exclude(values) \n{ \n  this.values = [];\n  \n  if (typeof values === \'object\' && values instanceof Exclude)\n    // Copy the exclude.\n    this.values = values.values.slice(0);\n  else if (values) {\n    for (var i = 0; i < values.length; ++i) {\n      if (values[i] == Exclude.ANY)\n        this.appendAny();\n      else\n        this.appendComponent(values[i]);\n    }\n  }\n};\n\nexports.Exclude = Exclude;\n\nExclude.ANY = "*";\n\n/**\n * Get the number of entries.\n * @returns {number} The number of entries.\n */\nExclude.prototype.size = function() { return this.values.length; };\n\n/**\n * Get the entry at the given index.\n * @param {number} i The index of the entry, starting from 0.\n * @returns {Exclude.ANY|Name.Component} Exclude.ANY or a Name.Component.\n */\nExclude.prototype.get = function(i) { return this.values[i]; };\n\n/**\n * Append an Exclude.ANY element.\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendAny = function() \n{\n  this.values.push(Exclude.ANY);\n  return this;\n};\n\n/**\n * Append a component entry, copying from component.\n * @param {Name.Component|Buffer} component\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendComponent = function(component) \n{\n  this.values.push(new Name.Component(component));\n  return this;\n};\n\n/**\n * Clear all the entries.\n */\nExclude.prototype.clear = function() \n{\n  this.values = [];\n};\n\nExclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);\n\n  while (true) {\n    if (decoder.peekDTag(NDNProtocolDTags.Component))\n      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {\n      decoder.readElementStartDTag(NDNProtocolDTags.Any);\n      decoder.readElementClose();\n      this.appendAny();\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {\n      // Skip the Bloom and treat it as Any.\n      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);\n      this.appendAny();\n    }\n    else\n      break;\n  }\n    \n  decoder.readElementClose();\n};\n\nExclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{\n  if (this.values == null || this.values.length == 0)\n    return;\n\n  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);\n    \n  // TODO: Do we want to order the components (except for ANY)?\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      encoder.writeElementStartDTag(NDNProtocolDTags.Any);\n      encoder.writeElementClose();\n    }\n    else\n      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());\n  }\n\n  encoder.writeElementClose();\n};\n\n/**\n * Return a string with elements separated by "," and Exclude.ANY shown as "*". \n */\nExclude.prototype.toUri = function() \n{\n  if (this.values == null || this.values.length == 0)\n    return "";\n\n  var result = "";\n  for (var i = 0; i < this.values.length; ++i) {\n    if (i > 0)\n      result += ",";\n        \n    if (this.values[i] == Exclude.ANY)\n      result += "*";\n    else\n      result += Name.toEscapedString(this.values[i].getValue());\n  }\n  return result;\n};\n\n/**\n * Return true if the component matches any of the exclude criteria.\n */\nExclude.prototype.matches = function(/*Buffer*/ component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      var lowerBound = null;\n      if (i > 0)\n        lowerBound = this.values[i - 1];\n      \n      // Find the upper bound, possibly skipping over multiple ANY in a row.\n      var iUpperBound;\n      var upperBound = null;\n      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {\n        if (this.values[iUpperBound] != Exclude.ANY) {\n          upperBound = this.values[iUpperBound];\n          break;\n        }\n      }\n      \n      // If lowerBound != null, we already checked component equals lowerBound on the last pass.\n      // If upperBound != null, we will check component equals upperBound on the next pass.\n      if (upperBound != null) {\n        if (lowerBound != null) {\n          if (Exclude.compareComponents(component, lowerBound) > 0 &&\n              Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n        else {\n          if (Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n          \n        // Make i equal iUpperBound on the next pass.\n        i = iUpperBound - 1;\n      }\n      else {\n        if (lowerBound != null) {\n            if (Exclude.compareComponents(component, lowerBound) > 0)\n              return true;\n        }\n        else\n          // this.values has only ANY.\n          return true;\n      }\n    }\n    else {\n      if (DataUtils.arraysEqual(component, this.values[i].getValue()))\n        return true;\n    }\n  }\n  \n  return false;\n};\n\n/**\n * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.\n * A component is less if it is shorter, otherwise if equal length do a byte comparison.\n */\nExclude.compareComponents = function(component1, component2) \n{\n  if (typeof component1 == \'object\' && component1 instanceof Name.Component)\n    component1 = component1.getValue();\n  if (typeof component2 == \'object\' && component2 instanceof Name.Component)\n    component2 = component2.getValue();\n\n  if (component1.length < component2.length)\n    return -1;\n  if (component1.length > component2.length)\n    return 1;\n  \n  for (var i = 0; i < component1.length; ++i) {\n    if (component1[i] < component2[i])\n      return -1;\n    if (component1[i] > component2[i])\n      return 1;\n  }\n\n  return 0;\n};\n\n})()\n},{"./buffer.js":30,"./encoding/binary-xml-decoder.js":58,"./encoding/binary-xml-encoder.js":59,"./encoding/data-utils.js":23,"./name.js":9,"./util/ndn-protoco-id-tags.js":60}],13:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar SignedBlob = require(\'./util/signed-blob.js\').SignedBlob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Signature = require(\'./signature.js\').Signature;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\n/**\n * Create a new Data with the optional values.  There are 2 forms of constructor:\n * new Data([name] [, content]);\n * new Data(name, metaInfo [, content]);\n *\n * @constructor\n * @param {Name} name\n * @param {MetaInfo} metaInfo\n * @param {Buffer} content\n */\nvar Data = function Data(name, metaInfoOrContent, arg3)\n{\n  if (typeof name === \'string\')\n    this.name = new Name(name);\n  else\n    this.name = typeof name === \'object\' && name instanceof Name ?\n       new Name(name) : new Name();\n\n  var metaInfo;\n  var content;\n  if (typeof metaInfoOrContent === \'object\' &&\n      metaInfoOrContent instanceof MetaInfo) {\n    metaInfo = metaInfoOrContent;\n    content = arg3;\n  }\n  else {\n    metaInfo = null;\n    content = metaInfoOrContent;\n  }\n\n  // Use signedInfo instead of metaInfo for backward compatibility.\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n       new MetaInfo(metaInfo) : new MetaInfo();\n\n  if (typeof content === \'string\')\n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else\n    this.content = content;\n\n  this.signature = new Signature();\n\n  this.wireEncoding = SignedBlob();\n};\n\nexports.Data = Data;\n\n/**\n * Get the data packet\'s name.\n * @returns {Name} The name.\n */\nData.prototype.getName = function()\n{\n  return this.name;\n};\n\n/**\n * Get the data packet\'s meta info.\n * @returns {MetaInfo} The meta info.\n */\nData.prototype.getMetaInfo = function()\n{\n  return this.signedInfo;\n};\n\n/**\n * Get the data packet\'s signature object.\n * @returns {Signature} The signature object.\n */\nData.prototype.getSignature = function()\n{\n  return this.signature;\n};\n\n/**\n * Get the data packet\'s content.\n * @returns {Buffer} The content as a customBuf, which is null if unspecified.\n */\nData.prototype.getContent = function()\n{\n  return this.content;\n};\n\n/**\n * Set name to a copy of the given Name.\n * @param {Name} name The Name which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setName = function(name)\n{\n  this.name = typeof name === \'object\' && name instanceof Name ?\n    new Name(name) : new Name();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set metaInfo to a copy of the given MetaInfo.\n * @param {MetaInfo} metaInfo The MetaInfo which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setMetaInfo = function(metaInfo)\n{\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n    new MetaInfo(metaInfo) : new MetaInfo();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the signature to a copy of the given signature.\n * @param {Signature} signature The signature object which is cloned.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setSignature = function(signature)\n{\n  this.signature = typeof signature === \'object\' && signature instanceof Signature ?\n    signature.clone() : new Signature();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the content to the given value.\n * @param {type} content The array this is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setContent = function(content)\n{\n  if (typeof content === \'string\')\n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else\n    this.content = new customBuf(content);\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\nData.prototype.sign = function(wireFormat)\n{\n  var rs = require(\'buffer\')\n  var ss = require(\'./crypto.js\')\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n\n  if (this.getSignatureOrMetaInfoKeyLocator() == null ||\n      this.getSignatureOrMetaInfoKeyLocator().getType() == null)\n    this.getMetaInfo().setFields();\n\n  if (this.wireEncoding == null || this.wireEncoding.isNull()) {\n    // Need to encode to set wireEncoding.\n    // Set an initial empty signature so that we can encode.\n    this.getSignature().setSignature(new customBuf(128));\n    this.wireEncode(wireFormat);\n  }\n\n  var rsa = require("./crypto.js").createSign(\'RSA-SHA256\');\n  rsa.update(this.wireEncoding.signedBuf());\n\n  var sig = new customBuf\n    (DataUtils.toNumbersIfString(rsa.sign(globalKeyManager.privateKey)));\n  this.signature.signature = sig;\n};\n\n// The first time verify is called, it sets this to determine if a signature\n//   buffer needs to be converted to a string for the crypto verifier.\nData.verifyUsesString = null;\nData.prototype.verify = function(/*Key*/ key)\n{\n  if (key == null || key.publicKeyPem == null)\n    throw new Error(\'Cannot verify Data without a public key.\');\n\n  if (Data.verifyUsesString == null) {\n    var hashResult = require("crypto").createHash(\'sha256\').digest();\n    // If the has result is a string, we assume that this is a version of\n    //   crypto where verify also uses a string signature.\n    Data.verifyUsesString = (typeof hashResult === \'string\');\n  }\n\n  if (this.wireEncoding == null || this.wireEncoding.isNull())\n    // Need to encode to set wireEncoding.\n    this.wireEncode();\n  var verifier = require(\'./crypto.js\').createVerify(\'RSA-SHA256\');\n  verifier.update(this.wireEncoding.signedBuf());\n  var signatureBytes = Data.verifyUsesString ?\n    DataUtils.toString(this.signature.signature) : this.signature.signature;\n  return verifier.verify(key.publicKeyPem, signatureBytes);\n};\n\nData.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };\n\n/**\n * Encode this Data for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object\n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {SignedBlob} The encoded buffer in a SignedBlob object.\n */\nData.prototype.wireEncode = function(wireFormat)\n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var result = wireFormat.encodeData(this);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  this.wireEncoding = new SignedBlob\n    (result.encoding, result.signedPortionBeginOffset,\n     result.signedPortionEndOffset);\n  return this.wireEncoding;\n};\n\n/**\n * Decode the input using a particular wire format and update this Data.\n * @param {Blob|Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object\n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nData.prototype.wireDecode = function(input, wireFormat)\n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ?\n                     input.buf() : input;\n  var result = wireFormat.decodeData(this, decodeBuffer);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  // In the Blob constructor, set copy true, but if input is already a Blob, it\n  //   won\'t copy.\n  this.wireEncoding = new SignedBlob\n    (new Blob(input, true), result.signedPortionBeginOffset,\n     result.signedPortionEndOffset);\n};\n\n/**\n * If getSignature() has a key locator, return it.  Otherwise, use\n * the key locator from getMetaInfo() for backward compatibility and print\n * a warning to console.log that the key locator has moved to the Signature\n * object.  If neither has a key locator, return an empty key locator.\n * When we stop supporting the key locator in MetaInfo, this function is not\n * necessary and we will just use the key locator in the Signature.\n * @returns {KeyLocator} The key locator to use.\n */\nData.prototype.getSignatureOrMetaInfoKeyLocator = function()\n{\n  if (this.signature != null && this.signature.getKeyLocator() != null &&\n      this.signature.getKeyLocator().getType() != null &&\n      this.signature.getKeyLocator().getType() >= 0)\n    // The application is using the key locator in the correct object.\n    return this.signature.getKeyLocator();\n\n  if (this.signedInfo != null && this.signedInfo.locator != null &&\n      this.signedInfo.locator.type != null &&\n      this.signedInfo.locator.type >= 0) {\n    //console.log("WARNING: Temporarily using the key locator found in the MetaInfo - expected it in the Signature object.");\n    //console.log("WARNING: In the future, the key locator in the Signature object will not be supported.");\n    return this.signedInfo.locator;\n  }\n\n  // Return the empty key locator from the Signature object if possible.\n  if (this.signature != null && this.signature.getKeyLocator() != null)\n    return this.signature.getKeyLocator();\n  else\n    return new KeyLocator();\n}\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeData.\n */\nData.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  BinaryXmlWireFormat.decodeData(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeData.\n */\nData.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeData(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nData.prototype.encode = function(wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  return wireFormat.encodeData(this).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nData.prototype.decode = function(input, wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  wireFormat.decodeData(this, input);\n};\n\n/**\n * @deprecated Use new Data.\n */\nvar ContentObject = function ContentObject(name, signedInfo, content)\n{\n  // Call the base constructor.\n  Data.call(this, name, signedInfo, content);\n}\n\nContentObject.prototype = new Data();\n\nexports.ContentObject = ContentObject;\n\n})()\n},{"./buffer.js":30,"./crypto.js":30,"./encoding/binary-xml-encoder.js":59,"./encoding/binary-xml-wire-format.js":19,"./encoding/data-utils.js":23,"./encoding/wire-format.js":18,"./key-locator.js":16,"./meta-info.js":14,"./name.js":9,"./security/key-manager.js":28,"./signature.js":65,"./util/blob.js":25,"./util/ndn-protoco-id-tags.js":60,"./util/signed-blob.js":64,"buffer":63,"crypto":56}],14:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data MetaInfo object.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Blob = require(\'./util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar Name = require(\'./name.js\').Name;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar NDNTime = require(\'./util/ndn-time.js\').NDNTime;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar LOG = require(\'./log.js\').Log.LOG;\n\nvar ContentType = {\n  BLOB:0,\n  // ContentType DATA is deprecated.  Use ContentType.BLOB .\n  DATA:0, \n  LINK:1, \n  KEY: 2, \n  // ContentType ENCR, GONE and NACK are not supported in NDN-TLV encoding and are deprecated.\n  ENCR:3, \n  GONE:4, \n  NACK:5\n};\n\nexports.ContentType = ContentType;\n\n/**\n * Create a new MetaInfo with the optional values.\n * @constructor\n */\nvar MetaInfo = function MetaInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID, skipSetFields) \n{\n  if (typeof publisherOrMetaInfo === \'object\' && \n      publisherOrMetaInfo instanceof MetaInfo) {\n    // Copy values.\n    var metaInfo = publisherOrMetaInfo;\n    this.publisher = metaInfo.publisher;\n    this.timestamp = metaInfo.timestamp;\n    this.type = metaInfo.type;\n    this.locator = metaInfo.locator == null ? \n      new KeyLocator() : new KeyLocator(metaInfo.locator);\n    this.freshnessSeconds = metaInfo.freshnessSeconds;\n    this.finalBlockID = metaInfo.finalBlockID;\n  }\n  else {\n    this.publisher = publisherOrMetaInfo; //publisherPublicKeyDigest\n    this.timestamp = timestamp; // NDN Time\n    this.type = type; // ContentType\n    this.locator = locator == null ? new KeyLocator() : new KeyLocator(locator);\n    this.freshnessSeconds = freshnessSeconds; // Integer\n    this.finalBlockID = finalBlockID; //byte array\n\n    if (!skipSetFields)\n      this.setFields();\n  }\n};\n\nexports.MetaInfo = MetaInfo;\n\n/**\n * Get the content type.\n * @returns {an int from ContentType} The content type.\n */\nMetaInfo.prototype.getType = function()\n{\n  return this.type;\n};\n\n/**\n * Get the freshness period.\n * @returns {number} The freshness period in milliseconds, or null if not \n * specified.\n */\nMetaInfo.prototype.getFreshnessPeriod = function()\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (this.freshnessSeconds == null || this.freshnessSeconds < 0)\n    return null;\n  else\n    // Convert to milliseconds.\n    return this.freshnessSeconds * 1000.0;\n};\n\n/**\n * Get the final block ID.\n * @returns {Buffer} The final block ID or null if not specified.\n */\nMetaInfo.prototype.getFinalBlockID = function()\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  return this.finalBlockID;\n};\n\n/**\n * Set the content type.\n * @param {an int from ContentType} type The content type.  If null, this \n * uses ContentType.BLOB.\n */\nMetaInfo.prototype.setType = function(type)\n{\n  this.type = type == null || type < 0 ? ContentType.BLOB : type;\n};\n\n/**\n * Set the freshness period.\n * @param {type} freshnessPeriod The freshness period in milliseconds, or null\n * for not specified.\n */\nMetaInfo.prototype.setFreshnessPeriod = function(freshnessPeriod)\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (freshnessPeriod == null || freshnessPeriod < 0)\n    this.freshnessSeconds = null;\n  else\n    // Convert from milliseconds.\n    this.freshnessSeconds = freshnessPeriod / 1000.0;\n};\n\nMetaInfo.prototype.setFinalBlockID = function(finalBlockID)\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  if (finalBlockID == null)\n    this.finalBlockID = null;\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Blob)\n    this.finalBlockID = finalBlockID.buf();\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Name.Component)\n    this.finalBlockID = finalBlockID.getValue();\n  else \n    this.finalBlockID = new customBuf(finalBlockID);\n};\n\nMetaInfo.prototype.setFields = function() \n{\n  var key = globalKeyManager.getKey();\n  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());\n\n  var d = new Date();\n    \n  var time = d.getTime();  \n\n  this.timestamp = new NDNTime(time);\n    \n  if (LOG > 4) console.log(\'TIME msec is\');\n\n  if (LOG > 4) console.log(this.timestamp.msec);\n\n  //DATA\n  this.type = ContentType.BLOB;\n  \n  if (LOG > 4) console.log(\'PUBLIC KEY TO WRITE TO DATA PACKET IS \');\n  if (LOG > 4) console.log(key.publicToDER().toString(\'hex\'));\n\n  this.locator = new KeyLocator(key.getKeyID(), KeyLocatorType.KEY_LOCATOR_DIGEST);\n};\n\nMetaInfo.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    if (LOG > 4) console.log(\'DECODING PUBLISHER KEY\');\n    this.publisher = new PublisherPublicKeyDigest();\n    this.publisher.from_ndnb(decoder);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {\n    if (LOG > 4) console.log(\'DECODING TIMESTAMP\');\n    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Type)) {\n    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);\n    \n    if (LOG > 4) console.log(\'Binary Type of of Signed Info is \'+binType);\n\n    this.type = binType;\n    \n    //TODO Implement type of Key Reading\n    if (null == this.type)\n      throw new Error("Cannot parse signedInfo type: bytes.");\n  } \n  else\n    this.type = ContentType.DATA; // default\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n    if (LOG > 4) console.log(\'FRESHNESS IN SECONDS IS \'+ this.freshnessSeconds);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {\n    if (LOG > 4) console.log(\'DECODING FINAL BLOCKID\');\n    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {\n    if (LOG > 4) console.log(\'DECODING KEY LOCATOR\');\n    this.locator = new KeyLocator();\n    this.locator.from_ndnb(decoder);\n  }\n      \n  decoder.readElementClose();\n};\n\n/**\n * Encode this MetaInfo in ndnb, using the given keyLocator instead of the\n * locator in this object.\n * @param {BinaryXMLEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nMetaInfo.prototype.to_ndnb = function(encoder, keyLocator)  {\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.publisher) {\n    // We have a publisherPublicKeyDigest, so use it.\n    if (LOG > 3) console.log(\'ENCODING PUBLISHER KEY\' + this.publisher.publisherPublicKeyDigest);\n    this.publisher.to_ndnb(encoder);\n  }\n  else {\n    if (null != keyLocator &&\n        keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n        keyLocator.getKeyData() != null &&\n        keyLocator.getKeyData().length > 0)\n      // We have a TLV-style KEY_LOCATOR_DIGEST, so encode as the\n      //   publisherPublicKeyDigest.\n      encoder.writeDTagElement\n        (NDNProtocolDTags.PublisherPublicKeyDigest, keyLocator.getKeyData());\n  }\n\n  if (null != this.timestamp)\n    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);\n  \n  if (null != this.type && this.type != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);\n  \n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  if (null != this.finalBlockID)\n    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);\n\n  if (null != keyLocator)\n    keyLocator.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nMetaInfo.prototype.valueToType = function() \n{\n  return null;  \n};\n\nMetaInfo.prototype.getElementLabel = function() { \n  return NDNProtocolDTags.SignedInfo;\n};\n\nMetaInfo.prototype.validate = function() \n{\n  // We don\'t do partial matches any more, even though encoder/decoder\n  // is still pretty generous.\n  if (null == this.timestamp)\n    return false;\n  return true;\n};\n\n/**\n * @deprecated Use new MetaInfo.\n */\nvar SignedInfo = function SignedInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID) \n{\n  // Call the base constructor.\n  MetaInfo.call(this, publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID); \n}\n\n// Set skipSetFields true since we only need the prototype functions.\nSignedInfo.prototype = new MetaInfo(null, null, null, null, null, null, true);\n\nexports.SignedInfo = SignedInfo;\n\n})()\n},{"./buffer.js":30,"./encoding/binary-xml-decoder.js":58,"./encoding/binary-xml-encoder.js":59,"./key-locator.js":16,"./log.js":62,"./name.js":9,"./publisher-public-key-digest.js":17,"./security/key-manager.js":28,"./util/blob.js":25,"./util/ndn-protoco-id-tags.js":60,"./util/ndn-time.js":27}],15:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Key Objects\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\n/**\n * Key\n */\nvar Key = function Key()\n{\n  this.publicKeyDer = null;     // customBuf\n  this.publicKeyDigest = null;  // customBuf\n  this.publicKeyPem = null;     // String\n  this.privateKeyPem = null;    // String\n};\n\nexports.Key = Key;\n\n/**\n * Helper functions to read Key fields\n * TODO: generateRSA()\n */\n\nKey.prototype.publicToDER = function()\n{\n  return this.publicKeyDer;  // customBuf\n};\n\nKey.prototype.privateToDER = function()\n{\n  // Remove the \'-----XXX-----\' from the beginning and the end of the key\n  // and also remove any \\n in the key string\n  var lines = this.privateKeyPem.split(\'\\n\');\n  priKey = "";\n  for (var i = 1; i < lines.length - 1; i++)\n    priKey += lines[i];\n\n  return new customBuf(priKey, \'base64\');\n};\n\nKey.prototype.publicToPEM = function()\n{\n  return this.publicKeyPem;\n};\n\nKey.prototype.privateToPEM = function()\n{\n  return this.privateKeyPem;\n};\n\nKey.prototype.getKeyID = function()\n{\n  return this.publicKeyDigest;\n};\n\nexports.Key = Key;\n\nKey.prototype.readDerPublicKey = function(/*Buffer*/pub_der)\n{\n  if (LOG > 4) console.log("Encode DER public key:\\n" + pub_der.toString(\'hex\'));\n\n  this.publicKeyDer = pub_der;\n\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(this.publicKeyDer);\n  this.publicKeyDigest = new customBuf(DataUtils.toNumbersIfString(hash.digest()));\n  var keyStr = pub_der.toString(\'base64\');\n  var keyPem = "-----BEGIN PUBLIC KEY-----\\n";\n  for (var i = 0; i < keyStr.length; i += 64)\n  keyPem += (keyStr.substr(i, 64) + "\\n");\n  keyPem += "-----END PUBLIC KEY-----";\n  this.publicKeyPem = keyPem;\n\n  if (LOG > 4) console.log("Convert public key to PEM format:\\n" + this.publicKeyPem);\n};\n\n/**\n * Load RSA key pair from PEM-encoded strings.\n * Will throw an Error if both \'pub\' and \'pri\' are null.\n */\nKey.prototype.fromPemString = function(pub, pri)\n{\n  if (pub == null && pri == null)\n    throw new Error(\'Cannot create Key object if both public and private PEM string is empty.\');\n\n  // Read public key\n  if (pub != null) {\n    this.publicKeyPem = pub;\n    if (LOG > 4) console.log("Key.publicKeyPem: \\n" + this.publicKeyPem);\n\n    // Remove the \'-----XXX-----\' from the beginning and the end of the public key\n    // and also remove any \\n in the public key string\n    var lines = pub.split(\'\\n\');\n    pub = "";\n    for (var i = 1; i < lines.length - 1; i++)\n      pub += lines[i];\n    this.publicKeyDer = new customBuf(pub, \'base64\');\n    if (LOG > 4) console.log("Key.publicKeyDer: \\n" + this.publicKeyDer.toString(\'hex\'));\n\n    var hash = require("./crypto.js").createHash(\'sha256\');\n    hash.update(this.publicKeyDer);\n    this.publicKeyDigest = new customBuf(DataUtils.toNumbersIfString(hash.digest()));\n    if (LOG > 4) console.log("Key.publicKeyDigest: \\n" + this.publicKeyDigest.toString(\'hex\'));\n  }\n\n  // Read private key\n  if (pri != null) {\n    this.privateKeyPem = pri;\n    if (LOG > 4) console.log("Key.privateKeyPem: \\n" + this.privateKeyPem);\n  }\n};\n\nKey.prototype.fromPem = Key.prototype.fromPemString;\n\n/**\n * Static method that create a Key object.\n * Parameter \'obj\' is a JSON object that has two properties:\n *   pub: the PEM string for the public key\n *   pri: the PEM string for the private key\n * Will throw an Error if both obj.pub and obj.pri are null.\n */\nKey.createFromPEM = function(obj)\n{\n    var key = new Key();\n    key.fromPemString(obj.pub, obj.pri);\n    return key;\n};\n\n})()\n},{"./buffer.js":30,"./crypto.js":30,"./encoding/data-utils.js":23,"./log.js":62}],16:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN KeyLocator object.\n */\n\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherID = require(\'./publisher-id.js\').PublisherID;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * KeyLocator\n */\nvar KeyLocatorType = {\n  KEYNAME: 1,\n  KEY_LOCATOR_DIGEST: 2,\n  KEY: 3,\n  CERTIFICATE: 4\n};\n\nexports.KeyLocatorType = KeyLocatorType;\n\n/**\n * @constructor\n */\nvar KeyLocator = function KeyLocator(input,type) \n{ \n  if (typeof input === \'object\' && input instanceof KeyLocator) {\n    // Copy from the input KeyLocator.\n    this.type = input.type;\n    this.keyName = new KeyName();\n    if (input.keyName != null) {\n      this.keyName.contentName = input.keyName.contentName == null ? \n        null : new Name(input.keyName.contentName);\n      this.keyName.publisherID = input.keyName.publisherID;\n    }\n    this.keyData = input.keyData == null ? null : new customBuf(input.keyData);\n    this.publicKey = input.publicKey == null ? null : new customBuf(input.publicKey);\n    this.certificate = input.certificate == null ? null : new customBuf(input.certificate);\n  }\n  else {\n    this.type = type;\n    this.keyName = new KeyName();\n\n    if (type == KeyLocatorType.KEYNAME)\n      this.keyName = input;\n    else if (type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n      this.keyData = new customBuf(input);\n    else if (type == KeyLocatorType.KEY) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.publicKey = this.keyData;\n    }\n    else if (type == KeyLocatorType.CERTIFICATE) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.certificate = this.keyData;\n    }\n  }\n};\n\nexports.KeyLocator = KeyLocator;\n\n/**\n * Get the key locator type. If KeyLocatorType.KEYNAME, you may also\n * getKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you may also\n * getKeyData() to get the digest.\n * @returns {number} The key locator type, or null if not specified.\n */\nKeyLocator.prototype.getType = function() { return this.type; };\n\n/**\n * Get the key name.  This is meaningful if getType() is KeyLocatorType.KEYNAME.\n * @returns {Name} The key name. If not specified, the Name is empty.\n */\nKeyLocator.prototype.getKeyName = function() \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  if (this.keyName.contentName == null)\n    this.keyName.contentName = new Name();\n  \n  return this.keyName.contentName;\n};\n\n/**\n * Get the key data. If getType() is KeyLocatorType.KEY_LOCATOR_DIGEST, this is \n * the digest bytes. If getType() is KeyLocatorType.KEY, this is the DER \n * encoded public key. If getType() is KeyLocatorType.CERTIFICATE, this is the \n * DER encoded certificate. \n * @returns {Buffer} The key data, or null if not specified.\n */\nKeyLocator.prototype.getKeyData = function() \n{ \n  if (this.type == KeyLocatorType.KEY)\n    return this.publicKey;\n  else if (this.type == KeyLocatorType.CERTIFICATE)\n    return this.certificate;\n  else\n    return this.keyData;\n};\n\n/**\n * Set the key locator type.  If KeyLocatorType.KEYNAME, you must also\n * setKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you must also\n * setKeyData() to the digest.\n * @param {number} type The key locator type.  If null, the type is unspecified.\n */\nKeyLocator.prototype.setType = function(type) { this.type = type; }; \n\n/**\n * Set key name to a copy of the given Name.  This is the name if getType() \n * is KeyLocatorType.KEYNAME.\n * @param {Name} name The key name which is copied.\n */\nKeyLocator.prototype.setKeyName = function(name) \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  \n  this.keyName.contentName = typeof name === \'object\' && name instanceof Name ?\n                             new Name(name) : new Name(); \n}; \n\n/**\n * Set the key data to the given value. This is the digest bytes if getType() is \n * KeyLocatorType.KEY_LOCATOR_DIGEST.\n * @param {Buffer} keyData The array with the key data bytes.\n */\nKeyLocator.prototype.setKeyData = function(keyData)\n{\n  var value = keyData;\n  if (value != null)\n    // Make a copy.\n    value = new customBuf(value);\n  \n  this.keyData = value;\n  // Set for backwards compatibility.\n  this.publicKey = value;\n  this.certificate = value;\n};\n\n/**\n * Clear the keyData and set the type to none.\n */\nKeyLocator.prototype.clear = function() \n{\n  this.type = null;\n  this.keyName = null;\n  this.keyData = null;\n  this.publicKey = null;\n  this.certificate = null;\n};\n\nKeyLocator.prototype.from_ndnb = function(decoder) {\n\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Key)) \n  {\n    try {\n      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);\n      // This is a DER-encoded SubjectPublicKeyInfo.\n      \n      //TODO FIX THIS, This should create a Key Object instead of keeping bytes\n\n      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);\n      this.type = KeyLocatorType.KEY;    \n\n      if (LOG > 4) console.log(\'PUBLIC KEY FOUND: \'+ this.publicKey);\n    } \n    catch (e) {\n      throw new Error("Cannot parse key: ", e);\n    } \n\n    if (null == this.publicKey)\n      throw new Error("Cannot parse key: ");\n  } \n  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {\n    try {\n      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);\n      \n      /*\n       * Certificates not yet working\n       */\n      \n      this.certificate = encodedCert;\n      this.type = KeyLocatorType.CERTIFICATE;\n\n      if (LOG > 4) console.log(\'CERTIFICATE FOUND: \'+ this.certificate);      \n    } \n    catch (e) {\n      throw new Error("Cannot decode certificate: " +  e);\n    }\n    if (null == this.certificate)\n      throw new Error("Cannot parse certificate! ");\n  } else  {\n    this.type = KeyLocatorType.KEYNAME;\n    \n    this.keyName = new KeyName();\n    this.keyName.from_ndnb(decoder);\n  }\n  decoder.readElementClose();\n};  \n\nKeyLocator.prototype.to_ndnb = function(encoder) \n{\n  if (LOG > 4) console.log(\'type is is \' + this.type);\n\n  if (this.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n    // encodeSignedInfo already encoded this as the publisherPublicKeyDigest,\n    //   so do nothing here.\n    return;\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (this.type == KeyLocatorType.KEY) {\n    if (LOG > 5) console.log(\'About to encode a public key\' +this.publicKey);\n    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);  \n  } \n  else if (this.type == KeyLocatorType.CERTIFICATE) {  \n    try {\n      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);\n    } \n    catch (e) {\n      throw new Error("CertificateEncodingException attempting to write key locator: " + e);\n    }    \n  } \n  else if (this.type == KeyLocatorType.KEYNAME)\n    this.keyName.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyLocator.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.KeyLocator; \n};\n\n/**\n * KeyName is only used by KeyLocator.\n * @constructor\n */\nvar KeyName = function KeyName() \n{\n  this.contentName = new Name();  //contentName\n  this.publisherID = this.publisherID;  //publisherID\n};\n\nexports.KeyName = KeyName;\n\nKeyName.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.contentName = new Name();\n  this.contentName.from_ndnb(decoder);\n  \n  if (LOG > 4) console.log(\'KEY NAME FOUND: \');\n  \n  if (PublisherID.peek(decoder)) {\n    this.publisherID = new PublisherID();\n    this.publisherID.from_ndnb(decoder);\n  }\n  \n  decoder.readElementClose();\n};\n\nKeyName.prototype.to_ndnb = function(encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  this.contentName.to_ndnb(encoder);\n  if (null != this.publisherID)\n    this.publisherID.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nKeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };\n\n\n})()\n},{"./buffer.js":30,"./log.js":62,"./name.js":9,"./publisher-id.js":66,"./util/ndn-protoco-id-tags.js":60}],17:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents PublisherPublicKeyDigest Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd) \n{ \n this.PUBLISHER_ID_LEN = 512/8;\n this.publisherPublicKeyDigest = pkd;\n};\n\nexports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;\n\nPublisherPublicKeyDigest.prototype.from_ndnb = function(decoder) \n{\n  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'Publisher public key digest is \' + this.publisherPublicKeyDigest);\n\n  if (null == this.publisherPublicKeyDigest)\n    throw new Error("Cannot parse publisher key digest.");\n    \n  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)\n\n  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {\n    if (LOG > 0)\n      console.log(\'LENGTH OF PUBLISHER ID IS WRONG! Expected \' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);\n      \n    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;    \n  }\n};\n\nPublisherPublicKeyDigest.prototype.to_ndnb= function(encoder) \n{\n  //TODO Check that the ByteArray for the key is present\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  if (LOG > 3) console.log(\'PUBLISHER KEY DIGEST IS\'+this.publisherPublicKeyDigest);\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);\n};\n  \nPublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };\n\nPublisherPublicKeyDigest.prototype.validate = function() \n{\n    return null != this.publisherPublicKeyDigest;\n};\n\n},{"./log.js":62,"./util/ndn-protoco-id-tags.js":60}],30:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n// Library namespace\nvar ndn = ndn || {};\n\nvar exports = ndn;\n\nvar ASN1HEX = require(\'../contrib/securityLib/asn1hex-1.1.js\')\nvar KJUR = require(\'../contrib/securityLib/crypto-1.0.js\')\nvar RSAKey = require(\'../contrib/securityLib/rsasign-1.2.js\')\nvar b64tohex = require(\'../contrib/securityLib/base64.js\').b64tohex\n// Factory method to create node.js compatible buffer objects\nvar customBuf = function customBuf(data, format) \n{\n  var obj;\n\n  if (typeof data == \'number\')\n    obj = new Uint8Array(data);\n  else if (typeof data == \'string\') {\n    if (format == null || format == \'utf8\') {\n      var utf8 = customBuf.str2rstr_utf8(data);\n      obj = new Uint8Array(utf8.length);\n      for (var i = 0; i < utf8.length; i++)\n        obj[i] = utf8.charCodeAt(i);\n    } \n    else if (format == \'binary\') {\n      obj = new Uint8Array(data.length);\n      for (var i = 0; i < data.length; i++)\n        obj[i] = data.charCodeAt(i);\n    } \n    else if (format == \'hex\') {\n      obj = new Uint8Array(Math.floor(data.length / 2));\n      var i = 0;\n      data.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else if (format == \'base64\') {\n      var hex = b64tohex(data);\n      obj = new Uint8Array(Math.floor(hex.length / 2));\n      var i = 0;\n      hex.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else \n      throw new Error(\'Buffer: unknown encoding format \' + format);\n  } \n  else if (typeof data == \'object\' && (data instanceof Uint8Array || data instanceof customBuf)) {\n    // The second argument is a boolean for "copy", default true.\n    if (format == false)\n      obj = data.subarray(0);\n    else\n      obj = new Uint8Array(data);\n  }\n  else if (typeof data == \'object\' && data instanceof ArrayBuffer)\n    // Copy.\n    obj = new Uint8Array(data);\n  else if (typeof data == \'object\')\n    // Assume component is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    obj = new Uint8Array(data);\n  else\n    throw new Error(\'Buffer: unknown data type.\');\n\n  try {\n    obj.__proto__ = customBuf.prototype;\n  } catch(ex) {\n    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);\n  }\n\n  obj.__proto__.toString = function(encoding) {\n    if (encoding == null || encoding == \'binary\') {\n      var ret = "";\n      for (var i = 0; i < this.length; i++)\n        ret += String.fromCharCode(this[i]);\n      return ret;\n    }\n\n    var ret = "";\n    for (var i = 0; i < this.length; i++)\n      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);\n\n    if (encoding == \'hex\')\n      return ret;\n    else if (encoding == \'base64\')\n      return hex2b64(ret);\n    else\n      throw new Error(\'Buffer.toString: unknown encoding format \' + encoding);\n  };\n\n  obj.__proto__.slice = function(begin, end) {\n    if (end !== undefined)\n      return new customBuf(this.subarray(begin, end), false);\n    else\n      return new customBuf(this.subarray(begin), false);\n  };\n\n  obj.__proto__.copy = function(target, targetStart) {\n    if (targetStart !== undefined)\n      target.set(this, targetStart);\n    else\n      target.set(this);\n  };\n\n  return obj;\n};\n\ncustomBuf.prototype = Uint8Array.prototype;\n\ncustomBuf.concat = function(arrays) \n{\n  var totalLength = 0;\n  for (var i = 0; i < arrays.length; ++i)\n    totalLength += arrays[i].length;\n    \n  var result = new customBuf(totalLength);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; ++i) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return result;\n};\n\ncustomBuf.str2rstr_utf8 = function(input)\n{\n  var output = "";\n  var i = -1;\n  var x, y;\n\n  while (++i < input.length)\n  {\n    // Decode utf-16 surrogate pairs\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\n    {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    // Encode output as utf-8\n    if (x <= 0x7F)\n      output += String.fromCharCode(x);\n    else if (x <= 0x7FF)\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0xFFFF)\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0x1FFFFF)\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\n                                    0x80 | ((x >>> 12) & 0x3F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n  }\n  return output;\n};\n\n// Factory method to create hasher objects\nexports.createHash = function(alg) \n{\n  if (alg != \'sha256\')\n    throw new Error(\'createHash: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});\n\n  obj.update = function(buf) {\n    this.md.updateHex(buf.toString(\'hex\'));\n  };\n\n  obj.digest = function() {\n    return new customBuf(this.md.digest(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA signer objects\nexports.createSign = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  obj.sign = function(keypem) {\n    var rsa = new RSAKey();\n    rsa.readPrivateKeyFromPEMString(keypem);\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initSign(rsa);\n    for (var i = 0; i < this.arr.length; ++i)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n\n    return new customBuf(signer.sign(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA verifier objects\nexports.createVerify = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n    \n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  var getSubjectPublicKeyPosFromHex = function(hPub) {  \n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0); \n    if (a.length != 2) \n      return -1;\n    var pBitString = a[1];\n    if (hPub.substring(pBitString, pBitString + 2) != \'03\') \n      return -1;\n    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);\n    if (hPub.substring(pBitStringV, pBitStringV + 2) != \'00\') \n      return -1;\n    return pBitStringV + 2;\n  };\n\n  var readPublicDER = function(pub_der) {\n    var hex = pub_der.toString(\'hex\'); \n    var p = getSubjectPublicKeyPosFromHex(hex);\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);\n    if (a.length != 2) \n      return null;\n    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);\n    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);\n    var rsaKey = new RSAKey();\n    rsaKey.setPublic(hN, hE);\n    return rsaKey;\n  };\n\n  obj.verify = function(keypem, sig) {\n    var key = new ndn.Key();\n    key.fromPemString(keypem);\n\n    var rsa = readPublicDER(key.publicToDER());\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initVerifyByPublicKey(rsa);\n    for (var i = 0; i < this.arr.length; i++)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n    var hSig = sig.toString(\'hex\'); \n    return signer.verify(hSig);\n  };\n\n  return obj;\n};\n\nexports.randomBytes = function(size)\n{\n  // TODO: Use a cryptographic random number generator.\n  var result = new customBuf(size);\n  for (var i = 0; i < size; ++i)\n    result[i] = Math.floor(Math.random() * 256);\n  return result;\n};\n\nexports.Buffer = customBuf;\n\nmodule.exports = exports;\n\n})()\n},{"../contrib/securityLib/asn1hex-1.1.js":67,"../contrib/securityLib/base64.js":70,"../contrib/securityLib/crypto-1.0.js":68,"../contrib/securityLib/rsasign-1.2.js":69}],32:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Provide the callback closure for the async communication methods in the Face class.\n * This is a port of Closure.py from PyNDN, written by: \n * Derek Kulinski <takeda@takeda.tk>\n * Jeff Burke <jburke@ucla.edu>\n */\n\n/**\n * A subclass of Closure is passed to expressInterest and registerPrefix.\n * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.\n * @constructor\n */\nvar Closure = function Closure() \n{\n  // I don\'t think storing Face\'s closure is needed\n  // and it creates a reference loop, as of now both\n  // of those variables are never set -- Derek\n  //\n  // Use instance variables to return data to callback\n  this.ndn_data = null;  // this holds the ndn_closure\n  this.ndn_data_dirty = false; \n};\n\nexports.Closure = Closure;\n\n// Upcall result\nClosure.RESULT_ERR               = -1; // upcall detected an error\nClosure.RESULT_OK                =  0; // normal upcall return\nClosure.RESULT_REEXPRESS         =  1; // reexpress the same interest again\nClosure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest\nClosure.RESULT_VERIFY            =  3; // force an unverified result to be verified\nClosure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest\n                                       //   with the key available in the local storage\n\n// Upcall kind\nClosure.UPCALL_FINAL              = 0; // handler is about to be deregistered\nClosure.UPCALL_INTEREST           = 1; // incoming interest\nClosure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered\nClosure.UPCALL_CONTENT            = 3; // incoming verified content\nClosure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out\nClosure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified\nClosure.UPCALL_CONTENT_BAD        = 6; // verification failed\n\n/**\n * Override this in your subclass.\n * If you\'re getting strange errors in upcall()\n * check your code whether you\'re returning a value.\n */\nClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  //dump(\'upcall \' + this + " " + kind + " " + upcallInfo + "\\n");\n  return Closure.RESULT_OK;\n};\n\n/**\n * An UpcallInfo is passed to Closure.upcall.\n * @constructor\n */\nvar UpcallInfo = function UpcallInfo(face, interest, matchedComps, data) \n{\n  this.face = face;  // Face object (not used)\n  this.ndn = face;   // deprecated\n  this.interest = interest;  // Interest object\n  this.matchedComps = matchedComps;  // int\n  this.data = data;  // Data\n  this.contentObject = data; // deprecated.  Include for backward compatibility.\n};\n\nUpcallInfo.prototype.toString = function() \n{\n  var ret = "face = " + this.face;\n  ret += "\\nInterest = " + this.interest;\n  ret += "\\nmatchedComps = " + this.matchedComps;\n  ret += "\\nData: " + this.data;\n  return ret;\n};\n\nexports.UpcallInfo = UpcallInfo;\n\n},{}],46:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Tlv class has static type codes for the NDN-TLV wire format.\n * @constructor\n */\nvar Tlv = function Tlv()\n{\n}\n\nexports.Tlv = Tlv;\n\nTlv.Interest =         5;\nTlv.Data =             6;\nTlv.Name =             7;\nTlv.NameComponent =    8;\nTlv.Selectors =        9;\nTlv.Nonce =            10;\nTlv.Scope =            11;\nTlv.InterestLifetime = 12;\nTlv.MinSuffixComponents = 13;\nTlv.MaxSuffixComponents = 14;\nTlv.PublisherPublicKeyLocator = 15;\nTlv.Exclude =          16;\nTlv.ChildSelector =    17;\nTlv.MustBeFresh =      18;\nTlv.Any =              19;\nTlv.MetaInfo =         20;\nTlv.Content =          21;\nTlv.SignatureInfo =    22;\nTlv.SignatureValue =   23;\nTlv.ContentType =      24;\nTlv.FreshnessPeriod =  25;\nTlv.FinalBlockId =     26;\nTlv.SignatureType =    27;\nTlv.KeyLocator =       28;\nTlv.KeyLocatorDigest = 29;\nTlv.FaceInstance =     128;\nTlv.ForwardingEntry =  129;\nTlv.StatusResponse =   130;\nTlv.Action =           131;\nTlv.FaceID =           132;\nTlv.IPProto =          133;\nTlv.Host =             134;\nTlv.Port =             135;\nTlv.MulticastInterface = 136;\nTlv.MulticastTTL =     137;\nTlv.ForwardingFlags =  138;\nTlv.StatusCode =       139;\nTlv.StatusText =       140;\n\nTlv.SignatureType_DigestSha256 = 0;\nTlv.SignatureType_SignatureSha256WithRsa = 1;\n\n},{}],18:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like TlvWireFormat.\n * @constructor\n */\nvar WireFormat = function WireFormat() {\n};\n\nexports.WireFormat = WireFormat;\n\n/**\n * Encode interest and return the encoding.  Your derived class should override.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeInterest = function(interest) \n{\n  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as an interest and set the fields of the interest object. \n * Your derived class should override.\n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Encode data and return the encoding and signed offsets. Your derived class \n * should override.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeData = function(data) \n{\n  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as a data packet, set the fields in the data object, and return \n * the signed offsets.  Your derived class should override.\n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeData = function(data, input) \n{\n  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Set the static default WireFormat used by default encoding and decoding \n * methods.\n * @param wireFormat {a subclass of WireFormat} An object of a subclass of \n * WireFormat.\n */\nWireFormat.setDefaultWireFormat = function(wireFormat)\n{\n  WireFormat.defaultWireFormat = wireFormat;\n};\n\n/**\n * Return the default WireFormat used by default encoding and decoding methods \n * which was set with setDefaultWireFormat.\n * @returns {a subclass of WireFormat} The WireFormat object.\n */\nWireFormat.getDefaultWireFormat = function()\n{\n  return WireFormat.defaultWireFormat;\n};\n\n// Invoke TlvWireFormat to set the default format.\n// Since tlv-wire-format.js includes this file, put this at the bottom \n// to avoid problems with cycles of require.\nvar TlvWireFormat = require(\'./tlv-wire-format.js\').TlvWireFormat;\n\n})()\n},{"../buffer.js":30,"./tlv-wire-format.js":20}],19:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar Blob = require(\'../util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Name = require(\'../name.js\').Name;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar Signature = require(\'../signature.js\').Signature;\nvar MetaInfo = require(\'../meta-info.js\').MetaInfo;\nvar PublisherPublicKeyDigest = require(\'../publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\n\n/**\n * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.\n * @constructor\n */\nvar BinaryXmlWireFormat = function BinaryXmlWireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nexports.BinaryXmlWireFormat = BinaryXmlWireFormat;\n\n// Default object.\nBinaryXmlWireFormat.instance = null;\n\n/**\n * Encode interest as Binary XML and return the encoding.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nBinaryXmlWireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new BinaryXMLEncoder();\n  BinaryXmlWireFormat.encodeInterest(interest, encoder);  \n  return new Blob(encoder.getReducedOstream(), false);  \n};\n\n/**\n * Decode input as a Binary XML interest and set the fields of the interest object. \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nBinaryXmlWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeInterest(interest, decoder);\n};\n\n/**\n * Encode data as Binary XML and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nBinaryXmlWireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new BinaryXMLEncoder(1500);\n  var result = BinaryXmlWireFormat.encodeData(data, encoder);\n  result.encoding = new Blob(encoder.getReducedOstream(), false);\n  return result;\n};\n\n/**\n * @deprecated Use encodeData(data).\n */\nBinaryXmlWireFormat.prototype.encodeContentObject = function(data)\n{\n  return this.encodeData(data);\n};\n\n/**\n * Decode input as a Binary XML data packet, set the fields in the data object, and return \n * the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  return BinaryXmlWireFormat.decodeData(data, decoder);\n};\n\n/**\n * @deprecated Use decodeData(data, input).\n */\nBinaryXmlWireFormat.prototype.decodeContentObject = function(data, input) \n{\n  this.decodeData(data, input);\n};\n\n/**\n * Get a singleton instance of a BinaryXmlWireFormat.  Assuming that the default \n * wire format was set with \n * WireFormat.setDefaultWireFormat(BinaryXmlWireFormat.get()), you can check if \n * this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == BinaryXmlWireFormat.get().\n * @returns {BinaryXmlWireFormat} The singleton instance.\n */\nBinaryXmlWireFormat.get = function()\n{\n  if (BinaryXmlWireFormat.instance === null)\n    BinaryXmlWireFormat.instance = new BinaryXmlWireFormat();\n  return BinaryXmlWireFormat.instance;\n};\n\n/**\n * Encode the interest by calling the operations on the encoder.\n * @param {Interest} interest\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeInterest = function(interest, encoder) \n{\n  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);\n    \n  interest.name.to_ndnb(encoder);\n  \n  if (null != interest.minSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);  \n\n  if (null != interest.maxSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);\n\n  if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n      interest.getKeyLocator().getKeyData() != null &&\n      interest.getKeyLocator().getKeyData().length > 0)\n    // There is a KEY_LOCATOR_DIGEST. Use this instead of the publisherPublicKeyDigest.\n    encoder.writeDTagElement\n      (NDNProtocolDTags.PublisherPublicKeyDigest, \n       interest.getKeyLocator().getKeyData());\n  else {\n    if (null != interest.publisherPublicKeyDigest)\n      interest.publisherPublicKeyDigest.to_ndnb(encoder);\n  }\n    \n  if (null != interest.exclude)\n    interest.exclude.to_ndnb(encoder);\n    \n  if (null != interest.childSelector) \n    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);\n\n  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null) \n    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);\n    \n  if (null != interest.scope) \n    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);\n    \n  if (null != interest.interestLifetime) \n    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime, \n                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));\n    \n  if (null != interest.nonce)\n    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);\n    \n  encoder.writeElementClose();\n};\n\n/**\n * Use the decoder to place the result in interest.\n * @param {Interest} interest\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeInterest = function(interest, decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name = new Name();\n  interest.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))\n    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);\n  else\n    interest.minSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents)) \n    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);\n  else\n    interest.maxSuffixComponents = null;\n      \n  // Initially clear the keyLocator.\n  interest.getKeyLocator().clear();\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    interest.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  else\n    interest.publisherPublicKeyDigest = null;\n  if (interest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest.length > 0) {\n    // We keep the deprecated publisherPublicKeyDigest for backwards \n    //   compatibility.  Also set the key locator.\n    interest.getKeyLocator().setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    interest.getKeyLocator().setKeyData\n      (interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {\n    interest.exclude = new Exclude();\n    interest.exclude.from_ndnb(decoder);\n  }\n  else\n    interest.exclude = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))\n    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);\n  else\n    interest.childSelector = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))\n    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);\n  else\n    interest.answerOriginKind = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.Scope))\n    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);\n  else\n    interest.scope = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))\n    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt\n               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;\n  else\n    interest.interestLifetime = null;              \n    \n  if (decoder.peekDTag(NDNProtocolDTags.Nonce))\n    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);\n  else\n    interest.nonce = null;\n    \n  decoder.readElementClose();\n};\n\n/**\n * Encode the data by calling the operations on the encoder.\n * @param {Data} data\n * @param {BinaryXMLEncoder} encoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.encodeData = function(data, encoder)  \n{\n  //TODO verify name, MetaInfo and Signature is present\n  encoder.writeElementStartDTag(data.getElementLabel());\n\n  if (null != data.signature) \n    data.signature.to_ndnb(encoder);\n    \n  var signedPortionBeginOffset = encoder.offset;\n\n  if (null != data.name) \n    data.name.to_ndnb(encoder);\n  \n  if (null != data.signedInfo) \n    // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n    //   the key locator from the MetaInfo to the Signauture object.\n    data.signedInfo.to_ndnb(encoder, data.getSignatureOrMetaInfoKeyLocator());\n\n  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);\n  \n  var signedPortionEndOffset = encoder.offset;\n  \n  encoder.writeElementClose();\n  \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Use the decoder to place the result in data.\n * @param {Data} data\n * @param {BinaryXMLDecoder} decoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.decodeData = function(data, decoder) \n{\n  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT\n  decoder.readElementStartDTag(data.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {\n    data.signature = new Signature();\n    data.signature.from_ndnb(decoder);\n  }\n  else\n    data.signature = null;\n    \n  var signedPortionBeginOffset = decoder.offset;\n\n  data.name = new Name();\n  data.name.from_ndnb(decoder);\n    \n  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {\n    data.signedInfo = new MetaInfo();\n    data.signedInfo.from_ndnb(decoder);\n    if (data.signedInfo.locator != null && data.getSignature() != null)\n      // Copy the key locator pointer to the Signature object for the transition \n      //   of moving the key locator from the MetaInfo to the Signature object.\n      data.getSignature().keyLocator = data.signedInfo.locator;\n  }\n  else\n    data.signedInfo = null;\n\n  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);\n    \n  var signedPortionEndOffset = decoder.offset;\n    \n  decoder.readElementClose();\n    \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n})()\n},{"../exclude.js":12,"../key-locator.js":16,"../meta-info.js":14,"../name.js":9,"../publisher-public-key-digest.js":17,"../signature.js":65,"../util/blob.js":25,"../util/ndn-protoco-id-tags.js":60,"./binary-xml-decoder.js":58,"./binary-xml-encoder.js":59,"./data-utils.js":23,"./wire-format.js":18}],20:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Tlv0_1a2WireFormat = require(\'./tlv-0_1a2-wire-format.js\').Tlv0_1a2WireFormat;\n\n/**\n * A TlvWireFormat extends Tlv0_1a2WireFormat to override its methods to \n * implement encoding and decoding using the preferred implementation of NDN-TLV.\n * @constructor\n */\nvar TlvWireFormat = function TlvWireFormat() \n{\n  // Inherit from Tlv0_1a2WireFormat.\n  Tlv0_1a2WireFormat.call(this);\n};\n\nTlvWireFormat.prototype = new Tlv0_1a2WireFormat();\nTlvWireFormat.prototype.name = "TlvWireFormat";\n\nexports.TlvWireFormat = TlvWireFormat;\n\n// Default object.\nTlvWireFormat.instance = null;\n\n/**\n * Get a singleton instance of a TlvWireFormat.  Assuming that the default \n * wire format was set with WireFormat.setDefaultWireFormat(TlvWireFormat.get()), \n * you can check if this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == TlvWireFormat.get().\n * @returns {TlvWireFormat} The singleton instance.\n */\nTlvWireFormat.get = function()\n{\n  if (TlvWireFormat.instance === null)\n    TlvWireFormat.instance = new TlvWireFormat();\n  return TlvWireFormat.instance;\n};\n\n// On loading this module, make this the default wire format.\n// This module will be loaded because WireFormat loads it.\nWireFormat.setDefaultWireFormat(TlvWireFormat.get());\n\n},{"./tlv-0_1a2-wire-format.js":71,"./wire-format.js":18}],23:[function(require,module,exports){\n(function(){/**\n * This class contains utilities to help parse the data\n *\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n\n/**\n * A DataUtils has static methods for converting data.\n * @constructor\n */\n\n\nvar DataUtils = function()\n{\n};\n\nexports.DataUtils = new DataUtils();\n\n/*\n * NOTE THIS IS CURRENTLY NOT BEING USED\n *\n */\n\nDataUtils.prototype.keyStr = "ABCDEFGHIJKLMNOP" +\n                   "QRSTUVWXYZabcdef" +\n                   "ghijklmnopqrstuv" +\n                   "wxyz0123456789+/" +\n                   "=";\n\n/**\n * Raw String to Base 64\n */\nDataUtils.prototype.stringtoBase64 = function stringtoBase64(input)\n{\n   //input = escape(input);\n   var output = "";\n   var chr1, chr2, chr3 = "";\n   var enc1, enc2, enc3, enc4 = "";\n   var i = 0;\n\n   do {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2))\n       enc3 = enc4 = 64;\n    else if (isNaN(chr3))\n       enc4 = 64;\n\n    output = output +\n       DataUtils.keyStr.charAt(enc1) +\n       DataUtils.keyStr.charAt(enc2) +\n       DataUtils.keyStr.charAt(enc3) +\n       DataUtils.keyStr.charAt(enc4);\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n   } while (i < input.length);\n\n   return output;\n};\n\n/**\n * Base 64 to Raw String\n */\nDataUtils.prototype.base64toString = function base64toString(input)\n{\n  var output = "";\n  var chr1, chr2, chr3 = "";\n  var enc1, enc2, enc3, enc4 = "";\n  var i = 0;\n\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n  /* Test for invalid characters. */\n  if (base64test.exec(input)) {\n    alert("There were invalid base64 characters in the input text.\\n" +\n          "Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\\n" +\n          "Expect errors in decoding.");\n  }\n\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");\n\n  do {\n    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 != 64)\n      output = output + String.fromCharCode(chr2);\n\n    if (enc4 != 64)\n      output = output + String.fromCharCode(chr3);\n\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n  } while (i < input.length);\n\n  return output;\n};\n\n/**\n * customBuf to Hex String\n */\nDataUtils.prototype.toHex = function(buffer)\n{\n  return buffer.toString(\'hex\');\n};\n\n/**\n * Raw string to hex string.\n */\nDataUtils.prototype.stringToHex = function(args)\n{\n  var ret = "";\n  for (var i = 0; i < args.length; ++i) {\n    var value = args.charCodeAt(i);\n    ret += (value < 16 ? "0" : "") + value.toString(16);\n  }\n  return ret;\n};\n\n/**\n * customBuf to raw string.\n */\nDataUtils.prototype.toString = function(buffer)\n{\n  return buffer.toString(\'binary\');\n};\n\n/**\n * Hex String to customBuf.\n */\nDataUtils.prototype.toNumbers = function(str)\n{\n  return new customBuf(str, \'hex\');\n};\n\n/**\n * Hex String to raw string.\n */\nDataUtils.prototype.hexToRawString = function(str)\n{\n  if (typeof str ==\'string\') {\n  var ret = "";\n  str.replace(/(..)/g, function(s) {\n    ret += String.fromCharCode(parseInt(s, 16));\n  });\n  return ret;\n  }\n};\n\n/**\n * Raw String to customBuf.\n */\nDataUtils.prototype.toNumbersFromString = function(str)\n{\n  return new customBuf(str, \'binary\');\n};\n\n/**\n * Encode str as utf8 and return as customBuf.\n * If value is a string, then interpret it as a raw string and convert to\n * a Buffer. Otherwise assume it is a Buffer or array type and just return it.\n * @param {string|any} value\n * @returns {Buffer}\n */\nDataUtils.prototype.toNumbersIfString = function(value)\n{\n  if (typeof value === \'string\')\n    return new customBuf(value, \'binary\');\n  else\n    return value;\n};\n\n/**\n * Encode str as utf8 and return as Buffer.\n */\nDataUtils.prototype.stringToUtf8Array = function(str)\n{\n  return new customBuf(str, \'utf8\');\n};\n\n/**\n * arrays is an array of customBuf. Return a new customBuf which is the concatenation of all.\n */\nDataUtils.prototype.concatArrays = function(arrays)\n{\n  return customBuf.concat(arrays);\n};\n\n// TODO: Take customBuf and use TextDecoder when available.\nDataUtils.prototype.decodeUtf8 = function(utftext)\n{\n  var string = "";\n  var i = 0;\n  var c = 0;\n    var c1 = 0;\n    var c2 = 0;\n\n  while (i < utftext.length) {\n    c = utftext.charCodeAt(i);\n\n    if (c < 128) {\n      string += String.fromCharCode(c);\n      i++;\n    }\n    else if (c > 191 && c < 224) {\n      c2 = utftext.charCodeAt(i + 1);\n      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n      i += 2;\n    }\n    else {\n      c2 = utftext.charCodeAt(i+1);\n      var c3 = utftext.charCodeAt(i+2);\n      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n      i += 3;\n    }\n  }\n\n  return string;\n};\n\n/**\n * Return true if a1 and a2 are the same length with equal elements.\n */\nDataUtils.prototype.arraysEqual = function(a1, a2)\n{\n  // A simple sanity check that it is an array.\n  if (!a1.slice)\n    throw new Error("DataUtils.arraysEqual: a1 is not an array");\n  if (!a2.slice)\n    throw new Error("DataUtils.arraysEqual: a2 is not an array");\n\n  if (a1.length != a2.length)\n    return false;\n\n  for (var i = 0; i < a1.length; ++i) {\n    if (a1[i] != a2[i])\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Convert the big endian customBuf to an unsigned int.\n * Don\'t check for overflow.\n */\nDataUtils.prototype.bigEndianToUnsignedInt = function(bytes)\n{\n  var result = 0;\n  for (var i = 0; i < bytes.length; ++i) {\n    result <<= 8;\n    result += bytes[i];\n  }\n  return result;\n};\n\n/**\n * Convert the int value to a new big endian customBuf and return.\n * If value is 0 or negative, return new customBuf(0).\n */\nDataUtils.prototype.nonNegativeIntToBigEndian = function(value)\n{\n  value = Math.round(value);\n  if (value <= 0)\n    return new customBuf(0);\n\n  // Assume value is not over 64 bits.\n  var size = 8;\n  var result = new customBuf(size);\n  var i = 0;\n  while (value != 0) {\n    ++i;\n    result[size - i] = value & 0xff;\n    value >>= 8;\n  }\n  return result.slice(size - i, size);\n};\n\n/**\n * Modify array to randomly shuffle the elements.\n */\nDataUtils.prototype.shuffle = function(array)\n{\n  for (var i = array.length - 1; i >= 1; --i) {\n    // j is from 0 to i.\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n};\n\n})()\n},{"../buffer.js":30}],24:[function(require,module,exports){\n(function(){/**\n * This file contains utilities to help encode and decode NDN objects.\n * Copyright (C) 2013-2014 Regents of the University of California.\n * author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Key = require(\'../key.js\').Key;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Interest = require(\'../interest.js\').Interest;\nvar Data = require(\'../data.js\').Data;\nvar FaceInstance = require(\'../face-instance.js\').FaceInstance;\nvar ForwardingEntry = require(\'../forwarding-entry.js\').ForwardingEntry;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * An EncodingUtils has static methods for encoding data.\n * @constructor\n */\nvar EncodingUtils = function EncodingUtils() \n{\n};\n\nexports.EncodingUtils = EncodingUtils;\n\nEncodingUtils.encodeToHexInterest = function(interest, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(interest.wireEncode(wireFormat).buf());\n};\n\nEncodingUtils.encodeToHexData = function(data, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(data.wireEncode(wireFormat).buf());\n};\n\n/**\n * @deprecated Use EncodingUtils.encodeToHexData(data).\n */\nEncodingUtils.encodeToHexContentObject = function(data, wireFormat) \n{\n  return EncodingUtils.encodeToHexData(data, wireFormat);\n}\n\nEncodingUtils.encodeForwardingEntry = function(data) \n{\n  var enc = new BinaryXMLEncoder();\n  data.to_ndnb(enc);\n  var bytes = enc.getReducedOstream();\n\n  return bytes;\n};\n\nEncodingUtils.decodeHexFaceInstance = function(result) \n{  \n  var numbers = DataUtils.toNumbers(result); \n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODING HEX FACE INSTANCE  \\n\'+numbers);\n\n  var faceInstance = new FaceInstance();\n  faceInstance.from_ndnb(decoder);\n  \n  return faceInstance;\n};\n\nEncodingUtils.decodeHexInterest = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var interest = new Interest();\n  interest.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return interest;\n};\n\nEncodingUtils.decodeHexData = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var data = new Data();\n  data.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return data;\n};\n\n/**\n * @deprecated Use EncodingUtils.decodeHexData(input).\n */\nEncodingUtils.decodeHexContentObject = function(input, wireFormat) \n{\n  return EncodingUtils.decodeHexData(input, wireFormat);\n}\n\nEncodingUtils.decodeHexForwardingEntry = function(result) \n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODED HEX FORWARDING ENTRY \\n\'+numbers);\n  \n  var forwardingEntry = new ForwardingEntry();\n  forwardingEntry.from_ndnb(decoder);\n  return forwardingEntry;\n};\n\n/**\n * Decode the customBuf array which holds SubjectPublicKeyInfo and return an RSAKey.\n */\nEncodingUtils.decodeSubjectPublicKeyInfo = function(array) \n{\n  var hex = DataUtils.toHex(array).toLowerCase();\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));\n  var rsaKey = new RSAKey();\n  rsaKey.setPublic(a[0], a[1]);\n  return rsaKey;\n}\n\n/**\n * Return a user friendly HTML string with the contents of data.\n * This also outputs to console.log.\n */\nEncodingUtils.dataToHtml = function(/* Data */ data) \n{\n  var output ="";\n      \n  if (data == -1)\n    output+= "NO CONTENT FOUND"\n  else if (data == -2)\n    output+= "CONTENT NAME IS EMPTY"\n  else {\n    if (data.name != null && data.name.components != null) {\n      output+= "NAME: " + data.name.toUri();\n        \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.digestAlgorithm != null) {\n      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.witness != null) {\n      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.signature != null) {\n      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {\n      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.timestamp != null) {\n      var d = new Date();\n      d.setTime(data.signedInfo.timestamp.msec);\n      \n      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];\n      \n      output += "TimeStamp: "+d;\n      output+= "<br />";\n      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;\n      \n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {\n      output += "keyLocator: ";\n      if (data.signedInfo.locator.type == KeyLocatorType.KEY)\n        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n        output += "KeyLocatorDigest: " + DataUtils.toHex(data.signedInfo.locator.getKeyData()).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)\n        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)\n        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";\n      else\n        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";      \n    }\n  }\n\n  return output;\n};\n\n/**\n * @deprecated Use return EncodingUtils.dataToHtml(data).\n */\nEncodingUtils.contentObjectToHtml = function(data) \n{\n  return EncodingUtils.dataToHtml(data);\n}\n\n//\n// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.\n//\n\nvar encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }\nvar encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }\nvar encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }\nvar decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }\nvar decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }\nvar decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }\nvar decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }\nvar decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }\nvar contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }\n\n/**\n * @deprecated Use interest.wireEncode().\n */\nfunction encodeToBinaryInterest(interest) { return interest.wireEncode().buf(); }\n/**\n * @deprecated Use data.wireEncode().\n */\nfunction encodeToBinaryContentObject(data) { return data.wireEncode().buf(); }\n\n})()\n},{"../data.js":13,"../face-instance.js":72,"../forwarding-entry.js":57,"../interest.js":11,"../key-locator.js":16,"../key.js":15,"../log.js":62,"./binary-xml-decoder.js":58,"./binary-xml-encoder.js":59,"./data-utils.js":23,"./wire-format.js":18}],25:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * A Blob holds an immutable byte array implemented as a customBuf.  This should be \n * treated like a string which is a pointer to an immutable string. (It is OK to \n * pass a pointer to the string because the new owner can\u2019t change the bytes of \n * the string.)  Blob does not inherit from customBuf. Instead you must call buf() \n * to get the byte array which reminds you that you should not change the \n * contents.  Also remember that buf() can return null.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {boolean} copy (optional) (optional) If true, copy the contents of \n * value into a new customBuf.  If false, just use the existing value without \n * copying. If omitted, then copy the contents (unless value is already a Blob).\n * IMPORTANT: If copy is false, if you keep a pointer to the value then you must\n * treat the value as immutable and promise not to change it.\n */\nvar Blob = function Blob(value, copy) \n{\n  if (copy == null)\n    copy = true;\n  \n  if (value == null)\n    this.buffer = null;\n  else if (typeof value === \'object\' && value instanceof Blob)\n    // Use the existing buffer.  Don\'t need to check for copy.\n    this.buffer = value.buffer;\n  else {\n    if (typeof value === \'string\')\n      // Convert from a string to utf-8 byte encoding.\n      this.buffer = new customBuf(value, \'utf8\');\n    else {\n      if (copy)\n        // We are copying, so just make another customBuf.\n        this.buffer = new customBuf(value);\n      else {\n        if (typeof value === \'object\' && value instanceof customBuf)\n          // We can use as-is.\n          this.buffer = value;\n        else\n          // We need a customBuf, so copy.\n          this.buffer = new customBuf(value);\n      }\n    }\n  }\n};\n\nexports.Blob = Blob;\n\n/**\n * Return the length of the immutable byte array.\n * @returns {number} The length of the array.  If buf() is null, return 0.\n */\nBlob.prototype.size = function()\n{\n  if (this.buffer != null)\n    return this.buffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return the immutable byte array.  DO NOT change the contents of the customBuf.  \n * If you need to change it, make a copy.\n * @returns {Buffer} The customBuf holding the immutable byte array, or null.\n */\nBlob.prototype.buf = function()\n{\n  return this.buffer;\n};\n\n/**\n * Return true if the array is null, otherwise false.\n * @returns {boolean} True if the array is null.\n */\nBlob.prototype.isNull = function()\n{\n  return this.buffer == null;\n};\n\n/**\n * Return the hex representation of the bytes in the byte array.\n * @returns {string} The hex string.\n */\nBlob.prototype.toHex = function() \n{  \n  if (this.buffer == null)\n    return "";\n  else\n    return this.buffer.toString(\'hex\');\n};\n\n})()\n},{"../buffer.js":30}],73:[function(require,module,exports){\nrequire=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module \'"+r+"\'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],2:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require(\'util\');\nvar Buffer = require("buffer").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError\'s when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = \'AssertionError\';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return \'\' + value;\n  }\n  if (typeof value === \'number\' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === \'function\' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == \'string\') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + \':\', this.message].join(\' \');\n  } else {\n    return [\n      this.name + \':\',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(\' \');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError\'s constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, \'==\', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \'==\', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \'!=\', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'deepEqual\', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == \'object\',\n  // equivalence is determined by ==.\n  } else if (typeof actual != \'object\' && typeof expected != \'object\') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \'prototype\' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == \'[object Arguments]\';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical \'prototype\' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I\'ve managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn\'t\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'notDeepEqual\', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \'===\', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \'!==\', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === \'string\') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? \' (\' + expected.name + \').\' : \'.\') +\n            (message ? \' \' + message : \'.\');\n\n  if (shouldThrow && !actual) {\n    fail(\'Missing expected exception\' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(\'Got unwanted exception\' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){\nmodule.exports=require(\'q9TxCC\');\n},{}],"q9TxCC":[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n    case \'binary\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nSlowBuffer.prototype.fill = function(value, start, end) {\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this.parent[i + this.offset] = subject.readUInt8(i);\n        }\n        else {\n          this.parent[i + this.offset] = subject[i];\n        }\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1];\n    }\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer.parent[buffer.offset + offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){\nvar events = require(\'events\');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === \'[object Date]\'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === \'[object RegExp]\'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { \'bold\' : [1, 22],\n          \'italic\' : [3, 23],\n          \'underline\' : [4, 24],\n          \'inverse\' : [7, 27],\n          \'white\' : [37, 39],\n          \'grey\' : [90, 39],\n          \'black\' : [30, 39],\n          \'blue\' : [34, 39],\n          \'cyan\' : [36, 39],\n          \'green\' : [32, 39],\n          \'magenta\' : [35, 39],\n          \'red\' : [31, 39],\n          \'yellow\' : [33, 39] };\n\n    var style =\n        { \'special\': \'cyan\',\n          \'number\': \'blue\',\n          \'boolean\': \'yellow\',\n          \'undefined\': \'grey\',\n          \'null\': \'bold\',\n          \'string\': \'green\',\n          \'date\': \'magenta\',\n          // "name": intentionally not styling\n          \'regexp\': \'red\' }[styleType];\n\n    if (style) {\n      return \'\\033[\' + styles[style][0] + \'m\' + str +\n             \'\\033[\' + styles[style][1] + \'m\';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === \'function\' &&\n        // Filter out the util module, it\'s inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case \'undefined\':\n        return stylize(\'undefined\', \'undefined\');\n\n      case \'string\':\n        var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                                 .replace(/\'/g, "\\\\\'")\n                                                 .replace(/\\\\"/g, \'"\') + \'\\\'\';\n        return stylize(simple, \'string\');\n\n      case \'number\':\n        return stylize(\'\' + value, \'number\');\n\n      case \'boolean\':\n        return stylize(\'\' + value, \'boolean\');\n    }\n    // For some reason typeof null is "object", so special case here.\n    if (value === null) {\n      return stylize(\'null\', \'null\');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === \'function\' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        var name = value.name ? \': \' + value.name : \'\';\n        return stylize(\'[Function\' + name + \']\', \'special\');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), \'date\');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = \'Array\';\n      braces = [\'[\', \']\'];\n    } else {\n      type = \'Object\';\n      braces = [\'{\', \'}\'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === \'function\') {\n      var n = value.name ? \': \' + value.name : \'\';\n      base = (isRegExp(value)) ? \' \' + value : \' [Function\' + n + \']\';\n    } else {\n      base = \'\';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = \' \' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        return stylize(\'[Object]\', \'special\');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Getter/Setter]\', \'special\');\n          } else {\n            str = stylize(\'[Getter]\', \'special\');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Setter]\', \'special\');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = \'[\' + key + \']\';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf(\'\\n\') > -1) {\n            if (isArray(value)) {\n              str = str.split(\'\\n\').map(function(line) {\n                return \'  \' + line;\n              }).join(\'\\n\').substr(2);\n            } else {\n              str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n                return \'   \' + line;\n              }).join(\'\\n\');\n            }\n          }\n        } else {\n          str = stylize(\'[Circular]\', \'special\');\n        }\n      }\n      if (typeof name === \'undefined\') {\n        if (type === \'Array\' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\'\' + key);\n        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, \'name\');\n        } else {\n          name = name.replace(/\'/g, "\\\\\'")\n                     .replace(/\\\\"/g, \'"\')\n                     .replace(/(^"|"$)/g, "\'");\n          name = stylize(name, \'string\');\n        }\n      }\n\n      return name + \': \' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === \'\' ? \'\' : base + \'\\n \') +\n               \' \' +\n               output.join(\',\\n  \') +\n               \' \' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === \'undefined\' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === \'object\' && Object.prototype.toString.call(re) === \'[object RegExp]\');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== \'object\') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { \'__proto__\' : null };\n    }\n    else {\n        if (typeof prototype !== \'object\') {\n            throw new TypeError(\n                \'typeof prototype[\' + (typeof prototype) + \'] != \\\'object\\\'\'\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== \'undefined\' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== \'string\') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== \'object\') {\n      str += \' \' + x;\n    } else {\n      str += \' \' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{"events":6}],5:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],7:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],8:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            if (ev.source === window && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],6:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === \'function\'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === \'[object Array]\'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled \'error\' event\n      } else {\n        throw new Error("Uncaught, unspecified \'error\' event.");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == \'function\') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'addListener only takes instances of Function\');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == "newListeners"! Before\n  // adding it to the listeners, first emit "newListeners".\n  this.emit(\'newListener\', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error(\'(node) warning: possible EventEmitter memory \' +\n                      \'leak detected. %d listeners added. \' +\n                      \'Use emitter.setMaxListeners() to increase limit.\',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'removeListener only takes instances of Function\');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n})(require("__browserify_process"))\n},{"__browserify_process":8}],4:[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        this.parent[i + this.offset] = subject[i];\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    val |= buffer.parent[buffer.offset + offset + 1];\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset + 1] << 16;\n    val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    val = buffer.parent[buffer.offset + offset + 2] << 16;\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  buffer.parent[buffer.offset + offset] = value;\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;\n  } else {\n    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset] = value & 0x00ff;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset + 3] = value & 0xff;\n  } else {\n    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset] = value & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}]},{},[])\n;;module.exports=require("buffer-browserify")\n\n},{}],26:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar BinaryXMLDecoder = require(\'../encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Name = require(\'../name.js\').Name;\n\n/**\n * Create a context for getting the response from the name enumeration command, as neede by getComponents.\n * (To do name enumeration, call the static method NameEnumeration.getComponents.)\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nvar NameEnumeration = function NameEnumeration(face, onComponents) \n{\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n  \n  var self = this;\n  this.onData = function(interest, data) { self.processData(data); };\n  this.onTimeout = function(interest) { self.processTimeout(); };\n};\n\nexports.NameEnumeration = NameEnumeration;\n\n/**\n * Use the name enumeration protocol to get the child components of the name prefix.\n * @param {Face} face The Face object for using expressInterest.\n * @param {Name} name The name prefix for finding the child components.\n * @param {function} onComponents On getting the response, this calls onComponents(components) where\n * components is an array of customBuf name components.  If there is no response, this calls onComponents(null). \n */\nNameEnumeration.getComponents = function(face, prefix, onComponents)\n{\n  var command = new Name(prefix);\n  // Add %C1.E.be\n  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])\n  \n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n/**\n * Parse the response from the name enumeration command and call this.onComponents.\n * @param {Data} data\n */\nNameEnumeration.prototype.processData = function(data) \n{\n  try {\n    if (!NameEnumeration.endsWithSegmentNumber(data.name))\n      // We don\'t expect a name without a segment number.  Treat it as a bad packet.\n      this.onComponents(null);\n    else {\n      var segmentNumber = DataUtils.bigEndianToUnsignedInt\n          (data.name.get(data.name.size() - 1).getValue());\n\n      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.\n      var expectedSegmentNumber = this.contentParts.length;\n      if (segmentNumber != expectedSegmentNumber)\n        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);\n      else {\n        // Save the content and check if we are finished.\n        this.contentParts.push(data.content);\n\n        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);\n          if (segmentNumber == finalSegmentNumber) {\n            // We are finished.  Parse and return the result.\n            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));\n            return;\n          }\n        }\n\n        // Fetch the next segment.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);\n      }\n    }\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Just call onComponents(null).\n */\nNameEnumeration.prototype.processTimeout = function()\n{\n  try {\n    this.onComponents(null);\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.\n * @param {Uint8Array} content The content to parse.\n * @returns {Array<Buffer>} The array of components.\n */\nNameEnumeration.parseComponents = function(content)\n{\n  var components = [];\n  var decoder = new BinaryXMLDecoder(content);\n  \n  decoder.readElementStartDTag(NDNProtocolDTags.Collection);\n \n  while (decoder.peekDTag(NDNProtocolDTags.Link)) {\n    decoder.readElementStartDTag(NDNProtocolDTags.Link);    \n    decoder.readElementStartDTag(NDNProtocolDTags.Name);\n    \n    components.push(new customBuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));\n    \n    decoder.readElementClose();  \n    decoder.readElementClose();  \n  }\n\n  decoder.readElementClose();\n  return components;\n};\n\n/**\n * Check if the last component in the name is a segment number.\n * TODO: Move to Name class.\n * @param {Name} name\n * @returns {Boolean} True if the name ends with a segment number, otherwise false.\n */\nNameEnumeration.endsWithSegmentNumber = function(name) {\n  return name.components != null && name.size() >= 1 &&\n         name.get(name.size() - 1).getValue().length >= 1 &&\n         name.get(name.size() - 1).getValue()[0] == 0;\n};\n\n})(require("__browserify_buffer").Buffer)\n},{"../buffer.js":30,"../encoding/binary-xml-decoder.js":58,"../encoding/data-utils.js":23,"../name.js":9,"./ndn-protoco-id-tags.js":60,"__browserify_buffer":73}],27:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents NDNTime Objects\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar NDNTime = function NDNTime(input) \n{\n  this.NANOS_MAX = 999877929;\n  \n  if (typeof input ==\'number\')\n    this.msec = input;\n  else {\n    if (LOG > 1) console.log(\'UNRECOGNIZED TYPE FOR TIME\');\n  }\n};\n\nexports.NDNTime = NDNTime;\n\nNDNTime.prototype.getJavascriptDate = function() \n{\n  var d = new Date();\n  d.setTime(this.msec);\n  return d\n};  \n\n},{"../log.js":62}],28:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar Key = require(\'../key.js\').Key;\n\n/**\n * @constructor\n */\nvar KeyManager = function KeyManager()\n{\n  this.certificate = \n  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +\n  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +\n  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +\n  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +\n  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +\n  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +\n  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +\n  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +\n  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";\n\n  // Public Key\n    this.publicKey = \n  "-----BEGIN PUBLIC KEY-----\\n" +\n  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\\n" +\n  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\\n" +\n  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\\n" +\n  "WFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "-----END PUBLIC KEY-----";\n  // Private Key\n    this.privateKey = \n  "-----BEGIN RSA PRIVATE KEY-----\\n" +\n  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\\n" +\n  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\\n" +\n  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\\n" +\n  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\\n" +\n  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\\n" +\n  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\\n" +\n  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\\n" +\n  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\\n" +\n  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\\n" +\n  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\\n" +\n  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\\n" +\n  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\\n" +\n  "-----END RSA PRIVATE KEY-----";\n  \n  this.key = null;\n};\n\n/**\n * Return a Key object for the keys in this KeyManager.  This creates the Key on the first\n * call and returns a cached copy after that.\n * @returns {Key}\n */\nKeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n  \n  return this.key;\n}\n\nvar globalKeyManager = globalKeyManager || new KeyManager();\nexports.globalKeyManager = globalKeyManager;\n\n},{"../key.js":15}],29:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLStructureDecoder = require(\'./binary-xml-structure-decoder.js\').BinaryXMLStructureDecoder;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvStructureDecoder = require(\'./tlv/tlv-structure-decoder.js\').TlvStructureDecoder;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * A ElementReader lets you call onReceivedData multiple times which uses a\n * BinaryXMLStructureDecoder or TlvStructureDecoder to detect the end of a\n * binary XML or TLV element and calls elementListener.onReceivedElement(element)\n * with the element.  This handles the case where a single call to\n * onReceivedData may contain multiple elements.\n * @constructor\n * @param {{onReceivedElement:function}} elementListener\n */\nvar ElementReader = function ElementReader(elementListener)\n{\n  this.elementListener = elementListener;\n  this.dataParts = [];\n  this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n  this.tlvStructureDecoder = new TlvStructureDecoder();\n  this.useTlv = null;\n};\n\nexports.ElementReader = ElementReader;\n\nElementReader.prototype.onReceivedData = function(/* customBuf */ data)\n{\n  // Process multiple objects in the data.\n  while (true) {\n    if (this.dataParts.length == 0) {\n      // This is the beginning of an element.  Check whether it is binaryXML or TLV.\n      if (data.length <= 0)\n        // Wait for more data.\n        return;\n\n      // The type codes for TLV Interest and Data packets are chosen to not\n      //   conflict with the first byte of a binary XML packet, so we can\n      //   just look at the first byte.\n      if (data[0] == Tlv.Interest || data[0] == Tlv.Data || data[0] == 0x80)\n        this.useTlv = true;\n      else\n        // Binary XML.\n        this.useTlv = false;\n    }\n\n    var gotElementEnd;\n    var offset;\n    if (this.useTlv) {\n      // Scan the input to check if a whole TLV object has been read.\n      this.tlvStructureDecoder.seek(0);\n      gotElementEnd = this.tlvStructureDecoder.findElementEnd(data);\n      offset = this.tlvStructureDecoder.getOffset();\n    }\n    else {\n      // Scan the input to check if a whole Binary XML object has been read.\n      this.binaryXmlStructureDecoder.seek(0);\n      gotElementEnd = this.binaryXmlStructureDecoder.findElementEnd(data);\n      offset = this.binaryXmlStructureDecoder.offset;\n    }\n\n    if (gotElementEnd) {\n      // Got the remainder of an object.  Report to the caller.\n      this.dataParts.push(data.slice(0, offset));\n      var element = DataUtils.concatArrays(this.dataParts);\n      this.dataParts = [];\n      try {\n        this.elementListener.onReceivedElement(element);\n      } catch (ex) {\n          console.log("ElementReader: ignoring exception from onReceivedElement: " , ex);\n      }\n\n      // Need to read a new object.\n      data = data.slice(offset, data.length);\n      this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n      this.tlvStructureDecoder = new TlvStructureDecoder();\n      if (data.length == 0)\n        // No more data in the packet.\n        return;\n\n      // else loop back to decode.\n    }\n    else {\n      // Save for a later call to concatArrays so that we only copy data once.\n      this.dataParts.push(data);\n      if (LOG > 3) console.log(\'Incomplete packet received. Length \' + data.length + \'. Wait for more input.\');\n        return;\n    }\n  }\n};\n\n})()\n},{"../buffer.js":30,"../log.js":62,"./binary-xml-structure-decoder.js":74,"./data-utils.js":23,"./tlv/tlv-structure-decoder.js":75,"./tlv/tlv.js":22}],76:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require(\'util\');\nvar Buffer = require("buffer").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError\'s when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = \'AssertionError\';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return \'\' + value;\n  }\n  if (typeof value === \'number\' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === \'function\' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == \'string\') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + \':\', this.message].join(\' \');\n  } else {\n    return [\n      this.name + \':\',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(\' \');\n  }\n};\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError\'s constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, \'==\', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \'==\', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \'!=\', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'deepEqual\', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == \'object\',\n  // equivalence is determined by ==.\n  } else if (typeof actual != \'object\' && typeof expected != \'object\') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \'prototype\' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == \'[object Arguments]\';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical \'prototype\' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I\'ve managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn\'t\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'notDeepEqual\', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \'===\', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \'!==\', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === \'string\') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? \' (\' + expected.name + \').\' : \'.\') +\n            (message ? \' \' + message : \'.\');\n\n  if (shouldThrow && !actual) {\n    fail(\'Missing expected exception\' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(\'Got unwanted exception\' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{"buffer":63,"util":77}],21:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DecodingException = require(\'../decoding-exception.js\').DecodingException;\n\n/**\n * Create a new TlvDecoder for decoding the input in the NDN-TLV wire format.\n * @constructor\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nvar TlvDecoder = function TlvDecoder(input)\n{\n  this.input = input;\n  this.offset = 0;\n};\n\nexports.TlvDecoder = TlvDecoder;\n\n/**\n * Decode VAR-NUMBER in NDN-TLV and return it. Update offset.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readVarNumber = function() \n{\n  // Assume array values are in the range 0 to 255.\n  var firstOctet = this.input[this.offset];\n  this.offset += 1;\n  if (firstOctet < 253)\n    return firstOctet;\n  else\n    return this.readExtendedVarNumber(firstOctet);\n};\n\n/**\n * A private function to do the work of readVarNumber, given the firstOctet\n * which is >= 253.\n * @param {number} firstOctet The first octet which is >= 253, used to decode \n * the remaining bytes.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readExtendedVarNumber = function(firstOctet) \n{\n  // This is a private function so we know firstOctet >= 253.\n  if (firstOctet == 253) {\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n    this.offset += 2;\n  }\n  else if (firstOctet == 254) {\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n    this.offset += 4;\n  }\n  else {\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n    this.offset += 8;\n  }\n  \n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType and return the length. Update offset.  Also make \n * sure the decoded length does not exceed the number of bytes remaining in the \n * input.\n * @param {number} expectedType The expected type.\n * @returns {number} The length of the TLV.\n * @throws DecodingException if (did not get the expected TLV type or the TLV length \n * exceeds the buffer length.\n */\nTlvDecoder.prototype.readTypeAndLength = function(expectedType) \n{\n  var type = this.readVarNumber();\n  if (type != expectedType)\n    throw new DecodingException("Did not get the expected TLV type");\n\n  var length = this.readVarNumber();\n  if (this.offset + length > this.input.length)\n    throw new DecodingException("TLV length exceeds the buffer length");\n\n  return length;\n};\n\n/**\n * Decode the type and length from the input starting at offset, expecting the \n * type to be expectedType.  Update offset.  Also make sure the decoded length \n * does not exceed the number of bytes remaining in the input. Return the offset \n * of the end of this parent TLV, which is used in decoding optional nested \n * TLVs. After reading all nested TLVs, call finishNestedTlvs.\n * @param {number} expectedType The expected type.\n * @returns {number} The offset of the end of the parent TLV.\n * @throws DecodingException if did not get the expected TLV type or the TLV \n * length exceeds the buffer length.\n */\nTlvDecoder.prototype.readNestedTlvsStart = function(expectedType) \n{\n  return this.readTypeAndLength(expectedType) + this.offset;\n};\n\n/**\n * Call this after reading all nested TLVs to skip any remaining unrecognized \n * TLVs and to check if the offset after the final nested TLV matches the \n * endOffset returned by readNestedTlvsStart.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @throws DecodingException if the TLV length does not equal the total length \n * of the nested TLVs.\n */\nTlvDecoder.prototype.finishNestedTlvs = function(endOffset) \n{\n  // We expect offset to be endOffset, so check this first.\n  if (this.offset == endOffset)\n    return;\n\n  // Skip remaining TLVs.\n  while (this.offset < endOffset) {\n    // Skip the type VAR-NUMBER.\n    this.readVarNumber();\n    // Read the length and update offset.\n    var length = this.readVarNumber();\n    this.offset += length;\n\n    if (this.offset > this.input.length)\n      throw new DecodingException("TLV length exceeds the buffer length");\n  }\n  \n  if (this.offset != endOffset)\n    throw new DecodingException\n      ("TLV length does not equal the total length of the nested TLVs");\n};\n\n/**\n * Decode the type from this\'s input starting at offset, and if it is the \n * expectedType, then return true, else false.  However, if this\'s offset is \n * greater than or equal to endOffset, then return false and don\'t try to read \n * the type. Do not update offset.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true if the type of the next TLV is the expectedType, \n *  otherwise false.\n */\nTlvDecoder.prototype.peekType = function(expectedType, endOffset) \n{\n  if (this.offset >= endOffset)\n    // No more sub TLVs to look at.\n    return false;\n  else {\n    var saveOffset = this.offset;\n    var type = this.readVarNumber();\n    // Restore offset.\n    this.offset = saveOffset;\n\n    return type == expectedType;\n  }\n};\n\n/**\n * Decode a non-negative integer in NDN-TLV and return it. Update offset by \n * length.\n * @param {number} length The number of bytes in the encoded integer.\n * @returns {number} The integer.\n * @throws DecodingException if length is an invalid length for a TLV \n * non-negative integer.\n */\nTlvDecoder.prototype.readNonNegativeInteger = function(length) \n{\n  var result;\n  if (length == 1)\n    result = this.input[this.offset];\n  else if (length == 2)\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n  else if (length == 4)\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n  else if (length == 8)\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n  else\n    throw new DecodingException("Invalid length for a TLV nonNegativeInteger");\n\n  this.offset += length;\n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then decode a non-negative integer in NDN-TLV \n * and return it.  Update offset.\n * @param {number} expectedType The expected type.\n * @returns {number} The integer.\n * @throws DecodingException if did not get the expected TLV type or can\'t \n * decode the value.\n */\nTlvDecoder.prototype.readNonNegativeIntegerTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  return this.readNonNegativeInteger(length);\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call \n * readNonNegativeIntegerTlv and return the integer.  Otherwise, return null.  \n * However, if this\'s offset is greater than or equal to endOffset, then return \n * null and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {number} The integer or null if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readOptionalNonNegativeIntegerTlv = function\n  (expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readNonNegativeIntegerTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then return an array of the bytes in the value.\n * Update offset.\n * @param {number} expectedType The expected type.\n * @returns {Buffer} The bytes in the value as a slice on the buffer.  This is\n * not a copy of the bytes in the input buffer.  If you need a copy, then you \n * must make a copy of the return value.\n * @throws DecodingException if did not get the expected TLV type.\n */\nTlvDecoder.prototype.readBlobTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  var result = this.input.slice(this.offset, this.offset + length);\n\n  // readTypeAndLength already checked if length exceeds the input buffer.\n  this.offset += length;\n  return result;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call readBlobTlv \n * and return the value.  Otherwise, return null. However, if this\'s offset is \n * greater than or equal to endOffset, then return null and don\'t try to read \n * the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {Buffer} The bytes in the value as a slice on the buffer or null if \n * the next TLV doesn\'t have the expected type.  This is not a copy of the bytes \n * in the input buffer.  If you need a copy, then you must make a copy of the \n * return value.\n */\nTlvDecoder.prototype.readOptionalBlobTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readBlobTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then read a type and \n * value, ignoring the value, and return true. Otherwise, return false.\n * However, if this\'s offset is greater than or equal to endOffset, then return \n * false and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true, or else false if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readBooleanTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset)) {\n    var length = this.readTypeAndLength(expectedType);\n    // We expect the length to be 0, but update offset anyway.\n    this.offset += length;\n    return true;\n  }\n  else\n    return false;\n};\n\n/**\n * Get the offset into the input, used for the next read.\n * @returns {number} The offset.\n */\nTlvDecoder.prototype.getOffset = function() \n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};  \n\n})()\n},{"../../buffer.js":30,"../decoding-exception.js":78}],60:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class contains all NDNx tags\n */\n\n\nvar NDNProtocolDTags = {\n\n  /**\n   * Note if you add one of these, add it to the reverse string map as well.\n   * Emphasize getting the work done at compile time over trying to make something\n   * flexible and developer error-proof.\n   */\n\n   Any : 13,\n   Name : 14,\n   Component : 15,\n   Certificate : 16,\n   Collection : 17,\n   CompleteName : 18,\n   Content : 19,\n   SignedInfo : 20,\n   ContentDigest : 21,\n   ContentHash : 22,\n   Count : 24,\n   Header : 25,\n   Interest : 26,  /* 20090915 */\n   Key : 27,\n   KeyLocator : 28,\n   KeyName : 29,\n   Length : 30,\n   Link : 31,\n   LinkAuthenticator : 32,\n   NameComponentCount : 33,  /* DeprecatedInInterest */\n   RootDigest : 36,\n   Signature : 37,\n   Start : 38,\n   Timestamp : 39,\n   Type : 40,\n   Nonce : 41,\n   Scope : 42,\n   Exclude : 43,\n   Bloom : 44,\n   BloomSeed : 45,\n   AnswerOriginKind : 47,\n   InterestLifetime : 48,\n   Witness : 53,\n   SignatureBits : 54,\n   DigestAlgorithm : 55,\n   BlockSize : 56,\n   FreshnessSeconds : 58,\n   FinalBlockID : 59,\n   PublisherPublicKeyDigest : 60,\n   PublisherCertificateDigest : 61,\n   PublisherIssuerKeyDigest : 62,\n   PublisherIssuerCertificateDigest : 63,\n   Data : 64,  /* 20090915 */\n   WrappedKey : 65,\n   WrappingKeyIdentifier : 66,\n   WrapAlgorithm : 67,\n   KeyAlgorithm : 68,\n   Label : 69,\n   EncryptedKey : 70,\n   EncryptedNonceKey : 71,\n   WrappingKeyName : 72,\n   Action : 73,\n   FaceID : 74,\n   IPProto : 75,\n   Host : 76,\n   Port : 77,\n   MulticastInterface : 78,\n   ForwardingFlags : 79,\n   FaceInstance : 80,\n   ForwardingEntry : 81,\n   MulticastTTL : 82,\n   MinSuffixComponents : 83,\n   MaxSuffixComponents : 84,\n   ChildSelector : 85,\n   RepositoryInfo : 86,\n   Version : 87,\n   RepositoryVersion : 88,\n   GlobalPrefix : 89,\n   LocalName : 90,\n   Policy : 91,\n   Namespace : 92,\n   GlobalPrefixName : 93,\n   PolicyVersion : 94,\n   KeyValueSet : 95,\n   KeyValuePair : 96,\n   IntegerValue : 97,\n   DecimalValue : 98,\n   StringValue : 99,\n   BinaryValue : 100,\n   NameValue : 101,\n   Entry : 102,\n   ACL : 103,\n   ParameterizedName : 104,\n   Prefix : 105,\n   Suffix : 106,\n   Root : 107,\n   ProfileName : 108,\n   Parameters : 109,\n   InfoString : 110,\n  // 111 unallocated\n   StatusResponse : 112,\n   StatusCode : 113,\n   StatusText : 114,\n\n  // Sync protocol\n   SyncNode : 115,\n   SyncNodeKind : 116,\n   SyncNodeElement : 117,\n   SyncVersion : 118,\n   SyncNodeElements : 119,\n   SyncContentHash : 120,\n   SyncLeafCount : 121,\n   SyncTreeDepth : 122,\n   SyncByteCount : 123,\n   ConfigSlice : 124,\n   ConfigSliceList : 125,\n   ConfigSliceOp : 126,\n\n  // Remember to keep in sync with schema/tagnames.csvsdict\n   NDNProtocolDataUnit : 17702112,\n   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"\n};\n\nexports.NDNProtocolDTags = NDNProtocolDTags;\n\nvar NDNProtocolDTagsStrings = [\n  null, null, null, null, null, null, null, null, null, null, null,\n  null, null,\n  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",\n  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",\n  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",\n  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",\n  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",\n  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",\n  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",\n  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",\n  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",\n  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",\n  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",\n  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",\n  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",\n  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",\n  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",\n  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",\n  "InfoString", null,\n    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",\n    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",\n    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];\n\nexports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;\n\n},{}],62:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Log class holds the global static variable LOG.\n */\nvar Log = function Log()\n{\n}\n\nexports.Log = Log;\n\n/**\n * LOG is the level for logging debugging statements.  0 means no log messages.\n * @type Number\n */\nLog.LOG = 0;\n\n})()\n},{}],56:[function(require,module,exports){\n(function(){var Buffer = require(\'buffer\').Buffer\nvar sha = require(\'./sha\')\nvar sha256 = require(\'./sha256\')\nvar rng = require(\'./rng\')\nvar md5 = require(\'./md5\')\n\nvar algorithms = {\n  sha1: sha,\n  sha256: sha256,\n  md5: md5\n}\n\nvar blocksize = 64\nvar zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)\nfunction hmac(fn, key, data) {\n  if(!Buffer.isBuffer(key)) key = new Buffer(key)\n  if(!Buffer.isBuffer(data)) data = new Buffer(data)\n\n  if(key.length > blocksize) {\n    key = fn(key)\n  } else if(key.length < blocksize) {\n    key = Buffer.concat([key, zeroBuffer], blocksize)\n  }\n\n  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)\n  for(var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  var hash = fn(Buffer.concat([ipad, data]))\n  return fn(Buffer.concat([opad, hash]))\n}\n\nfunction hash(alg, key) {\n  alg = alg || \'sha1\'\n  var fn = algorithms[alg]\n  var bufs = []\n  var length = 0\n  if(!fn) error(\'algorithm:\', alg, \'is not yet supported\')\n  return {\n    update: function (data) {\n      if(!Buffer.isBuffer(data)) data = new Buffer(data)\n        \n      bufs.push(data)\n      length += data.length\n      return this\n    },\n    digest: function (enc) {\n      var buf = Buffer.concat(bufs)\n      var r = key ? hmac(fn, key, buf) : fn(buf)\n      bufs = null\n      return enc ? r.toString(enc) : r\n    }\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(\' \')\n  throw new Error([\n    m,\n    \'we accept pull requests\',\n    \'http://github.com/dominictarr/crypto-browserify\'\n    ].join(\'\\n\'))\n}\n\nexports.createHash = function (alg) { return hash(alg) }\nexports.createHmac = function (alg, key) { return hash(alg, key) }\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, new Buffer(rng(size)))\n    } catch (err) { callback(err) }\n  } else {\n    return new Buffer(rng(size))\n  }\n}\n\nfunction each(a, f) {\n  for(var i in a)\n    f(a[i], i)\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\neach([\'createCredentials\'\n, \'createCipher\'\n, \'createCipheriv\'\n, \'createDecipher\'\n, \'createDecipheriv\'\n, \'createSign\'\n, \'createVerify\'\n, \'createDiffieHellman\'\n, \'pbkdf2\'], function (name) {\n  exports[name] = function () {\n    error(\'sorry,\', name, \'is not implemented yet\')\n  }\n})\n\n})()\n},{"./md5":82,"./rng":81,"./sha":79,"./sha256":80,"buffer":63}],70:[function(require,module,exports){\nvar b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\nvar b64pad="=";\nvar BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction hex2b64(h) {\n  var i;\n  var c;\n  var ret = "";\n  for(i = 0; i+3 <= h.length; i+=3) {\n    c = parseInt(h.substring(i,i+3),16);\n    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n  }\n  if(i+1 == h.length) {\n    c = parseInt(h.substring(i,i+1),16);\n    ret += b64map.charAt(c << 2);\n  }\n  else if(i+2 == h.length) {\n    c = parseInt(h.substring(i,i+2),16);\n    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n  }\n  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n  return ret;\n}\n\n// convert a base64 string to hex\nfunction b64tohex(s) {\n  var ret = ""\n  var i;\n  var k = 0; // b64 state, 0-3\n  var slop;\n  for(i = 0; i < s.length; ++i) {\n    if(s.charAt(i) == b64pad) break;\n    v = b64map.indexOf(s.charAt(i));\n    if(v < 0) continue;\n    if(k == 0) {\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 1;\n    }\n    else if(k == 1) {\n      ret += int2char((slop << 2) | (v >> 4));\n      slop = v & 0xf;\n      k = 2;\n    }\n    else if(k == 2) {\n      ret += int2char(slop);\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 3;\n    }\n    else {\n      ret += int2char((slop << 2) | (v >> 4));\n      ret += int2char(v & 0xf);\n      k = 0;\n    }\n  }\n  if(k == 1)\n    ret += int2char(slop << 2);\n  return ret;\n}\n\n// convert a base64 string to a byte/number array\nfunction b64toBA(s) {\n  //piggyback on b64tohex for now, optimize later\n  var h = b64tohex(s);\n  var i;\n  var a = new Array();\n  for(i = 0; 2*i < h.length; ++i) {\n    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n  }\n  return a;\n}\n\nmodule.exports = {b64tohex: b64tohex, b64toBA: b64toBA, hex2b64: hex2b64};\n\n},{}],77:[function(require,module,exports){\nvar events = require(\'events\');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === \'[object Date]\'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === \'[object RegExp]\'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { \'bold\' : [1, 22],\n          \'italic\' : [3, 23],\n          \'underline\' : [4, 24],\n          \'inverse\' : [7, 27],\n          \'white\' : [37, 39],\n          \'grey\' : [90, 39],\n          \'black\' : [30, 39],\n          \'blue\' : [34, 39],\n          \'cyan\' : [36, 39],\n          \'green\' : [32, 39],\n          \'magenta\' : [35, 39],\n          \'red\' : [31, 39],\n          \'yellow\' : [33, 39] };\n\n    var style =\n        { \'special\': \'cyan\',\n          \'number\': \'blue\',\n          \'boolean\': \'yellow\',\n          \'undefined\': \'grey\',\n          \'null\': \'bold\',\n          \'string\': \'green\',\n          \'date\': \'magenta\',\n          // "name": intentionally not styling\n          \'regexp\': \'red\' }[styleType];\n\n    if (style) {\n      return \'\\u001b[\' + styles[style][0] + \'m\' + str +\n             \'\\u001b[\' + styles[style][1] + \'m\';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === \'function\' &&\n        // Filter out the util module, it\'s inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case \'undefined\':\n        return stylize(\'undefined\', \'undefined\');\n\n      case \'string\':\n        var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                                 .replace(/\'/g, "\\\\\'")\n                                                 .replace(/\\\\"/g, \'"\') + \'\\\'\';\n        return stylize(simple, \'string\');\n\n      case \'number\':\n        return stylize(\'\' + value, \'number\');\n\n      case \'boolean\':\n        return stylize(\'\' + value, \'boolean\');\n    }\n    // For some reason typeof null is "object", so special case here.\n    if (value === null) {\n      return stylize(\'null\', \'null\');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === \'function\' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        var name = value.name ? \': \' + value.name : \'\';\n        return stylize(\'[Function\' + name + \']\', \'special\');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), \'date\');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = \'Array\';\n      braces = [\'[\', \']\'];\n    } else {\n      type = \'Object\';\n      braces = [\'{\', \'}\'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === \'function\') {\n      var n = value.name ? \': \' + value.name : \'\';\n      base = (isRegExp(value)) ? \' \' + value : \' [Function\' + n + \']\';\n    } else {\n      base = \'\';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = \' \' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        return stylize(\'[Object]\', \'special\');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Getter/Setter]\', \'special\');\n          } else {\n            str = stylize(\'[Getter]\', \'special\');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Setter]\', \'special\');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = \'[\' + key + \']\';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf(\'\\n\') > -1) {\n            if (isArray(value)) {\n              str = str.split(\'\\n\').map(function(line) {\n                return \'  \' + line;\n              }).join(\'\\n\').substr(2);\n            } else {\n              str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n                return \'   \' + line;\n              }).join(\'\\n\');\n            }\n          }\n        } else {\n          str = stylize(\'[Circular]\', \'special\');\n        }\n      }\n      if (typeof name === \'undefined\') {\n        if (type === \'Array\' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\'\' + key);\n        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, \'name\');\n        } else {\n          name = name.replace(/\'/g, "\\\\\'")\n                     .replace(/\\\\"/g, \'"\')\n                     .replace(/(^"|"$)/g, "\'");\n          name = stylize(name, \'string\');\n        }\n      }\n\n      return name + \': \' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === \'\' ? \'\' : base + \'\\n \') +\n               \' \' +\n               output.join(\',\\n  \') +\n               \' \' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === \'undefined\' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === \'object\' && Object.prototype.toString.call(ar) === \'[object Array]\');\n}\n\n\nfunction isRegExp(re) {\n  typeof re === \'object\' && Object.prototype.toString.call(re) === \'[object RegExp]\';\n}\n\n\nfunction isDate(d) {\n  return typeof d === \'object\' && Object.prototype.toString.call(d) === \'[object Date]\';\n}\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { \'__proto__\' : null };\n    }\n    else {\n        if (typeof prototype !== \'object\') {\n            throw new TypeError(\n                \'typeof prototype[\' + (typeof prototype) + \'] != \\\'object\\\'\'\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== \'undefined\' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== \'string\') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== \'object\') {\n      str += \' \' + x;\n    } else {\n      str += \' \' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{"events":83}],78:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * Create a new DecodingException wrapping the given error object.\n * Call with: throw new DecodingException(new Error("message")).\n * @constructor\n * @param {string} error The exception created with new Error.\n */\nfunction DecodingException(error) \n{\n  this.message = error.message;\n  // Copy lineNumber, etc. from where new Error was called.\n  for (var prop in error)\n      this[prop] = error[prop];\n}\nDecodingException.prototype = new Error();\nDecodingException.prototype.name = "DecodingException";\n\nexports.DecodingException = DecodingException;\n\n},{}],31:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang\n * See COPYING for copyright and distribution information.\n * This class represents the top-level object for communicating with an NDN host.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar crypto = require(\'./crypto.js\');\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Interest = require(\'./interest.js\').Interest;\nvar Data = require(\'./data.js\').Data;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\nvar TlvWireFormat = require(\'./encoding/tlv-wire-format.js\').TlvWireFormat;\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nvar Tlv = require(\'./encoding/tlv/tlv.js\').Tlv;\nvar TlvDecoder = require(\'./encoding/tlv/tlv-decoder.js\').TlvDecoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Key = require(\'./key.js\').Key;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar ForwardingFlags = require(\'./forwarding-flags.js\').ForwardingFlags;\nvar Closure = require(\'./closure.js\').Closure;\nvar UpcallInfo = require(\'./closure.js\').UpcallInfo;\nvar TcpTransport = require(\'./transport/tcp-transport.js\').TcpTransport;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Face with the given settings.\n * This throws an exception if Face.supported is false.\n * @constructor\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.\n *              OR function() { return new TcpTransport(); },       // If in Node.js.\n *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.\n *   host: null, // If null, use getHostAndPort when connecting.\n *   port: 9696, // If in the browser.\n *      OR 6363, // If in Node.js.\n *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },\n *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },\n *   verify: false // If false, don\'t verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.\n * }\n */\nvar Face = function Face(settings)\n{\n  if (!Face.supported)\n    throw new Error("The necessary JavaScript support is not available on this platform.");\n\n  settings = (settings || {});\n  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.\n  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });\n  this.transport = getTransport();\n  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);\n  this.host = (settings.host !== undefined ? settings.host : null);\n  this.port = (settings.port || (typeof WebSocketTransport != \'undefined\' ? 9696 : 6363));\n  this.readyStatus = Face.UNOPEN;\n  this.verify = (settings.verify !== undefined ? settings.verify : false);\n  // Event handler\n  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });\n  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });\n  this.ndndid = null;\n};\n\nexports.Face = Face;\n\nFace.UNOPEN = 0;  // created but not opened yet\nFace.OPENED = 1;  // connection to ndnd opened\nFace.CLOSED = 2;  // connection to ndnd closed\n\n/**\n * Return true if necessary JavaScript support is available, else log an error and return false.\n */\nFace.getSupported = function()\n{\n  try {\n    var dummy = new customBuf(1).slice(0, 1);\n  }\n  catch (ex) {\n    console.log("NDN not available: customBuf not supported. " + ex);\n    return false;\n  }\n\n  return true;\n};\n\nFace.supported = Face.getSupported();\n\nFace.ndndIdFetcher = new Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\');\n\nFace.prototype.createRoute = function(host, port)\n{\n  this.host=host;\n  this.port=port;\n};\n\nFace.KeyStore = new Array();\n\nvar KeyStoreEntry = function KeyStoreEntry(name, rsa, time)\n{\n  this.keyName = name;  // KeyName\n  this.rsaKey = rsa;    // RSA key\n  this.timeStamp = time;  // Time Stamp\n};\n\nFace.addKeyEntry = function(/* KeyStoreEntry */ keyEntry)\n{\n  var result = Face.getKeyByName(keyEntry.keyName);\n  if (result == null)\n    Face.KeyStore.push(keyEntry);\n  else\n    result = keyEntry;\n};\n\nFace.getKeyByName = function(/* KeyName */ name)\n{\n  var result = null;\n\n  for (var i = 0; i < Face.KeyStore.length; i++) {\n    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {\n      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)\n        result = Face.KeyStore[i];\n    }\n  }\n\n  return result;\n};\n\nFace.prototype.close = function()\n{\n  if (this.readyStatus != Face.OPENED)\n    throw new Error(\'Cannot close because Face connection is not opened.\');\n\n  this.readyStatus = Face.CLOSED;\n  this.transport.close();\n};\n\n// For fetching data\nFace.PITTable = new Array();\n\n/**\n * @constructor\n */\nvar PITEntry = function PITEntry(interest, closure)\n{\n  this.interest = interest;  // Interest\n  this.closure = closure;    // Closure\n  this.timerID = -1;  // Timer ID\n};\n\n/**\n * Return the entry from Face.PITTable where the name conforms to the interest selectors, and\n * the interest name is the longest that matches name.\n */\n\n/**\n * Find all entries from Face.PITTable where the name conforms to the entry\'s\n * interest selectors, remove the entries from the table, cancel their timeout\n * timers and return them.\n * @param {Name} name The name to find the interest for (from the incoming data\n * packet).\n * @returns {Array<PITEntry>} The matching entries from Face.PITTable, or [] if\n * none are found.\n */\nFace.extractEntriesForExpressedInterest = function(name)\n{\n  var result = [];\n\n  // Go backwards through the list so we can erase entries.\n  for (var i = Face.PITTable.length - 1; i >= 0; --i) {\n    var entry = Face.PITTable[i];\n    if (entry.interest.matchesName(name)) {\n      // Cancel the timeout timer.\n      clearTimeout(entry.timerID);\n\n      result.push(entry);\n      Face.PITTable.splice(i, 1);\n    }\n  }\n\n  return result;\n};\n\n// For publishing data\nFace.registeredPrefixTable = new Array();\n\n/**\n * @constructor\n */\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n/**\n * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.\n * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).\n * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.\n */\nfunction getEntryForRegisteredPrefix(name)\n{\n  var iResult = -1;\n\n  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {\n    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " , Face.registeredPrefixTable[i].prefix , " matches " , name);\n    if (Face.registeredPrefixTable[i].prefix.match(name)) {\n      if (iResult < 0 ||\n          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())\n        // Update to the longer match.\n        iResult = i;\n    }\n  }\n\n  if (iResult >= 0)\n    return Face.registeredPrefixTable[iResult];\n  else\n    return null;\n}\n\n/**\n * Return a function that selects a host at random from hostList and returns { host: host, port: port }.\n * If no more hosts remain, return null.\n */\nFace.makeShuffledGetHostAndPort = function(hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n/**\n * Send the interest through the transport, read the entire response and call onData.\n * If the interest times out according to interest lifetime, call onTimeout (if not omitted).\n * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):\n * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from\n * a name and optional interest template:\n * expressInterest(name [, template], onData [, onTimeout]).\n * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.\n * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.\n * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:\n *   interest is the interest given to expressInterest,\n *   data is the received Data object.\n * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime,\n *   this calls onTimeout(interest) where:\n *   interest is the interest given to expressInterest.\n * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).\n * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest.\n * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).\n */\nFace.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of expressInterest, each shown inline below.\n\n  // expressInterest(Name name, Closure closure);                      // deprecated\n  // expressInterest(Name name, Closure closure,   Interest template); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    if (arg3) {\n      var template = arg3;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n    }\n    else\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n\n    this.expressInterestWithClosure(interest, arg2);\n    return;\n  }\n\n  var interest;\n  var onData;\n  var onTimeout;\n  // expressInterest(Interest interest, function onData);\n  // expressInterest(Interest interest, function onData, function onTimeout);\n  if (typeof interestOrName == \'object\' && interestOrName instanceof Interest) {\n    // Just use a copy of the interest.\n    interest = new Interest(interestOrName);\n    onData = arg2;\n    onTimeout = (arg3 ? arg3 : function() {});\n  }\n  else {\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    // expressInterest(Name name, Interest template, function onData);\n    // expressInterest(Name name, Interest template, function onData, function onTimeout);\n    if (arg2 && typeof arg2 == \'object\' && arg2 instanceof Interest) {\n      var template = arg2;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n\n      onData = arg3;\n      onTimeout = (arg4 ? arg4 : function() {});\n    }\n    // expressInterest(Name name, function onData);\n    // expressInterest(Name name, function onData,   function onTimeout);\n    else {\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n      onData = arg2;\n      onTimeout = (arg3 ? arg3 : function() {});\n    }\n  }\n\n  // Make a Closure from the callbacks so we can use expressInterestWithClosure.\n  // TODO: Convert the PIT to use callbacks, not a closure.\n  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout), interest);\n}\n\nFace.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.onData = onData;\n  this.onTimeout = onTimeout;\n  this.onInterest = onInterest;\n  this.prefix = prefix;\n  this.transport = transport;\n};\n\nFace.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {\n  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)\n    this.onData(upcallInfo.interest, upcallInfo.data);\n  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)\n    this.onTimeout(upcallInfo.interest);\n  else if (kind == Closure.UPCALL_INTEREST)\n    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.\n    this.onInterest(this.prefix, upcallInfo.interest, this.transport)\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * A private method to send the the interest to host:port, read the entire response and call\n * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),\n *                 new UpcallInfo(this, interest, 0, data)).\n * @deprecated Use expressInterest with callback functions, not Closure.\n * @param {Interest} the interest, already processed with a template (if supplied).\n * @param {Closure} closure\n */\nFace.prototype.expressInterestWithClosure = function(interest, closure)\n{\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else {\n      var thisNDN = this;\n      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });\n    }\n  }\n  else\n    this.reconnectAndExpressInterest(interest, closure);\n};\n\n/**\n * If the host and port are different than the ones in this.transport, then call\n *   this.transport.connect to change the connection (or connect for the first time).\n * Then call expressInterestHelper.\n */\nFace.prototype.reconnectAndExpressInterest = function(interest, closure)\n{\n  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {\n    var thisNDN = this;\n    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });\n    this.readyStatus = Face.OPENED;\n  }\n  else\n    this.expressInterestHelper(interest, closure);\n};\n\n/**\n * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call\n *   this.transport.send to send the interest.\n */\nFace.prototype.expressInterestHelper = function(interest, closure)\n{\n  var binaryInterest = interest.wireEncode();\n  var thisNDN = this;\n  //TODO: check local content store first\n  if (closure != null) {\n    var pitEntry = new PITEntry(interest, closure);\n    // TODO: This needs to be a single thread-safe transaction on a global object.\n    Face.PITTable.push(pitEntry);\n    closure.pitEntry = pitEntry;\n\n    // Set interest timer.\n    var timeoutMilliseconds = (interest.interestLifetime || 4000);\n    var timeoutCallback = function() {\n      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());\n\n      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express\n      //   the interest because we don\'t want to match it in the mean time.\n      // TODO: Make this a thread-safe operation on the global PITTable.\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0)\n        Face.PITTable.splice(index, 1);\n\n      // Raise closure callback\n      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {\n        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());\n        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n        Face.PITTable.push(pitEntry);\n        thisNDN.transport.send(binaryInterest.buf());\n      }\n    };\n\n    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n  }\n\n  this.transport.send(binaryInterest.buf());\n};\n\n/**\n * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.\n * This uses the form:\n * registerPrefix(name, onInterest, onRegisterFailed [, flags]).\n * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.\n * @param {Name} prefix The Name prefix.\n * @param {function} onInterest When an interest is received which matches the name prefix, this calls\n * onInterest(prefix, interest, transport) where:\n *   prefix is the prefix given to registerPrefix.\n *   interest is the received interest.\n *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().\n * @param {function} onRegisterFailed If failed to retrieve the connected hub\'s ID or failed to register the prefix,\n * this calls onRegisterFailed(prefix) where:\n *   prefix is the prefix given to registerPrefix.\n * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.\n * If omitted, use the default flags defined by the default ForwardingFlags constructor.\n */\nFace.prototype.registerPrefix = function(prefix, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of registerPrefix, each shown inline below.\n\n  // registerPrefix(Name prefix, Closure closure);            // deprecated\n  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.registerPrefixWithClosure(prefix, arg2, arg3);\n    else\n      this.registerPrefixWithClosure(prefix, arg2);\n    return;\n  }\n\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);\n  var onInterest = arg2;\n  var onRegisterFailed = (arg3 ? arg3 : function() {});\n  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());\n  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport),\n                                 intFlags, onRegisterFailed);\n}\n\n/**\n * A private method to register the prefix with the host, receive the data and call\n * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)).\n * @deprecated Use registerPrefix with callback functions, not Closure.\n * @param {Name} prefix\n * @param {Closure} closure\n * @param {number} intFlags\n * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix)\n * if registration fails.\n */\nFace.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed)\n{\n  intFlags = intFlags | 3;\n  var thisNDN = this;\n  var onConnected = function() {\n    if (thisNDN.ndndid == null) {\n      // Fetch ndndid first, then register.\n      var interest = new Interest(Face.ndndIdFetcher);\n      interest.interestLifetime = 4000; // milliseconds\n      if (LOG > 3) console.log(\'Expressing interest for ndndid from ndnd.\');\n      thisNDN.reconnectAndExpressInterest\n        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));\n    }\n    else\n      thisNDN.registerPrefixHelper(prefix, closure, flags, onRegisterFailed);\n  };\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else\n      this.connectAndExecute(onConnected);\n  }\n  else\n    onConnected();\n};\n\n/**\n * This is a closure to receive the Data for Face.ndndIdFetcher and call\n *   registerPrefixHelper(prefix, callerClosure, flags).\n */\nFace.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.prefix = prefix;\n  this.callerClosure = callerClosure;\n  this.flags = flags;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n\n  if (LOG > 3) console.log(\'Got ndndid from ndnd.\');\n  // Get the digest of the public key in the data packet content.\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(upcallInfo.data.getContent());\n  this.face.ndndid = new customBuf(DataUtils.toNumbersIfString(hash.digest()));\n  if (LOG > 3) console.log(this.face.ndndid);\n\n  this.face.registerPrefixHelper\n    (this.prefix, this.callerClosure, this.flags, this.onRegisterFailed);\n\n  return Closure.RESULT_OK;\n};\n/**\n * This is a closure to receive the response Data packet from the register\n * prefix interest sent to the connected NDN hub. If this gets a bad response\n * or a timeout, call onRegisterFailed.\n */\nFace.RegisterResponseClosure = function RegisterResponseClosure\n  (prefix, onRegisterFailed)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.prefix = prefix;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.RegisterResponseClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n\n  var expectedName = new Name("/ndnx/.../selfreg");\n  // Got a response. Do a quick check of expected name components.\n  if (upcallInfo.data.getName().size() < 4 ||\n      !upcallInfo.data.getName().get(0).equals(expectedName.get(0)) ||\n      !upcallInfo.data.getName().get(2).equals(expectedName.get(2))) {\n    this.onRegisterFailed(this.prefix);\n    return;\n  }\n\n  // Otherwise, silently succeed.\n  return Closure.RESULT_OK;\n};\n\n/**\n * Do the work of registerPrefix once we know we are connected with a ndndid.\n */\nFace.prototype.registerPrefixHelper = function\n  (prefix, closure, flags, onRegisterFailed)\n{\n  var fe = new ForwardingEntry(\'selfreg\', prefix, null, null, flags, null);\n\n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  var encoder = new BinaryXMLEncoder();\n  fe.to_ndnb(encoder);\n  var bytes = encoder.getReducedOstream();\n\n  var si = new MetaInfo();\n  si.setFields();\n\n  // Set the name to a random value so that each request is unique.\n  var data = new Data(new Name().append(require("crypto").randomBytes(4)), si, bytes);\n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  data.sign(BinaryXmlWireFormat.get());\n  var coBinary = data.wireEncode(BinaryXmlWireFormat.get());;\n\n  var nodename = this.ndndid;\n  var interestName = new Name([\'ndnx\', nodename, \'selfreg\', coBinary]);\n\n  var interest = new Interest(interestName);\n  interest.setInterestLifetimeMilliseconds(4000.0);\n  interest.setScope(1);\n  if (LOG > 3) console.log(\'Send Interest registration packet.\');\n\n  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n  this.reconnectAndExpressInterest\n    (interest, new Face.RegisterResponseClosure(prefix, onRegisterFailed));\n};\n\n/**\n * This is called when an entire binary XML element is received, such as a Data or Interest.\n * Look up in the PITTable and call the closure callback.\n */\nFace.prototype.onReceivedElement = function(element)\n{\n  if (LOG > 3) console.log(\'Complete element received. Length \' + element.length + \'. Start decoding.\');\n  // First, decode as Interest or Data.\n  var interest = null;\n  var data = null;\n  // The type codes for TLV Interest and Data packets are chosen to not\n  //   conflict with the first byte of a binary XML packet, so we can\n  //   just look at the first byte.\n  if (element[0] == Tlv.Interest || element[0] == Tlv.Data) {\n    if (LOG > 3) console.log(\'Detected Tlv element\', element, TlvWireFormat.get())\n    var decoder = new TlvDecoder(element);\n    if (decoder.peekType(Tlv.Interest, element.length)) {\n      interest = new Interest();\n      interest.wireDecode(element, TlvWireFormat.get());\n    }\n    else if (decoder.peekType(Tlv.Data, element.length)) {\n      data = new Data();\n      data.wireDecode(element, TlvWireFormat.get());\n    }\n  }\n  else {\n    if (LOG > 3) console.log(\'assumed BinaryXML\')\n    // Binary XML.\n    var decoder = new BinaryXMLDecoder(element);\n    if (decoder.peekDTag(NDNProtocolDTags.Interest)) {\n      interest = new Interest();\n      interest.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Data)) {\n      data = new Data();\n      data.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n  }\n\n  // Now process as Interest or Data.\n  if (interest !== null) {\n    if (LOG > 3) console.log(\'Interest packet received.\');\n    var entry = getEntryForRegisteredPrefix(interest.name);\n    if (entry != null) {\n      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());\n      var info = new UpcallInfo(this, interest, 0, null);\n      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);\n      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null)\n        this.transport.send(info.data.wireEncode().buf());\n    }\n  }\n  else if (data !== null) {\n    if (LOG > 3) console.log(\'Data packet received.\');\n\n    var pendingInterests = Face.extractEntriesForExpressedInterest(data.name);\n    // Process each matching PIT entry (if any).\n    for (var i = 0; i < pendingInterests.length; ++i) {\n      var pitEntry = pendingInterests[i];\n      var currentClosure = pitEntry.closure;\n\n      if (this.verify == false) {\n        // Pass content up without verifying the signature\n        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));\n        continue;\n      }\n\n      // Key verification\n\n      // Recursive key fetching & verification closure\n      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {\n        this.data = content;  // unverified data packet object\n        this.closure = closure;  // closure corresponding to the data\n        this.keyName = key;  // name of current key to be fetched\n\n        Closure.call(this);\n      };\n\n      var thisNDN = this;\n      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {\n        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n          console.log("In KeyFetchClosure.upcall: interest time out.");\n          console.log(this.keyName.contentName.toUri());\n        }\n        else if (kind == Closure.UPCALL_CONTENT) {\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(upcallInfo.data.content);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));\n\n          // Store key in cache\n          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());\n          Face.addKeyEntry(keyEntry);\n        }\n        else if (kind == Closure.UPCALL_CONTENT_BAD)\n          console.log("In KeyFetchClosure.upcall: signature verification failed");\n      };\n\n      if (data.signedInfo && data.signedInfo.locator && data.signature) {\n        if (LOG > 3) console.log("Key verification...");\n        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();\n\n        var wit = null;\n        if (data.signature.witness != null)\n            //SWT: deprecate support for Witness decoding and Merkle hash tree verification\n            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n        var keylocator = data.signedInfo.locator;\n        if (keylocator.type == KeyLocatorType.KEYNAME) {\n          if (LOG > 3) console.log("KeyLocator contains KEYNAME");\n\n          if (keylocator.keyName.contentName.match(data.name)) {\n            if (LOG > 3) console.log("Content is key itself");\n\n            var rsakey = new Key();\n            rsakey.readDerPublicKey(data.content);\n            var verified = data.verify(rsakey);\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n            // SWT: We don\'t need to store key here since the same key will be stored again in the closure.\n          }\n          else {\n            // Check local key store\n            var keyEntry = Face.getKeyByName(keylocator.keyName);\n            if (keyEntry) {\n              // Key found, verify now\n              if (LOG > 3) console.log("Local key cache hit");\n              var rsakey = keyEntry.rsaKey;\n              var verified = data.verify(rsakey);\n              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n              // Raise callback\n              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n            }\n            else {\n              // Not found, fetch now\n              if (LOG > 3) console.log("Fetch key according to keylocator");\n              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);\n              // TODO: Use expressInterest with callbacks, not Closure.\n              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);\n            }\n          }\n        }\n        else if (keylocator.type == KeyLocatorType.KEY) {\n          if (LOG > 3) console.log("Keylocator contains KEY");\n\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(keylocator.publicKey);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          // Raise callback\n          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n          // Since KeyLocator does not contain key name for this key,\n          // we have no way to store it as a key entry in KeyStore.\n        }\n        else {\n          var cert = keylocator.certificate;\n          console.log("KeyLocator contains CERT");\n          console.log(cert);\n          // TODO: verify certificate\n        }\n      }\n    }\n  }\n};\n\n/**\n * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host\n *   is not alive.  Get a host and port, connect, then execute onConnected().\n */\nFace.prototype.connectAndExecute = function(onConnected)\n{\n  var hostAndPort = this.getHostAndPort();\n  if (hostAndPort == null) {\n    console.log(\'ERROR: No more hosts from getHostAndPort\');\n    this.host = null;\n    return;\n  }\n\n  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {\n    console.log(\'ERROR: The host returned by getHostAndPort is not alive: \' + this.host + ":" + this.port);\n    return;\n  }\n\n  this.host = hostAndPort.host;\n  this.port = hostAndPort.port;\n  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);\n\n  // Fetch any content.\n  var interest = new Interest(new Name("/"));\n  interest.interestLifetime = 4000; // milliseconds\n\n  var thisNDN = this;\n  var timerID = setTimeout(function() {\n    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);\n      // Try again.\n      thisNDN.connectAndExecute(onConnected);\n  }, 3000);\n\n  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));\n};\n\n/**\n * This is called by the Transport when the connection is closed by the remote host.\n */\nFace.prototype.closeByTransport = function()\n{\n  this.readyStatus = Face.CLOSED;\n  this.onclose();\n};\n\nFace.ConnectClosure = function ConnectClosure(face, onConnected, timerID)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.onConnected = onConnected;\n  this.timerID = timerID;\n};\n\nFace.ConnectClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.\n    return Closure.RESULT_ERR;\n\n  // The host is alive, so cancel the timeout and continue with onConnected().\n  clearTimeout(this.timerID);\n\n    // Call Face.onopen after success\n  this.face.readyStatus = Face.OPENED;\n  this.face.onopen();\n\n  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);\n  this.onConnected();\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * @deprecated Use new Face.\n */\nvar NDN = function NDN(settings)\n{\n  // Call the base constructor.\n  Face.call(this, settings);\n}\n\n// Use dummy functions so that the Face constructor will not try to set its own defaults.\nNDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });\n\nexports.NDN = NDN;\n\nNDN.supported = Face.supported;\nNDN.UNOPEN = Face.UNOPEN;\nNDN.OPENED = Face.OPENED;\nNDN.CLOSED = Face.CLOSED;\n\n})()\n},{"./buffer.js":54,"./closure.js":32,"./crypto.js":54,"./data.js":37,"./encoding/binary-xml-decoder.js":85,"./encoding/binary-xml-encoder.js":86,"./encoding/binary-xml-wire-format.js":43,"./encoding/data-utils.js":47,"./encoding/tlv-wire-format.js":44,"./encoding/tlv/tlv-decoder.js":45,"./encoding/tlv/tlv.js":46,"./forwarding-entry.js":84,"./forwarding-flags.js":34,"./interest.js":35,"./key-locator.js":40,"./key.js":39,"./log.js":89,"./meta-info.js":38,"./name.js":33,"./transport/tcp-transport.js":88,"./util/ndn-protoco-id-tags.js":87,"crypto":56}],33:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents a Name as an array of components where each is a byte array.\n */\n \nvar Blob = require(\'./util/blob.js\').Blob;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Name from components.\n * \n * @constructor\n * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.  \n * Otherwise it is an array of components which are appended according to Name.append, so\n * convert each and store it as an array of customBuf.  If a component is a string, encode as utf8.\n */\nvar Name = function Name(components) \n{\n  if (typeof components == \'string\') {    \n    if (LOG > 3) console.log(\'Content Name String \' + components);\n    this.components = Name.createNameArray(components);\n  }\n  else if (typeof components === \'object\') {    \n    this.components = [];\n    if (components instanceof Name)\n      this.append(components);\n    else {\n      for (var i = 0; i < components.length; ++i)\n        this.append(components[i]);\n    }\n  }\n  else if (components == null)\n    this.components = [];\n  else\n    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");\n};\n\nexports.Name = Name;\n\n/**\n * \n * @constructor\n * Create a new Name.Component with a copy of the given value.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don\'t unescape).\n */\nName.Component = function NameComponent(value) \n{\n  if (typeof value === \'string\')\n    this.value = DataUtils.stringToUtf8Array(value);\n  else if (typeof value === \'object\' && value instanceof Name.Component)\n    this.value = new customBuf(value.value);\n  else if (typeof value === \'object\' && value instanceof Blob)\n    this.value = new customBuf(value.buf());\n  else if (typeof value === \'object\' && value instanceof customBuf)\n    this.value = new customBuf(value);\n  else if (typeof value === \'object\' && typeof ArrayBuffer !== \'undefined\' &&  value instanceof ArrayBuffer) {\n    // Make a copy.  Don\'t use ArrayBuffer.slice since it isn\'t always supported.                                                      \n    this.value = new customBuf(new ArrayBuffer(value.byteLength));\n    this.value.set(new customBuf(value));\n  }\n  else if (typeof value === \'object\')\n    // Assume value is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    this.value = new customBuf(value);\n  else if (!value)\n    this.value = new customBuf(0);\n  else \n    throw new Error("Name.Component constructor: Invalid type");\n}\n\n/**\n * Get the component value.\n * @returns {Buffer} The component value.\n */\nName.Component.prototype.getValue = function() \n{\n  return this.value;\n}\n\n/**\n * Convert this component value to a string by escaping characters according to the NDN URI Scheme.\n * This also adds "..." to a value with zero or more ".".\n * @returns {string} The escaped string.\n */\nName.Component.prototype.toEscapedString = function() \n{\n  return Name.toEscapedString(this.value);\n}\n\n/**\n * Check if this is the same component as other.\n * @param {Name.Component} other The other Component to compare with.\n * @returns {Boolean} true if the components are equal, otherwise false.\n */\nName.Component.prototype.equals = function(other) \n{\n  return DataUtils.arraysEqual(this.value, other.value);\n}\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.getName = function() \n{\n  return this.toUri();\n};\n\n/** Parse uri as a URI and return an array of customBuf components.\n */\nName.createNameArray = function(uri) \n{\n  uri = uri.trim();\n  if (uri.length <= 0)\n    return [];\n\n  var iColon = uri.indexOf(\':\');\n  if (iColon >= 0) {\n    // Make sure the colon came before a \'/\'.\n    var iFirstSlash = uri.indexOf(\'/\');\n    if (iFirstSlash < 0 || iColon < iFirstSlash)\n      // Omit the leading protocol such as ndn:\n      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();\n  }\n    \n  if (uri[0] == \'/\') {\n    if (uri.length >= 2 && uri[1] == \'/\') {\n      // Strip the authority following "//".\n      var iAfterAuthority = uri.indexOf(\'/\', 2);\n      if (iAfterAuthority < 0)\n        // Unusual case: there was only an authority.\n        return [];\n      else\n        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();\n    }\n    else\n      uri = uri.substr(1, uri.length - 1).trim();\n  }\n\n  var array = uri.split(\'/\');\n    \n  // Unescape the components.\n  for (var i = 0; i < array.length; ++i) {\n    var value = Name.fromEscapedString(array[i]);\n        \n    if (value == null) {\n      // Ignore the illegal componenent.  This also gets rid of a trailing \'/\'.\n      array.splice(i, 1);\n      --i;  \n      continue;\n    }\n    else\n      array[i] = new Name.Component(value);\n  }\n\n  return array;\n};\n\nName.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)  \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  this.components = [];\n\n  while (decoder.peekDTag(NDNProtocolDTags.Component))\n    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    \n  decoder.readElementClose();\n};\n\nName.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{    \n  if (this.components == null) \n    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  var count = this.size();\n  for (var i=0; i < count; i++)\n    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());\n  \n  encoder.writeElementClose();\n};\n\nName.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.Name;\n};\n\n/**\n * Convert the component to a customBuf and append to this Name.\n * Return this Name object to allow chaining calls to add.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don\'t unescape).\n * @returns {Name}\n */\nName.prototype.append = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name) {\n    var components;\n    if (component == this)\n      // special case, when we need to create a copy\n      components = this.components.slice(0, this.components.length);\n    else\n      components = component.components;\n      \n    for (var i = 0; i < components.length; ++i)\n      this.components.push(new Name.Component(components[i]));\n  }\n  else\n    // Just use the Name.Component constructor.\n    this.components.push(new Name.Component(component));\n\n  return this;\n};\n\n/**\n * @deprecated Use append.\n */\nName.prototype.add = function(component)\n{\n  return this.append(component);\n};\n\n/**\n * Clear all the components.\n */\nName.prototype.clear = function()\n{\n  this.components = [];  \n};\n\n/**\n * Return the escaped name string according to "NDNx URI Scheme".\n * @returns {String}\n */\nName.prototype.toUri = function() \n{  \n  if (this.size() == 0)\n    return "/";\n    \n  var result = "";\n  \n  for (var i = 0; i < this.size(); ++i)\n    result += "/"+ Name.toEscapedString(this.components[i].getValue());\n  \n  return result;  \n};\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.to_uri = function() \n{\n  return this.toUri();\n};\n\n/**\n * Append a component with the encoded segment number.\n * @param {number} segment The segment number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendSegment = function(segment) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(segment);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * Append a component with the encoded version number.\n * Note that this encodes the exact value of version without converting from a \n * time representation.\n * @param {number} version The version number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendVersion = function(version) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(version);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0xfD;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * @deprecated Use appendSegment.\n */\nName.prototype.addSegment = function(number) \n{\n  return this.appendSegment(number);\n};\n\n/**\n * Get a new name, constructed as a subset of components.\n * @param {number} iStartComponent The index if the first component to get.\n * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,\n * return components starting at iStartComponent until the end of the name.\n * @returns {Name} A new name.\n */\nName.prototype.getSubName = function(iStartComponent, nComponents)\n{\n  if (nComponents == undefined)\n    nComponents = this.components.length - iStartComponent;\n  \n  var result = new Name();\n\n  var iEnd = iStartComponent + nComponents;\n  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)\n    result.components.push(this.components[i]);\n\n  return result;  \n};\n\n/**\n * Return a new Name with the first nComponents components of this Name.\n * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up\n * to name.size() - N. For example getPrefix(-1) returns the name without the final component.\n * @returns {Name} A new name.\n */\nName.prototype.getPrefix = function(nComponents) \n{\n  if (nComponents < 0)\n    return this.getSubName(0, this.components.length + nComponents);\n  else\n    return this.getSubName(0, nComponents);\n};\n\n/**\n * @brief Get prefix of the name, containing less minusComponents right components\n * @param minusComponents number of components to cut from the back\n */\nName.prototype.cut = function(minusComponents) \n{\n  return new Name(this.components.slice(0, this.components.length - minusComponents));\n};\n\n/**\n * Return the number of name components.\n * @returns {number}\n */\nName.prototype.size = function() \n{\n  return this.components.length;\n};\n\n/**\n * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().\n * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component\n * at size() - (-i).\n * @returns {Name.Component}\n */\nName.prototype.get = function(i) \n{\n  if (i >= 0) {\n    if (i >= this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[i]);\n  }\n  else {\n    // Negative index.\n    if (i < -this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[this.components.length - (-i)]);\n  }\n};\n\n/**\n * @deprecated Use size().\n */\nName.prototype.getComponentCount = function() \n{\n  return this.components.length;\n};\n\n/**\n * @deprecated To get just the component value, use get(i).getValue().\n */\nName.prototype.getComponent = function(i) \n{\n  return new customBuf(this.components[i].getValue());\n};\n\n/**\n * The "file name" in a name is the last component that isn\'t blank and doesn\'t start with one of the\n *   special marker octets (for version, etc.).  Return the index in this.components of\n *   the file name, or -1 if not found.\n */\nName.prototype.indexOfFileName = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var component = this.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n        \n    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 || \n        (component[0] >= 0xF5 && component[0] <= 0xFF))\n      continue;\n        \n    return i;\n  }\n    \n  return -1;\n};\n\n/**\n * Return true if this Name has the same components as name.\n */\nName.prototype.equals = function(name) \n{\n  if (this.components.length != name.components.length)\n    return false;\n    \n  // Start from the last component because they are more likely to differ.\n  for (var i = this.components.length - 1; i >= 0; --i) {\n    if (!this.components[i].equals(name.components[i]))\n      return false;\n  }\n    \n  return true;\n};\n\n/**\n * @deprecated Use equals.\n */\nName.prototype.equalsName = function(name)\n{\n  return this.equals(name);\n};\n\n/**\n * Find the last component in name that has a ContentDigest and return the digest value as customBuf, \n *   or null if not found.  See Name.getComponentContentDigestValue.\n */\nName.prototype.getContentDigestValue = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var digestValue = Name.getComponentContentDigestValue(this.components[i]);\n    if (digestValue != null)\n      return digestValue;\n  }\n    \n  return null;\n};\n\n/**\n * If component is a ContentDigest, return the digest value as a customBuf slice (don\'t modify!).\n * If not a ContentDigest, return null.\n * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.\n */\nName.getComponentContentDigestValue = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length; \n  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.\n  if (component.length == digestComponentLength &&\n      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length), \n                            Name.ContentDigestPrefix) &&\n      DataUtils.arraysEqual(component.slice\n         (component.length - Name.ContentDigestSuffix.length, component.length),\n                            Name.ContentDigestSuffix))\n   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);\n else\n   return null;\n};\n\n// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB. \nName.ContentDigestPrefix = new customBuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);\nName.ContentDigestSuffix = new customBuf([0x00]);\n\n\n/**\n * Return value as an escaped string according to "NDNx URI Scheme".\n * We can\'t use encodeURIComponent because that doesn\'t encode all the characters we want to.\n * @param {Buffer|Name.Component} component The value or Name.Component to escape.\n * @returns {string} The escaped string.\n */\nName.toEscapedString = function(value) \n{\n  if (typeof value == \'object\' && value instanceof Name.Component)\n    value = value.getValue();\n  \n  var result = "";\n  var gotNonDot = false;\n  for (var i = 0; i < value.length; ++i) {\n    if (value[i] != 0x2e) {\n      gotNonDot = true;\n      break;\n    }\n  }\n  if (!gotNonDot) {\n    // Special case for component of zero or more periods.  Add 3 periods.\n    result = "...";\n    for (var i = 0; i < value.length; ++i)\n      result += ".";\n  }\n  else {\n    for (var i = 0; i < value.length; ++i) {\n      var x = value[i];\n      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)\n      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||\n          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d || \n          x == 0x2e || x == 0x5f)\n        result += String.fromCharCode(x);\n      else\n        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();\n    }\n  }\n  return result;\n};\n\n/**\n * Return a customBuf byte array by decoding the escapedString according to "NDNx URI Scheme".\n * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.\n * @param {string} escapedString The escaped string to decode.\n * @returns {Buffer} The byte array, or null which means to skip the component in the name.\n */\nName.fromEscapedString = function(escapedString) \n{\n  var value = unescape(escapedString.trim());\n        \n  if (value.match(/[^.]/) == null) {\n    // Special case for value of only periods.  \n    if (value.length <= 2)\n      // Zero, one or two periods is illegal.  Ignore this componenent to be\n      //   consistent with the C implementation.\n      return null;\n    else\n      // Remove 3 periods.\n      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));\n  }\n  else\n    return DataUtils.toNumbersFromString(value);\n};\n\n/**\n * Return true if the N components of this name are the same as the first N components of the given name.\n * @param {Name} name The name to check.\n * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.\n */\nName.prototype.match = function(name) \n{\n  var i_name = this.components;\n  var o_name = name.components;\n\n  // This name is longer than the name we are checking it against.\n  if (i_name.length > o_name.length)\n    return false;\n\n  // Check if at least one of given components doesn\'t match.\n  for (var i = 0; i < i_name.length; ++i) {\n    if (!i_name[i].equals(o_name[i]))\n      return false;\n  }\n\n  return true;\n};\n\n})()\n},{"./buffer.js":54,"./encoding/binary-xml-decoder.js":85,"./encoding/binary-xml-encoder.js":86,"./encoding/data-utils.js":47,"./log.js":89,"./util/blob.js":49,"./util/ndn-protoco-id-tags.js":87}],34:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\n\n/**\n * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for\n * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding\n * bits are changed, amended or deprecated.\n * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.\n */\nvar ForwardingFlags = function ForwardingFlags() \n{\n  this.active = true;\n  this.childInherit = true;\n  this.advertise = false;\n  this.last = false;\n  this.capture = false;\n  this.local = false;\n  this.tap = false;\n  this.captureOk = false;\n}\n\nexports.ForwardingFlags = ForwardingFlags;\n\n/**\n * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.\n * @returns {number} An integer with the bits set.\n */\nForwardingFlags.prototype.getForwardingEntryFlags = function()\n{\n  var result = 0;\n  \n  if (this.active)\n    result |= ForwardingEntry.ACTIVE;\n  if (this.childInherit)\n    result |= ForwardingEntry.CHILD_INHERIT;\n  if (this.advertise)\n    result |= ForwardingEntry.ADVERTISE;\n  if (this.last)\n    result |= ForwardingEntry.LAST;\n  if (this.capture)\n    result |= ForwardingEntry.CAPTURE;\n  if (this.local)\n    result |= ForwardingEntry.LOCAL;\n  if (this.tap)\n    result |= ForwardingEntry.TAP;\n  if (this.captureOk)\n    result |= ForwardingEntry.CAPTURE_OK;\n  \n  return result;\n};\n\n/**\n * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.\n * @param {number} forwardingEntryFlags An integer with the bits set.\n */\nForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)\n{\n  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);\n  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);\n  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);\n  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);\n  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);\n  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);\n  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);\n  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);\n};\n\n/**\n * Get the value of the "active" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getActive = function() { return this.active; };\n\n/**\n * Get the value of the "childInherit" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };\n\n/**\n * Get the value of the "advertise" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };\n\n/**\n * Get the value of the "last" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLast = function() { return this.last; };\n\n/**\n * Get the value of the "capture" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCapture = function() { return this.capture; };\n\n/**\n * Get the value of the "local" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLocal = function() { return this.local; };\n\n/**\n * Get the value of the "tap" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getTap = function() { return this.tap; };\n\n/**\n * Get the value of the "captureOk" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };\n\n/**\n * Set the value of the "active" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setActive = function(value) { this.active = value; };\n\n/**\n * Set the value of the "childInherit" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };\n\n/**\n * Set the value of the "advertise" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };\n\n/**\n * Set the value of the "last" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLast = function(value) { this.last = value; };\n\n/**\n * Set the value of the "capture" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };\n\n/**\n * Set the value of the "local" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLocal = function(value) { this.local = value; };\n\n/**\n * Set the value of the "tap" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setTap = function(value) { this.tap = value; };\n\n/**\n * Set the value of the "captureOk" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };\n\n},{"./forwarding-entry.js":84}],35:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar Name = require(\'./name.js\').Name;\nvar Exclude = require(\'./exclude.js\').Exclude;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').LOG\n/**\n * Create a new Interest with the optional values.\n * \n * @constructor\n * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the\n * other arguments.  Otherwise this is the optional name for the new Interest.\n * @param {number} minSuffixComponents\n * @param {number} maxSuffixComponents\n * @param {Buffer} publisherPublicKeyDigest\n * @param {Exclude} exclude\n * @param {number} childSelector\n * @param {number} answerOriginKind\n * @param {number} scope\n * @param {number} interestLifetimeMilliseconds in milliseconds\n * @param {Buffer} nonce\n */\nvar Interest = function Interest\n   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude, \n    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce) \n{\n  if (typeof nameOrInterest === \'object\' && nameOrInterest instanceof Interest) {\n    // Special case: this is a copy constructor.  Ignore all but the first argument.\n    var interest = nameOrInterest;\n    if (interest.name)\n      // Copy the name.\n      this.name = new Name(interest.name);\n    this.maxSuffixComponents = interest.maxSuffixComponents;\n    this.minSuffixComponents = interest.minSuffixComponents;\n\n    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator(interest.keyLocator);\n    this.exclude = new Exclude(interest.exclude);\n    this.childSelector = interest.childSelector;\n    this.answerOriginKind = interest.answerOriginKind;\n    this.scope = interest.scope;\n    this.interestLifetime = interest.interestLifetime;\n    if (interest.nonce)\n      // Copy.\n      this.nonce = new customBuf(interest.nonce);    \n  }  \n  else {\n    this.name = typeof nameOrInterest === \'object\' && nameOrInterest instanceof Name ?\n                new Name(nameOrInterest) : new Name();\n    this.maxSuffixComponents = maxSuffixComponents;\n    this.minSuffixComponents = minSuffixComponents;\n\n    this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator();\n    this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                   new Exclude(exclude) : new Exclude();\n    this.childSelector = childSelector;\n    this.answerOriginKind = answerOriginKind;\n    this.scope = scope;\n    this.interestLifetime = interestLifetimeMilliseconds;\n    if (nonce)\n      // Copy and make sure it is a customBuf.\n      this.nonce = new customBuf(nonce);\n  }\n};\n\nexports.Interest = Interest;\n\nInterest.RECURSIVE_POSTFIX = "*";\n\nInterest.CHILD_SELECTOR_LEFT = 0;\nInterest.CHILD_SELECTOR_RIGHT = 1;\n\nInterest.ANSWER_NO_CONTENT_STORE = 0;\nInterest.ANSWER_CONTENT_STORE = 1;\nInterest.ANSWER_GENERATED = 2;\nInterest.ANSWER_STALE = 4;    // Stale answer OK\nInterest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"\n\nInterest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;\n\n/**\n * Return true if this.name.match(name) and the name conforms to the interest selectors.\n * @param {Name} name\n * @returns {boolean}\n */\nInterest.prototype.matchesName = function(/*Name*/ name) \n{\n  if (!this.name.match(name))\n    return false;\n    \n  if (this.minSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))\n    return false;\n  if (this.maxSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))\n    return false;\n  if (this.exclude != null && name.size() > this.name.size() &&\n      this.exclude.matches(name.components[this.name.size()]))\n    return false;\n    \n  return true;\n};\n\n/**\n * @deprecated Use matchesName.\n */\nInterest.prototype.matches_name = function(/*Name*/ name) \n{\n  return this.matchesName(name);\n};\n\n/**\n * Return a new Interest with the same fields as this Interest.  \n */\nInterest.prototype.clone = function() \n{\n  return new Interest\n     (this.name, this.minSuffixComponents, this.maxSuffixComponents, \n      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind, \n      this.scope, this.interestLifetime, this.nonce);\n};\n\n/**\n * Get the interest Name.\n * @returns {Name} The name.  The name size() may be 0 if not specified.\n */\nInterest.prototype.getName = function() { return this.name; };\n\n/**\n * Get the min suffix components.\n * @returns number} The min suffix components, or null if not specified.\n */\nInterest.prototype.getMinSuffixComponents = function() \n{ \n  return this.minSuffixComponents; \n};\n\n/**\n * Get the max suffix components.\n * @returns {number} The max suffix components, or null if not specified.\n */\nInterest.prototype.getMaxSuffixComponents = function() \n{ \n  return this.maxSuffixComponents; \n};\n\n/**\n * Get the interest key locator.\n * @returns {KeyLocator} The key locator. If its getType() is null, \n * then the key locator is not specified.\n */\nInterest.prototype.getKeyLocator = function() \n{ \n  return this.keyLocator; \n};\n\n/**\n * Get the exclude object.\n * @returns {Exclude} The exclude object. If the exclude size() is zero, then\n * the exclude is not specified.\n */\nInterest.prototype.getExclude = function() { return this.exclude; };\n\n/**\n * Get the child selector.\n * @returns {number} The child selector, or null if not specified.\n */\nInterest.prototype.getChildSelector = function() \n{ \n  return this.childSelector; \n};\n\n/**\n * @deprecated Use getMustBeFresh.\n */\nInterest.prototype.getAnswerOriginKind = function() \n{ \n  return this.answerOriginKind; \n};\n  \n  /**\n   * Return true if the content must be fresh.\n   * @return true if must be fresh, otherwise false.\n   */\n  \n/**\n * Get the must be fresh flag. If not specified, the default is true.\n * @returns {boolean} The must be fresh flag.\n */\nInterest.prototype.getMustBeFresh = function() \n{\n  if (this.answerOriginKind == null || this.answerOriginKind < 0)\n    return true;\n  else\n    return (this.answerOriginKind & Interest.ANSWER_STALE) == 0;\n};\n\n/**\n * Return the nonce value from the incoming interest.  If you change any of the \n * fields in this Interest object, then the nonce value is cleared.\n * @returns {Buffer} The nonce, or null if not specified.\n */\nInterest.prototype.getNonce = function() { return this.nonce; };\n\n/**\n * Get the interest scope.\n * @returns {number} The scope, or null if not specified.\n */\nInterest.prototype.getScope = function() { return this.scope; };\n\n/**\n * Get the interest lifetime.\n * @returns {number} The interest lifetime in milliseconds, or null if not \n * specified.\n */\nInterest.prototype.getInterestLifetimeMilliseconds = function() \n{ \n  return this.interestLifetime; \n};\n\nInterest.prototype.setName = function(name)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.name = typeof name === \'object\' && name instanceof Interest ?\n              new Name(name) : new Name();\n};\n                \nInterest.prototype.setMinSuffixComponents = function(minSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.minSuffixComponents = minSuffixComponents;\n};\n\nInterest.prototype.setMaxSuffixComponents = function(maxSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.maxSuffixComponents = maxSuffixComponents;\n};\n\n/**\n * Set this interest to use a copy of the given exclude object. Note: You can \n * also change this interest\'s exclude object modifying the object from \n * getExclude().\n * @param {Exclude} exclude The exlcude object that is copied.\n */\nInterest.prototype.setExclude = function(exclude)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                 new Exclude(exclude) : new Exclude();\n};\n\nInterest.prototype.setChildSelector = function(childSelector)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.childSelector = childSelector;\n};\n\n/**\n * @deprecated Use setMustBeFresh.\n */\nInterest.prototype.setAnswerOriginKind = function(answerOriginKind)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.answerOriginKind = answerOriginKind;\n};\n\n/**\n * Set the MustBeFresh flag.\n * @param {boolean} mustBeFresh True if the content must be fresh, otherwise false.\n */\nInterest.prototype.setMustBeFresh = function(mustBeFresh)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  if (this.answerOriginKind == null || this.answerOriginKind < 0) {\n    // It is is already the default where MustBeFresh is true. \n    if (!mustBeFresh)\n      // Set answerOriginKind_ so that getMustBeFresh returns false.\n      this.answerOriginKind = Interest.ANSWER_STALE; \n  }\n  else {\n    if (mustBeFresh)\n      // Clear the stale bit.\n      this.answerOriginKind &= ~Interest.ANSWER_STALE;\n    else\n      // Set the stale bit.\n      this.answerOriginKind |= Interest.ANSWER_STALE;\n  }\n};\n\nInterest.prototype.setScope = function(scope)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.scope = scope;\n};\n\nInterest.prototype.setInterestLifetimeMilliseconds = function(interestLifetimeMilliseconds)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.interestLifetime = interestLifetimeMilliseconds;\n};\n\n/**\n * @deprecated You should let the wire encoder generate a random nonce \n * internally before sending the interest.\n */\nInterest.prototype.setNonce = function(nonce)\n{\n  if (nonce)\n    // Copy and make sure it is a customBuf.\n    this.nonce = new customBuf(nonce);\n  else\n    this.nonce = null;\n};\n\n/**\n * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and\n * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".\n * @returns {string} The URI string.\n * @note This is an experimental feature.  See the API docs for more detail at\n * http://named-data.net/doc/ndn-ccl-api/interest.html#interest-touri-method .\n */\nInterest.prototype.toUri = function() \n{  \n  var selectors = "";\n  \n  if (this.minSuffixComponents != null)\n    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;\n  if (this.maxSuffixComponents != null)\n    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;\n  if (this.childSelector != null)\n    selectors += "&ndn.ChildSelector=" + this.childSelector;\n  if (this.answerOriginKind != null)\n    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;\n  if (this.scope != null)\n    selectors += "&ndn.Scope=" + this.scope;\n  if (this.interestLifetime != null)\n    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;\n  if (this.publisherPublicKeyDigest != null)\n    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  if (this.nonce != null)\n    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);\n  if (this.exclude != null && this.exclude.size() > 0)\n    selectors += "&ndn.Exclude=" + this.exclude.toUri();\n\n  var result = this.name.toUri();\n  if (selectors != "")\n    // Replace the first & with ?.\n    result += "?" + selectors.substr(1);\n  \n  return result;\n};\n\n/**\n * Encode this Interest for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {Blob} The encoded buffer in a Blob object.\n */\nInterest.prototype.wireEncode = function(wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return wireFormat.encodeInterest(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Interest.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nInterest.prototype.wireDecode = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  if (LOG > 3 ) console.log(\'decoding input to interes\', input)\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ? \n                     input.buf() : input;\n  wireFormat.decodeInterest(this, decodeBuffer);\n};\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom \n// to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  BinaryXmlWireFormat.decodeInterest(this, decoder);\n};\n\n/**\n * @deprecated Use wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder) \n{\n  BinaryXmlWireFormat.encodeInterest(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.encode = function(wireFormat) \n{\n  return this.wireEncode(BinaryXmlWireFormat.get()).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.decode = function(input, wireFormat) \n{\n  this.wireDecode(input, BinaryXmlWireFormat.get())\n};\n\n})()\n},{"./buffer.js":54,"./encoding/binary-xml-wire-format.js":43,"./encoding/wire-format.js":42,"./exclude.js":36,"./key-locator.js":40,"./log.js":89,"./name.js":33,"./publisher-public-key-digest.js":41,"./util/blob.js":49}],36:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an Interest Exclude.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\n\n/**\n * Create a new Exclude.\n * @constructor\n * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, customBuf component or Exclude.ANY.\n */\nvar Exclude = function Exclude(values) \n{ \n  this.values = [];\n  \n  if (typeof values === \'object\' && values instanceof Exclude)\n    // Copy the exclude.\n    this.values = values.values.slice(0);\n  else if (values) {\n    for (var i = 0; i < values.length; ++i) {\n      if (values[i] == Exclude.ANY)\n        this.appendAny();\n      else\n        this.appendComponent(values[i]);\n    }\n  }\n};\n\nexports.Exclude = Exclude;\n\nExclude.ANY = "*";\n\n/**\n * Get the number of entries.\n * @returns {number} The number of entries.\n */\nExclude.prototype.size = function() { return this.values.length; };\n\n/**\n * Get the entry at the given index.\n * @param {number} i The index of the entry, starting from 0.\n * @returns {Exclude.ANY|Name.Component} Exclude.ANY or a Name.Component.\n */\nExclude.prototype.get = function(i) { return this.values[i]; };\n\n/**\n * Append an Exclude.ANY element.\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendAny = function() \n{\n  this.values.push(Exclude.ANY);\n  return this;\n};\n\n/**\n * Append a component entry, copying from component.\n * @param {Name.Component|Buffer} component\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendComponent = function(component) \n{\n  this.values.push(new Name.Component(component));\n  return this;\n};\n\n/**\n * Clear all the entries.\n */\nExclude.prototype.clear = function() \n{\n  this.values = [];\n};\n\nExclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);\n\n  while (true) {\n    if (decoder.peekDTag(NDNProtocolDTags.Component))\n      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {\n      decoder.readElementStartDTag(NDNProtocolDTags.Any);\n      decoder.readElementClose();\n      this.appendAny();\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {\n      // Skip the Bloom and treat it as Any.\n      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);\n      this.appendAny();\n    }\n    else\n      break;\n  }\n    \n  decoder.readElementClose();\n};\n\nExclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{\n  if (this.values == null || this.values.length == 0)\n    return;\n\n  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);\n    \n  // TODO: Do we want to order the components (except for ANY)?\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      encoder.writeElementStartDTag(NDNProtocolDTags.Any);\n      encoder.writeElementClose();\n    }\n    else\n      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());\n  }\n\n  encoder.writeElementClose();\n};\n\n/**\n * Return a string with elements separated by "," and Exclude.ANY shown as "*". \n */\nExclude.prototype.toUri = function() \n{\n  if (this.values == null || this.values.length == 0)\n    return "";\n\n  var result = "";\n  for (var i = 0; i < this.values.length; ++i) {\n    if (i > 0)\n      result += ",";\n        \n    if (this.values[i] == Exclude.ANY)\n      result += "*";\n    else\n      result += Name.toEscapedString(this.values[i].getValue());\n  }\n  return result;\n};\n\n/**\n * Return true if the component matches any of the exclude criteria.\n */\nExclude.prototype.matches = function(/*Buffer*/ component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      var lowerBound = null;\n      if (i > 0)\n        lowerBound = this.values[i - 1];\n      \n      // Find the upper bound, possibly skipping over multiple ANY in a row.\n      var iUpperBound;\n      var upperBound = null;\n      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {\n        if (this.values[iUpperBound] != Exclude.ANY) {\n          upperBound = this.values[iUpperBound];\n          break;\n        }\n      }\n      \n      // If lowerBound != null, we already checked component equals lowerBound on the last pass.\n      // If upperBound != null, we will check component equals upperBound on the next pass.\n      if (upperBound != null) {\n        if (lowerBound != null) {\n          if (Exclude.compareComponents(component, lowerBound) > 0 &&\n              Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n        else {\n          if (Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n          \n        // Make i equal iUpperBound on the next pass.\n        i = iUpperBound - 1;\n      }\n      else {\n        if (lowerBound != null) {\n            if (Exclude.compareComponents(component, lowerBound) > 0)\n              return true;\n        }\n        else\n          // this.values has only ANY.\n          return true;\n      }\n    }\n    else {\n      if (DataUtils.arraysEqual(component, this.values[i].getValue()))\n        return true;\n    }\n  }\n  \n  return false;\n};\n\n/**\n * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.\n * A component is less if it is shorter, otherwise if equal length do a byte comparison.\n */\nExclude.compareComponents = function(component1, component2) \n{\n  if (typeof component1 == \'object\' && component1 instanceof Name.Component)\n    component1 = component1.getValue();\n  if (typeof component2 == \'object\' && component2 instanceof Name.Component)\n    component2 = component2.getValue();\n\n  if (component1.length < component2.length)\n    return -1;\n  if (component1.length > component2.length)\n    return 1;\n  \n  for (var i = 0; i < component1.length; ++i) {\n    if (component1[i] < component2[i])\n      return -1;\n    if (component1[i] > component2[i])\n      return 1;\n  }\n\n  return 0;\n};\n\n})()\n},{"./buffer.js":54,"./encoding/binary-xml-decoder.js":85,"./encoding/binary-xml-encoder.js":86,"./encoding/data-utils.js":47,"./name.js":33,"./util/ndn-protoco-id-tags.js":87}],37:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar SignedBlob = require(\'./util/signed-blob.js\').SignedBlob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Signature = require(\'./signature.js\').Signature;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\n/**\n * Create a new Data with the optional values.  There are 2 forms of constructor:\n * new Data([name] [, content]);\n * new Data(name, metaInfo [, content]);\n *\n * @constructor\n * @param {Name} name\n * @param {MetaInfo} metaInfo\n * @param {Buffer} content\n */\nvar Data = function Data(name, metaInfoOrContent, arg3)\n{\n  if (typeof name === \'string\')\n    this.name = new Name(name);\n  else\n    this.name = typeof name === \'object\' && name instanceof Name ?\n       new Name(name) : new Name();\n\n  var metaInfo;\n  var content;\n  if (typeof metaInfoOrContent === \'object\' &&\n      metaInfoOrContent instanceof MetaInfo) {\n    metaInfo = metaInfoOrContent;\n    content = arg3;\n  }\n  else {\n    metaInfo = null;\n    content = metaInfoOrContent;\n  }\n\n  // Use signedInfo instead of metaInfo for backward compatibility.\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n       new MetaInfo(metaInfo) : new MetaInfo();\n\n  if (typeof content === \'string\')\n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else\n    this.content = content;\n\n  this.signature = new Signature();\n\n  this.wireEncoding = SignedBlob();\n};\n\nexports.Data = Data;\n\n/**\n * Get the data packet\'s name.\n * @returns {Name} The name.\n */\nData.prototype.getName = function()\n{\n  return this.name;\n};\n\n/**\n * Get the data packet\'s meta info.\n * @returns {MetaInfo} The meta info.\n */\nData.prototype.getMetaInfo = function()\n{\n  return this.signedInfo;\n};\n\n/**\n * Get the data packet\'s signature object.\n * @returns {Signature} The signature object.\n */\nData.prototype.getSignature = function()\n{\n  return this.signature;\n};\n\n/**\n * Get the data packet\'s content.\n * @returns {Buffer} The content as a customBuf, which is null if unspecified.\n */\nData.prototype.getContent = function()\n{\n  return this.content;\n};\n\n/**\n * Set name to a copy of the given Name.\n * @param {Name} name The Name which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setName = function(name)\n{\n  this.name = typeof name === \'object\' && name instanceof Name ?\n    new Name(name) : new Name();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set metaInfo to a copy of the given MetaInfo.\n * @param {MetaInfo} metaInfo The MetaInfo which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setMetaInfo = function(metaInfo)\n{\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n    new MetaInfo(metaInfo) : new MetaInfo();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the signature to a copy of the given signature.\n * @param {Signature} signature The signature object which is cloned.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setSignature = function(signature)\n{\n  this.signature = typeof signature === \'object\' && signature instanceof Signature ?\n    signature.clone() : new Signature();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the content to the given value.\n * @param {type} content The array this is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setContent = function(content)\n{\n  if (typeof content === \'string\')\n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else\n    this.content = new customBuf(content);\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\nData.prototype.sign = function(wireFormat)\n{\n  var rs = require(\'buffer\')\n  var ss = require(\'./crypto.js\')\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n\n  if (this.getSignatureOrMetaInfoKeyLocator() == null ||\n      this.getSignatureOrMetaInfoKeyLocator().getType() == null)\n    this.getMetaInfo().setFields();\n\n  if (this.wireEncoding == null || this.wireEncoding.isNull()) {\n    // Need to encode to set wireEncoding.\n    // Set an initial empty signature so that we can encode.\n    this.getSignature().setSignature(new customBuf(128));\n    this.wireEncode(wireFormat);\n  }\n\n  var rsa = require("./crypto.js").createSign(\'RSA-SHA256\');\n  rsa.update(this.wireEncoding.signedBuf());\n\n  var sig = new customBuf\n    (DataUtils.toNumbersIfString(rsa.sign(globalKeyManager.privateKey)));\n  this.signature.signature = sig;\n};\n\n// The first time verify is called, it sets this to determine if a signature\n//   buffer needs to be converted to a string for the crypto verifier.\nData.verifyUsesString = null;\nData.prototype.verify = function(/*Key*/ key)\n{\n  if (key == null || key.publicKeyPem == null)\n    throw new Error(\'Cannot verify Data without a public key.\');\n\n  if (Data.verifyUsesString == null) {\n    var hashResult = require("crypto").createHash(\'sha256\').digest();\n    // If the has result is a string, we assume that this is a version of\n    //   crypto where verify also uses a string signature.\n    Data.verifyUsesString = (typeof hashResult === \'string\');\n  }\n\n  if (this.wireEncoding == null || this.wireEncoding.isNull())\n    // Need to encode to set wireEncoding.\n    this.wireEncode();\n  var verifier = require(\'./crypto.js\').createVerify(\'RSA-SHA256\');\n  verifier.update(this.wireEncoding.signedBuf());\n  var signatureBytes = Data.verifyUsesString ?\n    DataUtils.toString(this.signature.signature) : this.signature.signature;\n  return verifier.verify(key.publicKeyPem, signatureBytes);\n};\n\nData.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };\n\n/**\n * Encode this Data for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object\n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {SignedBlob} The encoded buffer in a SignedBlob object.\n */\nData.prototype.wireEncode = function(wireFormat)\n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var result = wireFormat.encodeData(this);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  this.wireEncoding = new SignedBlob\n    (result.encoding, result.signedPortionBeginOffset,\n     result.signedPortionEndOffset);\n  return this.wireEncoding;\n};\n\n/**\n * Decode the input using a particular wire format and update this Data.\n * @param {Blob|Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object\n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nData.prototype.wireDecode = function(input, wireFormat)\n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ?\n                     input.buf() : input;\n  var result = wireFormat.decodeData(this, decodeBuffer);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  // In the Blob constructor, set copy true, but if input is already a Blob, it\n  //   won\'t copy.\n  this.wireEncoding = new SignedBlob\n    (new Blob(input, true), result.signedPortionBeginOffset,\n     result.signedPortionEndOffset);\n};\n\n/**\n * If getSignature() has a key locator, return it.  Otherwise, use\n * the key locator from getMetaInfo() for backward compatibility and print\n * a warning to console.log that the key locator has moved to the Signature\n * object.  If neither has a key locator, return an empty key locator.\n * When we stop supporting the key locator in MetaInfo, this function is not\n * necessary and we will just use the key locator in the Signature.\n * @returns {KeyLocator} The key locator to use.\n */\nData.prototype.getSignatureOrMetaInfoKeyLocator = function()\n{\n  if (this.signature != null && this.signature.getKeyLocator() != null &&\n      this.signature.getKeyLocator().getType() != null &&\n      this.signature.getKeyLocator().getType() >= 0)\n    // The application is using the key locator in the correct object.\n    return this.signature.getKeyLocator();\n\n  if (this.signedInfo != null && this.signedInfo.locator != null &&\n      this.signedInfo.locator.type != null &&\n      this.signedInfo.locator.type >= 0) {\n    //console.log("WARNING: Temporarily using the key locator found in the MetaInfo - expected it in the Signature object.");\n    //console.log("WARNING: In the future, the key locator in the Signature object will not be supported.");\n    return this.signedInfo.locator;\n  }\n\n  // Return the empty key locator from the Signature object if possible.\n  if (this.signature != null && this.signature.getKeyLocator() != null)\n    return this.signature.getKeyLocator();\n  else\n    return new KeyLocator();\n}\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeData.\n */\nData.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  BinaryXmlWireFormat.decodeData(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeData.\n */\nData.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeData(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nData.prototype.encode = function(wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  return wireFormat.encodeData(this).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nData.prototype.decode = function(input, wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  wireFormat.decodeData(this, input);\n};\n\n/**\n * @deprecated Use new Data.\n */\nvar ContentObject = function ContentObject(name, signedInfo, content)\n{\n  // Call the base constructor.\n  Data.call(this, name, signedInfo, content);\n}\n\nContentObject.prototype = new Data();\n\nexports.ContentObject = ContentObject;\n\n})()\n},{"./buffer.js":54,"./crypto.js":54,"./encoding/binary-xml-encoder.js":86,"./encoding/binary-xml-wire-format.js":43,"./encoding/data-utils.js":47,"./encoding/wire-format.js":42,"./key-locator.js":40,"./meta-info.js":38,"./name.js":33,"./security/key-manager.js":52,"./signature.js":91,"./util/blob.js":49,"./util/ndn-protoco-id-tags.js":87,"./util/signed-blob.js":90,"buffer":63,"crypto":56}],38:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data MetaInfo object.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Blob = require(\'./util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar Name = require(\'./name.js\').Name;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar NDNTime = require(\'./util/ndn-time.js\').NDNTime;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar LOG = require(\'./log.js\').Log.LOG;\n\nvar ContentType = {\n  BLOB:0,\n  // ContentType DATA is deprecated.  Use ContentType.BLOB .\n  DATA:0, \n  LINK:1, \n  KEY: 2, \n  // ContentType ENCR, GONE and NACK are not supported in NDN-TLV encoding and are deprecated.\n  ENCR:3, \n  GONE:4, \n  NACK:5\n};\n\nexports.ContentType = ContentType;\n\n/**\n * Create a new MetaInfo with the optional values.\n * @constructor\n */\nvar MetaInfo = function MetaInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID, skipSetFields) \n{\n  if (typeof publisherOrMetaInfo === \'object\' && \n      publisherOrMetaInfo instanceof MetaInfo) {\n    // Copy values.\n    var metaInfo = publisherOrMetaInfo;\n    this.publisher = metaInfo.publisher;\n    this.timestamp = metaInfo.timestamp;\n    this.type = metaInfo.type;\n    this.locator = metaInfo.locator == null ? \n      new KeyLocator() : new KeyLocator(metaInfo.locator);\n    this.freshnessSeconds = metaInfo.freshnessSeconds;\n    this.finalBlockID = metaInfo.finalBlockID;\n  }\n  else {\n    this.publisher = publisherOrMetaInfo; //publisherPublicKeyDigest\n    this.timestamp = timestamp; // NDN Time\n    this.type = type; // ContentType\n    this.locator = locator == null ? new KeyLocator() : new KeyLocator(locator);\n    this.freshnessSeconds = freshnessSeconds; // Integer\n    this.finalBlockID = finalBlockID; //byte array\n\n    if (!skipSetFields)\n      this.setFields();\n  }\n};\n\nexports.MetaInfo = MetaInfo;\n\n/**\n * Get the content type.\n * @returns {an int from ContentType} The content type.\n */\nMetaInfo.prototype.getType = function()\n{\n  return this.type;\n};\n\n/**\n * Get the freshness period.\n * @returns {number} The freshness period in milliseconds, or null if not \n * specified.\n */\nMetaInfo.prototype.getFreshnessPeriod = function()\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (this.freshnessSeconds == null || this.freshnessSeconds < 0)\n    return null;\n  else\n    // Convert to milliseconds.\n    return this.freshnessSeconds * 1000.0;\n};\n\n/**\n * Get the final block ID.\n * @returns {Buffer} The final block ID or null if not specified.\n */\nMetaInfo.prototype.getFinalBlockID = function()\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  return this.finalBlockID;\n};\n\n/**\n * Set the content type.\n * @param {an int from ContentType} type The content type.  If null, this \n * uses ContentType.BLOB.\n */\nMetaInfo.prototype.setType = function(type)\n{\n  this.type = type == null || type < 0 ? ContentType.BLOB : type;\n};\n\n/**\n * Set the freshness period.\n * @param {type} freshnessPeriod The freshness period in milliseconds, or null\n * for not specified.\n */\nMetaInfo.prototype.setFreshnessPeriod = function(freshnessPeriod)\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (freshnessPeriod == null || freshnessPeriod < 0)\n    this.freshnessSeconds = null;\n  else\n    // Convert from milliseconds.\n    this.freshnessSeconds = freshnessPeriod / 1000.0;\n};\n\nMetaInfo.prototype.setFinalBlockID = function(finalBlockID)\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  if (finalBlockID == null)\n    this.finalBlockID = null;\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Blob)\n    this.finalBlockID = finalBlockID.buf();\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Name.Component)\n    this.finalBlockID = finalBlockID.getValue();\n  else \n    this.finalBlockID = new customBuf(finalBlockID);\n};\n\nMetaInfo.prototype.setFields = function() \n{\n  var key = globalKeyManager.getKey();\n  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());\n\n  var d = new Date();\n    \n  var time = d.getTime();  \n\n  this.timestamp = new NDNTime(time);\n    \n  if (LOG > 4) console.log(\'TIME msec is\');\n\n  if (LOG > 4) console.log(this.timestamp.msec);\n\n  //DATA\n  this.type = ContentType.BLOB;\n  \n  if (LOG > 4) console.log(\'PUBLIC KEY TO WRITE TO DATA PACKET IS \');\n  if (LOG > 4) console.log(key.publicToDER().toString(\'hex\'));\n\n  this.locator = new KeyLocator(key.getKeyID(), KeyLocatorType.KEY_LOCATOR_DIGEST);\n};\n\nMetaInfo.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    if (LOG > 4) console.log(\'DECODING PUBLISHER KEY\');\n    this.publisher = new PublisherPublicKeyDigest();\n    this.publisher.from_ndnb(decoder);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {\n    if (LOG > 4) console.log(\'DECODING TIMESTAMP\');\n    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Type)) {\n    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);\n    \n    if (LOG > 4) console.log(\'Binary Type of of Signed Info is \'+binType);\n\n    this.type = binType;\n    \n    //TODO Implement type of Key Reading\n    if (null == this.type)\n      throw new Error("Cannot parse signedInfo type: bytes.");\n  } \n  else\n    this.type = ContentType.DATA; // default\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n    if (LOG > 4) console.log(\'FRESHNESS IN SECONDS IS \'+ this.freshnessSeconds);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {\n    if (LOG > 4) console.log(\'DECODING FINAL BLOCKID\');\n    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {\n    if (LOG > 4) console.log(\'DECODING KEY LOCATOR\');\n    this.locator = new KeyLocator();\n    this.locator.from_ndnb(decoder);\n  }\n      \n  decoder.readElementClose();\n};\n\n/**\n * Encode this MetaInfo in ndnb, using the given keyLocator instead of the\n * locator in this object.\n * @param {BinaryXMLEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nMetaInfo.prototype.to_ndnb = function(encoder, keyLocator)  {\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.publisher) {\n    // We have a publisherPublicKeyDigest, so use it.\n    if (LOG > 3) console.log(\'ENCODING PUBLISHER KEY\' + this.publisher.publisherPublicKeyDigest);\n    this.publisher.to_ndnb(encoder);\n  }\n  else {\n    if (null != keyLocator &&\n        keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n        keyLocator.getKeyData() != null &&\n        keyLocator.getKeyData().length > 0)\n      // We have a TLV-style KEY_LOCATOR_DIGEST, so encode as the\n      //   publisherPublicKeyDigest.\n      encoder.writeDTagElement\n        (NDNProtocolDTags.PublisherPublicKeyDigest, keyLocator.getKeyData());\n  }\n\n  if (null != this.timestamp)\n    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);\n  \n  if (null != this.type && this.type != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);\n  \n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  if (null != this.finalBlockID)\n    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);\n\n  if (null != keyLocator)\n    keyLocator.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nMetaInfo.prototype.valueToType = function() \n{\n  return null;  \n};\n\nMetaInfo.prototype.getElementLabel = function() { \n  return NDNProtocolDTags.SignedInfo;\n};\n\nMetaInfo.prototype.validate = function() \n{\n  // We don\'t do partial matches any more, even though encoder/decoder\n  // is still pretty generous.\n  if (null == this.timestamp)\n    return false;\n  return true;\n};\n\n/**\n * @deprecated Use new MetaInfo.\n */\nvar SignedInfo = function SignedInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID) \n{\n  // Call the base constructor.\n  MetaInfo.call(this, publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID); \n}\n\n// Set skipSetFields true since we only need the prototype functions.\nSignedInfo.prototype = new MetaInfo(null, null, null, null, null, null, true);\n\nexports.SignedInfo = SignedInfo;\n\n})()\n},{"./buffer.js":54,"./encoding/binary-xml-decoder.js":85,"./encoding/binary-xml-encoder.js":86,"./key-locator.js":40,"./log.js":89,"./name.js":33,"./publisher-public-key-digest.js":41,"./security/key-manager.js":52,"./util/blob.js":49,"./util/ndn-protoco-id-tags.js":87,"./util/ndn-time.js":51}],39:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Key Objects\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\n/**\n * Key\n */\nvar Key = function Key()\n{\n  this.publicKeyDer = null;     // customBuf\n  this.publicKeyDigest = null;  // customBuf\n  this.publicKeyPem = null;     // String\n  this.privateKeyPem = null;    // String\n};\n\nexports.Key = Key;\n\n/**\n * Helper functions to read Key fields\n * TODO: generateRSA()\n */\n\nKey.prototype.publicToDER = function()\n{\n  return this.publicKeyDer;  // customBuf\n};\n\nKey.prototype.privateToDER = function()\n{\n  // Remove the \'-----XXX-----\' from the beginning and the end of the key\n  // and also remove any \\n in the key string\n  var lines = this.privateKeyPem.split(\'\\n\');\n  priKey = "";\n  for (var i = 1; i < lines.length - 1; i++)\n    priKey += lines[i];\n\n  return new customBuf(priKey, \'base64\');\n};\n\nKey.prototype.publicToPEM = function()\n{\n  return this.publicKeyPem;\n};\n\nKey.prototype.privateToPEM = function()\n{\n  return this.privateKeyPem;\n};\n\nKey.prototype.getKeyID = function()\n{\n  return this.publicKeyDigest;\n};\n\nexports.Key = Key;\n\nKey.prototype.readDerPublicKey = function(/*Buffer*/pub_der)\n{\n  if (LOG > 4) console.log("Encode DER public key:\\n" + pub_der.toString(\'hex\'));\n\n  this.publicKeyDer = pub_der;\n\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(this.publicKeyDer);\n  this.publicKeyDigest = new customBuf(DataUtils.toNumbersIfString(hash.digest()));\n  var keyStr = pub_der.toString(\'base64\');\n  var keyPem = "-----BEGIN PUBLIC KEY-----\\n";\n  for (var i = 0; i < keyStr.length; i += 64)\n  keyPem += (keyStr.substr(i, 64) + "\\n");\n  keyPem += "-----END PUBLIC KEY-----";\n  this.publicKeyPem = keyPem;\n\n  if (LOG > 4) console.log("Convert public key to PEM format:\\n" + this.publicKeyPem);\n};\n\n/**\n * Load RSA key pair from PEM-encoded strings.\n * Will throw an Error if both \'pub\' and \'pri\' are null.\n */\nKey.prototype.fromPemString = function(pub, pri)\n{\n  if (pub == null && pri == null)\n    throw new Error(\'Cannot create Key object if both public and private PEM string is empty.\');\n\n  // Read public key\n  if (pub != null) {\n    this.publicKeyPem = pub;\n    if (LOG > 4) console.log("Key.publicKeyPem: \\n" + this.publicKeyPem);\n\n    // Remove the \'-----XXX-----\' from the beginning and the end of the public key\n    // and also remove any \\n in the public key string\n    var lines = pub.split(\'\\n\');\n    pub = "";\n    for (var i = 1; i < lines.length - 1; i++)\n      pub += lines[i];\n    this.publicKeyDer = new customBuf(pub, \'base64\');\n    if (LOG > 4) console.log("Key.publicKeyDer: \\n" + this.publicKeyDer.toString(\'hex\'));\n\n    var hash = require("./crypto.js").createHash(\'sha256\');\n    hash.update(this.publicKeyDer);\n    this.publicKeyDigest = new customBuf(DataUtils.toNumbersIfString(hash.digest()));\n    if (LOG > 4) console.log("Key.publicKeyDigest: \\n" + this.publicKeyDigest.toString(\'hex\'));\n  }\n\n  // Read private key\n  if (pri != null) {\n    this.privateKeyPem = pri;\n    if (LOG > 4) console.log("Key.privateKeyPem: \\n" + this.privateKeyPem);\n  }\n};\n\nKey.prototype.fromPem = Key.prototype.fromPemString;\n\n/**\n * Static method that create a Key object.\n * Parameter \'obj\' is a JSON object that has two properties:\n *   pub: the PEM string for the public key\n *   pri: the PEM string for the private key\n * Will throw an Error if both obj.pub and obj.pri are null.\n */\nKey.createFromPEM = function(obj)\n{\n    var key = new Key();\n    key.fromPemString(obj.pub, obj.pri);\n    return key;\n};\n\n})()\n},{"./buffer.js":54,"./crypto.js":54,"./encoding/data-utils.js":47,"./log.js":89}],40:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN KeyLocator object.\n */\n\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherID = require(\'./publisher-id.js\').PublisherID;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * KeyLocator\n */\nvar KeyLocatorType = {\n  KEYNAME: 1,\n  KEY_LOCATOR_DIGEST: 2,\n  KEY: 3,\n  CERTIFICATE: 4\n};\n\nexports.KeyLocatorType = KeyLocatorType;\n\n/**\n * @constructor\n */\nvar KeyLocator = function KeyLocator(input,type) \n{ \n  if (typeof input === \'object\' && input instanceof KeyLocator) {\n    // Copy from the input KeyLocator.\n    this.type = input.type;\n    this.keyName = new KeyName();\n    if (input.keyName != null) {\n      this.keyName.contentName = input.keyName.contentName == null ? \n        null : new Name(input.keyName.contentName);\n      this.keyName.publisherID = input.keyName.publisherID;\n    }\n    this.keyData = input.keyData == null ? null : new customBuf(input.keyData);\n    this.publicKey = input.publicKey == null ? null : new customBuf(input.publicKey);\n    this.certificate = input.certificate == null ? null : new customBuf(input.certificate);\n  }\n  else {\n    this.type = type;\n    this.keyName = new KeyName();\n\n    if (type == KeyLocatorType.KEYNAME)\n      this.keyName = input;\n    else if (type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n      this.keyData = new customBuf(input);\n    else if (type == KeyLocatorType.KEY) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.publicKey = this.keyData;\n    }\n    else if (type == KeyLocatorType.CERTIFICATE) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.certificate = this.keyData;\n    }\n  }\n};\n\nexports.KeyLocator = KeyLocator;\n\n/**\n * Get the key locator type. If KeyLocatorType.KEYNAME, you may also\n * getKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you may also\n * getKeyData() to get the digest.\n * @returns {number} The key locator type, or null if not specified.\n */\nKeyLocator.prototype.getType = function() { return this.type; };\n\n/**\n * Get the key name.  This is meaningful if getType() is KeyLocatorType.KEYNAME.\n * @returns {Name} The key name. If not specified, the Name is empty.\n */\nKeyLocator.prototype.getKeyName = function() \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  if (this.keyName.contentName == null)\n    this.keyName.contentName = new Name();\n  \n  return this.keyName.contentName;\n};\n\n/**\n * Get the key data. If getType() is KeyLocatorType.KEY_LOCATOR_DIGEST, this is \n * the digest bytes. If getType() is KeyLocatorType.KEY, this is the DER \n * encoded public key. If getType() is KeyLocatorType.CERTIFICATE, this is the \n * DER encoded certificate. \n * @returns {Buffer} The key data, or null if not specified.\n */\nKeyLocator.prototype.getKeyData = function() \n{ \n  if (this.type == KeyLocatorType.KEY)\n    return this.publicKey;\n  else if (this.type == KeyLocatorType.CERTIFICATE)\n    return this.certificate;\n  else\n    return this.keyData;\n};\n\n/**\n * Set the key locator type.  If KeyLocatorType.KEYNAME, you must also\n * setKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you must also\n * setKeyData() to the digest.\n * @param {number} type The key locator type.  If null, the type is unspecified.\n */\nKeyLocator.prototype.setType = function(type) { this.type = type; }; \n\n/**\n * Set key name to a copy of the given Name.  This is the name if getType() \n * is KeyLocatorType.KEYNAME.\n * @param {Name} name The key name which is copied.\n */\nKeyLocator.prototype.setKeyName = function(name) \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  \n  this.keyName.contentName = typeof name === \'object\' && name instanceof Name ?\n                             new Name(name) : new Name(); \n}; \n\n/**\n * Set the key data to the given value. This is the digest bytes if getType() is \n * KeyLocatorType.KEY_LOCATOR_DIGEST.\n * @param {Buffer} keyData The array with the key data bytes.\n */\nKeyLocator.prototype.setKeyData = function(keyData)\n{\n  var value = keyData;\n  if (value != null)\n    // Make a copy.\n    value = new customBuf(value);\n  \n  this.keyData = value;\n  // Set for backwards compatibility.\n  this.publicKey = value;\n  this.certificate = value;\n};\n\n/**\n * Clear the keyData and set the type to none.\n */\nKeyLocator.prototype.clear = function() \n{\n  this.type = null;\n  this.keyName = null;\n  this.keyData = null;\n  this.publicKey = null;\n  this.certificate = null;\n};\n\nKeyLocator.prototype.from_ndnb = function(decoder) {\n\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Key)) \n  {\n    try {\n      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);\n      // This is a DER-encoded SubjectPublicKeyInfo.\n      \n      //TODO FIX THIS, This should create a Key Object instead of keeping bytes\n\n      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);\n      this.type = KeyLocatorType.KEY;    \n\n      if (LOG > 4) console.log(\'PUBLIC KEY FOUND: \'+ this.publicKey);\n    } \n    catch (e) {\n      throw new Error("Cannot parse key: ", e);\n    } \n\n    if (null == this.publicKey)\n      throw new Error("Cannot parse key: ");\n  } \n  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {\n    try {\n      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);\n      \n      /*\n       * Certificates not yet working\n       */\n      \n      this.certificate = encodedCert;\n      this.type = KeyLocatorType.CERTIFICATE;\n\n      if (LOG > 4) console.log(\'CERTIFICATE FOUND: \'+ this.certificate);      \n    } \n    catch (e) {\n      throw new Error("Cannot decode certificate: " +  e);\n    }\n    if (null == this.certificate)\n      throw new Error("Cannot parse certificate! ");\n  } else  {\n    this.type = KeyLocatorType.KEYNAME;\n    \n    this.keyName = new KeyName();\n    this.keyName.from_ndnb(decoder);\n  }\n  decoder.readElementClose();\n};  \n\nKeyLocator.prototype.to_ndnb = function(encoder) \n{\n  if (LOG > 4) console.log(\'type is is \' + this.type);\n\n  if (this.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n    // encodeSignedInfo already encoded this as the publisherPublicKeyDigest,\n    //   so do nothing here.\n    return;\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (this.type == KeyLocatorType.KEY) {\n    if (LOG > 5) console.log(\'About to encode a public key\' +this.publicKey);\n    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);  \n  } \n  else if (this.type == KeyLocatorType.CERTIFICATE) {  \n    try {\n      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);\n    } \n    catch (e) {\n      throw new Error("CertificateEncodingException attempting to write key locator: " + e);\n    }    \n  } \n  else if (this.type == KeyLocatorType.KEYNAME)\n    this.keyName.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyLocator.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.KeyLocator; \n};\n\n/**\n * KeyName is only used by KeyLocator.\n * @constructor\n */\nvar KeyName = function KeyName() \n{\n  this.contentName = new Name();  //contentName\n  this.publisherID = this.publisherID;  //publisherID\n};\n\nexports.KeyName = KeyName;\n\nKeyName.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.contentName = new Name();\n  this.contentName.from_ndnb(decoder);\n  \n  if (LOG > 4) console.log(\'KEY NAME FOUND: \');\n  \n  if (PublisherID.peek(decoder)) {\n    this.publisherID = new PublisherID();\n    this.publisherID.from_ndnb(decoder);\n  }\n  \n  decoder.readElementClose();\n};\n\nKeyName.prototype.to_ndnb = function(encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  this.contentName.to_ndnb(encoder);\n  if (null != this.publisherID)\n    this.publisherID.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nKeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };\n\n\n})()\n},{"./buffer.js":54,"./log.js":89,"./name.js":33,"./publisher-id.js":92,"./util/ndn-protoco-id-tags.js":87}],41:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents PublisherPublicKeyDigest Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd) \n{ \n this.PUBLISHER_ID_LEN = 512/8;\n this.publisherPublicKeyDigest = pkd;\n};\n\nexports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;\n\nPublisherPublicKeyDigest.prototype.from_ndnb = function(decoder) \n{\n  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'Publisher public key digest is \' + this.publisherPublicKeyDigest);\n\n  if (null == this.publisherPublicKeyDigest)\n    throw new Error("Cannot parse publisher key digest.");\n    \n  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)\n\n  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {\n    if (LOG > 0)\n      console.log(\'LENGTH OF PUBLISHER ID IS WRONG! Expected \' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);\n      \n    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;    \n  }\n};\n\nPublisherPublicKeyDigest.prototype.to_ndnb= function(encoder) \n{\n  //TODO Check that the ByteArray for the key is present\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  if (LOG > 3) console.log(\'PUBLISHER KEY DIGEST IS\'+this.publisherPublicKeyDigest);\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);\n};\n  \nPublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };\n\nPublisherPublicKeyDigest.prototype.validate = function() \n{\n    return null != this.publisherPublicKeyDigest;\n};\n\n},{"./log.js":89,"./util/ndn-protoco-id-tags.js":87}],55:[function(require,module,exports){\n(function(){exports.Face = require(\'./js/face.js\').Face;\nexports.NDN = require(\'./js/face.js\').NDN; // deprecated\nexports.Closure = require(\'./js/closure.js\').Closure;\nexports.Name = require(\'./js/name.js\').Name;\nexports.ForwardingFlags = require(\'./js/forwarding-flags.js\').ForwardingFlags;\nexports.Interest = require(\'./js/interest.js\').Interest;\nexports.Exclude = require(\'./js/exclude.js\').Exclude;\nexports.Data = require(\'./js/data.js\').Data;\nexports.ContentObject = require(\'./js/data.js\').ContentObject; // deprecated\nexports.ContentType = require(\'./js/meta-info.js\').ContentType;\nexports.MetaInfo = require(\'./js/meta-info.js\').MetaInfo;\nexports.SignedInfo = require(\'./js/meta-info.js\').SignedInfo; // deprecated\nexports.Key = require(\'./js/key.js\').Key;\nexports.KeyLocator = require(\'./js/key-locator.js\').KeyLocator;\nexports.KeyName = require(\'./js/key-locator.js\').KeyName;\nexports.KeyLocatorType = require(\'./js/key-locator.js\').KeyLocatorType;\nexports.PublisherPublicKeyDigest = require(\'./js/publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nexports.WireFormat = require(\'./js/encoding/wire-format.js\').WireFormat;\nexports.BinaryXmlWireFormat = require(\'./js/encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nexports.TlvWireFormat = require(\'./js/encoding/tlv-wire-format.js\').TlvWireFormat;\nexports.TlvDecoder = require(\'./js/encoding/tlv/tlv-decoder.js\').TlvDecoder;\nexports.Tlv = require(\'./js/encoding/tlv/tlv.js\').Tlv\nexports.DataUtils = require(\'./js/encoding/data-utils.js\').DataUtils;\nexports.EncodingUtils = require(\'./js/encoding/encoding-utils.js\').EncodingUtils;\nexports.Blob = require(\'./js/util/blob.js\').Blob;\nexports.NameEnumeration = require(\'./js/util/name-enumeration.js\').NameEnumeration;\nexports.NDNTime = require(\'./js/util/ndn-time.js\').NDNTime;\nexports.globalKeyManager = require(\'./js/security/key-manager.js\').globalKeyManager;\nexports.ElementReader = require(\'./js/encoding/element-reader.js\').ElementReader;\nexports.customBuffer = require(\'./js/browserify.js\').Buffer\n\n})()\n},{"./js/browserify.js":116,"./js/closure.js":94,"./js/data.js":99,"./js/encoding/binary-xml-wire-format.js":105,"./js/encoding/data-utils.js":109,"./js/encoding/element-reader.js":115,"./js/encoding/encoding-utils.js":110,"./js/encoding/tlv-wire-format.js":106,"./js/encoding/tlv/tlv-decoder.js":107,"./js/encoding/tlv/tlv.js":108,"./js/encoding/wire-format.js":104,"./js/exclude.js":98,"./js/face.js":93,"./js/forwarding-flags.js":96,"./js/interest.js":97,"./js/key-locator.js":102,"./js/key.js":101,"./js/meta-info.js":100,"./js/name.js":95,"./js/publisher-public-key-digest.js":103,"./js/security/key-manager.js":114,"./js/util/blob.js":111,"./js/util/name-enumeration.js":112,"./js/util/ndn-time.js":113}],54:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n// Library namespace\nvar ndn = ndn || {};\n\nvar exports = ndn;\n\nvar ASN1HEX = require(\'../contrib/securityLib/asn1hex-1.1.js\')\nvar KJUR = require(\'../contrib/securityLib/crypto-1.0.js\')\nvar RSAKey = require(\'../contrib/securityLib/rsasign-1.2.js\')\nvar b64tohex = require(\'../contrib/securityLib/base64.js\').b64tohex\n// Factory method to create node.js compatible buffer objects\nvar customBuf = function customBuf(data, format) \n{\n  var obj;\n\n  if (typeof data == \'number\')\n    obj = new Uint8Array(data);\n  else if (typeof data == \'string\') {\n    if (format == null || format == \'utf8\') {\n      var utf8 = customBuf.str2rstr_utf8(data);\n      obj = new Uint8Array(utf8.length);\n      for (var i = 0; i < utf8.length; i++)\n        obj[i] = utf8.charCodeAt(i);\n    } \n    else if (format == \'binary\') {\n      obj = new Uint8Array(data.length);\n      for (var i = 0; i < data.length; i++)\n        obj[i] = data.charCodeAt(i);\n    } \n    else if (format == \'hex\') {\n      obj = new Uint8Array(Math.floor(data.length / 2));\n      var i = 0;\n      data.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else if (format == \'base64\') {\n      var hex = b64tohex(data);\n      obj = new Uint8Array(Math.floor(hex.length / 2));\n      var i = 0;\n      hex.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else \n      throw new Error(\'Buffer: unknown encoding format \' + format);\n  } \n  else if (typeof data == \'object\' && (data instanceof Uint8Array || data instanceof customBuf)) {\n    // The second argument is a boolean for "copy", default true.\n    if (format == false)\n      obj = data.subarray(0);\n    else\n      obj = new Uint8Array(data);\n  }\n  else if (typeof data == \'object\' && data instanceof ArrayBuffer)\n    // Copy.\n    obj = new Uint8Array(data);\n  else if (typeof data == \'object\')\n    // Assume component is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    obj = new Uint8Array(data);\n  else\n    throw new Error(\'Buffer: unknown data type.\');\n\n  try {\n    obj.__proto__ = customBuf.prototype;\n  } catch(ex) {\n    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);\n  }\n\n  obj.__proto__.toString = function(encoding) {\n    if (encoding == null || encoding == \'binary\') {\n      var ret = "";\n      for (var i = 0; i < this.length; i++)\n        ret += String.fromCharCode(this[i]);\n      return ret;\n    }\n\n    var ret = "";\n    for (var i = 0; i < this.length; i++)\n      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);\n\n    if (encoding == \'hex\')\n      return ret;\n    else if (encoding == \'base64\')\n      return hex2b64(ret);\n    else\n      throw new Error(\'Buffer.toString: unknown encoding format \' + encoding);\n  };\n\n  obj.__proto__.slice = function(begin, end) {\n    if (end !== undefined)\n      return new customBuf(this.subarray(begin, end), false);\n    else\n      return new customBuf(this.subarray(begin), false);\n  };\n\n  obj.__proto__.copy = function(target, targetStart) {\n    if (targetStart !== undefined)\n      target.set(this, targetStart);\n    else\n      target.set(this);\n  };\n\n  return obj;\n};\n\ncustomBuf.prototype = Uint8Array.prototype;\n\ncustomBuf.concat = function(arrays) \n{\n  var totalLength = 0;\n  for (var i = 0; i < arrays.length; ++i)\n    totalLength += arrays[i].length;\n    \n  var result = new customBuf(totalLength);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; ++i) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return result;\n};\n\ncustomBuf.str2rstr_utf8 = function(input)\n{\n  var output = "";\n  var i = -1;\n  var x, y;\n\n  while (++i < input.length)\n  {\n    // Decode utf-16 surrogate pairs\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\n    {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    // Encode output as utf-8\n    if (x <= 0x7F)\n      output += String.fromCharCode(x);\n    else if (x <= 0x7FF)\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0xFFFF)\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0x1FFFFF)\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\n                                    0x80 | ((x >>> 12) & 0x3F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n  }\n  return output;\n};\n\n// Factory method to create hasher objects\nexports.createHash = function(alg) \n{\n  if (alg != \'sha256\')\n    throw new Error(\'createHash: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});\n\n  obj.update = function(buf) {\n    this.md.updateHex(buf.toString(\'hex\'));\n  };\n\n  obj.digest = function() {\n    return new customBuf(this.md.digest(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA signer objects\nexports.createSign = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  obj.sign = function(keypem) {\n    var rsa = new RSAKey();\n    rsa.readPrivateKeyFromPEMString(keypem);\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initSign(rsa);\n    for (var i = 0; i < this.arr.length; ++i)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n\n    return new customBuf(signer.sign(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA verifier objects\nexports.createVerify = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n    \n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  var getSubjectPublicKeyPosFromHex = function(hPub) {  \n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0); \n    if (a.length != 2) \n      return -1;\n    var pBitString = a[1];\n    if (hPub.substring(pBitString, pBitString + 2) != \'03\') \n      return -1;\n    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);\n    if (hPub.substring(pBitStringV, pBitStringV + 2) != \'00\') \n      return -1;\n    return pBitStringV + 2;\n  };\n\n  var readPublicDER = function(pub_der) {\n    var hex = pub_der.toString(\'hex\'); \n    var p = getSubjectPublicKeyPosFromHex(hex);\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);\n    if (a.length != 2) \n      return null;\n    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);\n    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);\n    var rsaKey = new RSAKey();\n    rsaKey.setPublic(hN, hE);\n    return rsaKey;\n  };\n\n  obj.verify = function(keypem, sig) {\n    var key = new ndn.Key();\n    key.fromPemString(keypem);\n\n    var rsa = readPublicDER(key.publicToDER());\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initVerifyByPublicKey(rsa);\n    for (var i = 0; i < this.arr.length; i++)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n    var hSig = sig.toString(\'hex\'); \n    return signer.verify(hSig);\n  };\n\n  return obj;\n};\n\nexports.randomBytes = function(size)\n{\n  // TODO: Use a cryptographic random number generator.\n  var result = new customBuf(size);\n  for (var i = 0; i < size; ++i)\n    result[i] = Math.floor(Math.random() * 256);\n  return result;\n};\n\nexports.Buffer = customBuf;\n\nmodule.exports = exports;\n\n})()\n},{"../contrib/securityLib/asn1hex-1.1.js":117,"../contrib/securityLib/base64.js":120,"../contrib/securityLib/crypto-1.0.js":118,"../contrib/securityLib/rsasign-1.2.js":119}],42:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like TlvWireFormat.\n * @constructor\n */\nvar WireFormat = function WireFormat() {\n};\n\nexports.WireFormat = WireFormat;\n\n/**\n * Encode interest and return the encoding.  Your derived class should override.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeInterest = function(interest) \n{\n  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as an interest and set the fields of the interest object. \n * Your derived class should override.\n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Encode data and return the encoding and signed offsets. Your derived class \n * should override.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeData = function(data) \n{\n  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as a data packet, set the fields in the data object, and return \n * the signed offsets.  Your derived class should override.\n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeData = function(data, input) \n{\n  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Set the static default WireFormat used by default encoding and decoding \n * methods.\n * @param wireFormat {a subclass of WireFormat} An object of a subclass of \n * WireFormat.\n */\nWireFormat.setDefaultWireFormat = function(wireFormat)\n{\n  WireFormat.defaultWireFormat = wireFormat;\n};\n\n/**\n * Return the default WireFormat used by default encoding and decoding methods \n * which was set with setDefaultWireFormat.\n * @returns {a subclass of WireFormat} The WireFormat object.\n */\nWireFormat.getDefaultWireFormat = function()\n{\n  return WireFormat.defaultWireFormat;\n};\n\n// Invoke TlvWireFormat to set the default format.\n// Since tlv-wire-format.js includes this file, put this at the bottom \n// to avoid problems with cycles of require.\nvar TlvWireFormat = require(\'./tlv-wire-format.js\').TlvWireFormat;\n\n})()\n},{"../buffer.js":54,"./tlv-wire-format.js":44}],43:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar Blob = require(\'../util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Name = require(\'../name.js\').Name;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar Signature = require(\'../signature.js\').Signature;\nvar MetaInfo = require(\'../meta-info.js\').MetaInfo;\nvar PublisherPublicKeyDigest = require(\'../publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\n\n/**\n * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.\n * @constructor\n */\nvar BinaryXmlWireFormat = function BinaryXmlWireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nexports.BinaryXmlWireFormat = BinaryXmlWireFormat;\n\n// Default object.\nBinaryXmlWireFormat.instance = null;\n\n/**\n * Encode interest as Binary XML and return the encoding.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nBinaryXmlWireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new BinaryXMLEncoder();\n  BinaryXmlWireFormat.encodeInterest(interest, encoder);  \n  return new Blob(encoder.getReducedOstream(), false);  \n};\n\n/**\n * Decode input as a Binary XML interest and set the fields of the interest object. \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nBinaryXmlWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeInterest(interest, decoder);\n};\n\n/**\n * Encode data as Binary XML and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nBinaryXmlWireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new BinaryXMLEncoder(1500);\n  var result = BinaryXmlWireFormat.encodeData(data, encoder);\n  result.encoding = new Blob(encoder.getReducedOstream(), false);\n  return result;\n};\n\n/**\n * @deprecated Use encodeData(data).\n */\nBinaryXmlWireFormat.prototype.encodeContentObject = function(data)\n{\n  return this.encodeData(data);\n};\n\n/**\n * Decode input as a Binary XML data packet, set the fields in the data object, and return \n * the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  return BinaryXmlWireFormat.decodeData(data, decoder);\n};\n\n/**\n * @deprecated Use decodeData(data, input).\n */\nBinaryXmlWireFormat.prototype.decodeContentObject = function(data, input) \n{\n  this.decodeData(data, input);\n};\n\n/**\n * Get a singleton instance of a BinaryXmlWireFormat.  Assuming that the default \n * wire format was set with \n * WireFormat.setDefaultWireFormat(BinaryXmlWireFormat.get()), you can check if \n * this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == BinaryXmlWireFormat.get().\n * @returns {BinaryXmlWireFormat} The singleton instance.\n */\nBinaryXmlWireFormat.get = function()\n{\n  if (BinaryXmlWireFormat.instance === null)\n    BinaryXmlWireFormat.instance = new BinaryXmlWireFormat();\n  return BinaryXmlWireFormat.instance;\n};\n\n/**\n * Encode the interest by calling the operations on the encoder.\n * @param {Interest} interest\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeInterest = function(interest, encoder) \n{\n  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);\n    \n  interest.name.to_ndnb(encoder);\n  \n  if (null != interest.minSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);  \n\n  if (null != interest.maxSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);\n\n  if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n      interest.getKeyLocator().getKeyData() != null &&\n      interest.getKeyLocator().getKeyData().length > 0)\n    // There is a KEY_LOCATOR_DIGEST. Use this instead of the publisherPublicKeyDigest.\n    encoder.writeDTagElement\n      (NDNProtocolDTags.PublisherPublicKeyDigest, \n       interest.getKeyLocator().getKeyData());\n  else {\n    if (null != interest.publisherPublicKeyDigest)\n      interest.publisherPublicKeyDigest.to_ndnb(encoder);\n  }\n    \n  if (null != interest.exclude)\n    interest.exclude.to_ndnb(encoder);\n    \n  if (null != interest.childSelector) \n    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);\n\n  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null) \n    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);\n    \n  if (null != interest.scope) \n    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);\n    \n  if (null != interest.interestLifetime) \n    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime, \n                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));\n    \n  if (null != interest.nonce)\n    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);\n    \n  encoder.writeElementClose();\n};\n\n/**\n * Use the decoder to place the result in interest.\n * @param {Interest} interest\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeInterest = function(interest, decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name = new Name();\n  interest.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))\n    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);\n  else\n    interest.minSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents)) \n    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);\n  else\n    interest.maxSuffixComponents = null;\n      \n  // Initially clear the keyLocator.\n  interest.getKeyLocator().clear();\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    interest.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  else\n    interest.publisherPublicKeyDigest = null;\n  if (interest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest.length > 0) {\n    // We keep the deprecated publisherPublicKeyDigest for backwards \n    //   compatibility.  Also set the key locator.\n    interest.getKeyLocator().setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    interest.getKeyLocator().setKeyData\n      (interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {\n    interest.exclude = new Exclude();\n    interest.exclude.from_ndnb(decoder);\n  }\n  else\n    interest.exclude = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))\n    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);\n  else\n    interest.childSelector = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))\n    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);\n  else\n    interest.answerOriginKind = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.Scope))\n    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);\n  else\n    interest.scope = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))\n    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt\n               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;\n  else\n    interest.interestLifetime = null;              \n    \n  if (decoder.peekDTag(NDNProtocolDTags.Nonce))\n    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);\n  else\n    interest.nonce = null;\n    \n  decoder.readElementClose();\n};\n\n/**\n * Encode the data by calling the operations on the encoder.\n * @param {Data} data\n * @param {BinaryXMLEncoder} encoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.encodeData = function(data, encoder)  \n{\n  //TODO verify name, MetaInfo and Signature is present\n  encoder.writeElementStartDTag(data.getElementLabel());\n\n  if (null != data.signature) \n    data.signature.to_ndnb(encoder);\n    \n  var signedPortionBeginOffset = encoder.offset;\n\n  if (null != data.name) \n    data.name.to_ndnb(encoder);\n  \n  if (null != data.signedInfo) \n    // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n    //   the key locator from the MetaInfo to the Signauture object.\n    data.signedInfo.to_ndnb(encoder, data.getSignatureOrMetaInfoKeyLocator());\n\n  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);\n  \n  var signedPortionEndOffset = encoder.offset;\n  \n  encoder.writeElementClose();\n  \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Use the decoder to place the result in data.\n * @param {Data} data\n * @param {BinaryXMLDecoder} decoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.decodeData = function(data, decoder) \n{\n  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT\n  decoder.readElementStartDTag(data.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {\n    data.signature = new Signature();\n    data.signature.from_ndnb(decoder);\n  }\n  else\n    data.signature = null;\n    \n  var signedPortionBeginOffset = decoder.offset;\n\n  data.name = new Name();\n  data.name.from_ndnb(decoder);\n    \n  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {\n    data.signedInfo = new MetaInfo();\n    data.signedInfo.from_ndnb(decoder);\n    if (data.signedInfo.locator != null && data.getSignature() != null)\n      // Copy the key locator pointer to the Signature object for the transition \n      //   of moving the key locator from the MetaInfo to the Signature object.\n      data.getSignature().keyLocator = data.signedInfo.locator;\n  }\n  else\n    data.signedInfo = null;\n\n  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);\n    \n  var signedPortionEndOffset = decoder.offset;\n    \n  decoder.readElementClose();\n    \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n})()\n},{"../exclude.js":36,"../key-locator.js":40,"../meta-info.js":38,"../name.js":33,"../publisher-public-key-digest.js":41,"../signature.js":91,"../util/blob.js":49,"../util/ndn-protoco-id-tags.js":87,"./binary-xml-decoder.js":85,"./binary-xml-encoder.js":86,"./data-utils.js":47,"./wire-format.js":42}],44:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Tlv0_1a2WireFormat = require(\'./tlv-0_1a2-wire-format.js\').Tlv0_1a2WireFormat;\n\n/**\n * A TlvWireFormat extends Tlv0_1a2WireFormat to override its methods to \n * implement encoding and decoding using the preferred implementation of NDN-TLV.\n * @constructor\n */\nvar TlvWireFormat = function TlvWireFormat() \n{\n  // Inherit from Tlv0_1a2WireFormat.\n  Tlv0_1a2WireFormat.call(this);\n};\n\nTlvWireFormat.prototype = new Tlv0_1a2WireFormat();\nTlvWireFormat.prototype.name = "TlvWireFormat";\n\nexports.TlvWireFormat = TlvWireFormat;\n\n// Default object.\nTlvWireFormat.instance = null;\n\n/**\n * Get a singleton instance of a TlvWireFormat.  Assuming that the default \n * wire format was set with WireFormat.setDefaultWireFormat(TlvWireFormat.get()), \n * you can check if this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == TlvWireFormat.get().\n * @returns {TlvWireFormat} The singleton instance.\n */\nTlvWireFormat.get = function()\n{\n  if (TlvWireFormat.instance === null)\n    TlvWireFormat.instance = new TlvWireFormat();\n  return TlvWireFormat.instance;\n};\n\n// On loading this module, make this the default wire format.\n// This module will be loaded because WireFormat loads it.\nWireFormat.setDefaultWireFormat(TlvWireFormat.get());\n\n},{"./tlv-0_1a2-wire-format.js":121,"./wire-format.js":42}],47:[function(require,module,exports){\n(function(){/**\n * This class contains utilities to help parse the data\n *\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n\n/**\n * A DataUtils has static methods for converting data.\n * @constructor\n */\n\n\nvar DataUtils = function()\n{\n};\n\nexports.DataUtils = new DataUtils();\n\n/*\n * NOTE THIS IS CURRENTLY NOT BEING USED\n *\n */\n\nDataUtils.prototype.keyStr = "ABCDEFGHIJKLMNOP" +\n                   "QRSTUVWXYZabcdef" +\n                   "ghijklmnopqrstuv" +\n                   "wxyz0123456789+/" +\n                   "=";\n\n/**\n * Raw String to Base 64\n */\nDataUtils.prototype.stringtoBase64 = function stringtoBase64(input)\n{\n   //input = escape(input);\n   var output = "";\n   var chr1, chr2, chr3 = "";\n   var enc1, enc2, enc3, enc4 = "";\n   var i = 0;\n\n   do {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2))\n       enc3 = enc4 = 64;\n    else if (isNaN(chr3))\n       enc4 = 64;\n\n    output = output +\n       DataUtils.keyStr.charAt(enc1) +\n       DataUtils.keyStr.charAt(enc2) +\n       DataUtils.keyStr.charAt(enc3) +\n       DataUtils.keyStr.charAt(enc4);\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n   } while (i < input.length);\n\n   return output;\n};\n\n/**\n * Base 64 to Raw String\n */\nDataUtils.prototype.base64toString = function base64toString(input)\n{\n  var output = "";\n  var chr1, chr2, chr3 = "";\n  var enc1, enc2, enc3, enc4 = "";\n  var i = 0;\n\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n  /* Test for invalid characters. */\n  if (base64test.exec(input)) {\n    alert("There were invalid base64 characters in the input text.\\n" +\n          "Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\\n" +\n          "Expect errors in decoding.");\n  }\n\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");\n\n  do {\n    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 != 64)\n      output = output + String.fromCharCode(chr2);\n\n    if (enc4 != 64)\n      output = output + String.fromCharCode(chr3);\n\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n  } while (i < input.length);\n\n  return output;\n};\n\n/**\n * customBuf to Hex String\n */\nDataUtils.prototype.toHex = function(buffer)\n{\n  return buffer.toString(\'hex\');\n};\n\n/**\n * Raw string to hex string.\n */\nDataUtils.prototype.stringToHex = function(args)\n{\n  var ret = "";\n  for (var i = 0; i < args.length; ++i) {\n    var value = args.charCodeAt(i);\n    ret += (value < 16 ? "0" : "") + value.toString(16);\n  }\n  return ret;\n};\n\n/**\n * customBuf to raw string.\n */\nDataUtils.prototype.toString = function(buffer)\n{\n  return buffer.toString(\'binary\');\n};\n\n/**\n * Hex String to customBuf.\n */\nDataUtils.prototype.toNumbers = function(str)\n{\n  return new customBuf(str, \'hex\');\n};\n\n/**\n * Hex String to raw string.\n */\nDataUtils.prototype.hexToRawString = function(str)\n{\n  if (typeof str ==\'string\') {\n  var ret = "";\n  str.replace(/(..)/g, function(s) {\n    ret += String.fromCharCode(parseInt(s, 16));\n  });\n  return ret;\n  }\n};\n\n/**\n * Raw String to customBuf.\n */\nDataUtils.prototype.toNumbersFromString = function(str)\n{\n  return new customBuf(str, \'binary\');\n};\n\n/**\n * Encode str as utf8 and return as customBuf.\n * If value is a string, then interpret it as a raw string and convert to\n * a Buffer. Otherwise assume it is a Buffer or array type and just return it.\n * @param {string|any} value\n * @returns {Buffer}\n */\nDataUtils.prototype.toNumbersIfString = function(value)\n{\n  if (typeof value === \'string\')\n    return new customBuf(value, \'binary\');\n  else\n    return value;\n};\n\n/**\n * Encode str as utf8 and return as Buffer.\n */\nDataUtils.prototype.stringToUtf8Array = function(str)\n{\n  return new customBuf(str, \'utf8\');\n};\n\n/**\n * arrays is an array of customBuf. Return a new customBuf which is the concatenation of all.\n */\nDataUtils.prototype.concatArrays = function(arrays)\n{\n  return customBuf.concat(arrays);\n};\n\n// TODO: Take customBuf and use TextDecoder when available.\nDataUtils.prototype.decodeUtf8 = function(utftext)\n{\n  var string = "";\n  var i = 0;\n  var c = 0;\n    var c1 = 0;\n    var c2 = 0;\n\n  while (i < utftext.length) {\n    c = utftext.charCodeAt(i);\n\n    if (c < 128) {\n      string += String.fromCharCode(c);\n      i++;\n    }\n    else if (c > 191 && c < 224) {\n      c2 = utftext.charCodeAt(i + 1);\n      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n      i += 2;\n    }\n    else {\n      c2 = utftext.charCodeAt(i+1);\n      var c3 = utftext.charCodeAt(i+2);\n      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n      i += 3;\n    }\n  }\n\n  return string;\n};\n\n/**\n * Return true if a1 and a2 are the same length with equal elements.\n */\nDataUtils.prototype.arraysEqual = function(a1, a2)\n{\n  // A simple sanity check that it is an array.\n  if (!a1.slice)\n    throw new Error("DataUtils.arraysEqual: a1 is not an array");\n  if (!a2.slice)\n    throw new Error("DataUtils.arraysEqual: a2 is not an array");\n\n  if (a1.length != a2.length)\n    return false;\n\n  for (var i = 0; i < a1.length; ++i) {\n    if (a1[i] != a2[i])\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Convert the big endian customBuf to an unsigned int.\n * Don\'t check for overflow.\n */\nDataUtils.prototype.bigEndianToUnsignedInt = function(bytes)\n{\n  var result = 0;\n  for (var i = 0; i < bytes.length; ++i) {\n    result <<= 8;\n    result += bytes[i];\n  }\n  return result;\n};\n\n/**\n * Convert the int value to a new big endian customBuf and return.\n * If value is 0 or negative, return new customBuf(0).\n */\nDataUtils.prototype.nonNegativeIntToBigEndian = function(value)\n{\n  value = Math.round(value);\n  if (value <= 0)\n    return new customBuf(0);\n\n  // Assume value is not over 64 bits.\n  var size = 8;\n  var result = new customBuf(size);\n  var i = 0;\n  while (value != 0) {\n    ++i;\n    result[size - i] = value & 0xff;\n    value >>= 8;\n  }\n  return result.slice(size - i, size);\n};\n\n/**\n * Modify array to randomly shuffle the elements.\n */\nDataUtils.prototype.shuffle = function(array)\n{\n  for (var i = array.length - 1; i >= 1; --i) {\n    // j is from 0 to i.\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n};\n\n})()\n},{"../buffer.js":54}],48:[function(require,module,exports){\n(function(){/**\n * This file contains utilities to help encode and decode NDN objects.\n * Copyright (C) 2013-2014 Regents of the University of California.\n * author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Key = require(\'../key.js\').Key;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Interest = require(\'../interest.js\').Interest;\nvar Data = require(\'../data.js\').Data;\nvar FaceInstance = require(\'../face-instance.js\').FaceInstance;\nvar ForwardingEntry = require(\'../forwarding-entry.js\').ForwardingEntry;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * An EncodingUtils has static methods for encoding data.\n * @constructor\n */\nvar EncodingUtils = function EncodingUtils() \n{\n};\n\nexports.EncodingUtils = EncodingUtils;\n\nEncodingUtils.encodeToHexInterest = function(interest, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(interest.wireEncode(wireFormat).buf());\n};\n\nEncodingUtils.encodeToHexData = function(data, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(data.wireEncode(wireFormat).buf());\n};\n\n/**\n * @deprecated Use EncodingUtils.encodeToHexData(data).\n */\nEncodingUtils.encodeToHexContentObject = function(data, wireFormat) \n{\n  return EncodingUtils.encodeToHexData(data, wireFormat);\n}\n\nEncodingUtils.encodeForwardingEntry = function(data) \n{\n  var enc = new BinaryXMLEncoder();\n  data.to_ndnb(enc);\n  var bytes = enc.getReducedOstream();\n\n  return bytes;\n};\n\nEncodingUtils.decodeHexFaceInstance = function(result) \n{  \n  var numbers = DataUtils.toNumbers(result); \n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODING HEX FACE INSTANCE  \\n\'+numbers);\n\n  var faceInstance = new FaceInstance();\n  faceInstance.from_ndnb(decoder);\n  \n  return faceInstance;\n};\n\nEncodingUtils.decodeHexInterest = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var interest = new Interest();\n  interest.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return interest;\n};\n\nEncodingUtils.decodeHexData = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var data = new Data();\n  data.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return data;\n};\n\n/**\n * @deprecated Use EncodingUtils.decodeHexData(input).\n */\nEncodingUtils.decodeHexContentObject = function(input, wireFormat) \n{\n  return EncodingUtils.decodeHexData(input, wireFormat);\n}\n\nEncodingUtils.decodeHexForwardingEntry = function(result) \n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODED HEX FORWARDING ENTRY \\n\'+numbers);\n  \n  var forwardingEntry = new ForwardingEntry();\n  forwardingEntry.from_ndnb(decoder);\n  return forwardingEntry;\n};\n\n/**\n * Decode the customBuf array which holds SubjectPublicKeyInfo and return an RSAKey.\n */\nEncodingUtils.decodeSubjectPublicKeyInfo = function(array) \n{\n  var hex = DataUtils.toHex(array).toLowerCase();\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));\n  var rsaKey = new RSAKey();\n  rsaKey.setPublic(a[0], a[1]);\n  return rsaKey;\n}\n\n/**\n * Return a user friendly HTML string with the contents of data.\n * This also outputs to console.log.\n */\nEncodingUtils.dataToHtml = function(/* Data */ data) \n{\n  var output ="";\n      \n  if (data == -1)\n    output+= "NO CONTENT FOUND"\n  else if (data == -2)\n    output+= "CONTENT NAME IS EMPTY"\n  else {\n    if (data.name != null && data.name.components != null) {\n      output+= "NAME: " + data.name.toUri();\n        \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.digestAlgorithm != null) {\n      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.witness != null) {\n      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.signature != null) {\n      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {\n      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.timestamp != null) {\n      var d = new Date();\n      d.setTime(data.signedInfo.timestamp.msec);\n      \n      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];\n      \n      output += "TimeStamp: "+d;\n      output+= "<br />";\n      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;\n      \n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {\n      output += "keyLocator: ";\n      if (data.signedInfo.locator.type == KeyLocatorType.KEY)\n        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n        output += "KeyLocatorDigest: " + DataUtils.toHex(data.signedInfo.locator.getKeyData()).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)\n        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)\n        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";\n      else\n        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";      \n    }\n  }\n\n  return output;\n};\n\n/**\n * @deprecated Use return EncodingUtils.dataToHtml(data).\n */\nEncodingUtils.contentObjectToHtml = function(data) \n{\n  return EncodingUtils.dataToHtml(data);\n}\n\n//\n// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.\n//\n\nvar encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }\nvar encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }\nvar encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }\nvar decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }\nvar decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }\nvar decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }\nvar decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }\nvar decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }\nvar contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }\n\n/**\n * @deprecated Use interest.wireEncode().\n */\nfunction encodeToBinaryInterest(interest) { return interest.wireEncode().buf(); }\n/**\n * @deprecated Use data.wireEncode().\n */\nfunction encodeToBinaryContentObject(data) { return data.wireEncode().buf(); }\n\n})()\n},{"../data.js":37,"../face-instance.js":122,"../forwarding-entry.js":84,"../interest.js":35,"../key-locator.js":40,"../key.js":39,"../log.js":89,"./binary-xml-decoder.js":85,"./binary-xml-encoder.js":86,"./data-utils.js":47,"./wire-format.js":42}],49:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * A Blob holds an immutable byte array implemented as a customBuf.  This should be \n * treated like a string which is a pointer to an immutable string. (It is OK to \n * pass a pointer to the string because the new owner can\u2019t change the bytes of \n * the string.)  Blob does not inherit from customBuf. Instead you must call buf() \n * to get the byte array which reminds you that you should not change the \n * contents.  Also remember that buf() can return null.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {boolean} copy (optional) (optional) If true, copy the contents of \n * value into a new customBuf.  If false, just use the existing value without \n * copying. If omitted, then copy the contents (unless value is already a Blob).\n * IMPORTANT: If copy is false, if you keep a pointer to the value then you must\n * treat the value as immutable and promise not to change it.\n */\nvar Blob = function Blob(value, copy) \n{\n  if (copy == null)\n    copy = true;\n  \n  if (value == null)\n    this.buffer = null;\n  else if (typeof value === \'object\' && value instanceof Blob)\n    // Use the existing buffer.  Don\'t need to check for copy.\n    this.buffer = value.buffer;\n  else {\n    if (typeof value === \'string\')\n      // Convert from a string to utf-8 byte encoding.\n      this.buffer = new customBuf(value, \'utf8\');\n    else {\n      if (copy)\n        // We are copying, so just make another customBuf.\n        this.buffer = new customBuf(value);\n      else {\n        if (typeof value === \'object\' && value instanceof customBuf)\n          // We can use as-is.\n          this.buffer = value;\n        else\n          // We need a customBuf, so copy.\n          this.buffer = new customBuf(value);\n      }\n    }\n  }\n};\n\nexports.Blob = Blob;\n\n/**\n * Return the length of the immutable byte array.\n * @returns {number} The length of the array.  If buf() is null, return 0.\n */\nBlob.prototype.size = function()\n{\n  if (this.buffer != null)\n    return this.buffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return the immutable byte array.  DO NOT change the contents of the customBuf.  \n * If you need to change it, make a copy.\n * @returns {Buffer} The customBuf holding the immutable byte array, or null.\n */\nBlob.prototype.buf = function()\n{\n  return this.buffer;\n};\n\n/**\n * Return true if the array is null, otherwise false.\n * @returns {boolean} True if the array is null.\n */\nBlob.prototype.isNull = function()\n{\n  return this.buffer == null;\n};\n\n/**\n * Return the hex representation of the bytes in the byte array.\n * @returns {string} The hex string.\n */\nBlob.prototype.toHex = function() \n{  \n  if (this.buffer == null)\n    return "";\n  else\n    return this.buffer.toString(\'hex\');\n};\n\n})()\n},{"../buffer.js":54}],50:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar BinaryXMLDecoder = require(\'../encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Name = require(\'../name.js\').Name;\n\n/**\n * Create a context for getting the response from the name enumeration command, as neede by getComponents.\n * (To do name enumeration, call the static method NameEnumeration.getComponents.)\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nvar NameEnumeration = function NameEnumeration(face, onComponents) \n{\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n  \n  var self = this;\n  this.onData = function(interest, data) { self.processData(data); };\n  this.onTimeout = function(interest) { self.processTimeout(); };\n};\n\nexports.NameEnumeration = NameEnumeration;\n\n/**\n * Use the name enumeration protocol to get the child components of the name prefix.\n * @param {Face} face The Face object for using expressInterest.\n * @param {Name} name The name prefix for finding the child components.\n * @param {function} onComponents On getting the response, this calls onComponents(components) where\n * components is an array of customBuf name components.  If there is no response, this calls onComponents(null). \n */\nNameEnumeration.getComponents = function(face, prefix, onComponents)\n{\n  var command = new Name(prefix);\n  // Add %C1.E.be\n  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])\n  \n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n/**\n * Parse the response from the name enumeration command and call this.onComponents.\n * @param {Data} data\n */\nNameEnumeration.prototype.processData = function(data) \n{\n  try {\n    if (!NameEnumeration.endsWithSegmentNumber(data.name))\n      // We don\'t expect a name without a segment number.  Treat it as a bad packet.\n      this.onComponents(null);\n    else {\n      var segmentNumber = DataUtils.bigEndianToUnsignedInt\n          (data.name.get(data.name.size() - 1).getValue());\n\n      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.\n      var expectedSegmentNumber = this.contentParts.length;\n      if (segmentNumber != expectedSegmentNumber)\n        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);\n      else {\n        // Save the content and check if we are finished.\n        this.contentParts.push(data.content);\n\n        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);\n          if (segmentNumber == finalSegmentNumber) {\n            // We are finished.  Parse and return the result.\n            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));\n            return;\n          }\n        }\n\n        // Fetch the next segment.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);\n      }\n    }\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Just call onComponents(null).\n */\nNameEnumeration.prototype.processTimeout = function()\n{\n  try {\n    this.onComponents(null);\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.\n * @param {Uint8Array} content The content to parse.\n * @returns {Array<Buffer>} The array of components.\n */\nNameEnumeration.parseComponents = function(content)\n{\n  var components = [];\n  var decoder = new BinaryXMLDecoder(content);\n  \n  decoder.readElementStartDTag(NDNProtocolDTags.Collection);\n \n  while (decoder.peekDTag(NDNProtocolDTags.Link)) {\n    decoder.readElementStartDTag(NDNProtocolDTags.Link);    \n    decoder.readElementStartDTag(NDNProtocolDTags.Name);\n    \n    components.push(new customBuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));\n    \n    decoder.readElementClose();  \n    decoder.readElementClose();  \n  }\n\n  decoder.readElementClose();\n  return components;\n};\n\n/**\n * Check if the last component in the name is a segment number.\n * TODO: Move to Name class.\n * @param {Name} name\n * @returns {Boolean} True if the name ends with a segment number, otherwise false.\n */\nNameEnumeration.endsWithSegmentNumber = function(name) {\n  return name.components != null && name.size() >= 1 &&\n         name.get(name.size() - 1).getValue().length >= 1 &&\n         name.get(name.size() - 1).getValue()[0] == 0;\n};\n\n})(require("__browserify_buffer").Buffer)\n},{"../buffer.js":54,"../encoding/binary-xml-decoder.js":85,"../encoding/data-utils.js":47,"../name.js":33,"./ndn-protoco-id-tags.js":87,"__browserify_buffer":73}],51:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents NDNTime Objects\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar NDNTime = function NDNTime(input) \n{\n  this.NANOS_MAX = 999877929;\n  \n  if (typeof input ==\'number\')\n    this.msec = input;\n  else {\n    if (LOG > 1) console.log(\'UNRECOGNIZED TYPE FOR TIME\');\n  }\n};\n\nexports.NDNTime = NDNTime;\n\nNDNTime.prototype.getJavascriptDate = function() \n{\n  var d = new Date();\n  d.setTime(this.msec);\n  return d\n};  \n\n},{"../log.js":89}],52:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar Key = require(\'../key.js\').Key;\n\n/**\n * @constructor\n */\nvar KeyManager = function KeyManager()\n{\n  this.certificate = \n  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +\n  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +\n  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +\n  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +\n  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +\n  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +\n  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +\n  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +\n  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";\n\n  // Public Key\n    this.publicKey = \n  "-----BEGIN PUBLIC KEY-----\\n" +\n  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\\n" +\n  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\\n" +\n  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\\n" +\n  "WFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "-----END PUBLIC KEY-----";\n  // Private Key\n    this.privateKey = \n  "-----BEGIN RSA PRIVATE KEY-----\\n" +\n  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\\n" +\n  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\\n" +\n  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\\n" +\n  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\\n" +\n  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\\n" +\n  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\\n" +\n  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\\n" +\n  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\\n" +\n  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\\n" +\n  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\\n" +\n  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\\n" +\n  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\\n" +\n  "-----END RSA PRIVATE KEY-----";\n  \n  this.key = null;\n};\n\n/**\n * Return a Key object for the keys in this KeyManager.  This creates the Key on the first\n * call and returns a cached copy after that.\n * @returns {Key}\n */\nKeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n  \n  return this.key;\n}\n\nvar globalKeyManager = globalKeyManager || new KeyManager();\nexports.globalKeyManager = globalKeyManager;\n\n},{"../key.js":39}],53:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLStructureDecoder = require(\'./binary-xml-structure-decoder.js\').BinaryXMLStructureDecoder;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvStructureDecoder = require(\'./tlv/tlv-structure-decoder.js\').TlvStructureDecoder;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * A ElementReader lets you call onReceivedData multiple times which uses a\n * BinaryXMLStructureDecoder or TlvStructureDecoder to detect the end of a\n * binary XML or TLV element and calls elementListener.onReceivedElement(element)\n * with the element.  This handles the case where a single call to\n * onReceivedData may contain multiple elements.\n * @constructor\n * @param {{onReceivedElement:function}} elementListener\n */\nvar ElementReader = function ElementReader(elementListener)\n{\n  this.elementListener = elementListener;\n  this.dataParts = [];\n  this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n  this.tlvStructureDecoder = new TlvStructureDecoder();\n  this.useTlv = null;\n};\n\nexports.ElementReader = ElementReader;\n\nElementReader.prototype.onReceivedData = function(/* customBuf */ data)\n{\n  // Process multiple objects in the data.\n  while (true) {\n    if (this.dataParts.length == 0) {\n      // This is the beginning of an element.  Check whether it is binaryXML or TLV.\n      if (data.length <= 0)\n        // Wait for more data.\n        return;\n\n      // The type codes for TLV Interest and Data packets are chosen to not\n      //   conflict with the first byte of a binary XML packet, so we can\n      //   just look at the first byte.\n      if (data[0] == Tlv.Interest || data[0] == Tlv.Data || data[0] == 0x80)\n        this.useTlv = true;\n      else\n        // Binary XML.\n        this.useTlv = false;\n    }\n\n    var gotElementEnd;\n    var offset;\n    if (this.useTlv) {\n      // Scan the input to check if a whole TLV object has been read.\n      this.tlvStructureDecoder.seek(0);\n      gotElementEnd = this.tlvStructureDecoder.findElementEnd(data);\n      offset = this.tlvStructureDecoder.getOffset();\n    }\n    else {\n      // Scan the input to check if a whole Binary XML object has been read.\n      this.binaryXmlStructureDecoder.seek(0);\n      gotElementEnd = this.binaryXmlStructureDecoder.findElementEnd(data);\n      offset = this.binaryXmlStructureDecoder.offset;\n    }\n\n    if (gotElementEnd) {\n      // Got the remainder of an object.  Report to the caller.\n      this.dataParts.push(data.slice(0, offset));\n      var element = DataUtils.concatArrays(this.dataParts);\n      this.dataParts = [];\n      try {\n        this.elementListener.onReceivedElement(element);\n      } catch (ex) {\n          console.log("ElementReader: ignoring exception from onReceivedElement: " , ex);\n      }\n\n      // Need to read a new object.\n      data = data.slice(offset, data.length);\n      this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n      this.tlvStructureDecoder = new TlvStructureDecoder();\n      if (data.length == 0)\n        // No more data in the packet.\n        return;\n\n      // else loop back to decode.\n    }\n    else {\n      // Save for a later call to concatArrays so that we only copy data once.\n      this.dataParts.push(data);\n      if (LOG > 3) console.log(\'Incomplete packet received. Length \' + data.length + \'. Wait for more input.\');\n        return;\n    }\n  }\n};\n\n})()\n},{"../buffer.js":54,"../log.js":89,"./binary-xml-structure-decoder.js":123,"./data-utils.js":47,"./tlv/tlv-structure-decoder.js":124,"./tlv/tlv.js":46}],81:[function(require,module,exports){\n// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee "cryptographic quality"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  if (_global.crypto && crypto.getRandomValues) {\n    whatwgRNG = function(size) {\n      var bytes = new Uint8Array(size);\n      crypto.getRandomValues(bytes);\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n\n},{}],125:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],45:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DecodingException = require(\'../decoding-exception.js\').DecodingException;\n\n/**\n * Create a new TlvDecoder for decoding the input in the NDN-TLV wire format.\n * @constructor\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nvar TlvDecoder = function TlvDecoder(input)\n{\n  this.input = input;\n  this.offset = 0;\n};\n\nexports.TlvDecoder = TlvDecoder;\n\n/**\n * Decode VAR-NUMBER in NDN-TLV and return it. Update offset.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readVarNumber = function() \n{\n  // Assume array values are in the range 0 to 255.\n  var firstOctet = this.input[this.offset];\n  this.offset += 1;\n  if (firstOctet < 253)\n    return firstOctet;\n  else\n    return this.readExtendedVarNumber(firstOctet);\n};\n\n/**\n * A private function to do the work of readVarNumber, given the firstOctet\n * which is >= 253.\n * @param {number} firstOctet The first octet which is >= 253, used to decode \n * the remaining bytes.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readExtendedVarNumber = function(firstOctet) \n{\n  // This is a private function so we know firstOctet >= 253.\n  if (firstOctet == 253) {\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n    this.offset += 2;\n  }\n  else if (firstOctet == 254) {\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n    this.offset += 4;\n  }\n  else {\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n    this.offset += 8;\n  }\n  \n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType and return the length. Update offset.  Also make \n * sure the decoded length does not exceed the number of bytes remaining in the \n * input.\n * @param {number} expectedType The expected type.\n * @returns {number} The length of the TLV.\n * @throws DecodingException if (did not get the expected TLV type or the TLV length \n * exceeds the buffer length.\n */\nTlvDecoder.prototype.readTypeAndLength = function(expectedType) \n{\n  var type = this.readVarNumber();\n  if (type != expectedType)\n    throw new DecodingException("Did not get the expected TLV type");\n\n  var length = this.readVarNumber();\n  if (this.offset + length > this.input.length)\n    throw new DecodingException("TLV length exceeds the buffer length");\n\n  return length;\n};\n\n/**\n * Decode the type and length from the input starting at offset, expecting the \n * type to be expectedType.  Update offset.  Also make sure the decoded length \n * does not exceed the number of bytes remaining in the input. Return the offset \n * of the end of this parent TLV, which is used in decoding optional nested \n * TLVs. After reading all nested TLVs, call finishNestedTlvs.\n * @param {number} expectedType The expected type.\n * @returns {number} The offset of the end of the parent TLV.\n * @throws DecodingException if did not get the expected TLV type or the TLV \n * length exceeds the buffer length.\n */\nTlvDecoder.prototype.readNestedTlvsStart = function(expectedType) \n{\n  return this.readTypeAndLength(expectedType) + this.offset;\n};\n\n/**\n * Call this after reading all nested TLVs to skip any remaining unrecognized \n * TLVs and to check if the offset after the final nested TLV matches the \n * endOffset returned by readNestedTlvsStart.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @throws DecodingException if the TLV length does not equal the total length \n * of the nested TLVs.\n */\nTlvDecoder.prototype.finishNestedTlvs = function(endOffset) \n{\n  // We expect offset to be endOffset, so check this first.\n  if (this.offset == endOffset)\n    return;\n\n  // Skip remaining TLVs.\n  while (this.offset < endOffset) {\n    // Skip the type VAR-NUMBER.\n    this.readVarNumber();\n    // Read the length and update offset.\n    var length = this.readVarNumber();\n    this.offset += length;\n\n    if (this.offset > this.input.length)\n      throw new DecodingException("TLV length exceeds the buffer length");\n  }\n  \n  if (this.offset != endOffset)\n    throw new DecodingException\n      ("TLV length does not equal the total length of the nested TLVs");\n};\n\n/**\n * Decode the type from this\'s input starting at offset, and if it is the \n * expectedType, then return true, else false.  However, if this\'s offset is \n * greater than or equal to endOffset, then return false and don\'t try to read \n * the type. Do not update offset.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true if the type of the next TLV is the expectedType, \n *  otherwise false.\n */\nTlvDecoder.prototype.peekType = function(expectedType, endOffset) \n{\n  if (this.offset >= endOffset)\n    // No more sub TLVs to look at.\n    return false;\n  else {\n    var saveOffset = this.offset;\n    var type = this.readVarNumber();\n    // Restore offset.\n    this.offset = saveOffset;\n\n    return type == expectedType;\n  }\n};\n\n/**\n * Decode a non-negative integer in NDN-TLV and return it. Update offset by \n * length.\n * @param {number} length The number of bytes in the encoded integer.\n * @returns {number} The integer.\n * @throws DecodingException if length is an invalid length for a TLV \n * non-negative integer.\n */\nTlvDecoder.prototype.readNonNegativeInteger = function(length) \n{\n  var result;\n  if (length == 1)\n    result = this.input[this.offset];\n  else if (length == 2)\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n  else if (length == 4)\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n  else if (length == 8)\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n  else\n    throw new DecodingException("Invalid length for a TLV nonNegativeInteger");\n\n  this.offset += length;\n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then decode a non-negative integer in NDN-TLV \n * and return it.  Update offset.\n * @param {number} expectedType The expected type.\n * @returns {number} The integer.\n * @throws DecodingException if did not get the expected TLV type or can\'t \n * decode the value.\n */\nTlvDecoder.prototype.readNonNegativeIntegerTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  return this.readNonNegativeInteger(length);\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call \n * readNonNegativeIntegerTlv and return the integer.  Otherwise, return null.  \n * However, if this\'s offset is greater than or equal to endOffset, then return \n * null and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {number} The integer or null if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readOptionalNonNegativeIntegerTlv = function\n  (expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readNonNegativeIntegerTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then return an array of the bytes in the value.\n * Update offset.\n * @param {number} expectedType The expected type.\n * @returns {Buffer} The bytes in the value as a slice on the buffer.  This is\n * not a copy of the bytes in the input buffer.  If you need a copy, then you \n * must make a copy of the return value.\n * @throws DecodingException if did not get the expected TLV type.\n */\nTlvDecoder.prototype.readBlobTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  var result = this.input.slice(this.offset, this.offset + length);\n\n  // readTypeAndLength already checked if length exceeds the input buffer.\n  this.offset += length;\n  return result;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call readBlobTlv \n * and return the value.  Otherwise, return null. However, if this\'s offset is \n * greater than or equal to endOffset, then return null and don\'t try to read \n * the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {Buffer} The bytes in the value as a slice on the buffer or null if \n * the next TLV doesn\'t have the expected type.  This is not a copy of the bytes \n * in the input buffer.  If you need a copy, then you must make a copy of the \n * return value.\n */\nTlvDecoder.prototype.readOptionalBlobTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readBlobTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then read a type and \n * value, ignoring the value, and return true. Otherwise, return false.\n * However, if this\'s offset is greater than or equal to endOffset, then return \n * false and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true, or else false if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readBooleanTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset)) {\n    var length = this.readTypeAndLength(expectedType);\n    // We expect the length to be 0, but update offset anyway.\n    this.offset += length;\n    return true;\n  }\n  else\n    return false;\n};\n\n/**\n * Get the offset into the input, used for the next read.\n * @returns {number} The offset.\n */\nTlvDecoder.prototype.getOffset = function() \n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};  \n\n})()\n},{"../../buffer.js":54,"../decoding-exception.js":126}],57:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Forwarding Entries\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar Name = require(\'./name.js\').Name;\n\n/**\n * Create a new ForwardingEntry with the optional arguments.\n * @constructor\n * @param {String} action\n * @param {Name} prefixName\n * @param {PublisherPublicKeyDigest} ndndId\n * @param {number} faceID\n * @param {number} flags\n * @param {number} lifetime in seconds\n */\nvar ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime) \n{\n  this.action = action;\n  this.prefixName = prefixName;\n  this.ndndID = ndndId;\n  this.faceID = faceID;\n  this.flags = flags;\n  this.lifetime = lifetime;\n};\n\nexports.ForwardingEntry = ForwardingEntry;\n\nForwardingEntry.ACTIVE         = 1;\nForwardingEntry.CHILD_INHERIT  = 2;\nForwardingEntry.ADVERTISE      = 4;\nForwardingEntry.LAST           = 8;\nForwardingEntry.CAPTURE       = 16;\nForwardingEntry.LOCAL         = 32;\nForwardingEntry.TAP           = 64;\nForwardingEntry.CAPTURE_OK   = 128;\n\nForwardingEntry.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n  //throws DecodingException\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action); \n  if (decoder.peekDTag(NDNProtocolDTags.Name)) {\n    this.prefixName = new Name();\n    this.prefixName.from_ndnb(decoder) ;\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.NdndId = new PublisherPublicKeyDigest();\n    this.NdndId.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID); \n  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))\n    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\nForwardingEntry.prototype.to_ndnb = function(\n  //XMLEncoder \n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.prefixName)\n    this.prefixName.to_ndnb(encoder);\n  if (null != this.NdndId)\n    this.NdndId.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.flags)\n    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);\n  if (null != this.lifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);\n\n  encoder.writeElementClose();         \n};\n\nForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }\n\n},{"./name.js":9,"./publisher-public-key-digest.js":17,"./util/ndn-protoco-id-tags.js":60}],61:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.\nexports.TcpTransport = require(\'./transport/web-socket-transport.js\').WebSocketTransport;\n\n},{"./transport/web-socket-transport.js":127}],65:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data Signature object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Signature with the optional values.\n * @constructor\n */\nvar Signature = function Signature(witnessOrSignatureObject, signature, digestAlgorithm) \n{\n  if (typeof witnessOrSignatureObject === \'object\' && \n      witnessOrSignatureObject instanceof Signature) {\n    // Copy the values.\n    this.keyLocator = new KeyLocator(witnessOrSignatureObject.keyLocator);\n    this.signature = witnessOrSignatureObject.signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject.witness;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = witnessOrSignatureObject.digestAlgorithm;\n  }\n  else {\n    this.keyLocator = new KeyLocator();\n    this.signature = signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = digestAlgorithm;\n  }\n};\n\nexports.Signature = Signature;\n\n/**\n * Create a new Signature which is a copy of this object.\n * @returns {Signature} A new object which is a copy of this object.\n */\nSignature.prototype.clone = function()\n{\n  return new Signature(this);\n};\n\n/**\n * Get the key locator.\n * @returns {KeyLocator} The key locator.\n */\nSignature.prototype.getKeyLocator = function()\n{\n  return this.keyLocator;\n};\n\n/**\n * Get the data packet\'s signature bytes.\n * @returns {Buffer} The signature bytes.\n */\nSignature.prototype.getSignature = function()\n{\n  return this.signature;\n};\n\n/**\n * Set the key locator to a copy of the given keyLocator.\n * @param {KeyLocator} keyLocator The KeyLocator to copy.\n */\nSignature.prototype.setKeyLocator = function(keyLocator)\n{\n  this.keyLocator = typeof keyLocator === \'object\' && keyLocator instanceof KeyLocator ?\n                    new KeyLocator(keyLocator) : new KeyLocator();\n};\n  \n/**\n * Set the data packet\'s signature bytes.\n * @param {type} signature\n */\nSignature.prototype.setSignature = function(signature)\n{\n  if (signature == null)\n    this.signature = null;\n  else if (typeof signature === \'object\' && signature instanceof Blob)\n    this.signature = new customBuf(signature.buf());\n  else\n    this.signature = new customBuf(signature);\n};\n\nSignature.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'STARTED DECODING SIGNATURE\');\n    \n  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {\n    if (LOG > 4) console.log(\'DIGIEST ALGORITHM FOUND\');\n    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm); \n  }\n  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {\n    if (LOG > 4) console.log(\'WITNESS FOUND\');\n    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness); \n  }\n    \n  //FORCE TO READ A SIGNATURE\n\n  if (LOG > 4) console.log(\'SIGNATURE FOUND\');\n  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);\n\n  decoder.readElementClose();\n};\n\nSignature.prototype.to_ndnb = function(encoder) \n{      \n  if (!this.validate())\n    throw new Error("Cannot encode: field values missing.");\n  \n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))\n    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));\n  \n  if (null != this.witness)\n    // needs to handle null witness\n    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);\n\n  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);\n\n  encoder.writeElementClose();       \n};\n\nSignature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };\n\nSignature.prototype.validate = function() \n{\n  return null != this.signature;\n};\n\n})()\n},{"./buffer.js":30,"./encoding/binary-xml-decoder.js":58,"./encoding/binary-xml-encoder.js":59,"./key-locator.js":16,"./log.js":62,"./util/blob.js":25,"./util/ndn-protoco-id-tags.js":60}],128:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],83:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === \'function\'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === \'[object Array]\'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled \'error\' event\n      } else {\n        throw new Error("Uncaught, unspecified \'error\' event.");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == \'function\') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'addListener only takes instances of Function\');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == "newListeners"! Before\n  // adding it to the listeners, first emit "newListeners".\n  this.emit(\'newListener\', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error(\'(node) warning: possible EventEmitter memory \' +\n                      \'leak detected. %d listeners added. \' +\n                      \'Use emitter.setMaxListeners() to increase limit.\',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'removeListener only takes instances of Function\');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (typeof emitter._events[type] === \'function\')\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\n})(require("__browserify_process"))\n},{"__browserify_process":128}],63:[function(require,module,exports){\n(function(){var assert = require(\'assert\');\nexports.Buffer = Buffer;\nexports.SlowBuffer = Buffer;\nBuffer.poolSize = 8192;\nexports.INSPECT_MAX_BYTES = 50;\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n  this.parent = this;\n  this.offset = 0;\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this[i] = subject.readUInt8(i);\n        }\n        else {\n          this[i] = subject[i];\n        }\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    } else if (type === \'number\') {\n      for (var i = 0; i < this.length; i++) {\n        this[i] = 0;\n      }\n    }\n  }\n}\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this[i];\n};\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this[i] = v;\n};\n\nBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n    case \'binary\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;\n\nBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n};\n\nBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nBuffer.prototype.binarySlice = Buffer.prototype.asciiSlice;\n\nBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  Buffer._charsWritten = i * 2;\n  return i;\n};\n\n\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  if (end === undefined || isNaN(end)) {\n    end = this.length;\n  }\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  var temp = [];\n  for (var i=start; i<end; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=target_start; i<target_start+temp.length; i++) {\n    target[i] = temp[i-target_start];\n  }\n};\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof Buffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// helpers\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\nfunction isArray(subject) {\n  return (Array.isArray ||\n    function(subject){\n      return {}.toString.apply(subject) == \'[object Array]\'\n    })\n    (subject)\n}\n\nfunction isArrayIsh(subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\n// read/write bit-twiddling\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer[offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer[offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1];\n    }\n  } else {\n    val = buffer[offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer[offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer[offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer[offset + 3];\n    val = val + (buffer[offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer[offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer[offset + 1] << 8;\n    val |= buffer[offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer[offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer[offset] & 0x80;\n  if (!neg) {\n    return (buffer[offset]);\n  }\n\n  return ((0xff - buffer[offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer[offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer[offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer[offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\n})()\n},{"./buffer_ieee754":125,"assert":76,"base64-js":129}],66:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Publisher and PublisherType Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNProtocolDTagsStrings = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTagsStrings;\nvar DecodingException = require(\'./encoding/decoding-exception.js\').DecodingException;\n\n/**\n * @constructor\n */\nvar PublisherType = function PublisherType(tag) \n{\n  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;\n  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;\n  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;\n  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  this.Tag = tag;\n}; \n\n/**\n * @constructor\n */\nvar PublisherID = function PublisherID() \n{\n  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";\n  this.PUBLISHER_ID_LEN = 256/8;\n    \n  //TODO, implement publisherID creation and key creation\n\n  //TODO implement generatePublicKeyDigest\n  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray\n    \n  //TODO implement generate key\n  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);\n  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type   \n};\n\nexports.PublisherID = PublisherID;\n\nPublisherID.prototype.from_ndnb = function(decoder) \n{    \n  // We have a choice here of one of 4 binary element types.\n  var nextTag = PublisherID.peekAndGetNextDTag(decoder);\n    \n  this.publisherType = new PublisherType(nextTag); \n    \n  if (nextTag < 0)\n    throw new Error("Invalid publisher ID, got unexpected type");\n\n  this.publisherID = decoder.readBinaryDTagElement(nextTag);\n  if (null == this.publisherID)\n    throw new DecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));\n};\n\nPublisherID.prototype.to_ndnb = function(encoder) \n{\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);\n};\n\n/**\n * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.\n * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.\n * @returns {number} The PublisherID DTag or -1 if it is not one of them.\n */\nPublisherID.peekAndGetNextDTag = function(decoder) \n{\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))\n    return             NDNProtocolDTags.PublisherPublicKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))\n    return             NDNProtocolDTags.PublisherCertificateDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))\n    return             NDNProtocolDTags.PublisherIssuerKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))\n    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;\n  \n  return -1;\n};\n  \nPublisherID.peek = function(/* XMLDecoder */ decoder) \n{\n  return PublisherID.peekAndGetNextDTag(decoder) >= 0;\n};\n\nPublisherID.prototype.getElementLabel = function()\n{ \n  return this.publisherType.Tag;\n};\n\nPublisherID.prototype.validate = function() \n{\n  return null != id() && null != type();\n};\n\n},{"./encoding/decoding-exception.js":78,"./util/ndn-protoco-id-tags.js":60}],87:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class contains all NDNx tags\n */\n\n\nvar NDNProtocolDTags = {\n\n  /**\n   * Note if you add one of these, add it to the reverse string map as well.\n   * Emphasize getting the work done at compile time over trying to make something\n   * flexible and developer error-proof.\n   */\n\n   Any : 13,\n   Name : 14,\n   Component : 15,\n   Certificate : 16,\n   Collection : 17,\n   CompleteName : 18,\n   Content : 19,\n   SignedInfo : 20,\n   ContentDigest : 21,\n   ContentHash : 22,\n   Count : 24,\n   Header : 25,\n   Interest : 26,  /* 20090915 */\n   Key : 27,\n   KeyLocator : 28,\n   KeyName : 29,\n   Length : 30,\n   Link : 31,\n   LinkAuthenticator : 32,\n   NameComponentCount : 33,  /* DeprecatedInInterest */\n   RootDigest : 36,\n   Signature : 37,\n   Start : 38,\n   Timestamp : 39,\n   Type : 40,\n   Nonce : 41,\n   Scope : 42,\n   Exclude : 43,\n   Bloom : 44,\n   BloomSeed : 45,\n   AnswerOriginKind : 47,\n   InterestLifetime : 48,\n   Witness : 53,\n   SignatureBits : 54,\n   DigestAlgorithm : 55,\n   BlockSize : 56,\n   FreshnessSeconds : 58,\n   FinalBlockID : 59,\n   PublisherPublicKeyDigest : 60,\n   PublisherCertificateDigest : 61,\n   PublisherIssuerKeyDigest : 62,\n   PublisherIssuerCertificateDigest : 63,\n   Data : 64,  /* 20090915 */\n   WrappedKey : 65,\n   WrappingKeyIdentifier : 66,\n   WrapAlgorithm : 67,\n   KeyAlgorithm : 68,\n   Label : 69,\n   EncryptedKey : 70,\n   EncryptedNonceKey : 71,\n   WrappingKeyName : 72,\n   Action : 73,\n   FaceID : 74,\n   IPProto : 75,\n   Host : 76,\n   Port : 77,\n   MulticastInterface : 78,\n   ForwardingFlags : 79,\n   FaceInstance : 80,\n   ForwardingEntry : 81,\n   MulticastTTL : 82,\n   MinSuffixComponents : 83,\n   MaxSuffixComponents : 84,\n   ChildSelector : 85,\n   RepositoryInfo : 86,\n   Version : 87,\n   RepositoryVersion : 88,\n   GlobalPrefix : 89,\n   LocalName : 90,\n   Policy : 91,\n   Namespace : 92,\n   GlobalPrefixName : 93,\n   PolicyVersion : 94,\n   KeyValueSet : 95,\n   KeyValuePair : 96,\n   IntegerValue : 97,\n   DecimalValue : 98,\n   StringValue : 99,\n   BinaryValue : 100,\n   NameValue : 101,\n   Entry : 102,\n   ACL : 103,\n   ParameterizedName : 104,\n   Prefix : 105,\n   Suffix : 106,\n   Root : 107,\n   ProfileName : 108,\n   Parameters : 109,\n   InfoString : 110,\n  // 111 unallocated\n   StatusResponse : 112,\n   StatusCode : 113,\n   StatusText : 114,\n\n  // Sync protocol\n   SyncNode : 115,\n   SyncNodeKind : 116,\n   SyncNodeElement : 117,\n   SyncVersion : 118,\n   SyncNodeElements : 119,\n   SyncContentHash : 120,\n   SyncLeafCount : 121,\n   SyncTreeDepth : 122,\n   SyncByteCount : 123,\n   ConfigSlice : 124,\n   ConfigSliceList : 125,\n   ConfigSliceOp : 126,\n\n  // Remember to keep in sync with schema/tagnames.csvsdict\n   NDNProtocolDataUnit : 17702112,\n   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"\n};\n\nexports.NDNProtocolDTags = NDNProtocolDTags;\n\nvar NDNProtocolDTagsStrings = [\n  null, null, null, null, null, null, null, null, null, null, null,\n  null, null,\n  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",\n  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",\n  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",\n  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",\n  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",\n  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",\n  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",\n  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",\n  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",\n  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",\n  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",\n  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",\n  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",\n  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",\n  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",\n  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",\n  "InfoString", null,\n    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",\n    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",\n    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];\n\nexports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;\n\n},{}],89:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Log class holds the global static variable LOG.\n */\nvar Log = function Log()\n{\n}\n\nexports.Log = Log;\n\n/**\n * LOG is the level for logging debugging statements.  0 means no log messages.\n * @type Number\n */\nLog.LOG = 0;\n\n})()\n},{}],94:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Provide the callback closure for the async communication methods in the Face class.\n * This is a port of Closure.py from PyNDN, written by: \n * Derek Kulinski <takeda@takeda.tk>\n * Jeff Burke <jburke@ucla.edu>\n */\n\n/**\n * A subclass of Closure is passed to expressInterest and registerPrefix.\n * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.\n * @constructor\n */\nvar Closure = function Closure() \n{\n  // I don\'t think storing Face\'s closure is needed\n  // and it creates a reference loop, as of now both\n  // of those variables are never set -- Derek\n  //\n  // Use instance variables to return data to callback\n  this.ndn_data = null;  // this holds the ndn_closure\n  this.ndn_data_dirty = false; \n};\n\nexports.Closure = Closure;\n\n// Upcall result\nClosure.RESULT_ERR               = -1; // upcall detected an error\nClosure.RESULT_OK                =  0; // normal upcall return\nClosure.RESULT_REEXPRESS         =  1; // reexpress the same interest again\nClosure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest\nClosure.RESULT_VERIFY            =  3; // force an unverified result to be verified\nClosure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest\n                                       //   with the key available in the local storage\n\n// Upcall kind\nClosure.UPCALL_FINAL              = 0; // handler is about to be deregistered\nClosure.UPCALL_INTEREST           = 1; // incoming interest\nClosure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered\nClosure.UPCALL_CONTENT            = 3; // incoming verified content\nClosure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out\nClosure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified\nClosure.UPCALL_CONTENT_BAD        = 6; // verification failed\n\n/**\n * Override this in your subclass.\n * If you\'re getting strange errors in upcall()\n * check your code whether you\'re returning a value.\n */\nClosure.prototype.upcall = function(kind, upcallInfo) \n{\n  //dump(\'upcall \' + this + " " + kind + " " + upcallInfo + "\\n");\n  return Closure.RESULT_OK;\n};\n\n/**\n * An UpcallInfo is passed to Closure.upcall.\n * @constructor\n */\nvar UpcallInfo = function UpcallInfo(face, interest, matchedComps, data) \n{\n  this.face = face;  // Face object (not used)\n  this.ndn = face;   // deprecated\n  this.interest = interest;  // Interest object\n  this.matchedComps = matchedComps;  // int\n  this.data = data;  // Data\n  this.contentObject = data; // deprecated.  Include for backward compatibility.\n};\n\nUpcallInfo.prototype.toString = function() \n{\n  var ret = "face = " + this.face;\n  ret += "\\nInterest = " + this.interest;\n  ret += "\\nmatchedComps = " + this.matchedComps;\n  ret += "\\nData: " + this.data;\n  return ret;\n};\n\nexports.UpcallInfo = UpcallInfo;\n\n},{}],108:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Tlv class has static type codes for the NDN-TLV wire format.\n * @constructor\n */\nvar Tlv = function Tlv()\n{\n}\n\nexports.Tlv = Tlv;\n\nTlv.Interest =         5;\nTlv.Data =             6;\nTlv.Name =             7;\nTlv.NameComponent =    8;\nTlv.Selectors =        9;\nTlv.Nonce =            10;\nTlv.Scope =            11;\nTlv.InterestLifetime = 12;\nTlv.MinSuffixComponents = 13;\nTlv.MaxSuffixComponents = 14;\nTlv.PublisherPublicKeyLocator = 15;\nTlv.Exclude =          16;\nTlv.ChildSelector =    17;\nTlv.MustBeFresh =      18;\nTlv.Any =              19;\nTlv.MetaInfo =         20;\nTlv.Content =          21;\nTlv.SignatureInfo =    22;\nTlv.SignatureValue =   23;\nTlv.ContentType =      24;\nTlv.FreshnessPeriod =  25;\nTlv.FinalBlockId =     26;\nTlv.SignatureType =    27;\nTlv.KeyLocator =       28;\nTlv.KeyLocatorDigest = 29;\nTlv.FaceInstance =     128;\nTlv.ForwardingEntry =  129;\nTlv.StatusResponse =   130;\nTlv.Action =           131;\nTlv.FaceID =           132;\nTlv.IPProto =          133;\nTlv.Host =             134;\nTlv.Port =             135;\nTlv.MulticastInterface = 136;\nTlv.MulticastTTL =     137;\nTlv.ForwardingFlags =  138;\nTlv.StatusCode =       139;\nTlv.StatusText =       140;\n\nTlv.SignatureType_DigestSha256 = 0;\nTlv.SignatureType_SignatureSha256WithRsa = 1;\n\n},{}],120:[function(require,module,exports){\nvar b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\nvar b64pad="=";\nvar BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction hex2b64(h) {\n  var i;\n  var c;\n  var ret = "";\n  for(i = 0; i+3 <= h.length; i+=3) {\n    c = parseInt(h.substring(i,i+3),16);\n    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n  }\n  if(i+1 == h.length) {\n    c = parseInt(h.substring(i,i+1),16);\n    ret += b64map.charAt(c << 2);\n  }\n  else if(i+2 == h.length) {\n    c = parseInt(h.substring(i,i+2),16);\n    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n  }\n  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n  return ret;\n}\n\n// convert a base64 string to hex\nfunction b64tohex(s) {\n  var ret = ""\n  var i;\n  var k = 0; // b64 state, 0-3\n  var slop;\n  for(i = 0; i < s.length; ++i) {\n    if(s.charAt(i) == b64pad) break;\n    v = b64map.indexOf(s.charAt(i));\n    if(v < 0) continue;\n    if(k == 0) {\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 1;\n    }\n    else if(k == 1) {\n      ret += int2char((slop << 2) | (v >> 4));\n      slop = v & 0xf;\n      k = 2;\n    }\n    else if(k == 2) {\n      ret += int2char(slop);\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 3;\n    }\n    else {\n      ret += int2char((slop << 2) | (v >> 4));\n      ret += int2char(v & 0xf);\n      k = 0;\n    }\n  }\n  if(k == 1)\n    ret += int2char(slop << 2);\n  return ret;\n}\n\n// convert a base64 string to a byte/number array\nfunction b64toBA(s) {\n  //piggyback on b64tohex for now, optimize later\n  var h = b64tohex(s);\n  var i;\n  var a = new Array();\n  for(i = 0; 2*i < h.length; ++i) {\n    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n  }\n  return a;\n}\n\nmodule.exports = {b64tohex: b64tohex, b64toBA: b64toBA, hex2b64: hex2b64};\n\n},{}],58:[function(require,module,exports){\n(function(){/**\n * This class is used to decode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNTime = require(\'../util/ndn-time.js\').NDNTime;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n  \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n\n\n//returns a string\ntagToString = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {\n    return NDNProtocolDTagsStrings[tagVal];\n  } \n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  }\n  \n  return null;\n};\n\n//returns a Long\nstringToTag =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n  }\n  \n  return null;\n};\n\n/**\n * @constructor\n */\nvar BinaryXMLDecoder = function BinaryXMLDecoder(input) \n{\n  var MARK_LEN=512;\n  var DEBUG_MAX_LEN =  32768;\n  \n  this.input = input;\n  this.offset = 0;\n  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.\n  this.previouslyPeekedDTagStartOffset = -1;\n};\n\nexports.BinaryXMLDecoder = BinaryXMLDecoder;\n\n/**\n * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.\n   * Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n */\nBinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset) {\n    // peekDTag already decoded this DTag.\n    if (this.previouslyPeekedDTag != expectedTag)\n      throw new DecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));\n\n    // Fast forward past the header.\n    this.offset = this.previouslyPeekedDTagEndOffset;\n  }\n  else {\n    var typeAndValue = this.decodeTypeAndVal();\n    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)\n      throw new DecodingException(new Error("Header type is not a DTAG"));\n\n    if (typeAndValue.val() != expectedTag)\n      throw new DecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));\n  }  \n};\n\n/**\n * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readStartElement = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes)\n{\n  //TypeAndVal \n  var tv = this.decodeTypeAndVal();\n      \n  if (null == tv)\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));\n      \n  //String \n  var decodedTag = null;\n      \n  if (tv.type() == XML_TAG) {\n    // Tag value represents length-1 as tags can never be empty.\n    var valval;\n        \n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val())) + 1;\n    else\n      valval = (tv.val())+ 1;\n        \n    decodedTag = this.decodeUString(valval);\n  } \n  else if (tv.type() == XML_DTAG)\n    decodedTag = tv.val();\n      \n  if (null ==  decodedTag || decodedTag != startTag) {\n    console.log(\'expecting \'+ startTag + \' but got \'+ decodedTag);\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));\n  }\n      \n  // DKS: does not read attributes out of stream if caller doesn\'t\n  // ask for them. Should possibly peek and skip over them regardless.\n  // TODO: fix this\n  if (null != attributes)\n    readAttributes(attributes); \n};\n  \n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readAttributes = function(\n  // array of [attributeName, attributeValue] \n  attributes) \n{\n  if (null == attributes)\n    return;\n\n  try {\n    // Now need to get attributes.\n    //TypeAndVal \n    var nextTV = this.peekTypeAndVal();\n\n    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {\n      // Decode this attribute. First, really read the type and value.\n      //this.TypeAndVal \n      var thisTV = this.decodeTypeAndVal();\n\n      //String \n      var attributeName = null;\n      if (XML_ATTR == thisTV.type()) {\n        // Tag value represents length-1 as attribute names cannot be empty.\n        var valval ;\n        if (typeof thisTV.val() == \'string\')\n          valval = (parseInt(thisTV.val())) + 1;\n        else\n          valval = (thisTV.val())+ 1;\n        \n        attributeName = this.decodeUString(valval);\n      } \n      else if (XML_DATTR == thisTV.type()) {\n        // DKS TODO are attributes same or different dictionary?\n        attributeName = tagToString(thisTV.val());\n        if (null == attributeName)\n          throw new DecodingException(new Error("Unknown DATTR value" + thisTV.val()));\n      }\n      \n      // Attribute values are always UDATA\n      //String\n      var attributeValue = this.decodeUString();\n\n      attributes.push([attributeName, attributeValue]);\n      nextTV = this.peekTypeAndVal();\n    }\n  } \n  catch (e) {\n    throw new DecodingException(new Error("readStartElement", e));\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsString = function() \n{\n  //String \n  var decodedTag = null;\n  var previousOffset = this.offset;\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal \n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        // Tag value represents length-1 as tags can never be empty.\n        var valval ;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        decodedTag = this.decodeUString(valval);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tagToString(tv.val());          \n    } // else, not a type and val, probably an end element. rewind and return false.\n  } \n  catch (e) {\n  } \n  finally {\n    try {\n      this.offset = previousOffset;\n    } \n    catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new DecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,\n * then set return true.  Do not update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {boolean} True if the tag is the expected tag, otherwise false.\n */\nBinaryXMLDecoder.prototype.peekDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset)\n    // We already decoded this DTag.\n    return this.previouslyPeekedDTag == expectedTag;\n  else {\n    // First check if it is an element close (which cannot be the expected tag).  \n    if (this.input[this.offset] == XML_CLOSE)\n      return false;\n\n    var saveOffset = this.offset;\n    var typeAndValue = this.decodeTypeAndVal();\n    // readElementStartDTag will use this to fast forward.\n    this.previouslyPeekedDTagEndOffset = this.offset;\n    // Restore the position.\n    this.offset = saveOffset;\n\n    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {\n      this.previouslyPeekedDTagStartOffset = saveOffset;\n      this.previouslyPeekedDTag = typeAndValue.val();\n\n      return typeAndValue.val() == expectedTag;\n    }\n    else\n      return false;\n  }  \n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElement = function(\n    //String \n    startTag) \n{\n  //String \n  if (typeof startTag == \'string\') {\n    var decodedTag = this.peekStartElementAsString();\n    \n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else if (typeof startTag == \'number\') {\n    var decodedTag = this.peekStartElementAsLong();\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else\n    throw new DecodingException(new Error("SHOULD BE STRING OR NUMBER"));\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsLong = function() \n{\n  //Long\n  var decodedTag = null;    \n  var previousOffset = this.offset;\n  \n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        if (tv.val() + 1 > DEBUG_MAX_LEN)\n          throw new DecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));\n\n        var valval;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        // Tag value represents length-1 as tags can never be empty.\n        //String \n        var strTag = this.decodeUString(valval);\n        \n        decodedTag = stringToTag(strTag);\n      } \n      else if (tv.type() == XML_DTAG)\n        decodedTag = tv.val();          \n    } // else, not a type and val, probably an end element. rewind and return false.\n\n  } \n  catch (e) {  \n  } \n  finally {\n    try {\n      //this.input.reset();\n      this.offset = previousOffset;\n    } catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new Error("Cannot reset stream! " + e.getMessage(), e);\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a \n * customBuf. However, if allowNull is true, then the item may be absent.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @param {boolean} allowNull True if the binary item may be missing.\n * @returns {Buffer} A customBuf which is a slice on the data inside the input buffer. However, \n * if allowNull is true and the binary data item is absent, then return null.\n */\nBinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readBinaryElement = function(\n    //long \n    startTag,\n    //TreeMap<String, String> \n    attributes,\n    //boolean\n    allowNull) \n{\n  this.readStartElement(startTag, attributes);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * Read one byte from the input starting at its offset, expecting it to be the element close.\n * Update the input\'s offset.\n */\nBinaryXMLDecoder.prototype.readElementClose = function() \n{\n  var next = this.input[this.offset++];     \n  if (next != XML_CLOSE)\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n};\n\n/**\n * @deprecated Use readElementClose.\n */\nBinaryXMLDecoder.prototype.readEndElement = function() \n{\n  if (LOG > 4) console.log(\'this.offset is \'+this.offset);\n  \n  var next = this.input[this.offset]; \n  \n  this.offset++;\n  \n  if (LOG > 4) console.log(\'XML_CLOSE IS \'+XML_CLOSE);\n  if (LOG > 4) console.log(\'next is \'+next);\n  \n  if (next != XML_CLOSE) {\n    console.log("Expected end element, got: " + next);\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n  }\n};\n\n//String  \nBinaryXMLDecoder.prototype.readUString = function() \n{\n  //String \n  var ustring = this.decodeUString();  \n  this.readElementClose();\n  return ustring;\n};\n  \n/**\n * Read a blob as well as the end element. Returns a customBuf (or null for missing blob).\n * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,\n *   just read the end element and return null.\n */\nBinaryXMLDecoder.prototype.readBlob = function(allowNull) \n{\n  if (this.input[this.offset] == XML_CLOSE && allowNull) {\n    this.readElementClose();\n    return null;\n  }\n    \n  var blob = this.decodeBlob();  \n  this.readElementClose();\n  return blob;\n};\n\n/**\n * Decode the header from the input starting at its offset, expecting the type to be \n * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned \n * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {NDNTime} The dateTime value.\n */\nBinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)  \n{\n  var byteTimestamp = this.readBinaryDTagElement(expectedTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\n/**\n * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readDateTime = function(\n  //long \n  startTag)  \n{\n  var byteTimestamp = this.readBinaryElement(startTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  if (LOG > 4) console.log(\'DECODED DATE WITH VALUE\');\n  if (LOG > 4) console.log(lontimestamp);\n  \n  //NDNTime \n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\nBinaryXMLDecoder.prototype.decodeTypeAndVal = function() \n{\n  \n  /*int*/ var type = -1;\n  /*long*/ var val = 0;\n  /*boolean*/ var more = true;\n\n  do {\n    var next = this.input[this.offset ];\n    if (next == null)\n      // Quit the loop.\n      return null; \n    \n    if (next < 0)\n      return null; \n\n    if (0 == next && 0 == val)\n      return null;\n    \n    more = (0 == (next & XML_TT_NO_MORE));\n    \n    if  (more) {\n      val = val << XML_REG_VAL_BITS;\n      val |= (next & XML_REG_VAL_MASK);\n    } \n    else {\n      type = next & XML_TT_MASK;\n      val = val << XML_TT_VAL_BITS;\n      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);\n    }\n    \n    this.offset++;\n  } while (more);\n  \n  if (LOG > 4) console.log(\'TYPE is \'+ type + \' VAL is \'+ val);\n\n  return new TypeAndVal(type, val);\n};\n\n//TypeAndVal\nBinaryXMLDecoder.prototype.peekTypeAndVal = function() \n{\n  //TypeAndVal \n  var tv = null;\n  var previousOffset = this.offset;\n  \n  try {\n    tv = this.decodeTypeAndVal();\n  } \n  finally {\n    this.offset = previousOffset;\n  }\n  \n  return tv;\n};\n\n//Buffer\nBinaryXMLDecoder.prototype.decodeBlob = function(\n    //int \n    blobLength) \n{  \n  if (null == blobLength) {\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    var valval ;\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val()));\n    else\n      valval = (tv.val());\n    \n    return this.decodeBlob(valval);\n  }\n  \n  //Buffer\n  var bytes = new customBuf(this.input.slice(this.offset, this.offset+ blobLength));\n  this.offset += blobLength;\n  \n  return bytes;\n};\n\n//String\nBinaryXMLDecoder.prototype.decodeUString = function(\n    //int \n    byteLength) \n{\n  if (null == byteLength) {\n    var tempStreamPosition = this.offset;\n      \n    //TypeAndVal \n    var tv = this.decodeTypeAndVal();\n    \n    if (LOG > 4) console.log(\'TV is \'+tv);\n    if (LOG > 4) console.log(tv);\n    \n    if (LOG > 4) console.log(\'Type of TV is \'+typeof tv);\n  \n    // if we just have closers left, will get back null\n    if (null == tv || XML_UDATA != tv.type()) {\n      this.offset = tempStreamPosition;      \n      return "";\n    }\n      \n    return this.decodeUString(tv.val());\n  }\n  else {\n    //Buffer \n    var stringBytes = this.decodeBlob(byteLength);\n    \n    // TODO: Should this parse as UTF8?\n    return DataUtils.toString(stringBytes);    \n  }\n};\n\n//OBject containg a pair of type and value\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.t = _type;\n  this.v = _val;\n};\n\nTypeAndVal.prototype.type = function() \n{\n  return this.t;\n};\n\nTypeAndVal.prototype.val = function() \n{\n  return this.v;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {number} The parsed integer.\n */\nBinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)\n{\n  return parseInt(this.readUTF8DTagElement(expectedTag));\n};\n\n/**\n * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readIntegerElement = function(\n  //String \n  startTag) \n{\n  //String \n  if (LOG > 4) console.log(\'READING INTEGER \'+ startTag);\n  if (LOG > 4) console.log(\'TYPE OF \'+ typeof startTag);\n  \n  var strVal = this.readUTF8Element(startTag);\n  \n  return parseInt(strVal);\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item and return a string. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {string} The UDATA string.\n */\nBinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readUString();;\n};\n\n/**\n * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readUTF8Element = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes) \n{\n  //throws Error where name == "DecodingException" \n\n  // can\'t use getElementText, can\'t get attributes\n  this.readStartElement(startTag, attributes);\n  //String \n  var strElementText = this.readUString();\n  return strElementText;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nBinaryXMLDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n})()\n},{"../buffer.js":30,"../log.js":62,"../util/ndn-protoco-id-tags.js":60,"../util/ndn-time.js":27,"./data-utils.js":23,"./decoding-exception.js":78}],59:[function(require,module,exports){\n(function(){/**\n * This class is used to encode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n/**\n * @constructor\n */\nvar BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength) \n{\n  if (!initiaLength)\n    initiaLength = 16;\n  \n  this.ostream = new DynamicBuffer(initiaLength);\n  this.offset = 0;\n  this.CODEC_NAME = "Binary";\n};\n\nexports.BinaryXMLEncoder = BinaryXMLEncoder;\n\n/**\n * Encode utf8Content as utf8 and write to the output buffer as a UDATA.\n * @param {string} utf8Content The string to convert to utf8.\n */\nBinaryXMLEncoder.prototype.writeUString = function(utf8Content) \n{\n  this.encodeUString(utf8Content, XML_UDATA);\n};\n\nBinaryXMLEncoder.prototype.writeBlob = function(\n    /*Buffer*/ binaryContent) \n{  \n  if (LOG >3) console.log(binaryContent);\n  \n  this.encodeBlob(binaryContent, binaryContent.length);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer.\n * @param {number} tag The DTAG tag.\n */\nBinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)\n{\n  this.encodeTypeAndVal(XML_DTAG, tag);\n};\n\n/**\n * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeStartElement = function(\n  /*String*/ tag, \n  /*TreeMap<String,String>*/ attributes) \n{\n  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);\n  \n  if (null == dictionaryVal)\n    this.encodeUString(tag, XML_TAG);\n  else\n    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);\n  \n  if (null != attributes)\n    this.writeAttributes(attributes); \n};\n\n/**\n * Write an element close to the output buffer.\n */\nBinaryXMLEncoder.prototype.writeElementClose = function() \n{\n  this.ostream.ensureLength(this.offset + 1);\n  this.ostream.array[this.offset] = XML_CLOSE;\n  this.offset += 1;\n};\n\n/**\n * @deprecated Use writeElementClose.\n */\nBinaryXMLEncoder.prototype.writeEndElement = function() \n{\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes) \n{\n  if (null == attributes)\n    return;\n\n  // the keySet of a TreeMap is sorted.\n\n  for (var i = 0; i< attributes.length;i++) {\n    var strAttr = attributes[i].k;\n    var strValue = attributes[i].v;\n\n    var dictionaryAttr = stringToTag(strAttr);\n    if (null == dictionaryAttr)\n      // not in dictionary, encode as attr\n      // compressed format wants length of tag represented as length-1\n      // to save that extra bit, as tag cannot be 0 length.\n      // encodeUString knows to do that.\n      this.encodeUString(strAttr, XML_ATTR);\n    else\n      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);\n\n    // Write value\n    this.encodeUString(strValue);    \n  }\n};\n\n//returns a string\nstringToTag = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)\n    return NDNProtocolDTagsStrings[tagVal];\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  \n  return null;\n};\n\n//returns a Long\ntagToString =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  \n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n\n  return null;\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the content as explained below, \n * then an element close.\n * @param {number} tag The DTAG tag.\n * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,\n * call writeUString.  Otherwise, call writeBlob.\n */\nBinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)\n{\n  this.writeElementStartDTag(tag);\n  \n  if (typeof content === \'number\')\n    this.writeUString(content.toString());\n  else if (typeof content === \'string\')\n    this.writeUString(content);\n  else\n    this.writeBlob(content);\n  \n  this.writeElementClose();\n};\n\n/**\n * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n * If Content is a string, then encode as utf8 and write UDATA.\n */\nBinaryXMLEncoder.prototype.writeElement = function(\n    //long \n    tag, \n    //byte[] \n    Content,\n    //TreeMap<String, String> \n    attributes) \n{\n  this.writeStartElement(tag, attributes);\n  // Will omit if 0-length\n  \n  if (typeof Content === \'number\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER .charCodeAt(0) \' + Content.toString().charCodeAt(0));\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER \' + Content.toString());\n    if (LOG > 4) console.log(\'type of number is \' + typeof Content.toString());\n    \n    this.writeUString(Content.toString());\n  }\n  else if (typeof Content === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE STRING  \' + Content);\n    if (LOG > 4) console.log(\'type of STRING is \' + typeof Content);\n    \n    this.writeUString(Content);\n  }\n  else {\n    if (LOG > 4) console.log(\'GOING TO WRITE A BLOB  \' + Content);\n\n    this.writeBlob(Content);\n  }\n  \n  this.writeElementClose();\n};\n\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.type = _type;\n  this.val = _val;  \n};\n\nBinaryXMLEncoder.prototype.encodeTypeAndVal = function(\n    //int\n    type, \n    //long \n    val) \n{  \n  if (LOG > 4) console.log(\'Encoding type \'+ type+ \' and value \'+ val);\n  \n  if (LOG > 4) console.log(\'OFFSET IS \' + this.offset);\n  \n  if (type > XML_UDATA || type < 0 || val < 0)\n    throw new Error("Tag and value must be positive, and tag valid.");\n  \n  // Encode backwards. Calculate how many bytes we need:\n  var numEncodingBytes = this.numEncodingBytes(val);\n  this.ostream.ensureLength(this.offset + numEncodingBytes);\n\n  // Bottom 4 bits of val go in last byte with tag.\n  this.ostream.array[this.offset + numEncodingBytes - 1] = \n    //(byte)\n      (BYTE_MASK &\n          (((XML_TT_MASK & type) | \n           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n           XML_TT_NO_MORE); // set top bit for last byte\n  val = val >>> XML_TT_VAL_BITS;\n  \n  // Rest of val goes into preceding bytes, 7 bits per byte, top bit\n  // is "more" flag.\n  var i = this.offset + numEncodingBytes - 2;\n  while (0 != val && i >= this.offset) {\n    this.ostream.array[i] = //(byte)\n        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset\n    val = val >>> XML_REG_VAL_BITS;\n    --i;\n  }\n  \n  if (val != 0)\n    throw new Error("This should not happen: miscalculated encoding");\n\n  this.offset+= numEncodingBytes;\n  \n  return numEncodingBytes;\n};\n\n/**\n * Encode ustring as utf8.\n */\nBinaryXMLEncoder.prototype.encodeUString = function(\n    //String \n    ustring, \n    //byte \n    type) \n{  \n  if (null == ustring)\n    return;\n  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)\n    return;\n  \n  if (LOG > 3) console.log("The string to write is ");\n  if (LOG > 3) console.log(ustring);\n\n  var strBytes = DataUtils.stringToUtf8Array(ustring);\n  \n  this.encodeTypeAndVal(type, \n            (((type == XML_TAG) || (type == XML_ATTR)) ?\n                (strBytes.length-1) :\n                strBytes.length));\n  \n  if (LOG > 3) console.log("THE string to write is ");\n  \n  if (LOG > 3) console.log(strBytes);\n  \n  this.writeString(strBytes);\n  this.offset+= strBytes.length;\n};\n\n\nBinaryXMLEncoder.prototype.encodeBlob = function(\n    //Buffer \n    blob, \n    //int \n    length) \n{\n  if (null == blob)\n    return;\n  \n  if (LOG > 4) console.log(\'LENGTH OF XML_BLOB IS \'+length);\n  \n  this.encodeTypeAndVal(XML_BLOB, length);\n  this.writeBlobArray(blob);\n  this.offset += length;\n};\n\nvar ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);\n\nBinaryXMLEncoder.prototype.numEncodingBytes = function(\n    //long\n    x) \n{\n  if (x <= ENCODING_LIMIT_1_BYTE) return (1);\n  if (x <= ENCODING_LIMIT_2_BYTES) return (2);\n  if (x <= ENCODING_LIMIT_3_BYTES) return (3);\n  \n  var numbytes = 1;\n  \n  // Last byte gives you XML_TT_VAL_BITS\n  // Remainder each give you XML_REG_VAL_BITS\n  x = x >>> XML_TT_VAL_BITS;\n  while (x != 0) {\n        numbytes++;\n    x = x >>> XML_REG_VAL_BITS;\n  }\n  return (numbytes);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the dateTime\n   * as a big endian BLOB converted to 4096 ticks per second, then an element close.\n * @param {number} tag The DTAG tag.\n * @param {NDNTime} dateTime\n */\nBinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)\n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n/**\n * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeDateTime = function(\n    //String \n    tag, \n    //NDNTime \n    dateTime) \n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n// This does not update this.offset.\nBinaryXMLEncoder.prototype.writeString = function(input) \n{\n  if (typeof input === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING\');\n    if (LOG > 4) console.log(input);\n        \n    this.ostream.ensureLength(this.offset + input.length);\n    for (var i = 0; i < input.length; i++) {\n      if (LOG > 4) console.log(\'input.charCodeAt(i)=\' + input.charCodeAt(i));\n      this.ostream.array[this.offset + i] = (input.charCodeAt(i));\n    }\n  }\n  else\n  {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING IN BINARY FORM\');\n    if (LOG > 4) console.log(input);\n    \n    this.writeBlobArray(input);\n  }\n};\n\nBinaryXMLEncoder.prototype.writeBlobArray = function(\n    //Buffer \n    blob) \n{  \n  if (LOG > 4) console.log(\'GOING TO WRITE A BLOB\');\n    \n  this.ostream.copy(blob, this.offset);\n};\n\nBinaryXMLEncoder.prototype.getReducedOstream = function() \n{\n  return this.ostream.slice(0, this.offset);\n};\n\n})()\n},{"../buffer.js":30,"../log.js":62,"../util/dynamic-buffer.js":130,"../util/ndn-protoco-id-tags.js":60,"./data-utils.js":23}],64:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar Blob = require(\'./blob.js\').Blob;\n\n/**\n * A SignedBlob extends Blob to keep the offsets of a signed portion (e.g., the \n * bytes of Data packet). This inherits from Blob, including Blob.size and Blob.buf.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {number} signedPortionBeginOffset (optional) The offset in the \n * encoding of the beginning of the signed portion. If omitted, set to 0.\n * @param {number} signedPortionEndOffset (optional) The offset in the encoding \n * of the end of the signed portion. If omitted, set to 0.\n */\nvar SignedBlob = function SignedBlob(value, signedPortionBeginOffset, signedPortionEndOffset) \n{\n  // Call the base constructor.\n  Blob.call(this, value);\n  \n  if (this.buffer == null) {\n    this.signedPortionBeginOffset = 0;\n    this.signedPortionEndOffset = 0;\n  }\n  else if (typeof value === \'object\' && value instanceof SignedBlob) {\n    // Copy the SignedBlob, allowing override for offsets.\n    this.signedPortionBeginOffset = signedPortionBeginOffset == null ? \n      value.signedPortionBeginOffset : signedPortionBeginOffset;\n    this.signedPortionEndOffset = signedPortionEndOffset == null ? \n      value.signedPortionEndOffset : signedPortionEndOffset;\n  }\n  else {\n    this.signedPortionBeginOffset = signedPortionBeginOffset || 0;\n    this.signedPortionEndOffset = signedPortionEndOffset || 0;\n  }\n  \n  if (this.buffer == null)\n    this.signedBuffer = null;\n  else\n    this.signedBuffer = this.buffer.slice\n      (this.signedPortionBeginOffset, this.signedPortionEndOffset);\n};\n\nSignedBlob.prototype = new Blob();\nSignedBlob.prototype.name = "SignedBlob";\n\nexports.SignedBlob = SignedBlob;\n\n/**\n * Return the length of the signed portion of the immutable byte array.\n * @returns {number} The length of the signed portion.  If signedBuf() is null, \n * return 0.\n */\nSignedBlob.prototype.signedSize = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return a the signed portion of the immutable byte array.\n * @returns {Buffer} A slice into the customBuf which is the signed portion.  \n * If the pointer to the array is null, return null.\n */\nSignedBlob.prototype.signedBuf = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer;\n  else\n    return null;\n};\n\n/**\n * Return the offset in the array of the beginning of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionBeginOffset = function()\n{\n  return this.signedPortionBeginOffset;\n};\n\n/**\n * Return the offset in the array of the end of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionEndOffset = function()\n{\n  return this.signedPortionEndOffset;\n};\n\n})()\n},{"../buffer.js":30,"./blob.js":25}],72:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Face Instances\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\n\n/**\n * @constructor\n */\nvar FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,\n    multicastTTL, freshnessSeconds) \n{\n  this.action = action;\n  this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n  this.faceID = faceID;\n  this.ipProto = ipProto;\n  this.host = host;\n  this.Port = port;\n  this.multicastInterface =multicastInterface;\n  this.multicastTTL =multicastTTL;\n  this.freshnessSeconds = freshnessSeconds;\n};\n\nexports.FaceInstance = FaceInstance;\n\nFaceInstance.NetworkProtocol = { TCP:6, UDP:17};\n\n/**\n * Used by NetworkObject to decode the object from a network stream.\n */\nFaceInstance.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Action))   \n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    this.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {\n    //int\n    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);\n    \n    this.ipProto = null;\n    \n    if (FaceInstance.NetworkProtocol.TCP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.TCP;\n    else if (FaceInstance.NetworkProtocol.UDP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.UDP;\n    else\n      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Host))\n    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);\n  if (decoder.peekDTag(NDNProtocolDTags.Port))\n    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))\n    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))\n    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\n/**\n * Used by NetworkObject to encode the object to a network stream.\n */\nFaceInstance.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.publisherPublicKeyDigest)\n    this.publisherPublicKeyDigest.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.ipProto)\n    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);\n  if (null != this.host && this.host.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);  \n  if (null != this.Port)\n    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);\n  if (null != this.multicastInterface && this.multicastInterface.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);\n  if (null !=  this.multicastTTL)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  encoder.writeElementClose();         \n};\n\nFaceInstance.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.FaceInstance;\n};\n\n\n},{"./publisher-public-key-digest.js":17,"./util/ndn-protoco-id-tags.js":60}],71:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar crypto = require(\'../crypto.js\');\nvar Blob = require(\'../util/blob.js\').Blob;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvEncoder = require(\'./tlv/tlv-encoder.js\').TlvEncoder;\nvar TlvDecoder = require(\'./tlv/tlv-decoder.js\').TlvDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar ContentType = require(\'../meta-info.js\').ContentType;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Signature = require(\'../signature.js\').Signature;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\n\n/**\n * A Tlv0_1a2WireFormat implements the WireFormat interface for encoding and \n * decoding with the NDN-TLV wire format, version 0.1a2\n * @constructor\n */\nvar Tlv0_1a2WireFormat = function Tlv0_1a2WireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nTlv0_1a2WireFormat.prototype = new WireFormat();\nTlv0_1a2WireFormat.prototype.name = "Tlv0_1a2WireFormat";\n\nexports.Tlv0_1a2WireFormat = Tlv0_1a2WireFormat;\n\n// Default object.\nTlv0_1a2WireFormat.instance = null;\n\n/**\n * Encode the interest using NDN-TLV and return a customBuf.\n * @param {Interest} interest The Interest object to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nTlv0_1a2WireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new TlvEncoder();\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.InterestLifetime, interest.getInterestLifetimeMilliseconds());\n  encoder.writeOptionalNonNegativeIntegerTlv(Tlv.Scope, interest.getScope());\n  \n  // Encode the Nonce as 4 bytes.\n  if (interest.getNonce() == null || interest.getNonce().length == 0)\n    // This is the most common case. Generate a nonce.\n    encoder.writeBlobTlv(Tlv.Nonce, require("../crypto.js").randomBytes(4));\n  else if (interest.getNonce().length < 4) {\n    var nonce = customBuf(4);\n    // Copy existing nonce bytes.\n    interest.getNonce().copy(nonce);\n\n    // Generate random bytes for remaining bytes in the nonce.\n    for (var i = interest.getNonce().length; i < 4; ++i)\n      nonce[i] = require("crypto").randomBytes(1)[0];\n\n    encoder.writeBlobTlv(Tlv.Nonce, nonce);\n  }\n  else if (interest.getNonce().length == 4)\n    // Use the nonce as-is.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce());\n  else\n    // Truncate.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce().slice(0, 4));\n  \n  Tlv0_1a2WireFormat.encodeSelectors(interest, encoder);\n  Tlv0_1a2WireFormat.encodeName(interest.getName(), encoder);\n  \n  encoder.writeTypeAndLength(Tlv.Interest, encoder.getLength() - saveLength);\n      \n  return new Blob(encoder.getOutput(), false);\n};\n\n/**\n * Decode input as an NDN-TLV interest and set the fields of the interest \n * object.  \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nTlv0_1a2WireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Interest);\n  Tlv0_1a2WireFormat.decodeName(interest.getName(), decoder);\n  if (decoder.peekType(Tlv.Selectors, endOffset))\n    Tlv0_1a2WireFormat.decodeSelectors(interest, decoder);\n  // Require a Nonce, but don\'t force it to be 4 bytes.\n  var nonce = decoder.readBlobTlv(Tlv.Nonce);\n  interest.setScope(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.Scope, endOffset));\n  interest.setInterestLifetimeMilliseconds\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.InterestLifetime, endOffset));\n\n  // Set the nonce last because setting other interest fields clears it.\n  interest.setNonce(nonce);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode data as NDN-TLV and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nTlv0_1a2WireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new TlvEncoder(1500);\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  encoder.writeBlobTlv(Tlv.SignatureValue, data.getSignature().getSignature());\n  var signedPortionEndOffsetFromBack = encoder.getLength();\n\n  // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n  //   the key locator from the MetaInfo to the Signauture object.\n  Tlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue\n    (data.getSignature(), encoder, data.getSignatureOrMetaInfoKeyLocator());\n  encoder.writeBlobTlv(Tlv.Content, data.getContent());\n  Tlv0_1a2WireFormat.encodeMetaInfo(data.getMetaInfo(), encoder);\n  Tlv0_1a2WireFormat.encodeName(data.getName(), encoder);\n  var signedPortionBeginOffsetFromBack = encoder.getLength();\n\n  encoder.writeTypeAndLength(Tlv.Data, encoder.getLength() - saveLength);\n  var signedPortionBeginOffset = \n    encoder.getLength() - signedPortionBeginOffsetFromBack;\n  var signedPortionEndOffset = encoder.getLength() - signedPortionEndOffsetFromBack;\n\n  return { encoding: new Blob(encoder.getOutput(), false),\n           signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Decode input as an NDN-TLV data packet, set the fields in the data object, \n * and return the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nTlv0_1a2WireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Data);\n  var signedPortionBeginOffset = decoder.getOffset();\n\n  Tlv0_1a2WireFormat.decodeName(data.getName(), decoder);\n  Tlv0_1a2WireFormat.decodeMetaInfo(data.getMetaInfo(), decoder);\n  data.setContent(decoder.readBlobTlv(Tlv.Content));\n  Tlv0_1a2WireFormat.decodeSignatureInfo(data, decoder);\n  if (data.getSignature() != null && \n      data.getSignature().getKeyLocator() != null && \n      data.getMetaInfo() != null)\n    // Copy the key locator pointer to the MetaInfo object for the transition of \n    //   moving the key locator from the MetaInfo to the Signature object.\n    data.getMetaInfo().locator = data.getSignature().getKeyLocator();\n\n  var signedPortionEndOffset = decoder.getOffset();\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  data.getSignature().setSignature(decoder.readBlobTlv(Tlv.SignatureValue));\n\n  decoder.finishNestedTlvs(endOffset);\n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Get a singleton instance of a Tlv1_0a2WireFormat.  To always use the\n * preferred version NDN-TLV, you should use TlvWireFormat.get().\n * @returns {Tlv0_1a2WireFormat} The singleton instance.\n */\nTlv0_1a2WireFormat.get = function()\n{\n  if (Tlv0_1a2WireFormat.instance === null)\n    Tlv0_1a2WireFormat.instance = new Tlv0_1a2WireFormat();\n  return Tlv0_1a2WireFormat.instance;\n};\n\nTlv0_1a2WireFormat.encodeName = function(name, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode the components backwards.\n  for (var i = name.size() - 1; i >= 0; --i)\n    encoder.writeBlobTlv(Tlv.NameComponent, name.get(i).getValue());\n\n  encoder.writeTypeAndLength(Tlv.Name, encoder.getLength() - saveLength);\n};\n        \nTlv0_1a2WireFormat.decodeName = function(name, decoder)\n{\n  name.clear();\n  \n  var endOffset = decoder.readNestedTlvsStart(Tlv.Name);      \n  while (decoder.getOffset() < endOffset)\n      name.append(decoder.readBlobTlv(Tlv.NameComponent));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the interest selectors.  If no selectors are written, do not output a \n * Selectors TLV.\n */\nTlv0_1a2WireFormat.encodeSelectors = function(interest, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (interest.getMustBeFresh())\n    encoder.writeTypeAndLength(Tlv.MustBeFresh, 0);\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.ChildSelector, interest.getChildSelector());\n  if (interest.getExclude().size() > 0)\n    Tlv0_1a2WireFormat.encodeExclude(interest.getExclude(), encoder);\n  \n  if (interest.getKeyLocator().getType() != null)\n    Tlv0_1a2WireFormat.encodeKeyLocator(interest.getKeyLocator(), encoder);\n  else {\n    // There is no keyLocator. If there is a publisherPublicKeyDigest, then \n    //   encode as KEY_LOCATOR_DIGEST. (When we remove the deprecated \n    //   publisherPublicKeyDigest, we don\'t need this.)\n    if (null != interest.publisherPublicKeyDigest) {\n      var savePublisherPublicKeyDigestLength = encoder.getLength();\n      encoder.writeBlobTlv\n        (Tlv.KeyLocatorDigest, \n         interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n      encoder.writeTypeAndLength\n        (Tlv.KeyLocator, encoder.getLength() - savePublisherPublicKeyDigestLength);\n    }\n  }\n  \n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MaxSuffixComponents, interest.getMaxSuffixComponents());\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MinSuffixComponents, interest.getMinSuffixComponents());\n\n  // Only output the type and length if values were written.\n  if (encoder.getLength() != saveLength)\n    encoder.writeTypeAndLength(Tlv.Selectors, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSelectors = function(interest, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Selectors);\n\n  interest.setMinSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MinSuffixComponents, endOffset));\n  interest.setMaxSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MaxSuffixComponents, endOffset));\n\n  // Initially set publisherPublicKeyDigest to none.\n  interest.publisherPublicKeyDigest = null;\n  if (decoder.peekType(Tlv.KeyLocator, endOffset)) {\n    Tlv0_1a2WireFormat.decodeKeyLocator(interest.getKeyLocator(), decoder);\n    if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST) {\n      // For backwards compatibility, also set the publisherPublicKeyDigest.\n      interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest =\n        interest.getKeyLocator().getKeyData();\n    }\n  }\n  else\n    interest.getKeyLocator().clear();\n\n  if (decoder.peekType(Tlv.Exclude, endOffset))\n    Tlv0_1a2WireFormat.decodeExclude(interest.getExclude(), decoder);\n  else\n    interest.getExclude().clear();\n\n  interest.setChildSelector(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ChildSelector, endOffset));\n  interest.setMustBeFresh(decoder.readBooleanTlv(Tlv.MustBeFresh, endOffset));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n  \nTlv0_1a2WireFormat.encodeExclude = function(exclude, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // TODO: Do we want to order the components (except for ANY)?\n  // Encode the entries backwards.\n  for (var i = exclude.size() - 1; i >= 0; --i) {\n    var entry = exclude.get(i);\n\n    if (entry == Exclude.ANY)\n      encoder.writeTypeAndLength(Tlv.Any, 0);\n    else\n      encoder.writeBlobTlv(Tlv.NameComponent, entry.getValue());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.Exclude, encoder.getLength() - saveLength);\n};\n  \nTlv0_1a2WireFormat.decodeExclude = function(exclude, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Exclude);\n\n  exclude.clear();\n  while (true) {\n    if (decoder.peekType(Tlv.NameComponent, endOffset))\n      exclude.appendComponent(decoder.readBlobTlv(Tlv.NameComponent));\n    else if (decoder.readBooleanTlv(Tlv.Any, endOffset))\n      exclude.appendAny();\n    else\n      // Else no more entries.\n      break;\n  }\n  \n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeKeyLocator = function(keyLocator, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (keyLocator.getType() != null) {\n    if (keyLocator.getType() == KeyLocatorType.KEYNAME)\n      Tlv0_1a2WireFormat.encodeName(keyLocator.getKeyName(), encoder);\n    else if (keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST &&\n             keyLocator.getKeyData().length > 0)\n      encoder.writeBlobTlv(Tlv.KeyLocatorDigest, keyLocator.getKeyData());\n    else\n      throw new Error("Unrecognized KeyLocatorType " + keyLocator.getType());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.KeyLocator, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeKeyLocator = function(keyLocator, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.KeyLocator);\n\n  keyLocator.clear();\n\n  if (decoder.getOffset() == endOffset)\n    // The KeyLocator is omitted, so leave the fields as none.\n    return;\n\n  if (decoder.peekType(Tlv.Name, endOffset)) {\n    // KeyLocator is a Name.\n    keyLocator.setType(KeyLocatorType.KEYNAME);\n    Tlv0_1a2WireFormat.decodeName(keyLocator.getKeyName(), decoder);\n  }\n  else if (decoder.peekType(Tlv.KeyLocatorDigest, endOffset)) {\n    // KeyLocator is a KeyLocatorDigest.\n    keyLocator.setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    keyLocator.setKeyData(decoder.readBlobTlv(Tlv.KeyLocatorDigest));\n  }\n  else\n    throw new DecodingException\n      ("decodeKeyLocator: Unrecognized key locator type");\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the signature object in TLV, using the given keyLocator instead of the\n * locator in this object.\n * @param {Signature} signature The Signature object to encode.\n * @param {TlvEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nTlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue = function\n  (signature, encoder, keyLocator)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  Tlv0_1a2WireFormat.encodeKeyLocator(keyLocator, encoder);\n  encoder.writeNonNegativeIntegerTlv\n    (Tlv.SignatureType, Tlv.SignatureType_SignatureSha256WithRsa);\n\n  encoder.writeTypeAndLength(Tlv.SignatureInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSignatureInfo = function(data, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.SignatureInfo);\n\n  var signatureType = decoder.readNonNegativeIntegerTlv(Tlv.SignatureType);\n  // TODO: The library needs to handle other signature types than \n  //     SignatureSha256WithRsa.\n  if (signatureType == Tlv.SignatureType_SignatureSha256WithRsa) {\n      var signature = {}\n      signature.sig = Signature\n      data.setSignature(signature.sig());\n      // Modify data\'s signature object because if we create an object\n      //   and set it, then data will have to copy all the fields.\n      var signatureInfo = data.getSignature();\n      Tlv0_1a2WireFormat.decodeKeyLocator\n        (signatureInfo.getKeyLocator(), decoder);\n  }\n  else\n      throw new DecodingException\n       ("decodeSignatureInfo: unrecognized SignatureInfo type" + signatureType);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeMetaInfo = function(metaInfo, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  var finalBlockIdBuf = metaInfo.getFinalBlockID();\n  if (finalBlockIdBuf != null && finalBlockIdBuf.length > 0) {\n    // FinalBlockId has an inner NameComponent.\n    var finalBlockIdSaveLength = encoder.getLength();\n    encoder.writeBlobTlv(Tlv.NameComponent, finalBlockIdBuf);\n    encoder.writeTypeAndLength\n      (Tlv.FinalBlockId, encoder.getLength() - finalBlockIdSaveLength);\n  }\n\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.FreshnessPeriod, metaInfo.getFreshnessPeriod());\n  if (metaInfo.getType() != ContentType.BLOB) {\n    // Not the default, so we need to encode the type.\n    if (metaInfo.getType() == ContentType.LINK ||\n        metaInfo.getType() == ContentType.KEY)\n      // The ContentType enum is set up with the correct integer for \n      // each NDN-TLV ContentType.\n      encoder.writeNonNegativeIntegerTlv(Tlv.ContentType, metaInfo.getType());\n    else\n      throw new Error("unrecognized TLV ContentType");\n  }\n\n  encoder.writeTypeAndLength(Tlv.MetaInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeMetaInfo = function(metaInfo, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.MetaInfo);  \n\n  // The ContentType enum is set up with the correct integer for each \n  // NDN-TLV ContentType.  If readOptionalNonNegativeIntegerTlv returns\n  // None, then setType will convert it to BLOB.\n  metaInfo.setType(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ContentType, endOffset));\n  metaInfo.setFreshnessPeriod\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.FreshnessPeriod, endOffset));\n  if (decoder.peekType(Tlv.FinalBlockId, endOffset)) {\n    var finalBlockIdEndOffset = decoder.readNestedTlvsStart(Tlv.FinalBlockId);\n    metaInfo.setFinalBlockID(decoder.readBlobTlv(Tlv.NameComponent));\n    decoder.finishNestedTlvs(finalBlockIdEndOffset);\n  }\n  else\n    metaInfo.setFinalBlockID(null);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n})()\n},{"../crypto.js":30,"../exclude.js":12,"../key-locator.js":16,"../meta-info.js":14,"../signature.js":65,"../util/blob.js":25,"./decoding-exception.js":78,"./tlv/tlv-decoder.js":21,"./tlv/tlv-encoder.js":131,"./tlv/tlv.js":22,"./wire-format.js":18,"crypto":56}],74:[function(require,module,exports){\n/**\n * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to \n * determine its end.\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\n\nvar XML_EXT = 0x00; \nvar XML_TAG = 0x01; \nvar XML_DTAG = 0x02; \nvar XML_ATTR = 0x03; \nvar XML_DATTR = 0x04; \nvar XML_BLOB = 0x05; \nvar XML_UDATA = 0x06;   \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\n\n/**\n * @constructor\n */\nvar BinaryXMLStructureDecoder = function BinaryXMLDecoder() \n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.level = 0;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.headerBuffer = new DynamicBuffer(5);\n  this.nBytesToRead = 0;\n};\n\nexports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;\n\nBinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;\nBinaryXMLStructureDecoder.READ_BYTES = 1;\n\n/**\n * Continue scanning input starting from this.offset.  If found the end of the element\n *   which started at offset 0 then return true, else false.\n * If this returns false, you should read more into input and call again.\n * You have to pass in input each time because the array could be reallocated.\n * This throws an exception for badly formed ndnb.\n */\nBinaryXMLStructureDecoder.prototype.findElementEnd = function(\n  // customBuf\n  input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new BinaryXMLDecoder(input);\n  \n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input.\n      return false;\n  \n    switch (this.state) {\n      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:               \n        // First check for XML_CLOSE.\n        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {\n          ++this.offset;\n          // Close the level.\n          --this.level;\n          if (this.level == 0) {\n            // Finished.\n            this.gotElementEnd = true;\n            return true;\n          }\n          if (this.level < 0)\n            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));\n              \n          // Get ready for the next header.\n          this.startHeader();\n          break;\n        }\n        \n        var startingHeaderLength = this.headerLength;\n        while (true) {\n          if (this.offset >= input.length) {\n            // We can\'t get all of the header bytes from this input. Save in headerBuffer.\n            this.useHeaderBuffer = true;\n            var nNewBytes = this.headerLength - startingHeaderLength;\n            this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n              \n            return false;\n          }\n          var headerByte = input[this.offset++];\n          ++this.headerLength;\n          if (headerByte & XML_TT_NO_MORE)\n            // Break and read the header.\n            break;\n        }\n        \n        var typeAndVal;\n        if (this.useHeaderBuffer) {\n          // Copy the remaining bytes into headerBuffer.\n          nNewBytes = this.headerLength - startingHeaderLength;\n          this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();\n        }\n        else {\n          // We didn\'t have to use the headerBuffer.\n          decoder.seek(this.offset - this.headerLength);\n          typeAndVal = decoder.decodeTypeAndVal();\n        }\n        \n        if (typeAndVal == null)\n          throw new Error("BinaryXMLStructureDecoder: Can\'t read header starting at offset " +\n                          (this.offset - this.headerLength));\n        \n        // Set the next state based on the type.\n        var type = typeAndVal.t;\n        if (type == XML_DATTR)\n          // We already consumed the item. READ_HEADER_OR_CLOSE again.\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n          this.startHeader();\n        else if (type == XML_DTAG || type == XML_EXT) {\n          // Start a new level and READ_HEADER_OR_CLOSE again.\n          ++this.level;\n          this.startHeader();\n        }\n        else if (type == XML_TAG || type == XML_ATTR) {\n          if (type == XML_TAG)\n            // Start a new level and read the tag.\n            ++this.level;\n          // Minimum tag or attribute length is 1.\n          this.nBytesToRead = typeAndVal.v + 1;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n        }\n        else if (type == XML_BLOB || type == XML_UDATA) {\n          this.nBytesToRead = typeAndVal.v;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n        }\n        else\n          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);\n        break;\n    \n      case BinaryXMLStructureDecoder.READ_BYTES:\n        var nRemainingBytes = input.length - this.offset;\n        if (nRemainingBytes < this.nBytesToRead) {\n          // Need more.\n          this.offset += nRemainingBytes;\n          this.nBytesToRead -= nRemainingBytes;\n          return false;\n        }\n        // Got the bytes.  Read a new header or close.\n        this.offset += this.nBytesToRead;\n        this.startHeader();\n        break;\n    \n      default:\n        // We don\'t expect this to happen.\n        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);\n    }\n  }\n};\n\n/**\n * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header\n */\nBinaryXMLStructureDecoder.prototype.startHeader = function() \n{\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;    \n};\n\n/**\n *  Set the offset into the input, used for the next read.\n */\nBinaryXMLStructureDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n},{"../util/dynamic-buffer.js":130,"./binary-xml-decoder.js":58}],126:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * Create a new DecodingException wrapping the given error object.\n * Call with: throw new DecodingException(new Error("message")).\n * @constructor\n * @param {string} error The exception created with new Error.\n */\nfunction DecodingException(error) \n{\n  this.message = error.message;\n  // Copy lineNumber, etc. from where new Error was called.\n  for (var prop in error)\n      this[prop] = error[prop];\n}\nDecodingException.prototype = new Error();\nDecodingException.prototype.name = "DecodingException";\n\nexports.DecodingException = DecodingException;\n\n},{}],75:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar TlvDecoder = require(\'./tlv-decoder.js\').TlvDecoder;\nvar customBuf = require(\'../../buffer.js\').Buffer\n/**\n * Create and initialize a TlvStructureDecoder.\n */\nvar TlvStructureDecoder = function TlvStructureDecoder()\n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.state = TlvStructureDecoder.READ_TYPE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  // 8 bytes is enough to hold the extended bytes in the length encoding \n  // where it is an 8-byte number.\n  this.headerBuffer = new customBuf(8);\n  this.nBytesToRead = 0;\n};\n\nexports.TlvStructureDecoder = TlvStructureDecoder;\n\nTlvStructureDecoder.READ_TYPE =         0;\nTlvStructureDecoder.READ_TYPE_BYTES =   1;\nTlvStructureDecoder.READ_LENGTH =       2;\nTlvStructureDecoder.READ_LENGTH_BYTES = 3;\nTlvStructureDecoder.READ_VALUE_BYTES =  4;\n\n/**\n * Continue scanning input starting from this.offset to find the element end.  \n * If the end of the element which started at offset 0 is found, this returns \n * true and getOffset() is the length of the element.  Otherwise, this returns \n * false which means you should read more into input and call again.\n * @param {Buffer} input The input buffer. You have to pass in input each time\n * because the buffer could be reallocated.\n * @returns {boolean} true if found the element end, false if not.\n */\nTlvStructureDecoder.prototype.findElementEnd = function(input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new TlvDecoder(input);\n\n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input. Return and wait for more.\n      return false;\n\n    if (this.state == TlvStructureDecoder.READ_TYPE) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253)\n        // The value is simple, so we can skip straight to reading the length.\n        this.state = TlvStructureDecoder.READ_LENGTH;\n      else {\n        // Set up to skip the type bytes.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        this.state = TlvStructureDecoder.READ_TYPE_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_TYPE_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the type bytes. Move on to read the length.\n      this.offset += this.nBytesToRead;\n      this.state = TlvStructureDecoder.READ_LENGTH;\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253) {\n        // The value is simple, so we can skip straight to reading \n        //  the value bytes.\n        this.nBytesToRead = firstOctet;\n        if (this.nBytesToRead == 0) {\n          // No value bytes to read. We\'re finished.\n          this.gotElementEnd = true;\n          return true;\n        }\n\n        this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n      }\n      else {\n        // We need to read the bytes in the extended encoding of \n        //  the length.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        // We need to use firstOctet in the next state.\n        this.firstOctet = firstOctet;\n        this.state = TlvStructureDecoder.READ_LENGTH_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (!this.useHeaderBuffer && nRemainingBytes >= this.nBytesToRead) {\n        // We don\'t have to use the headerBuffer. Set nBytesToRead.\n        decoder.seek(this.offset);\n\n        this.nBytesToRead = decoder.readExtendedVarNumber(this.firstOctet);\n        // Update this.offset to the decoder\'s offset after reading.\n        this.offset = decoder.getOffset();\n      }\n      else {\n        this.useHeaderBuffer = true;\n\n        var nNeededBytes = this.nBytesToRead - this.headerLength;\n        if (nNeededBytes > nRemainingBytes) {\n          // We can\'t get all of the header bytes from this input. \n          // Save in headerBuffer.\n          if (this.headerLength + nRemainingBytes > this.headerBuffer.length)\n            // We don\'t expect this to happen.\n            throw new Error\n              ("Cannot store more header bytes than the size of headerBuffer");\n          input.slice(this.offset, this.offset + nRemainingBytes).copy\n            (this.headerBuffer, this.headerLength);\n          this.offset += nRemainingBytes;\n          this.headerLength += nRemainingBytes;\n\n          return false;\n        }\n\n        // Copy the remaining bytes into headerBuffer, read the \n        //   length and set nBytesToRead.\n        if (this.headerLength + nNeededBytes > this.headerBuffer.length)\n          // We don\'t expect this to happen.\n          throw new Error\n            ("Cannot store more header bytes than the size of headerBuffer");\n        input.slice(this.offset, this.offset + nNeededBytes).copy\n          (this.headerBuffer, this.headerLength);\n        this.offset += nNeededBytes;\n\n        // Use a local decoder just for the headerBuffer.\n        var bufferDecoder = new TlvDecoder(this.headerBuffer);\n        // Replace nBytesToRead with the length of the value.\n        this.nBytesToRead = bufferDecoder.readExtendedVarNumber(this.firstOctet);\n      }\n      \n      if (this.nBytesToRead == 0) {\n        // No value bytes to read. We\'re finished.\n        this.gotElementEnd = true;\n        return true;\n      }\n\n      // Get ready to read the value bytes.\n      this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n    }\n    else if (this.state == TlvStructureDecoder.READ_VALUE_BYTES) {\n      nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the bytes. We\'re finished.\n      this.offset += this.nBytesToRead;\n      this.gotElementEnd = true;\n      return true;\n    }\n    else\n      // We don\'t expect this to happen.\n      throw new Error("findElementEnd: unrecognized state");\n  }\n};\n\n/**\n * Get the current offset into the input buffer.\n * @returns {number} The offset.\n */\nTlvStructureDecoder.prototype.getOffset = function()\n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvStructureDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n\n})()\n},{"../../buffer.js":30,"./tlv-decoder.js":21}],79:[function(require,module,exports){\n/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar helpers = require(\'./helpers\');\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function sha1(buf) {\n  return helpers.hash(buf, core_sha1, 20, true);\n};\n\n},{"./helpers":132}],82:[function(require,module,exports){\n/*\r\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\r\n * Digest Algorithm, as defined in RFC 1321.\r\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for more info.\r\n */\r\n\r\nvar helpers = require(\'./helpers\');\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nfunction md5_vm_test()\r\n{\r\n  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";\r\n}\r\n\r\n/*\r\n * Calculate the MD5 of an array of little-endian words, and a bit length\r\n */\r\nfunction core_md5(x, len)\r\n{\r\n  /* append padding */\r\n  x[len >> 5] |= 0x80 << ((len) % 32);\r\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\r\n\r\n  var a =  1732584193;\r\n  var b = -271733879;\r\n  var c = -1732584194;\r\n  var d =  271733878;\r\n\r\n  for(var i = 0; i < x.length; i += 16)\r\n  {\r\n    var olda = a;\r\n    var oldb = b;\r\n    var oldc = c;\r\n    var oldd = d;\r\n\r\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\r\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\r\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\r\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\r\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\r\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\r\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\r\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\r\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\r\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\r\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\r\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\r\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\r\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\r\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\r\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\r\n\r\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\r\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\r\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\r\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\r\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\r\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\r\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\r\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\r\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\r\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\r\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\r\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\r\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\r\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\r\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\r\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\r\n\r\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\r\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\r\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\r\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\r\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\r\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\r\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\r\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\r\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\r\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\r\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\r\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\r\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\r\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\r\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\r\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\r\n\r\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\r\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\r\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\r\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\r\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\r\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\r\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\r\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\r\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\r\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\r\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\r\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\r\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\r\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\r\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\r\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\r\n\r\n    a = safe_add(a, olda);\r\n    b = safe_add(b, oldb);\r\n    c = safe_add(c, oldc);\r\n    d = safe_add(d, oldd);\r\n  }\r\n  return Array(a, b, c, d);\r\n\r\n}\r\n\r\n/*\r\n * These functions implement the four basic operations the algorithm uses.\r\n */\r\nfunction md5_cmn(q, a, b, x, s, t)\r\n{\r\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\r\n}\r\nfunction md5_ff(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\r\n}\r\nfunction md5_gg(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\r\n}\r\nfunction md5_hh(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\r\n}\r\nfunction md5_ii(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y)\r\n{\r\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n  return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction bit_rol(num, cnt)\r\n{\r\n  return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\nmodule.exports = function md5(buf) {\r\n  return helpers.hash(buf, core_md5, 16);\r\n};\r\n\n},{"./helpers":132}],80:[function(require,module,exports){\n\n/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar helpers = require(\'./helpers\');\n\nvar safe_add = function(x, y) {\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n};\n\nvar S = function(X, n) {\n  return (X >>> n) | (X << (32 - n));\n};\n\nvar R = function(X, n) {\n  return (X >>> n);\n};\n\nvar Ch = function(x, y, z) {\n  return ((x & y) ^ ((~x) & z));\n};\n\nvar Maj = function(x, y, z) {\n  return ((x & y) ^ (x & z) ^ (y & z));\n};\n\nvar Sigma0256 = function(x) {\n  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n};\n\nvar Sigma1256 = function(x) {\n  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n};\n\nvar Gamma0256 = function(x) {\n  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n};\n\nvar Gamma1256 = function(x) {\n  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n};\n\nvar core_sha256 = function(m, l) {\n  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);\n  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);\n    var W = new Array(64);\n    var a, b, c, d, e, f, g, h, i, j;\n    var T1, T2;\n  /* append padding */\n  m[l >> 5] |= 0x80 << (24 - l % 32);\n  m[((l + 64 >> 9) << 4) + 15] = l;\n  for (var i = 0; i < m.length; i += 16) {\n    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];\n    for (var j = 0; j < 64; j++) {\n      if (j < 16) {\n        W[j] = m[j + i];\n      } else {\n        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);\n      }\n      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);\n      T2 = safe_add(Sigma0256(a), Maj(a, b, c));\n      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);\n    }\n    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);\n    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);\n  }\n  return HASH;\n};\n\nmodule.exports = function sha256(buf) {\n  return helpers.hash(buf, core_sha256, 32, true);\n};\n\n},{"./helpers":132}],129:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],84:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Forwarding Entries\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar Name = require(\'./name.js\').Name;\n\n/**\n * Create a new ForwardingEntry with the optional arguments.\n * @constructor\n * @param {String} action\n * @param {Name} prefixName\n * @param {PublisherPublicKeyDigest} ndndId\n * @param {number} faceID\n * @param {number} flags\n * @param {number} lifetime in seconds\n */\nvar ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime) \n{\n  this.action = action;\n  this.prefixName = prefixName;\n  this.ndndID = ndndId;\n  this.faceID = faceID;\n  this.flags = flags;\n  this.lifetime = lifetime;\n};\n\nexports.ForwardingEntry = ForwardingEntry;\n\nForwardingEntry.ACTIVE         = 1;\nForwardingEntry.CHILD_INHERIT  = 2;\nForwardingEntry.ADVERTISE      = 4;\nForwardingEntry.LAST           = 8;\nForwardingEntry.CAPTURE       = 16;\nForwardingEntry.LOCAL         = 32;\nForwardingEntry.TAP           = 64;\nForwardingEntry.CAPTURE_OK   = 128;\n\nForwardingEntry.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n  //throws DecodingException\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action); \n  if (decoder.peekDTag(NDNProtocolDTags.Name)) {\n    this.prefixName = new Name();\n    this.prefixName.from_ndnb(decoder) ;\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.NdndId = new PublisherPublicKeyDigest();\n    this.NdndId.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID); \n  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))\n    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\nForwardingEntry.prototype.to_ndnb = function(\n  //XMLEncoder \n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.prefixName)\n    this.prefixName.to_ndnb(encoder);\n  if (null != this.NdndId)\n    this.NdndId.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.flags)\n    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);\n  if (null != this.lifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);\n\n  encoder.writeElementClose();         \n};\n\nForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }\n\n},{"./name.js":33,"./publisher-public-key-digest.js":41,"./util/ndn-protoco-id-tags.js":87}],88:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.\nexports.TcpTransport = require(\'./transport/web-socket-transport.js\').WebSocketTransport;\n\n},{"./transport/web-socket-transport.js":133}],91:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data Signature object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Signature with the optional values.\n * @constructor\n */\nvar Signature = function Signature(witnessOrSignatureObject, signature, digestAlgorithm) \n{\n  if (typeof witnessOrSignatureObject === \'object\' && \n      witnessOrSignatureObject instanceof Signature) {\n    // Copy the values.\n    this.keyLocator = new KeyLocator(witnessOrSignatureObject.keyLocator);\n    this.signature = witnessOrSignatureObject.signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject.witness;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = witnessOrSignatureObject.digestAlgorithm;\n  }\n  else {\n    this.keyLocator = new KeyLocator();\n    this.signature = signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = digestAlgorithm;\n  }\n};\n\nexports.Signature = Signature;\n\n/**\n * Create a new Signature which is a copy of this object.\n * @returns {Signature} A new object which is a copy of this object.\n */\nSignature.prototype.clone = function()\n{\n  return new Signature(this);\n};\n\n/**\n * Get the key locator.\n * @returns {KeyLocator} The key locator.\n */\nSignature.prototype.getKeyLocator = function()\n{\n  return this.keyLocator;\n};\n\n/**\n * Get the data packet\'s signature bytes.\n * @returns {Buffer} The signature bytes.\n */\nSignature.prototype.getSignature = function()\n{\n  return this.signature;\n};\n\n/**\n * Set the key locator to a copy of the given keyLocator.\n * @param {KeyLocator} keyLocator The KeyLocator to copy.\n */\nSignature.prototype.setKeyLocator = function(keyLocator)\n{\n  this.keyLocator = typeof keyLocator === \'object\' && keyLocator instanceof KeyLocator ?\n                    new KeyLocator(keyLocator) : new KeyLocator();\n};\n  \n/**\n * Set the data packet\'s signature bytes.\n * @param {type} signature\n */\nSignature.prototype.setSignature = function(signature)\n{\n  if (signature == null)\n    this.signature = null;\n  else if (typeof signature === \'object\' && signature instanceof Blob)\n    this.signature = new customBuf(signature.buf());\n  else\n    this.signature = new customBuf(signature);\n};\n\nSignature.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'STARTED DECODING SIGNATURE\');\n    \n  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {\n    if (LOG > 4) console.log(\'DIGIEST ALGORITHM FOUND\');\n    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm); \n  }\n  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {\n    if (LOG > 4) console.log(\'WITNESS FOUND\');\n    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness); \n  }\n    \n  //FORCE TO READ A SIGNATURE\n\n  if (LOG > 4) console.log(\'SIGNATURE FOUND\');\n  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);\n\n  decoder.readElementClose();\n};\n\nSignature.prototype.to_ndnb = function(encoder) \n{      \n  if (!this.validate())\n    throw new Error("Cannot encode: field values missing.");\n  \n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))\n    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));\n  \n  if (null != this.witness)\n    // needs to handle null witness\n    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);\n\n  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);\n\n  encoder.writeElementClose();       \n};\n\nSignature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };\n\nSignature.prototype.validate = function() \n{\n  return null != this.signature;\n};\n\n})()\n},{"./buffer.js":54,"./encoding/binary-xml-decoder.js":85,"./encoding/binary-xml-encoder.js":86,"./key-locator.js":40,"./log.js":89,"./util/blob.js":49,"./util/ndn-protoco-id-tags.js":87}],92:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Publisher and PublisherType Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNProtocolDTagsStrings = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTagsStrings;\nvar DecodingException = require(\'./encoding/decoding-exception.js\').DecodingException;\n\n/**\n * @constructor\n */\nvar PublisherType = function PublisherType(tag) \n{\n  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;\n  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;\n  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;\n  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  this.Tag = tag;\n}; \n\n/**\n * @constructor\n */\nvar PublisherID = function PublisherID() \n{\n  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";\n  this.PUBLISHER_ID_LEN = 256/8;\n    \n  //TODO, implement publisherID creation and key creation\n\n  //TODO implement generatePublicKeyDigest\n  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray\n    \n  //TODO implement generate key\n  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);\n  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type   \n};\n\nexports.PublisherID = PublisherID;\n\nPublisherID.prototype.from_ndnb = function(decoder) \n{    \n  // We have a choice here of one of 4 binary element types.\n  var nextTag = PublisherID.peekAndGetNextDTag(decoder);\n    \n  this.publisherType = new PublisherType(nextTag); \n    \n  if (nextTag < 0)\n    throw new Error("Invalid publisher ID, got unexpected type");\n\n  this.publisherID = decoder.readBinaryDTagElement(nextTag);\n  if (null == this.publisherID)\n    throw new DecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));\n};\n\nPublisherID.prototype.to_ndnb = function(encoder) \n{\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);\n};\n\n/**\n * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.\n * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.\n * @returns {number} The PublisherID DTag or -1 if it is not one of them.\n */\nPublisherID.peekAndGetNextDTag = function(decoder) \n{\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))\n    return             NDNProtocolDTags.PublisherPublicKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))\n    return             NDNProtocolDTags.PublisherCertificateDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))\n    return             NDNProtocolDTags.PublisherIssuerKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))\n    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;\n  \n  return -1;\n};\n  \nPublisherID.peek = function(/* XMLDecoder */ decoder) \n{\n  return PublisherID.peekAndGetNextDTag(decoder) >= 0;\n};\n\nPublisherID.prototype.getElementLabel = function()\n{ \n  return this.publisherType.Tag;\n};\n\nPublisherID.prototype.validate = function() \n{\n  return null != id() && null != type();\n};\n\n},{"./encoding/decoding-exception.js":126,"./util/ndn-protoco-id-tags.js":87}],93:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang\n * See COPYING for copyright and distribution information.\n * This class represents the top-level object for communicating with an NDN host.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar crypto = require(\'./crypto.js\');\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Interest = require(\'./interest.js\').Interest;\nvar Data = require(\'./data.js\').Data;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\nvar TlvWireFormat = require(\'./encoding/tlv-wire-format.js\').TlvWireFormat;\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\nvar Tlv = require(\'./encoding/tlv/tlv.js\').Tlv;\nvar TlvDecoder = require(\'./encoding/tlv/tlv-decoder.js\').TlvDecoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Key = require(\'./key.js\').Key;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar ForwardingFlags = require(\'./forwarding-flags.js\').ForwardingFlags;\nvar Closure = require(\'./closure.js\').Closure;\nvar UpcallInfo = require(\'./closure.js\').UpcallInfo;\nvar TcpTransport = require(\'./transport/tcp-transport.js\').TcpTransport;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Face with the given settings.\n * This throws an exception if Face.supported is false.\n * @constructor\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.\n *              OR function() { return new TcpTransport(); },       // If in Node.js.\n *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.\n *   host: null, // If null, use getHostAndPort when connecting.\n *   port: 9696, // If in the browser.\n *      OR 6363, // If in Node.js.\n *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },\n *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },\n *   verify: false // If false, don\'t verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.\n * }\n */\nvar Face = function Face(settings)\n{\n  if (!Face.supported)\n    throw new Error("The necessary JavaScript support is not available on this platform.");\n\n  settings = (settings || {});\n  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.\n  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });\n  this.transport = getTransport();\n  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);\n  this.host = (settings.host !== undefined ? settings.host : null);\n  this.port = (settings.port || (typeof WebSocketTransport != \'undefined\' ? 9696 : 6363));\n  this.readyStatus = Face.UNOPEN;\n  this.verify = (settings.verify !== undefined ? settings.verify : false);\n  // Event handler\n  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });\n  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });\n  this.ndndid = null;\n};\n\nexports.Face = Face;\n\nFace.UNOPEN = 0;  // created but not opened yet\nFace.OPENED = 1;  // connection to ndnd opened\nFace.CLOSED = 2;  // connection to ndnd closed\n\n/**\n * Return true if necessary JavaScript support is available, else log an error and return false.\n */\nFace.getSupported = function()\n{\n  try {\n    var dummy = new customBuf(1).slice(0, 1);\n  }\n  catch (ex) {\n    console.log("NDN not available: customBuf not supported. " + ex);\n    return false;\n  }\n\n  return true;\n};\n\nFace.supported = Face.getSupported();\n\nFace.ndndIdFetcher = new Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\');\n\nFace.prototype.createRoute = function(host, port)\n{\n  this.host=host;\n  this.port=port;\n};\n\nFace.KeyStore = new Array();\n\nvar KeyStoreEntry = function KeyStoreEntry(name, rsa, time)\n{\n  this.keyName = name;  // KeyName\n  this.rsaKey = rsa;    // RSA key\n  this.timeStamp = time;  // Time Stamp\n};\n\nFace.addKeyEntry = function(/* KeyStoreEntry */ keyEntry)\n{\n  var result = Face.getKeyByName(keyEntry.keyName);\n  if (result == null)\n    Face.KeyStore.push(keyEntry);\n  else\n    result = keyEntry;\n};\n\nFace.getKeyByName = function(/* KeyName */ name)\n{\n  var result = null;\n\n  for (var i = 0; i < Face.KeyStore.length; i++) {\n    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {\n      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)\n        result = Face.KeyStore[i];\n    }\n  }\n\n  return result;\n};\n\nFace.prototype.close = function()\n{\n  if (this.readyStatus != Face.OPENED)\n    throw new Error(\'Cannot close because Face connection is not opened.\');\n\n  this.readyStatus = Face.CLOSED;\n  this.transport.close();\n};\n\n// For fetching data\nFace.PITTable = new Array();\n\n/**\n * @constructor\n */\nvar PITEntry = function PITEntry(interest, closure)\n{\n  this.interest = interest;  // Interest\n  this.closure = closure;    // Closure\n  this.timerID = -1;  // Timer ID\n};\n\n/**\n * Return the entry from Face.PITTable where the name conforms to the interest selectors, and\n * the interest name is the longest that matches name.\n */\n\n/**\n * Find all entries from Face.PITTable where the name conforms to the entry\'s\n * interest selectors, remove the entries from the table, cancel their timeout\n * timers and return them.\n * @param {Name} name The name to find the interest for (from the incoming data\n * packet).\n * @returns {Array<PITEntry>} The matching entries from Face.PITTable, or [] if\n * none are found.\n */\nFace.extractEntriesForExpressedInterest = function(name)\n{\n  var result = [];\n\n  // Go backwards through the list so we can erase entries.\n  for (var i = Face.PITTable.length - 1; i >= 0; --i) {\n    var entry = Face.PITTable[i];\n    if (entry.interest.matchesName(name)) {\n      // Cancel the timeout timer.\n      clearTimeout(entry.timerID);\n\n      result.push(entry);\n      Face.PITTable.splice(i, 1);\n    }\n  }\n\n  return result;\n};\n\n// For publishing data\nFace.registeredPrefixTable = new Array();\n\n/**\n * @constructor\n */\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n/**\n * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.\n * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).\n * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.\n */\nfunction getEntryForRegisteredPrefix(name)\n{\n  var iResult = -1;\n\n  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {\n    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " , Face.registeredPrefixTable[i].prefix , " matches " , name);\n    if (Face.registeredPrefixTable[i].prefix.match(name)) {\n      if (iResult < 0 ||\n          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())\n        // Update to the longer match.\n        iResult = i;\n    }\n  }\n\n  if (iResult >= 0)\n    return Face.registeredPrefixTable[iResult];\n  else\n    return null;\n}\n\n/**\n * Return a function that selects a host at random from hostList and returns { host: host, port: port }.\n * If no more hosts remain, return null.\n */\nFace.makeShuffledGetHostAndPort = function(hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n/**\n * Send the interest through the transport, read the entire response and call onData.\n * If the interest times out according to interest lifetime, call onTimeout (if not omitted).\n * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):\n * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from\n * a name and optional interest template:\n * expressInterest(name [, template], onData [, onTimeout]).\n * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.\n * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.\n * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:\n *   interest is the interest given to expressInterest,\n *   data is the received Data object.\n * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime,\n *   this calls onTimeout(interest) where:\n *   interest is the interest given to expressInterest.\n * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).\n * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest.\n * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).\n */\nFace.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of expressInterest, each shown inline below.\n\n  // expressInterest(Name name, Closure closure);                      // deprecated\n  // expressInterest(Name name, Closure closure,   Interest template); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    if (arg3) {\n      var template = arg3;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n    }\n    else\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n\n    this.expressInterestWithClosure(interest, arg2);\n    return;\n  }\n\n  var interest;\n  var onData;\n  var onTimeout;\n  // expressInterest(Interest interest, function onData);\n  // expressInterest(Interest interest, function onData, function onTimeout);\n  if (typeof interestOrName == \'object\' && interestOrName instanceof Interest) {\n    // Just use a copy of the interest.\n    interest = new Interest(interestOrName);\n    onData = arg2;\n    onTimeout = (arg3 ? arg3 : function() {});\n  }\n  else {\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    // expressInterest(Name name, Interest template, function onData);\n    // expressInterest(Name name, Interest template, function onData, function onTimeout);\n    if (arg2 && typeof arg2 == \'object\' && arg2 instanceof Interest) {\n      var template = arg2;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n\n      onData = arg3;\n      onTimeout = (arg4 ? arg4 : function() {});\n    }\n    // expressInterest(Name name, function onData);\n    // expressInterest(Name name, function onData,   function onTimeout);\n    else {\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n      onData = arg2;\n      onTimeout = (arg3 ? arg3 : function() {});\n    }\n  }\n\n  // Make a Closure from the callbacks so we can use expressInterestWithClosure.\n  // TODO: Convert the PIT to use callbacks, not a closure.\n  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout), interest);\n}\n\nFace.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.onData = onData;\n  this.onTimeout = onTimeout;\n  this.onInterest = onInterest;\n  this.prefix = prefix;\n  this.transport = transport;\n};\n\nFace.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {\n  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)\n    this.onData(upcallInfo.interest, upcallInfo.data);\n  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)\n    this.onTimeout(upcallInfo.interest);\n  else if (kind == Closure.UPCALL_INTEREST)\n    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.\n    this.onInterest(this.prefix, upcallInfo.interest, this.transport)\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * A private method to send the the interest to host:port, read the entire response and call\n * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),\n *                 new UpcallInfo(this, interest, 0, data)).\n * @deprecated Use expressInterest with callback functions, not Closure.\n * @param {Interest} the interest, already processed with a template (if supplied).\n * @param {Closure} closure\n */\nFace.prototype.expressInterestWithClosure = function(interest, closure)\n{\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else {\n      var thisNDN = this;\n      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });\n    }\n  }\n  else\n    this.reconnectAndExpressInterest(interest, closure);\n};\n\n/**\n * If the host and port are different than the ones in this.transport, then call\n *   this.transport.connect to change the connection (or connect for the first time).\n * Then call expressInterestHelper.\n */\nFace.prototype.reconnectAndExpressInterest = function(interest, closure)\n{\n  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {\n    var thisNDN = this;\n    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });\n    this.readyStatus = Face.OPENED;\n  }\n  else\n    this.expressInterestHelper(interest, closure);\n};\n\n/**\n * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call\n *   this.transport.send to send the interest.\n */\nFace.prototype.expressInterestHelper = function(interest, closure)\n{\n  var binaryInterest = interest.wireEncode();\n  var thisNDN = this;\n  //TODO: check local content store first\n  if (closure != null) {\n    var pitEntry = new PITEntry(interest, closure);\n    // TODO: This needs to be a single thread-safe transaction on a global object.\n    Face.PITTable.push(pitEntry);\n    closure.pitEntry = pitEntry;\n\n    // Set interest timer.\n    var timeoutMilliseconds = (interest.interestLifetime || 4000);\n    var timeoutCallback = function() {\n      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());\n\n      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express\n      //   the interest because we don\'t want to match it in the mean time.\n      // TODO: Make this a thread-safe operation on the global PITTable.\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0)\n        Face.PITTable.splice(index, 1);\n\n      // Raise closure callback\n      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {\n        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());\n        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n        Face.PITTable.push(pitEntry);\n        thisNDN.transport.send(binaryInterest.buf());\n      }\n    };\n\n    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n  }\n\n  this.transport.send(binaryInterest.buf());\n};\n\n/**\n * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.\n * This uses the form:\n * registerPrefix(name, onInterest, onRegisterFailed [, flags]).\n * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.\n * @param {Name} prefix The Name prefix.\n * @param {function} onInterest When an interest is received which matches the name prefix, this calls\n * onInterest(prefix, interest, transport) where:\n *   prefix is the prefix given to registerPrefix.\n *   interest is the received interest.\n *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().\n * @param {function} onRegisterFailed If failed to retrieve the connected hub\'s ID or failed to register the prefix,\n * this calls onRegisterFailed(prefix) where:\n *   prefix is the prefix given to registerPrefix.\n * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.\n * If omitted, use the default flags defined by the default ForwardingFlags constructor.\n */\nFace.prototype.registerPrefix = function(prefix, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of registerPrefix, each shown inline below.\n\n  // registerPrefix(Name prefix, Closure closure);            // deprecated\n  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.registerPrefixWithClosure(prefix, arg2, arg3);\n    else\n      this.registerPrefixWithClosure(prefix, arg2);\n    return;\n  }\n\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);\n  var onInterest = arg2;\n  var onRegisterFailed = (arg3 ? arg3 : function() {});\n  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());\n  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport),\n                                 intFlags, onRegisterFailed);\n}\n\n/**\n * A private method to register the prefix with the host, receive the data and call\n * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)).\n * @deprecated Use registerPrefix with callback functions, not Closure.\n * @param {Name} prefix\n * @param {Closure} closure\n * @param {number} intFlags\n * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix)\n * if registration fails.\n */\nFace.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed)\n{\n  intFlags = intFlags | 3;\n  var thisNDN = this;\n  var onConnected = function() {\n    if (thisNDN.ndndid == null) {\n      // Fetch ndndid first, then register.\n      var interest = new Interest(Face.ndndIdFetcher);\n      interest.interestLifetime = 4000; // milliseconds\n      if (LOG > 3) console.log(\'Expressing interest for ndndid from ndnd.\');\n      thisNDN.reconnectAndExpressInterest\n        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));\n    }\n    else\n      thisNDN.registerPrefixHelper(prefix, closure, flags, onRegisterFailed);\n  };\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else\n      this.connectAndExecute(onConnected);\n  }\n  else\n    onConnected();\n};\n\n/**\n * This is a closure to receive the Data for Face.ndndIdFetcher and call\n *   registerPrefixHelper(prefix, callerClosure, flags).\n */\nFace.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.prefix = prefix;\n  this.callerClosure = callerClosure;\n  this.flags = flags;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n\n  if (LOG > 3) console.log(\'Got ndndid from ndnd.\');\n  // Get the digest of the public key in the data packet content.\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(upcallInfo.data.getContent());\n  this.face.ndndid = new customBuf(DataUtils.toNumbersIfString(hash.digest()));\n  if (LOG > 3) console.log(this.face.ndndid);\n\n  this.face.registerPrefixHelper\n    (this.prefix, this.callerClosure, this.flags, this.onRegisterFailed);\n\n  return Closure.RESULT_OK;\n};\n/**\n * This is a closure to receive the response Data packet from the register\n * prefix interest sent to the connected NDN hub. If this gets a bad response\n * or a timeout, call onRegisterFailed.\n */\nFace.RegisterResponseClosure = function RegisterResponseClosure\n  (prefix, onRegisterFailed)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.prefix = prefix;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.RegisterResponseClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n\n  var expectedName = new Name("/ndnx/.../selfreg");\n  // Got a response. Do a quick check of expected name components.\n  if (upcallInfo.data.getName().size() < 4 ||\n      !upcallInfo.data.getName().get(0).equals(expectedName.get(0)) ||\n      !upcallInfo.data.getName().get(2).equals(expectedName.get(2))) {\n    this.onRegisterFailed(this.prefix);\n    return;\n  }\n\n  // Otherwise, silently succeed.\n  return Closure.RESULT_OK;\n};\n\n/**\n * Do the work of registerPrefix once we know we are connected with a ndndid.\n */\nFace.prototype.registerPrefixHelper = function\n  (prefix, closure, flags, onRegisterFailed)\n{\n  var fe = new ForwardingEntry(\'selfreg\', prefix, null, null, flags, null);\n\n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  var encoder = new BinaryXMLEncoder();\n  fe.to_ndnb(encoder);\n  var bytes = encoder.getReducedOstream();\n\n  var si = new MetaInfo();\n  si.setFields();\n\n  // Set the name to a random value so that each request is unique.\n  var data = new Data(new Name().append(require("crypto").randomBytes(4)), si, bytes);\n  // Always encode as BinaryXml until we support TLV for ForwardingEntry.\n  data.sign(BinaryXmlWireFormat.get());\n  var coBinary = data.wireEncode(BinaryXmlWireFormat.get());;\n\n  var nodename = this.ndndid;\n  var interestName = new Name([\'ndnx\', nodename, \'selfreg\', coBinary]);\n\n  var interest = new Interest(interestName);\n  interest.setInterestLifetimeMilliseconds(4000.0);\n  interest.setScope(1);\n  if (LOG > 3) console.log(\'Send Interest registration packet.\');\n\n  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n  this.reconnectAndExpressInterest\n    (interest, new Face.RegisterResponseClosure(prefix, onRegisterFailed));\n};\n\n/**\n * This is called when an entire binary XML element is received, such as a Data or Interest.\n * Look up in the PITTable and call the closure callback.\n */\nFace.prototype.onReceivedElement = function(element)\n{\n  if (LOG > 3) console.log(\'Complete element received. Length \' + element.length + \'. Start decoding.\');\n  // First, decode as Interest or Data.\n  var interest = null;\n  var data = null;\n  // The type codes for TLV Interest and Data packets are chosen to not\n  //   conflict with the first byte of a binary XML packet, so we can\n  //   just look at the first byte.\n  if (element[0] == Tlv.Interest || element[0] == Tlv.Data) {\n    if (LOG > 3) console.log(\'Detected Tlv element\', element, TlvWireFormat.get())\n    var decoder = new TlvDecoder(element);\n    if (decoder.peekType(Tlv.Interest, element.length)) {\n      interest = new Interest();\n      interest.wireDecode(element, TlvWireFormat.get());\n    }\n    else if (decoder.peekType(Tlv.Data, element.length)) {\n      data = new Data();\n      data.wireDecode(element, TlvWireFormat.get());\n    }\n  }\n  else {\n    if (LOG > 3) console.log(\'assumed BinaryXML\')\n    // Binary XML.\n    var decoder = new BinaryXMLDecoder(element);\n    if (decoder.peekDTag(NDNProtocolDTags.Interest)) {\n      interest = new Interest();\n      interest.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Data)) {\n      data = new Data();\n      data.wireDecode(element, BinaryXmlWireFormat.get());\n    }\n  }\n\n  // Now process as Interest or Data.\n  if (interest !== null) {\n    if (LOG > 3) console.log(\'Interest packet received.\');\n    var entry = getEntryForRegisteredPrefix(interest.name);\n    if (entry != null) {\n      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());\n      var info = new UpcallInfo(this, interest, 0, null);\n      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);\n      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null)\n        this.transport.send(info.data.wireEncode().buf());\n    }\n  }\n  else if (data !== null) {\n    if (LOG > 3) console.log(\'Data packet received.\');\n\n    var pendingInterests = Face.extractEntriesForExpressedInterest(data.name);\n    // Process each matching PIT entry (if any).\n    for (var i = 0; i < pendingInterests.length; ++i) {\n      var pitEntry = pendingInterests[i];\n      var currentClosure = pitEntry.closure;\n\n      if (this.verify == false) {\n        // Pass content up without verifying the signature\n        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));\n        continue;\n      }\n\n      // Key verification\n\n      // Recursive key fetching & verification closure\n      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {\n        this.data = content;  // unverified data packet object\n        this.closure = closure;  // closure corresponding to the data\n        this.keyName = key;  // name of current key to be fetched\n\n        Closure.call(this);\n      };\n\n      var thisNDN = this;\n      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {\n        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n          console.log("In KeyFetchClosure.upcall: interest time out.");\n          console.log(this.keyName.contentName.toUri());\n        }\n        else if (kind == Closure.UPCALL_CONTENT) {\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(upcallInfo.data.content);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));\n\n          // Store key in cache\n          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());\n          Face.addKeyEntry(keyEntry);\n        }\n        else if (kind == Closure.UPCALL_CONTENT_BAD)\n          console.log("In KeyFetchClosure.upcall: signature verification failed");\n      };\n\n      if (data.signedInfo && data.signedInfo.locator && data.signature) {\n        if (LOG > 3) console.log("Key verification...");\n        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();\n\n        var wit = null;\n        if (data.signature.witness != null)\n            //SWT: deprecate support for Witness decoding and Merkle hash tree verification\n            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n        var keylocator = data.signedInfo.locator;\n        if (keylocator.type == KeyLocatorType.KEYNAME) {\n          if (LOG > 3) console.log("KeyLocator contains KEYNAME");\n\n          if (keylocator.keyName.contentName.match(data.name)) {\n            if (LOG > 3) console.log("Content is key itself");\n\n            var rsakey = new Key();\n            rsakey.readDerPublicKey(data.content);\n            var verified = data.verify(rsakey);\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n            // SWT: We don\'t need to store key here since the same key will be stored again in the closure.\n          }\n          else {\n            // Check local key store\n            var keyEntry = Face.getKeyByName(keylocator.keyName);\n            if (keyEntry) {\n              // Key found, verify now\n              if (LOG > 3) console.log("Local key cache hit");\n              var rsakey = keyEntry.rsaKey;\n              var verified = data.verify(rsakey);\n              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n              // Raise callback\n              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n            }\n            else {\n              // Not found, fetch now\n              if (LOG > 3) console.log("Fetch key according to keylocator");\n              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);\n              // TODO: Use expressInterest with callbacks, not Closure.\n              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);\n            }\n          }\n        }\n        else if (keylocator.type == KeyLocatorType.KEY) {\n          if (LOG > 3) console.log("Keylocator contains KEY");\n\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(keylocator.publicKey);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          // Raise callback\n          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n          // Since KeyLocator does not contain key name for this key,\n          // we have no way to store it as a key entry in KeyStore.\n        }\n        else {\n          var cert = keylocator.certificate;\n          console.log("KeyLocator contains CERT");\n          console.log(cert);\n          // TODO: verify certificate\n        }\n      }\n    }\n  }\n};\n\n/**\n * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host\n *   is not alive.  Get a host and port, connect, then execute onConnected().\n */\nFace.prototype.connectAndExecute = function(onConnected)\n{\n  var hostAndPort = this.getHostAndPort();\n  if (hostAndPort == null) {\n    console.log(\'ERROR: No more hosts from getHostAndPort\');\n    this.host = null;\n    return;\n  }\n\n  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {\n    console.log(\'ERROR: The host returned by getHostAndPort is not alive: \' + this.host + ":" + this.port);\n    return;\n  }\n\n  this.host = hostAndPort.host;\n  this.port = hostAndPort.port;\n  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);\n\n  // Fetch any content.\n  var interest = new Interest(new Name("/"));\n  interest.interestLifetime = 4000; // milliseconds\n\n  var thisNDN = this;\n  var timerID = setTimeout(function() {\n    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);\n      // Try again.\n      thisNDN.connectAndExecute(onConnected);\n  }, 3000);\n\n  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));\n};\n\n/**\n * This is called by the Transport when the connection is closed by the remote host.\n */\nFace.prototype.closeByTransport = function()\n{\n  this.readyStatus = Face.CLOSED;\n  this.onclose();\n};\n\nFace.ConnectClosure = function ConnectClosure(face, onConnected, timerID)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.onConnected = onConnected;\n  this.timerID = timerID;\n};\n\nFace.ConnectClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.\n    return Closure.RESULT_ERR;\n\n  // The host is alive, so cancel the timeout and continue with onConnected().\n  clearTimeout(this.timerID);\n\n    // Call Face.onopen after success\n  this.face.readyStatus = Face.OPENED;\n  this.face.onopen();\n\n  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);\n  this.onConnected();\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * @deprecated Use new Face.\n */\nvar NDN = function NDN(settings)\n{\n  // Call the base constructor.\n  Face.call(this, settings);\n}\n\n// Use dummy functions so that the Face constructor will not try to set its own defaults.\nNDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });\n\nexports.NDN = NDN;\n\nNDN.supported = Face.supported;\nNDN.UNOPEN = Face.UNOPEN;\nNDN.OPENED = Face.OPENED;\nNDN.CLOSED = Face.CLOSED;\n\n})()\n},{"./buffer.js":116,"./closure.js":94,"./crypto.js":116,"./data.js":99,"./encoding/binary-xml-decoder.js":135,"./encoding/binary-xml-encoder.js":136,"./encoding/binary-xml-wire-format.js":105,"./encoding/data-utils.js":109,"./encoding/tlv-wire-format.js":106,"./encoding/tlv/tlv-decoder.js":107,"./encoding/tlv/tlv.js":108,"./forwarding-entry.js":134,"./forwarding-flags.js":96,"./interest.js":97,"./key-locator.js":102,"./key.js":101,"./log.js":139,"./meta-info.js":100,"./name.js":95,"./transport/tcp-transport.js":138,"./util/ndn-protoco-id-tags.js":137,"crypto":56}],95:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents a Name as an array of components where each is a byte array.\n */\n \nvar Blob = require(\'./util/blob.js\').Blob;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Name from components.\n * \n * @constructor\n * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.  \n * Otherwise it is an array of components which are appended according to Name.append, so\n * convert each and store it as an array of customBuf.  If a component is a string, encode as utf8.\n */\nvar Name = function Name(components) \n{\n  if (typeof components == \'string\') {    \n    if (LOG > 3) console.log(\'Content Name String \' + components);\n    this.components = Name.createNameArray(components);\n  }\n  else if (typeof components === \'object\') {    \n    this.components = [];\n    if (components instanceof Name)\n      this.append(components);\n    else {\n      for (var i = 0; i < components.length; ++i)\n        this.append(components[i]);\n    }\n  }\n  else if (components == null)\n    this.components = [];\n  else\n    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");\n};\n\nexports.Name = Name;\n\n/**\n * \n * @constructor\n * Create a new Name.Component with a copy of the given value.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don\'t unescape).\n */\nName.Component = function NameComponent(value) \n{\n  if (typeof value === \'string\')\n    this.value = DataUtils.stringToUtf8Array(value);\n  else if (typeof value === \'object\' && value instanceof Name.Component)\n    this.value = new customBuf(value.value);\n  else if (typeof value === \'object\' && value instanceof Blob)\n    this.value = new customBuf(value.buf());\n  else if (typeof value === \'object\' && value instanceof customBuf)\n    this.value = new customBuf(value);\n  else if (typeof value === \'object\' && typeof ArrayBuffer !== \'undefined\' &&  value instanceof ArrayBuffer) {\n    // Make a copy.  Don\'t use ArrayBuffer.slice since it isn\'t always supported.                                                      \n    this.value = new customBuf(new ArrayBuffer(value.byteLength));\n    this.value.set(new customBuf(value));\n  }\n  else if (typeof value === \'object\')\n    // Assume value is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    this.value = new customBuf(value);\n  else if (!value)\n    this.value = new customBuf(0);\n  else \n    throw new Error("Name.Component constructor: Invalid type");\n}\n\n/**\n * Get the component value.\n * @returns {Buffer} The component value.\n */\nName.Component.prototype.getValue = function() \n{\n  return this.value;\n}\n\n/**\n * Convert this component value to a string by escaping characters according to the NDN URI Scheme.\n * This also adds "..." to a value with zero or more ".".\n * @returns {string} The escaped string.\n */\nName.Component.prototype.toEscapedString = function() \n{\n  return Name.toEscapedString(this.value);\n}\n\n/**\n * Check if this is the same component as other.\n * @param {Name.Component} other The other Component to compare with.\n * @returns {Boolean} true if the components are equal, otherwise false.\n */\nName.Component.prototype.equals = function(other) \n{\n  return DataUtils.arraysEqual(this.value, other.value);\n}\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.getName = function() \n{\n  return this.toUri();\n};\n\n/** Parse uri as a URI and return an array of customBuf components.\n */\nName.createNameArray = function(uri) \n{\n  uri = uri.trim();\n  if (uri.length <= 0)\n    return [];\n\n  var iColon = uri.indexOf(\':\');\n  if (iColon >= 0) {\n    // Make sure the colon came before a \'/\'.\n    var iFirstSlash = uri.indexOf(\'/\');\n    if (iFirstSlash < 0 || iColon < iFirstSlash)\n      // Omit the leading protocol such as ndn:\n      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();\n  }\n    \n  if (uri[0] == \'/\') {\n    if (uri.length >= 2 && uri[1] == \'/\') {\n      // Strip the authority following "//".\n      var iAfterAuthority = uri.indexOf(\'/\', 2);\n      if (iAfterAuthority < 0)\n        // Unusual case: there was only an authority.\n        return [];\n      else\n        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();\n    }\n    else\n      uri = uri.substr(1, uri.length - 1).trim();\n  }\n\n  var array = uri.split(\'/\');\n    \n  // Unescape the components.\n  for (var i = 0; i < array.length; ++i) {\n    var value = Name.fromEscapedString(array[i]);\n        \n    if (value == null) {\n      // Ignore the illegal componenent.  This also gets rid of a trailing \'/\'.\n      array.splice(i, 1);\n      --i;  \n      continue;\n    }\n    else\n      array[i] = new Name.Component(value);\n  }\n\n  return array;\n};\n\nName.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)  \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  this.components = [];\n\n  while (decoder.peekDTag(NDNProtocolDTags.Component))\n    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    \n  decoder.readElementClose();\n};\n\nName.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{    \n  if (this.components == null) \n    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  var count = this.size();\n  for (var i=0; i < count; i++)\n    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());\n  \n  encoder.writeElementClose();\n};\n\nName.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.Name;\n};\n\n/**\n * Convert the component to a customBuf and append to this Name.\n * Return this Name object to allow chaining calls to add.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don\'t unescape).\n * @returns {Name}\n */\nName.prototype.append = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name) {\n    var components;\n    if (component == this)\n      // special case, when we need to create a copy\n      components = this.components.slice(0, this.components.length);\n    else\n      components = component.components;\n      \n    for (var i = 0; i < components.length; ++i)\n      this.components.push(new Name.Component(components[i]));\n  }\n  else\n    // Just use the Name.Component constructor.\n    this.components.push(new Name.Component(component));\n\n  return this;\n};\n\n/**\n * @deprecated Use append.\n */\nName.prototype.add = function(component)\n{\n  return this.append(component);\n};\n\n/**\n * Clear all the components.\n */\nName.prototype.clear = function()\n{\n  this.components = [];  \n};\n\n/**\n * Return the escaped name string according to "NDNx URI Scheme".\n * @returns {String}\n */\nName.prototype.toUri = function() \n{  \n  if (this.size() == 0)\n    return "/";\n    \n  var result = "";\n  \n  for (var i = 0; i < this.size(); ++i)\n    result += "/"+ Name.toEscapedString(this.components[i].getValue());\n  \n  return result;  \n};\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.to_uri = function() \n{\n  return this.toUri();\n};\n\n/**\n * Append a component with the encoded segment number.\n * @param {number} segment The segment number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendSegment = function(segment) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(segment);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * Append a component with the encoded version number.\n * Note that this encodes the exact value of version without converting from a \n * time representation.\n * @param {number} version The version number.\n * @returns {Name} This name so that you can chain calls to append.\n */\nName.prototype.appendVersion = function(version) \n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(version);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0xfD;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * @deprecated Use appendSegment.\n */\nName.prototype.addSegment = function(number) \n{\n  return this.appendSegment(number);\n};\n\n/**\n * Get a new name, constructed as a subset of components.\n * @param {number} iStartComponent The index if the first component to get.\n * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,\n * return components starting at iStartComponent until the end of the name.\n * @returns {Name} A new name.\n */\nName.prototype.getSubName = function(iStartComponent, nComponents)\n{\n  if (nComponents == undefined)\n    nComponents = this.components.length - iStartComponent;\n  \n  var result = new Name();\n\n  var iEnd = iStartComponent + nComponents;\n  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)\n    result.components.push(this.components[i]);\n\n  return result;  \n};\n\n/**\n * Return a new Name with the first nComponents components of this Name.\n * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up\n * to name.size() - N. For example getPrefix(-1) returns the name without the final component.\n * @returns {Name} A new name.\n */\nName.prototype.getPrefix = function(nComponents) \n{\n  if (nComponents < 0)\n    return this.getSubName(0, this.components.length + nComponents);\n  else\n    return this.getSubName(0, nComponents);\n};\n\n/**\n * @brief Get prefix of the name, containing less minusComponents right components\n * @param minusComponents number of components to cut from the back\n */\nName.prototype.cut = function(minusComponents) \n{\n  return new Name(this.components.slice(0, this.components.length - minusComponents));\n};\n\n/**\n * Return the number of name components.\n * @returns {number}\n */\nName.prototype.size = function() \n{\n  return this.components.length;\n};\n\n/**\n * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().\n * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component\n * at size() - (-i).\n * @returns {Name.Component}\n */\nName.prototype.get = function(i) \n{\n  if (i >= 0) {\n    if (i >= this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[i]);\n  }\n  else {\n    // Negative index.\n    if (i < -this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[this.components.length - (-i)]);\n  }\n};\n\n/**\n * @deprecated Use size().\n */\nName.prototype.getComponentCount = function() \n{\n  return this.components.length;\n};\n\n/**\n * @deprecated To get just the component value, use get(i).getValue().\n */\nName.prototype.getComponent = function(i) \n{\n  return new customBuf(this.components[i].getValue());\n};\n\n/**\n * The "file name" in a name is the last component that isn\'t blank and doesn\'t start with one of the\n *   special marker octets (for version, etc.).  Return the index in this.components of\n *   the file name, or -1 if not found.\n */\nName.prototype.indexOfFileName = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var component = this.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n        \n    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 || \n        (component[0] >= 0xF5 && component[0] <= 0xFF))\n      continue;\n        \n    return i;\n  }\n    \n  return -1;\n};\n\n/**\n * Return true if this Name has the same components as name.\n */\nName.prototype.equals = function(name) \n{\n  if (this.components.length != name.components.length)\n    return false;\n    \n  // Start from the last component because they are more likely to differ.\n  for (var i = this.components.length - 1; i >= 0; --i) {\n    if (!this.components[i].equals(name.components[i]))\n      return false;\n  }\n    \n  return true;\n};\n\n/**\n * @deprecated Use equals.\n */\nName.prototype.equalsName = function(name)\n{\n  return this.equals(name);\n};\n\n/**\n * Find the last component in name that has a ContentDigest and return the digest value as customBuf, \n *   or null if not found.  See Name.getComponentContentDigestValue.\n */\nName.prototype.getContentDigestValue = function() \n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var digestValue = Name.getComponentContentDigestValue(this.components[i]);\n    if (digestValue != null)\n      return digestValue;\n  }\n    \n  return null;\n};\n\n/**\n * If component is a ContentDigest, return the digest value as a customBuf slice (don\'t modify!).\n * If not a ContentDigest, return null.\n * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.\n */\nName.getComponentContentDigestValue = function(component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length; \n  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.\n  if (component.length == digestComponentLength &&\n      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length), \n                            Name.ContentDigestPrefix) &&\n      DataUtils.arraysEqual(component.slice\n         (component.length - Name.ContentDigestSuffix.length, component.length),\n                            Name.ContentDigestSuffix))\n   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);\n else\n   return null;\n};\n\n// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB. \nName.ContentDigestPrefix = new customBuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);\nName.ContentDigestSuffix = new customBuf([0x00]);\n\n\n/**\n * Return value as an escaped string according to "NDNx URI Scheme".\n * We can\'t use encodeURIComponent because that doesn\'t encode all the characters we want to.\n * @param {Buffer|Name.Component} component The value or Name.Component to escape.\n * @returns {string} The escaped string.\n */\nName.toEscapedString = function(value) \n{\n  if (typeof value == \'object\' && value instanceof Name.Component)\n    value = value.getValue();\n  \n  var result = "";\n  var gotNonDot = false;\n  for (var i = 0; i < value.length; ++i) {\n    if (value[i] != 0x2e) {\n      gotNonDot = true;\n      break;\n    }\n  }\n  if (!gotNonDot) {\n    // Special case for component of zero or more periods.  Add 3 periods.\n    result = "...";\n    for (var i = 0; i < value.length; ++i)\n      result += ".";\n  }\n  else {\n    for (var i = 0; i < value.length; ++i) {\n      var x = value[i];\n      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)\n      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||\n          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d || \n          x == 0x2e || x == 0x5f)\n        result += String.fromCharCode(x);\n      else\n        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();\n    }\n  }\n  return result;\n};\n\n/**\n * Return a customBuf byte array by decoding the escapedString according to "NDNx URI Scheme".\n * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.\n * @param {string} escapedString The escaped string to decode.\n * @returns {Buffer} The byte array, or null which means to skip the component in the name.\n */\nName.fromEscapedString = function(escapedString) \n{\n  var value = unescape(escapedString.trim());\n        \n  if (value.match(/[^.]/) == null) {\n    // Special case for value of only periods.  \n    if (value.length <= 2)\n      // Zero, one or two periods is illegal.  Ignore this componenent to be\n      //   consistent with the C implementation.\n      return null;\n    else\n      // Remove 3 periods.\n      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));\n  }\n  else\n    return DataUtils.toNumbersFromString(value);\n};\n\n/**\n * Return true if the N components of this name are the same as the first N components of the given name.\n * @param {Name} name The name to check.\n * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.\n */\nName.prototype.match = function(name) \n{\n  var i_name = this.components;\n  var o_name = name.components;\n\n  // This name is longer than the name we are checking it against.\n  if (i_name.length > o_name.length)\n    return false;\n\n  // Check if at least one of given components doesn\'t match.\n  for (var i = 0; i < i_name.length; ++i) {\n    if (!i_name[i].equals(o_name[i]))\n      return false;\n  }\n\n  return true;\n};\n\n})()\n},{"./buffer.js":116,"./encoding/binary-xml-decoder.js":135,"./encoding/binary-xml-encoder.js":136,"./encoding/data-utils.js":109,"./log.js":139,"./util/blob.js":111,"./util/ndn-protoco-id-tags.js":137}],96:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar ForwardingEntry = require(\'./forwarding-entry.js\').ForwardingEntry;\n\n/**\n * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for\n * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding\n * bits are changed, amended or deprecated.\n * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.\n */\nvar ForwardingFlags = function ForwardingFlags() \n{\n  this.active = true;\n  this.childInherit = true;\n  this.advertise = false;\n  this.last = false;\n  this.capture = false;\n  this.local = false;\n  this.tap = false;\n  this.captureOk = false;\n}\n\nexports.ForwardingFlags = ForwardingFlags;\n\n/**\n * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.\n * @returns {number} An integer with the bits set.\n */\nForwardingFlags.prototype.getForwardingEntryFlags = function()\n{\n  var result = 0;\n  \n  if (this.active)\n    result |= ForwardingEntry.ACTIVE;\n  if (this.childInherit)\n    result |= ForwardingEntry.CHILD_INHERIT;\n  if (this.advertise)\n    result |= ForwardingEntry.ADVERTISE;\n  if (this.last)\n    result |= ForwardingEntry.LAST;\n  if (this.capture)\n    result |= ForwardingEntry.CAPTURE;\n  if (this.local)\n    result |= ForwardingEntry.LOCAL;\n  if (this.tap)\n    result |= ForwardingEntry.TAP;\n  if (this.captureOk)\n    result |= ForwardingEntry.CAPTURE_OK;\n  \n  return result;\n};\n\n/**\n * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.\n * @param {number} forwardingEntryFlags An integer with the bits set.\n */\nForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)\n{\n  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);\n  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);\n  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);\n  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);\n  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);\n  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);\n  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);\n  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);\n};\n\n/**\n * Get the value of the "active" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getActive = function() { return this.active; };\n\n/**\n * Get the value of the "childInherit" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };\n\n/**\n * Get the value of the "advertise" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };\n\n/**\n * Get the value of the "last" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLast = function() { return this.last; };\n\n/**\n * Get the value of the "capture" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCapture = function() { return this.capture; };\n\n/**\n * Get the value of the "local" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLocal = function() { return this.local; };\n\n/**\n * Get the value of the "tap" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getTap = function() { return this.tap; };\n\n/**\n * Get the value of the "captureOk" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };\n\n/**\n * Set the value of the "active" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setActive = function(value) { this.active = value; };\n\n/**\n * Set the value of the "childInherit" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };\n\n/**\n * Set the value of the "advertise" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };\n\n/**\n * Set the value of the "last" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLast = function(value) { this.last = value; };\n\n/**\n * Set the value of the "capture" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };\n\n/**\n * Set the value of the "local" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setLocal = function(value) { this.local = value; };\n\n/**\n * Set the value of the "tap" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setTap = function(value) { this.tap = value; };\n\n/**\n * Set the value of the "captureOk" flag\n * @param {number} value true to set the flag, false to clear it.\n */  \nForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };\n\n},{"./forwarding-entry.js":134}],97:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar Name = require(\'./name.js\').Name;\nvar Exclude = require(\'./exclude.js\').Exclude;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').LOG\n/**\n * Create a new Interest with the optional values.\n * \n * @constructor\n * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the\n * other arguments.  Otherwise this is the optional name for the new Interest.\n * @param {number} minSuffixComponents\n * @param {number} maxSuffixComponents\n * @param {Buffer} publisherPublicKeyDigest\n * @param {Exclude} exclude\n * @param {number} childSelector\n * @param {number} answerOriginKind\n * @param {number} scope\n * @param {number} interestLifetimeMilliseconds in milliseconds\n * @param {Buffer} nonce\n */\nvar Interest = function Interest\n   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude, \n    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce) \n{\n  if (typeof nameOrInterest === \'object\' && nameOrInterest instanceof Interest) {\n    // Special case: this is a copy constructor.  Ignore all but the first argument.\n    var interest = nameOrInterest;\n    if (interest.name)\n      // Copy the name.\n      this.name = new Name(interest.name);\n    this.maxSuffixComponents = interest.maxSuffixComponents;\n    this.minSuffixComponents = interest.minSuffixComponents;\n\n    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator(interest.keyLocator);\n    this.exclude = new Exclude(interest.exclude);\n    this.childSelector = interest.childSelector;\n    this.answerOriginKind = interest.answerOriginKind;\n    this.scope = interest.scope;\n    this.interestLifetime = interest.interestLifetime;\n    if (interest.nonce)\n      // Copy.\n      this.nonce = new customBuf(interest.nonce);    \n  }  \n  else {\n    this.name = typeof nameOrInterest === \'object\' && nameOrInterest instanceof Name ?\n                new Name(nameOrInterest) : new Name();\n    this.maxSuffixComponents = maxSuffixComponents;\n    this.minSuffixComponents = minSuffixComponents;\n\n    this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n    this.keyLocator = new KeyLocator();\n    this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                   new Exclude(exclude) : new Exclude();\n    this.childSelector = childSelector;\n    this.answerOriginKind = answerOriginKind;\n    this.scope = scope;\n    this.interestLifetime = interestLifetimeMilliseconds;\n    if (nonce)\n      // Copy and make sure it is a customBuf.\n      this.nonce = new customBuf(nonce);\n  }\n};\n\nexports.Interest = Interest;\n\nInterest.RECURSIVE_POSTFIX = "*";\n\nInterest.CHILD_SELECTOR_LEFT = 0;\nInterest.CHILD_SELECTOR_RIGHT = 1;\n\nInterest.ANSWER_NO_CONTENT_STORE = 0;\nInterest.ANSWER_CONTENT_STORE = 1;\nInterest.ANSWER_GENERATED = 2;\nInterest.ANSWER_STALE = 4;    // Stale answer OK\nInterest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"\n\nInterest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;\n\n/**\n * Return true if this.name.match(name) and the name conforms to the interest selectors.\n * @param {Name} name\n * @returns {boolean}\n */\nInterest.prototype.matchesName = function(/*Name*/ name) \n{\n  if (!this.name.match(name))\n    return false;\n    \n  if (this.minSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))\n    return false;\n  if (this.maxSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))\n    return false;\n  if (this.exclude != null && name.size() > this.name.size() &&\n      this.exclude.matches(name.components[this.name.size()]))\n    return false;\n    \n  return true;\n};\n\n/**\n * @deprecated Use matchesName.\n */\nInterest.prototype.matches_name = function(/*Name*/ name) \n{\n  return this.matchesName(name);\n};\n\n/**\n * Return a new Interest with the same fields as this Interest.  \n */\nInterest.prototype.clone = function() \n{\n  return new Interest\n     (this.name, this.minSuffixComponents, this.maxSuffixComponents, \n      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind, \n      this.scope, this.interestLifetime, this.nonce);\n};\n\n/**\n * Get the interest Name.\n * @returns {Name} The name.  The name size() may be 0 if not specified.\n */\nInterest.prototype.getName = function() { return this.name; };\n\n/**\n * Get the min suffix components.\n * @returns number} The min suffix components, or null if not specified.\n */\nInterest.prototype.getMinSuffixComponents = function() \n{ \n  return this.minSuffixComponents; \n};\n\n/**\n * Get the max suffix components.\n * @returns {number} The max suffix components, or null if not specified.\n */\nInterest.prototype.getMaxSuffixComponents = function() \n{ \n  return this.maxSuffixComponents; \n};\n\n/**\n * Get the interest key locator.\n * @returns {KeyLocator} The key locator. If its getType() is null, \n * then the key locator is not specified.\n */\nInterest.prototype.getKeyLocator = function() \n{ \n  return this.keyLocator; \n};\n\n/**\n * Get the exclude object.\n * @returns {Exclude} The exclude object. If the exclude size() is zero, then\n * the exclude is not specified.\n */\nInterest.prototype.getExclude = function() { return this.exclude; };\n\n/**\n * Get the child selector.\n * @returns {number} The child selector, or null if not specified.\n */\nInterest.prototype.getChildSelector = function() \n{ \n  return this.childSelector; \n};\n\n/**\n * @deprecated Use getMustBeFresh.\n */\nInterest.prototype.getAnswerOriginKind = function() \n{ \n  return this.answerOriginKind; \n};\n  \n  /**\n   * Return true if the content must be fresh.\n   * @return true if must be fresh, otherwise false.\n   */\n  \n/**\n * Get the must be fresh flag. If not specified, the default is true.\n * @returns {boolean} The must be fresh flag.\n */\nInterest.prototype.getMustBeFresh = function() \n{\n  if (this.answerOriginKind == null || this.answerOriginKind < 0)\n    return true;\n  else\n    return (this.answerOriginKind & Interest.ANSWER_STALE) == 0;\n};\n\n/**\n * Return the nonce value from the incoming interest.  If you change any of the \n * fields in this Interest object, then the nonce value is cleared.\n * @returns {Buffer} The nonce, or null if not specified.\n */\nInterest.prototype.getNonce = function() { return this.nonce; };\n\n/**\n * Get the interest scope.\n * @returns {number} The scope, or null if not specified.\n */\nInterest.prototype.getScope = function() { return this.scope; };\n\n/**\n * Get the interest lifetime.\n * @returns {number} The interest lifetime in milliseconds, or null if not \n * specified.\n */\nInterest.prototype.getInterestLifetimeMilliseconds = function() \n{ \n  return this.interestLifetime; \n};\n\nInterest.prototype.setName = function(name)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.name = typeof name === \'object\' && name instanceof Interest ?\n              new Name(name) : new Name();\n};\n                \nInterest.prototype.setMinSuffixComponents = function(minSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.minSuffixComponents = minSuffixComponents;\n};\n\nInterest.prototype.setMaxSuffixComponents = function(maxSuffixComponents)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.maxSuffixComponents = maxSuffixComponents;\n};\n\n/**\n * Set this interest to use a copy of the given exclude object. Note: You can \n * also change this interest\'s exclude object modifying the object from \n * getExclude().\n * @param {Exclude} exclude The exlcude object that is copied.\n */\nInterest.prototype.setExclude = function(exclude)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.exclude = typeof exclude === \'object\' && exclude instanceof Exclude ?\n                 new Exclude(exclude) : new Exclude();\n};\n\nInterest.prototype.setChildSelector = function(childSelector)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.childSelector = childSelector;\n};\n\n/**\n * @deprecated Use setMustBeFresh.\n */\nInterest.prototype.setAnswerOriginKind = function(answerOriginKind)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.answerOriginKind = answerOriginKind;\n};\n\n/**\n * Set the MustBeFresh flag.\n * @param {boolean} mustBeFresh True if the content must be fresh, otherwise false.\n */\nInterest.prototype.setMustBeFresh = function(mustBeFresh)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  if (this.answerOriginKind == null || this.answerOriginKind < 0) {\n    // It is is already the default where MustBeFresh is true. \n    if (!mustBeFresh)\n      // Set answerOriginKind_ so that getMustBeFresh returns false.\n      this.answerOriginKind = Interest.ANSWER_STALE; \n  }\n  else {\n    if (mustBeFresh)\n      // Clear the stale bit.\n      this.answerOriginKind &= ~Interest.ANSWER_STALE;\n    else\n      // Set the stale bit.\n      this.answerOriginKind |= Interest.ANSWER_STALE;\n  }\n};\n\nInterest.prototype.setScope = function(scope)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.scope = scope;\n};\n\nInterest.prototype.setInterestLifetimeMilliseconds = function(interestLifetimeMilliseconds)\n{\n  // The object has changed, so the nonce is invalid.\n  this.nonce = null;\n  \n  this.interestLifetime = interestLifetimeMilliseconds;\n};\n\n/**\n * @deprecated You should let the wire encoder generate a random nonce \n * internally before sending the interest.\n */\nInterest.prototype.setNonce = function(nonce)\n{\n  if (nonce)\n    // Copy and make sure it is a customBuf.\n    this.nonce = new customBuf(nonce);\n  else\n    this.nonce = null;\n};\n\n/**\n * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and\n * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".\n * @returns {string} The URI string.\n * @note This is an experimental feature.  See the API docs for more detail at\n * http://named-data.net/doc/ndn-ccl-api/interest.html#interest-touri-method .\n */\nInterest.prototype.toUri = function() \n{  \n  var selectors = "";\n  \n  if (this.minSuffixComponents != null)\n    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;\n  if (this.maxSuffixComponents != null)\n    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;\n  if (this.childSelector != null)\n    selectors += "&ndn.ChildSelector=" + this.childSelector;\n  if (this.answerOriginKind != null)\n    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;\n  if (this.scope != null)\n    selectors += "&ndn.Scope=" + this.scope;\n  if (this.interestLifetime != null)\n    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;\n  if (this.publisherPublicKeyDigest != null)\n    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  if (this.nonce != null)\n    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);\n  if (this.exclude != null && this.exclude.size() > 0)\n    selectors += "&ndn.Exclude=" + this.exclude.toUri();\n\n  var result = this.name.toUri();\n  if (selectors != "")\n    // Replace the first & with ?.\n    result += "?" + selectors.substr(1);\n  \n  return result;\n};\n\n/**\n * Encode this Interest for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {Blob} The encoded buffer in a Blob object.\n */\nInterest.prototype.wireEncode = function(wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return wireFormat.encodeInterest(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Interest.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object \n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nInterest.prototype.wireDecode = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  if (LOG > 3 ) console.log(\'decoding input to interes\', input)\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ? \n                     input.buf() : input;\n  wireFormat.decodeInterest(this, decodeBuffer);\n};\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom \n// to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  BinaryXmlWireFormat.decodeInterest(this, decoder);\n};\n\n/**\n * @deprecated Use wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder) \n{\n  BinaryXmlWireFormat.encodeInterest(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nInterest.prototype.encode = function(wireFormat) \n{\n  return this.wireEncode(BinaryXmlWireFormat.get()).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nInterest.prototype.decode = function(input, wireFormat) \n{\n  this.wireDecode(input, BinaryXmlWireFormat.get())\n};\n\n})()\n},{"./buffer.js":116,"./encoding/binary-xml-wire-format.js":105,"./encoding/wire-format.js":104,"./exclude.js":98,"./key-locator.js":102,"./log.js":139,"./name.js":95,"./publisher-public-key-digest.js":103,"./util/blob.js":111}],98:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an Interest Exclude.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\n\n/**\n * Create a new Exclude.\n * @constructor\n * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, customBuf component or Exclude.ANY.\n */\nvar Exclude = function Exclude(values) \n{ \n  this.values = [];\n  \n  if (typeof values === \'object\' && values instanceof Exclude)\n    // Copy the exclude.\n    this.values = values.values.slice(0);\n  else if (values) {\n    for (var i = 0; i < values.length; ++i) {\n      if (values[i] == Exclude.ANY)\n        this.appendAny();\n      else\n        this.appendComponent(values[i]);\n    }\n  }\n};\n\nexports.Exclude = Exclude;\n\nExclude.ANY = "*";\n\n/**\n * Get the number of entries.\n * @returns {number} The number of entries.\n */\nExclude.prototype.size = function() { return this.values.length; };\n\n/**\n * Get the entry at the given index.\n * @param {number} i The index of the entry, starting from 0.\n * @returns {Exclude.ANY|Name.Component} Exclude.ANY or a Name.Component.\n */\nExclude.prototype.get = function(i) { return this.values[i]; };\n\n/**\n * Append an Exclude.ANY element.\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendAny = function() \n{\n  this.values.push(Exclude.ANY);\n  return this;\n};\n\n/**\n * Append a component entry, copying from component.\n * @param {Name.Component|Buffer} component\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendComponent = function(component) \n{\n  this.values.push(new Name.Component(component));\n  return this;\n};\n\n/**\n * Clear all the entries.\n */\nExclude.prototype.clear = function() \n{\n  this.values = [];\n};\n\nExclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);\n\n  while (true) {\n    if (decoder.peekDTag(NDNProtocolDTags.Component))\n      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {\n      decoder.readElementStartDTag(NDNProtocolDTags.Any);\n      decoder.readElementClose();\n      this.appendAny();\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {\n      // Skip the Bloom and treat it as Any.\n      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);\n      this.appendAny();\n    }\n    else\n      break;\n  }\n    \n  decoder.readElementClose();\n};\n\nExclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  \n{\n  if (this.values == null || this.values.length == 0)\n    return;\n\n  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);\n    \n  // TODO: Do we want to order the components (except for ANY)?\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      encoder.writeElementStartDTag(NDNProtocolDTags.Any);\n      encoder.writeElementClose();\n    }\n    else\n      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());\n  }\n\n  encoder.writeElementClose();\n};\n\n/**\n * Return a string with elements separated by "," and Exclude.ANY shown as "*". \n */\nExclude.prototype.toUri = function() \n{\n  if (this.values == null || this.values.length == 0)\n    return "";\n\n  var result = "";\n  for (var i = 0; i < this.values.length; ++i) {\n    if (i > 0)\n      result += ",";\n        \n    if (this.values[i] == Exclude.ANY)\n      result += "*";\n    else\n      result += Name.toEscapedString(this.values[i].getValue());\n  }\n  return result;\n};\n\n/**\n * Return true if the component matches any of the exclude criteria.\n */\nExclude.prototype.matches = function(/*Buffer*/ component) \n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      var lowerBound = null;\n      if (i > 0)\n        lowerBound = this.values[i - 1];\n      \n      // Find the upper bound, possibly skipping over multiple ANY in a row.\n      var iUpperBound;\n      var upperBound = null;\n      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {\n        if (this.values[iUpperBound] != Exclude.ANY) {\n          upperBound = this.values[iUpperBound];\n          break;\n        }\n      }\n      \n      // If lowerBound != null, we already checked component equals lowerBound on the last pass.\n      // If upperBound != null, we will check component equals upperBound on the next pass.\n      if (upperBound != null) {\n        if (lowerBound != null) {\n          if (Exclude.compareComponents(component, lowerBound) > 0 &&\n              Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n        else {\n          if (Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n          \n        // Make i equal iUpperBound on the next pass.\n        i = iUpperBound - 1;\n      }\n      else {\n        if (lowerBound != null) {\n            if (Exclude.compareComponents(component, lowerBound) > 0)\n              return true;\n        }\n        else\n          // this.values has only ANY.\n          return true;\n      }\n    }\n    else {\n      if (DataUtils.arraysEqual(component, this.values[i].getValue()))\n        return true;\n    }\n  }\n  \n  return false;\n};\n\n/**\n * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.\n * A component is less if it is shorter, otherwise if equal length do a byte comparison.\n */\nExclude.compareComponents = function(component1, component2) \n{\n  if (typeof component1 == \'object\' && component1 instanceof Name.Component)\n    component1 = component1.getValue();\n  if (typeof component2 == \'object\' && component2 instanceof Name.Component)\n    component2 = component2.getValue();\n\n  if (component1.length < component2.length)\n    return -1;\n  if (component1.length > component2.length)\n    return 1;\n  \n  for (var i = 0; i < component1.length; ++i) {\n    if (component1[i] < component2[i])\n      return -1;\n    if (component1[i] > component2[i])\n      return 1;\n  }\n\n  return 0;\n};\n\n})()\n},{"./buffer.js":116,"./encoding/binary-xml-decoder.js":135,"./encoding/binary-xml-encoder.js":136,"./encoding/data-utils.js":109,"./name.js":95,"./util/ndn-protoco-id-tags.js":137}],99:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar SignedBlob = require(\'./util/signed-blob.js\').SignedBlob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar Name = require(\'./name.js\').Name;\nvar Signature = require(\'./signature.js\').Signature;\nvar MetaInfo = require(\'./meta-info.js\').MetaInfo;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar WireFormat = require(\'./encoding/wire-format.js\').WireFormat;\nvar customBuf = require(\'./buffer.js\').Buffer\n/**\n * Create a new Data with the optional values.  There are 2 forms of constructor:\n * new Data([name] [, content]);\n * new Data(name, metaInfo [, content]);\n *\n * @constructor\n * @param {Name} name\n * @param {MetaInfo} metaInfo\n * @param {Buffer} content\n */\nvar Data = function Data(name, metaInfoOrContent, arg3)\n{\n  if (typeof name === \'string\')\n    this.name = new Name(name);\n  else\n    this.name = typeof name === \'object\' && name instanceof Name ?\n       new Name(name) : new Name();\n\n  var metaInfo;\n  var content;\n  if (typeof metaInfoOrContent === \'object\' &&\n      metaInfoOrContent instanceof MetaInfo) {\n    metaInfo = metaInfoOrContent;\n    content = arg3;\n  }\n  else {\n    metaInfo = null;\n    content = metaInfoOrContent;\n  }\n\n  // Use signedInfo instead of metaInfo for backward compatibility.\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n       new MetaInfo(metaInfo) : new MetaInfo();\n\n  if (typeof content === \'string\')\n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else\n    this.content = content;\n\n  this.signature = new Signature();\n\n  this.wireEncoding = SignedBlob();\n};\n\nexports.Data = Data;\n\n/**\n * Get the data packet\'s name.\n * @returns {Name} The name.\n */\nData.prototype.getName = function()\n{\n  return this.name;\n};\n\n/**\n * Get the data packet\'s meta info.\n * @returns {MetaInfo} The meta info.\n */\nData.prototype.getMetaInfo = function()\n{\n  return this.signedInfo;\n};\n\n/**\n * Get the data packet\'s signature object.\n * @returns {Signature} The signature object.\n */\nData.prototype.getSignature = function()\n{\n  return this.signature;\n};\n\n/**\n * Get the data packet\'s content.\n * @returns {Buffer} The content as a customBuf, which is null if unspecified.\n */\nData.prototype.getContent = function()\n{\n  return this.content;\n};\n\n/**\n * Set name to a copy of the given Name.\n * @param {Name} name The Name which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setName = function(name)\n{\n  this.name = typeof name === \'object\' && name instanceof Name ?\n    new Name(name) : new Name();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set metaInfo to a copy of the given MetaInfo.\n * @param {MetaInfo} metaInfo The MetaInfo which is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setMetaInfo = function(metaInfo)\n{\n  this.signedInfo = typeof metaInfo === \'object\' && metaInfo instanceof MetaInfo ?\n    new MetaInfo(metaInfo) : new MetaInfo();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the signature to a copy of the given signature.\n * @param {Signature} signature The signature object which is cloned.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setSignature = function(signature)\n{\n  this.signature = typeof signature === \'object\' && signature instanceof Signature ?\n    signature.clone() : new Signature();\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\n/**\n * Set the content to the given value.\n * @param {type} content The array this is copied.\n * @returns {Data} This Data so that you can chain calls to update values.\n */\nData.prototype.setContent = function(content)\n{\n  if (typeof content === \'string\')\n    this.content = DataUtils.toNumbersFromString(content);\n  else if (typeof content === \'object\' && content instanceof Blob)\n    this.content = content.buf();\n  else\n    this.content = new customBuf(content);\n\n  // The object has changed, so the wireEncoding is invalid.\n  this.wireEncoding = SignedBlob();\n  return this;\n};\n\nData.prototype.sign = function(wireFormat)\n{\n  var rs = require(\'buffer\')\n  var ss = require(\'./crypto.js\')\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n\n  if (this.getSignatureOrMetaInfoKeyLocator() == null ||\n      this.getSignatureOrMetaInfoKeyLocator().getType() == null)\n    this.getMetaInfo().setFields();\n\n  if (this.wireEncoding == null || this.wireEncoding.isNull()) {\n    // Need to encode to set wireEncoding.\n    // Set an initial empty signature so that we can encode.\n    this.getSignature().setSignature(new customBuf(128));\n    this.wireEncode(wireFormat);\n  }\n\n  var rsa = require("./crypto.js").createSign(\'RSA-SHA256\');\n  rsa.update(this.wireEncoding.signedBuf());\n\n  var sig = new customBuf\n    (DataUtils.toNumbersIfString(rsa.sign(globalKeyManager.privateKey)));\n  this.signature.signature = sig;\n};\n\n// The first time verify is called, it sets this to determine if a signature\n//   buffer needs to be converted to a string for the crypto verifier.\nData.verifyUsesString = null;\nData.prototype.verify = function(/*Key*/ key)\n{\n  if (key == null || key.publicKeyPem == null)\n    throw new Error(\'Cannot verify Data without a public key.\');\n\n  if (Data.verifyUsesString == null) {\n    var hashResult = require("crypto").createHash(\'sha256\').digest();\n    // If the has result is a string, we assume that this is a version of\n    //   crypto where verify also uses a string signature.\n    Data.verifyUsesString = (typeof hashResult === \'string\');\n  }\n\n  if (this.wireEncoding == null || this.wireEncoding.isNull())\n    // Need to encode to set wireEncoding.\n    this.wireEncode();\n  var verifier = require(\'./crypto.js\').createVerify(\'RSA-SHA256\');\n  verifier.update(this.wireEncoding.signedBuf());\n  var signatureBytes = Data.verifyUsesString ?\n    DataUtils.toString(this.signature.signature) : this.signature.signature;\n  return verifier.verify(key.publicKeyPem, signatureBytes);\n};\n\nData.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };\n\n/**\n * Encode this Data for a particular wire format.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object\n * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().\n * @returns {SignedBlob} The encoded buffer in a SignedBlob object.\n */\nData.prototype.wireEncode = function(wireFormat)\n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var result = wireFormat.encodeData(this);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  this.wireEncoding = new SignedBlob\n    (result.encoding, result.signedPortionBeginOffset,\n     result.signedPortionEndOffset);\n  return this.wireEncoding;\n};\n\n/**\n * Decode the input using a particular wire format and update this Data.\n * @param {Blob|Buffer} input The buffer with the bytes to decode.\n * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object\n * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().\n */\nData.prototype.wireDecode = function(input, wireFormat)\n{\n  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  // If input is a blob, get its buf().\n  var decodeBuffer = typeof input === \'object\' && input instanceof Blob ?\n                     input.buf() : input;\n  var result = wireFormat.decodeData(this, decodeBuffer);\n  // TODO: Implement setDefaultWireEncoding with getChangeCount support.\n  // In the Blob constructor, set copy true, but if input is already a Blob, it\n  //   won\'t copy.\n  this.wireEncoding = new SignedBlob\n    (new Blob(input, true), result.signedPortionBeginOffset,\n     result.signedPortionEndOffset);\n};\n\n/**\n * If getSignature() has a key locator, return it.  Otherwise, use\n * the key locator from getMetaInfo() for backward compatibility and print\n * a warning to console.log that the key locator has moved to the Signature\n * object.  If neither has a key locator, return an empty key locator.\n * When we stop supporting the key locator in MetaInfo, this function is not\n * necessary and we will just use the key locator in the Signature.\n * @returns {KeyLocator} The key locator to use.\n */\nData.prototype.getSignatureOrMetaInfoKeyLocator = function()\n{\n  if (this.signature != null && this.signature.getKeyLocator() != null &&\n      this.signature.getKeyLocator().getType() != null &&\n      this.signature.getKeyLocator().getType() >= 0)\n    // The application is using the key locator in the correct object.\n    return this.signature.getKeyLocator();\n\n  if (this.signedInfo != null && this.signedInfo.locator != null &&\n      this.signedInfo.locator.type != null &&\n      this.signedInfo.locator.type >= 0) {\n    //console.log("WARNING: Temporarily using the key locator found in the MetaInfo - expected it in the Signature object.");\n    //console.log("WARNING: In the future, the key locator in the Signature object will not be supported.");\n    return this.signedInfo.locator;\n  }\n\n  // Return the empty key locator from the Signature object if possible.\n  if (this.signature != null && this.signature.getKeyLocator() != null)\n    return this.signature.getKeyLocator();\n  else\n    return new KeyLocator();\n}\n\n// Since binary-xml-wire-format.js includes this file, put these at the bottom to avoid problems with cycles of require.\nvar BinaryXmlWireFormat = require(\'./encoding/binary-xml-wire-format.js\').BinaryXmlWireFormat;\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeData.\n */\nData.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  BinaryXmlWireFormat.decodeData(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeData.\n */\nData.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeData(this, encoder);\n};\n\n/**\n * @deprecated Use wireEncode.  If you need binary XML, use\n * wireEncode(BinaryXmlWireFormat.get()).\n */\nData.prototype.encode = function(wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  return wireFormat.encodeData(this).buf();\n};\n\n/**\n * @deprecated Use wireDecode.  If you need binary XML, use\n * wireDecode(input, BinaryXmlWireFormat.get()).\n */\nData.prototype.decode = function(input, wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.get());\n  wireFormat.decodeData(this, input);\n};\n\n/**\n * @deprecated Use new Data.\n */\nvar ContentObject = function ContentObject(name, signedInfo, content)\n{\n  // Call the base constructor.\n  Data.call(this, name, signedInfo, content);\n}\n\nContentObject.prototype = new Data();\n\nexports.ContentObject = ContentObject;\n\n})()\n},{"./buffer.js":116,"./crypto.js":116,"./encoding/binary-xml-encoder.js":136,"./encoding/binary-xml-wire-format.js":105,"./encoding/data-utils.js":109,"./encoding/wire-format.js":104,"./key-locator.js":102,"./meta-info.js":100,"./name.js":95,"./security/key-manager.js":114,"./signature.js":141,"./util/blob.js":111,"./util/ndn-protoco-id-tags.js":137,"./util/signed-blob.js":140,"buffer":63,"crypto":56}],100:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data MetaInfo object.\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Blob = require(\'./util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar KeyLocatorType = require(\'./key-locator.js\').KeyLocatorType;\nvar Name = require(\'./name.js\').Name;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar NDNTime = require(\'./util/ndn-time.js\').NDNTime;\nvar globalKeyManager = require(\'./security/key-manager.js\').globalKeyManager;\nvar LOG = require(\'./log.js\').Log.LOG;\n\nvar ContentType = {\n  BLOB:0,\n  // ContentType DATA is deprecated.  Use ContentType.BLOB .\n  DATA:0, \n  LINK:1, \n  KEY: 2, \n  // ContentType ENCR, GONE and NACK are not supported in NDN-TLV encoding and are deprecated.\n  ENCR:3, \n  GONE:4, \n  NACK:5\n};\n\nexports.ContentType = ContentType;\n\n/**\n * Create a new MetaInfo with the optional values.\n * @constructor\n */\nvar MetaInfo = function MetaInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID, skipSetFields) \n{\n  if (typeof publisherOrMetaInfo === \'object\' && \n      publisherOrMetaInfo instanceof MetaInfo) {\n    // Copy values.\n    var metaInfo = publisherOrMetaInfo;\n    this.publisher = metaInfo.publisher;\n    this.timestamp = metaInfo.timestamp;\n    this.type = metaInfo.type;\n    this.locator = metaInfo.locator == null ? \n      new KeyLocator() : new KeyLocator(metaInfo.locator);\n    this.freshnessSeconds = metaInfo.freshnessSeconds;\n    this.finalBlockID = metaInfo.finalBlockID;\n  }\n  else {\n    this.publisher = publisherOrMetaInfo; //publisherPublicKeyDigest\n    this.timestamp = timestamp; // NDN Time\n    this.type = type; // ContentType\n    this.locator = locator == null ? new KeyLocator() : new KeyLocator(locator);\n    this.freshnessSeconds = freshnessSeconds; // Integer\n    this.finalBlockID = finalBlockID; //byte array\n\n    if (!skipSetFields)\n      this.setFields();\n  }\n};\n\nexports.MetaInfo = MetaInfo;\n\n/**\n * Get the content type.\n * @returns {an int from ContentType} The content type.\n */\nMetaInfo.prototype.getType = function()\n{\n  return this.type;\n};\n\n/**\n * Get the freshness period.\n * @returns {number} The freshness period in milliseconds, or null if not \n * specified.\n */\nMetaInfo.prototype.getFreshnessPeriod = function()\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (this.freshnessSeconds == null || this.freshnessSeconds < 0)\n    return null;\n  else\n    // Convert to milliseconds.\n    return this.freshnessSeconds * 1000.0;\n};\n\n/**\n * Get the final block ID.\n * @returns {Buffer} The final block ID or null if not specified.\n */\nMetaInfo.prototype.getFinalBlockID = function()\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  return this.finalBlockID;\n};\n\n/**\n * Set the content type.\n * @param {an int from ContentType} type The content type.  If null, this \n * uses ContentType.BLOB.\n */\nMetaInfo.prototype.setType = function(type)\n{\n  this.type = type == null || type < 0 ? ContentType.BLOB : type;\n};\n\n/**\n * Set the freshness period.\n * @param {type} freshnessPeriod The freshness period in milliseconds, or null\n * for not specified.\n */\nMetaInfo.prototype.setFreshnessPeriod = function(freshnessPeriod)\n{\n  // Use attribute freshnessSeconds for backwards compatibility.\n  if (freshnessPeriod == null || freshnessPeriod < 0)\n    this.freshnessSeconds = null;\n  else\n    // Convert from milliseconds.\n    this.freshnessSeconds = freshnessPeriod / 1000.0;\n};\n\nMetaInfo.prototype.setFinalBlockID = function(finalBlockID)\n{\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  if (finalBlockID == null)\n    this.finalBlockID = null;\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Blob)\n    this.finalBlockID = finalBlockID.buf();\n  else if (typeof finalBlockID === \'object\' && finalBlockID instanceof Name.Component)\n    this.finalBlockID = finalBlockID.getValue();\n  else \n    this.finalBlockID = new customBuf(finalBlockID);\n};\n\nMetaInfo.prototype.setFields = function() \n{\n  var key = globalKeyManager.getKey();\n  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());\n\n  var d = new Date();\n    \n  var time = d.getTime();  \n\n  this.timestamp = new NDNTime(time);\n    \n  if (LOG > 4) console.log(\'TIME msec is\');\n\n  if (LOG > 4) console.log(this.timestamp.msec);\n\n  //DATA\n  this.type = ContentType.BLOB;\n  \n  if (LOG > 4) console.log(\'PUBLIC KEY TO WRITE TO DATA PACKET IS \');\n  if (LOG > 4) console.log(key.publicToDER().toString(\'hex\'));\n\n  this.locator = new KeyLocator(key.getKeyID(), KeyLocatorType.KEY_LOCATOR_DIGEST);\n};\n\nMetaInfo.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    if (LOG > 4) console.log(\'DECODING PUBLISHER KEY\');\n    this.publisher = new PublisherPublicKeyDigest();\n    this.publisher.from_ndnb(decoder);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {\n    if (LOG > 4) console.log(\'DECODING TIMESTAMP\');\n    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Type)) {\n    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);\n    \n    if (LOG > 4) console.log(\'Binary Type of of Signed Info is \'+binType);\n\n    this.type = binType;\n    \n    //TODO Implement type of Key Reading\n    if (null == this.type)\n      throw new Error("Cannot parse signedInfo type: bytes.");\n  } \n  else\n    this.type = ContentType.DATA; // default\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n    if (LOG > 4) console.log(\'FRESHNESS IN SECONDS IS \'+ this.freshnessSeconds);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {\n    if (LOG > 4) console.log(\'DECODING FINAL BLOCKID\');\n    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {\n    if (LOG > 4) console.log(\'DECODING KEY LOCATOR\');\n    this.locator = new KeyLocator();\n    this.locator.from_ndnb(decoder);\n  }\n      \n  decoder.readElementClose();\n};\n\n/**\n * Encode this MetaInfo in ndnb, using the given keyLocator instead of the\n * locator in this object.\n * @param {BinaryXMLEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nMetaInfo.prototype.to_ndnb = function(encoder, keyLocator)  {\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.publisher) {\n    // We have a publisherPublicKeyDigest, so use it.\n    if (LOG > 3) console.log(\'ENCODING PUBLISHER KEY\' + this.publisher.publisherPublicKeyDigest);\n    this.publisher.to_ndnb(encoder);\n  }\n  else {\n    if (null != keyLocator &&\n        keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n        keyLocator.getKeyData() != null &&\n        keyLocator.getKeyData().length > 0)\n      // We have a TLV-style KEY_LOCATOR_DIGEST, so encode as the\n      //   publisherPublicKeyDigest.\n      encoder.writeDTagElement\n        (NDNProtocolDTags.PublisherPublicKeyDigest, keyLocator.getKeyData());\n  }\n\n  if (null != this.timestamp)\n    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);\n  \n  if (null != this.type && this.type != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);\n  \n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  if (null != this.finalBlockID)\n    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);\n\n  if (null != keyLocator)\n    keyLocator.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nMetaInfo.prototype.valueToType = function() \n{\n  return null;  \n};\n\nMetaInfo.prototype.getElementLabel = function() { \n  return NDNProtocolDTags.SignedInfo;\n};\n\nMetaInfo.prototype.validate = function() \n{\n  // We don\'t do partial matches any more, even though encoder/decoder\n  // is still pretty generous.\n  if (null == this.timestamp)\n    return false;\n  return true;\n};\n\n/**\n * @deprecated Use new MetaInfo.\n */\nvar SignedInfo = function SignedInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID) \n{\n  // Call the base constructor.\n  MetaInfo.call(this, publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID); \n}\n\n// Set skipSetFields true since we only need the prototype functions.\nSignedInfo.prototype = new MetaInfo(null, null, null, null, null, null, true);\n\nexports.SignedInfo = SignedInfo;\n\n})()\n},{"./buffer.js":116,"./encoding/binary-xml-decoder.js":135,"./encoding/binary-xml-encoder.js":136,"./key-locator.js":102,"./log.js":139,"./name.js":95,"./publisher-public-key-digest.js":103,"./security/key-manager.js":114,"./util/blob.js":111,"./util/ndn-protoco-id-tags.js":137,"./util/ndn-time.js":113}],101:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Key Objects\n */\n\nvar customBuf = require(\'./buffer.js\').Buffer\nvar DataUtils = require(\'./encoding/data-utils.js\').DataUtils;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\n/**\n * Key\n */\nvar Key = function Key()\n{\n  this.publicKeyDer = null;     // customBuf\n  this.publicKeyDigest = null;  // customBuf\n  this.publicKeyPem = null;     // String\n  this.privateKeyPem = null;    // String\n};\n\nexports.Key = Key;\n\n/**\n * Helper functions to read Key fields\n * TODO: generateRSA()\n */\n\nKey.prototype.publicToDER = function()\n{\n  return this.publicKeyDer;  // customBuf\n};\n\nKey.prototype.privateToDER = function()\n{\n  // Remove the \'-----XXX-----\' from the beginning and the end of the key\n  // and also remove any \\n in the key string\n  var lines = this.privateKeyPem.split(\'\\n\');\n  priKey = "";\n  for (var i = 1; i < lines.length - 1; i++)\n    priKey += lines[i];\n\n  return new customBuf(priKey, \'base64\');\n};\n\nKey.prototype.publicToPEM = function()\n{\n  return this.publicKeyPem;\n};\n\nKey.prototype.privateToPEM = function()\n{\n  return this.privateKeyPem;\n};\n\nKey.prototype.getKeyID = function()\n{\n  return this.publicKeyDigest;\n};\n\nexports.Key = Key;\n\nKey.prototype.readDerPublicKey = function(/*Buffer*/pub_der)\n{\n  if (LOG > 4) console.log("Encode DER public key:\\n" + pub_der.toString(\'hex\'));\n\n  this.publicKeyDer = pub_der;\n\n  var hash = require("./crypto.js").createHash(\'sha256\');\n  hash.update(this.publicKeyDer);\n  this.publicKeyDigest = new customBuf(DataUtils.toNumbersIfString(hash.digest()));\n  var keyStr = pub_der.toString(\'base64\');\n  var keyPem = "-----BEGIN PUBLIC KEY-----\\n";\n  for (var i = 0; i < keyStr.length; i += 64)\n  keyPem += (keyStr.substr(i, 64) + "\\n");\n  keyPem += "-----END PUBLIC KEY-----";\n  this.publicKeyPem = keyPem;\n\n  if (LOG > 4) console.log("Convert public key to PEM format:\\n" + this.publicKeyPem);\n};\n\n/**\n * Load RSA key pair from PEM-encoded strings.\n * Will throw an Error if both \'pub\' and \'pri\' are null.\n */\nKey.prototype.fromPemString = function(pub, pri)\n{\n  if (pub == null && pri == null)\n    throw new Error(\'Cannot create Key object if both public and private PEM string is empty.\');\n\n  // Read public key\n  if (pub != null) {\n    this.publicKeyPem = pub;\n    if (LOG > 4) console.log("Key.publicKeyPem: \\n" + this.publicKeyPem);\n\n    // Remove the \'-----XXX-----\' from the beginning and the end of the public key\n    // and also remove any \\n in the public key string\n    var lines = pub.split(\'\\n\');\n    pub = "";\n    for (var i = 1; i < lines.length - 1; i++)\n      pub += lines[i];\n    this.publicKeyDer = new customBuf(pub, \'base64\');\n    if (LOG > 4) console.log("Key.publicKeyDer: \\n" + this.publicKeyDer.toString(\'hex\'));\n\n    var hash = require("./crypto.js").createHash(\'sha256\');\n    hash.update(this.publicKeyDer);\n    this.publicKeyDigest = new customBuf(DataUtils.toNumbersIfString(hash.digest()));\n    if (LOG > 4) console.log("Key.publicKeyDigest: \\n" + this.publicKeyDigest.toString(\'hex\'));\n  }\n\n  // Read private key\n  if (pri != null) {\n    this.privateKeyPem = pri;\n    if (LOG > 4) console.log("Key.privateKeyPem: \\n" + this.privateKeyPem);\n  }\n};\n\nKey.prototype.fromPem = Key.prototype.fromPemString;\n\n/**\n * Static method that create a Key object.\n * Parameter \'obj\' is a JSON object that has two properties:\n *   pub: the PEM string for the public key\n *   pri: the PEM string for the private key\n * Will throw an Error if both obj.pub and obj.pri are null.\n */\nKey.createFromPEM = function(obj)\n{\n    var key = new Key();\n    key.fromPemString(obj.pub, obj.pri);\n    return key;\n};\n\n})()\n},{"./buffer.js":116,"./crypto.js":116,"./encoding/data-utils.js":109,"./log.js":139}],102:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN KeyLocator object.\n */\n\nvar Name = require(\'./name.js\').Name;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherID = require(\'./publisher-id.js\').PublisherID;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * KeyLocator\n */\nvar KeyLocatorType = {\n  KEYNAME: 1,\n  KEY_LOCATOR_DIGEST: 2,\n  KEY: 3,\n  CERTIFICATE: 4\n};\n\nexports.KeyLocatorType = KeyLocatorType;\n\n/**\n * @constructor\n */\nvar KeyLocator = function KeyLocator(input,type) \n{ \n  if (typeof input === \'object\' && input instanceof KeyLocator) {\n    // Copy from the input KeyLocator.\n    this.type = input.type;\n    this.keyName = new KeyName();\n    if (input.keyName != null) {\n      this.keyName.contentName = input.keyName.contentName == null ? \n        null : new Name(input.keyName.contentName);\n      this.keyName.publisherID = input.keyName.publisherID;\n    }\n    this.keyData = input.keyData == null ? null : new customBuf(input.keyData);\n    this.publicKey = input.publicKey == null ? null : new customBuf(input.publicKey);\n    this.certificate = input.certificate == null ? null : new customBuf(input.certificate);\n  }\n  else {\n    this.type = type;\n    this.keyName = new KeyName();\n\n    if (type == KeyLocatorType.KEYNAME)\n      this.keyName = input;\n    else if (type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n      this.keyData = new customBuf(input);\n    else if (type == KeyLocatorType.KEY) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.publicKey = this.keyData;\n    }\n    else if (type == KeyLocatorType.CERTIFICATE) {\n      this.keyData = new customBuf(input);\n      // Set for backwards compatibility.\n      this.certificate = this.keyData;\n    }\n  }\n};\n\nexports.KeyLocator = KeyLocator;\n\n/**\n * Get the key locator type. If KeyLocatorType.KEYNAME, you may also\n * getKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you may also\n * getKeyData() to get the digest.\n * @returns {number} The key locator type, or null if not specified.\n */\nKeyLocator.prototype.getType = function() { return this.type; };\n\n/**\n * Get the key name.  This is meaningful if getType() is KeyLocatorType.KEYNAME.\n * @returns {Name} The key name. If not specified, the Name is empty.\n */\nKeyLocator.prototype.getKeyName = function() \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  if (this.keyName.contentName == null)\n    this.keyName.contentName = new Name();\n  \n  return this.keyName.contentName;\n};\n\n/**\n * Get the key data. If getType() is KeyLocatorType.KEY_LOCATOR_DIGEST, this is \n * the digest bytes. If getType() is KeyLocatorType.KEY, this is the DER \n * encoded public key. If getType() is KeyLocatorType.CERTIFICATE, this is the \n * DER encoded certificate. \n * @returns {Buffer} The key data, or null if not specified.\n */\nKeyLocator.prototype.getKeyData = function() \n{ \n  if (this.type == KeyLocatorType.KEY)\n    return this.publicKey;\n  else if (this.type == KeyLocatorType.CERTIFICATE)\n    return this.certificate;\n  else\n    return this.keyData;\n};\n\n/**\n * Set the key locator type.  If KeyLocatorType.KEYNAME, you must also\n * setKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you must also\n * setKeyData() to the digest.\n * @param {number} type The key locator type.  If null, the type is unspecified.\n */\nKeyLocator.prototype.setType = function(type) { this.type = type; }; \n\n/**\n * Set key name to a copy of the given Name.  This is the name if getType() \n * is KeyLocatorType.KEYNAME.\n * @param {Name} name The key name which is copied.\n */\nKeyLocator.prototype.setKeyName = function(name) \n{ \n  if (this.keyName == null)\n    this.keyName = new KeyName();\n  \n  this.keyName.contentName = typeof name === \'object\' && name instanceof Name ?\n                             new Name(name) : new Name(); \n}; \n\n/**\n * Set the key data to the given value. This is the digest bytes if getType() is \n * KeyLocatorType.KEY_LOCATOR_DIGEST.\n * @param {Buffer} keyData The array with the key data bytes.\n */\nKeyLocator.prototype.setKeyData = function(keyData)\n{\n  var value = keyData;\n  if (value != null)\n    // Make a copy.\n    value = new customBuf(value);\n  \n  this.keyData = value;\n  // Set for backwards compatibility.\n  this.publicKey = value;\n  this.certificate = value;\n};\n\n/**\n * Clear the keyData and set the type to none.\n */\nKeyLocator.prototype.clear = function() \n{\n  this.type = null;\n  this.keyName = null;\n  this.keyData = null;\n  this.publicKey = null;\n  this.certificate = null;\n};\n\nKeyLocator.prototype.from_ndnb = function(decoder) {\n\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Key)) \n  {\n    try {\n      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);\n      // This is a DER-encoded SubjectPublicKeyInfo.\n      \n      //TODO FIX THIS, This should create a Key Object instead of keeping bytes\n\n      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);\n      this.type = KeyLocatorType.KEY;    \n\n      if (LOG > 4) console.log(\'PUBLIC KEY FOUND: \'+ this.publicKey);\n    } \n    catch (e) {\n      throw new Error("Cannot parse key: ", e);\n    } \n\n    if (null == this.publicKey)\n      throw new Error("Cannot parse key: ");\n  } \n  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {\n    try {\n      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);\n      \n      /*\n       * Certificates not yet working\n       */\n      \n      this.certificate = encodedCert;\n      this.type = KeyLocatorType.CERTIFICATE;\n\n      if (LOG > 4) console.log(\'CERTIFICATE FOUND: \'+ this.certificate);      \n    } \n    catch (e) {\n      throw new Error("Cannot decode certificate: " +  e);\n    }\n    if (null == this.certificate)\n      throw new Error("Cannot parse certificate! ");\n  } else  {\n    this.type = KeyLocatorType.KEYNAME;\n    \n    this.keyName = new KeyName();\n    this.keyName.from_ndnb(decoder);\n  }\n  decoder.readElementClose();\n};  \n\nKeyLocator.prototype.to_ndnb = function(encoder) \n{\n  if (LOG > 4) console.log(\'type is is \' + this.type);\n\n  if (this.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n    // encodeSignedInfo already encoded this as the publisherPublicKeyDigest,\n    //   so do nothing here.\n    return;\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (this.type == KeyLocatorType.KEY) {\n    if (LOG > 5) console.log(\'About to encode a public key\' +this.publicKey);\n    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);  \n  } \n  else if (this.type == KeyLocatorType.CERTIFICATE) {  \n    try {\n      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);\n    } \n    catch (e) {\n      throw new Error("CertificateEncodingException attempting to write key locator: " + e);\n    }    \n  } \n  else if (this.type == KeyLocatorType.KEYNAME)\n    this.keyName.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyLocator.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.KeyLocator; \n};\n\n/**\n * KeyName is only used by KeyLocator.\n * @constructor\n */\nvar KeyName = function KeyName() \n{\n  this.contentName = new Name();  //contentName\n  this.publisherID = this.publisherID;  //publisherID\n};\n\nexports.KeyName = KeyName;\n\nKeyName.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.contentName = new Name();\n  this.contentName.from_ndnb(decoder);\n  \n  if (LOG > 4) console.log(\'KEY NAME FOUND: \');\n  \n  if (PublisherID.peek(decoder)) {\n    this.publisherID = new PublisherID();\n    this.publisherID.from_ndnb(decoder);\n  }\n  \n  decoder.readElementClose();\n};\n\nKeyName.prototype.to_ndnb = function(encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  this.contentName.to_ndnb(encoder);\n  if (null != this.publisherID)\n    this.publisherID.to_ndnb(encoder);\n\n  encoder.writeElementClose();       \n};\n  \nKeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };\n\n\n})()\n},{"./buffer.js":116,"./log.js":139,"./name.js":95,"./publisher-id.js":142,"./util/ndn-protoco-id-tags.js":137}],103:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents PublisherPublicKeyDigest Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd) \n{ \n this.PUBLISHER_ID_LEN = 512/8;\n this.publisherPublicKeyDigest = pkd;\n};\n\nexports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;\n\nPublisherPublicKeyDigest.prototype.from_ndnb = function(decoder) \n{\n  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'Publisher public key digest is \' + this.publisherPublicKeyDigest);\n\n  if (null == this.publisherPublicKeyDigest)\n    throw new Error("Cannot parse publisher key digest.");\n    \n  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)\n\n  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {\n    if (LOG > 0)\n      console.log(\'LENGTH OF PUBLISHER ID IS WRONG! Expected \' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);\n      \n    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;    \n  }\n};\n\nPublisherPublicKeyDigest.prototype.to_ndnb= function(encoder) \n{\n  //TODO Check that the ByteArray for the key is present\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  if (LOG > 3) console.log(\'PUBLISHER KEY DIGEST IS\'+this.publisherPublicKeyDigest);\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);\n};\n  \nPublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };\n\nPublisherPublicKeyDigest.prototype.validate = function() \n{\n    return null != this.publisherPublicKeyDigest;\n};\n\n},{"./log.js":139,"./util/ndn-protoco-id-tags.js":137}],116:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n// Library namespace\nvar ndn = ndn || {};\n\nvar exports = ndn;\n\nvar ASN1HEX = require(\'../contrib/securityLib/asn1hex-1.1.js\')\nvar KJUR = require(\'../contrib/securityLib/crypto-1.0.js\')\nvar RSAKey = require(\'../contrib/securityLib/rsasign-1.2.js\')\nvar b64tohex = require(\'../contrib/securityLib/base64.js\').b64tohex\n// Factory method to create node.js compatible buffer objects\nvar customBuf = function customBuf(data, format) \n{\n  var obj;\n\n  if (typeof data == \'number\')\n    obj = new Uint8Array(data);\n  else if (typeof data == \'string\') {\n    if (format == null || format == \'utf8\') {\n      var utf8 = customBuf.str2rstr_utf8(data);\n      obj = new Uint8Array(utf8.length);\n      for (var i = 0; i < utf8.length; i++)\n        obj[i] = utf8.charCodeAt(i);\n    } \n    else if (format == \'binary\') {\n      obj = new Uint8Array(data.length);\n      for (var i = 0; i < data.length; i++)\n        obj[i] = data.charCodeAt(i);\n    } \n    else if (format == \'hex\') {\n      obj = new Uint8Array(Math.floor(data.length / 2));\n      var i = 0;\n      data.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else if (format == \'base64\') {\n      var hex = b64tohex(data);\n      obj = new Uint8Array(Math.floor(hex.length / 2));\n      var i = 0;\n      hex.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    } \n    else \n      throw new Error(\'Buffer: unknown encoding format \' + format);\n  } \n  else if (typeof data == \'object\' && (data instanceof Uint8Array || data instanceof customBuf)) {\n    // The second argument is a boolean for "copy", default true.\n    if (format == false)\n      obj = data.subarray(0);\n    else\n      obj = new Uint8Array(data);\n  }\n  else if (typeof data == \'object\' && data instanceof ArrayBuffer)\n    // Copy.\n    obj = new Uint8Array(data);\n  else if (typeof data == \'object\')\n    // Assume component is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    obj = new Uint8Array(data);\n  else\n    throw new Error(\'Buffer: unknown data type.\');\n\n  try {\n    obj.__proto__ = customBuf.prototype;\n  } catch(ex) {\n    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);\n  }\n\n  obj.__proto__.toString = function(encoding) {\n    if (encoding == null || encoding == \'binary\') {\n      var ret = "";\n      for (var i = 0; i < this.length; i++)\n        ret += String.fromCharCode(this[i]);\n      return ret;\n    }\n\n    var ret = "";\n    for (var i = 0; i < this.length; i++)\n      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);\n\n    if (encoding == \'hex\')\n      return ret;\n    else if (encoding == \'base64\')\n      return hex2b64(ret);\n    else\n      throw new Error(\'Buffer.toString: unknown encoding format \' + encoding);\n  };\n\n  obj.__proto__.slice = function(begin, end) {\n    if (end !== undefined)\n      return new customBuf(this.subarray(begin, end), false);\n    else\n      return new customBuf(this.subarray(begin), false);\n  };\n\n  obj.__proto__.copy = function(target, targetStart) {\n    if (targetStart !== undefined)\n      target.set(this, targetStart);\n    else\n      target.set(this);\n  };\n\n  return obj;\n};\n\ncustomBuf.prototype = Uint8Array.prototype;\n\ncustomBuf.concat = function(arrays) \n{\n  var totalLength = 0;\n  for (var i = 0; i < arrays.length; ++i)\n    totalLength += arrays[i].length;\n    \n  var result = new customBuf(totalLength);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; ++i) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return result;\n};\n\ncustomBuf.str2rstr_utf8 = function(input)\n{\n  var output = "";\n  var i = -1;\n  var x, y;\n\n  while (++i < input.length)\n  {\n    // Decode utf-16 surrogate pairs\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\n    {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    // Encode output as utf-8\n    if (x <= 0x7F)\n      output += String.fromCharCode(x);\n    else if (x <= 0x7FF)\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0xFFFF)\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0x1FFFFF)\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\n                                    0x80 | ((x >>> 12) & 0x3F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n  }\n  return output;\n};\n\n// Factory method to create hasher objects\nexports.createHash = function(alg) \n{\n  if (alg != \'sha256\')\n    throw new Error(\'createHash: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});\n\n  obj.update = function(buf) {\n    this.md.updateHex(buf.toString(\'hex\'));\n  };\n\n  obj.digest = function() {\n    return new customBuf(this.md.digest(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA signer objects\nexports.createSign = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  obj.sign = function(keypem) {\n    var rsa = new RSAKey();\n    rsa.readPrivateKeyFromPEMString(keypem);\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initSign(rsa);\n    for (var i = 0; i < this.arr.length; ++i)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n\n    return new customBuf(signer.sign(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA verifier objects\nexports.createVerify = function(alg) \n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n    \n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  var getSubjectPublicKeyPosFromHex = function(hPub) {  \n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0); \n    if (a.length != 2) \n      return -1;\n    var pBitString = a[1];\n    if (hPub.substring(pBitString, pBitString + 2) != \'03\') \n      return -1;\n    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);\n    if (hPub.substring(pBitStringV, pBitStringV + 2) != \'00\') \n      return -1;\n    return pBitStringV + 2;\n  };\n\n  var readPublicDER = function(pub_der) {\n    var hex = pub_der.toString(\'hex\'); \n    var p = getSubjectPublicKeyPosFromHex(hex);\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);\n    if (a.length != 2) \n      return null;\n    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);\n    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);\n    var rsaKey = new RSAKey();\n    rsaKey.setPublic(hN, hE);\n    return rsaKey;\n  };\n\n  obj.verify = function(keypem, sig) {\n    var key = new ndn.Key();\n    key.fromPemString(keypem);\n\n    var rsa = readPublicDER(key.publicToDER());\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initVerifyByPublicKey(rsa);\n    for (var i = 0; i < this.arr.length; i++)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n    var hSig = sig.toString(\'hex\'); \n    return signer.verify(hSig);\n  };\n\n  return obj;\n};\n\nexports.randomBytes = function(size)\n{\n  // TODO: Use a cryptographic random number generator.\n  var result = new customBuf(size);\n  for (var i = 0; i < size; ++i)\n    result[i] = Math.floor(Math.random() * 256);\n  return result;\n};\n\nexports.Buffer = customBuf;\n\nmodule.exports = exports;\n\n})()\n},{"../contrib/securityLib/asn1hex-1.1.js":143,"../contrib/securityLib/base64.js":146,"../contrib/securityLib/crypto-1.0.js":144,"../contrib/securityLib/rsasign-1.2.js":145}],85:[function(require,module,exports){\n(function(){/**\n * This class is used to decode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNTime = require(\'../util/ndn-time.js\').NDNTime;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n  \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n\n\n//returns a string\ntagToString = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {\n    return NDNProtocolDTagsStrings[tagVal];\n  } \n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  }\n  \n  return null;\n};\n\n//returns a Long\nstringToTag =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n  }\n  \n  return null;\n};\n\n/**\n * @constructor\n */\nvar BinaryXMLDecoder = function BinaryXMLDecoder(input) \n{\n  var MARK_LEN=512;\n  var DEBUG_MAX_LEN =  32768;\n  \n  this.input = input;\n  this.offset = 0;\n  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.\n  this.previouslyPeekedDTagStartOffset = -1;\n};\n\nexports.BinaryXMLDecoder = BinaryXMLDecoder;\n\n/**\n * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.\n   * Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n */\nBinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset) {\n    // peekDTag already decoded this DTag.\n    if (this.previouslyPeekedDTag != expectedTag)\n      throw new DecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));\n\n    // Fast forward past the header.\n    this.offset = this.previouslyPeekedDTagEndOffset;\n  }\n  else {\n    var typeAndValue = this.decodeTypeAndVal();\n    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)\n      throw new DecodingException(new Error("Header type is not a DTAG"));\n\n    if (typeAndValue.val() != expectedTag)\n      throw new DecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));\n  }  \n};\n\n/**\n * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readStartElement = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes)\n{\n  //TypeAndVal \n  var tv = this.decodeTypeAndVal();\n      \n  if (null == tv)\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));\n      \n  //String \n  var decodedTag = null;\n      \n  if (tv.type() == XML_TAG) {\n    // Tag value represents length-1 as tags can never be empty.\n    var valval;\n        \n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val())) + 1;\n    else\n      valval = (tv.val())+ 1;\n        \n    decodedTag = this.decodeUString(valval);\n  } \n  else if (tv.type() == XML_DTAG)\n    decodedTag = tv.val();\n      \n  if (null ==  decodedTag || decodedTag != startTag) {\n    console.log(\'expecting \'+ startTag + \' but got \'+ decodedTag);\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));\n  }\n      \n  // DKS: does not read attributes out of stream if caller doesn\'t\n  // ask for them. Should possibly peek and skip over them regardless.\n  // TODO: fix this\n  if (null != attributes)\n    readAttributes(attributes); \n};\n  \n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readAttributes = function(\n  // array of [attributeName, attributeValue] \n  attributes) \n{\n  if (null == attributes)\n    return;\n\n  try {\n    // Now need to get attributes.\n    //TypeAndVal \n    var nextTV = this.peekTypeAndVal();\n\n    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {\n      // Decode this attribute. First, really read the type and value.\n      //this.TypeAndVal \n      var thisTV = this.decodeTypeAndVal();\n\n      //String \n      var attributeName = null;\n      if (XML_ATTR == thisTV.type()) {\n        // Tag value represents length-1 as attribute names cannot be empty.\n        var valval ;\n        if (typeof thisTV.val() == \'string\')\n          valval = (parseInt(thisTV.val())) + 1;\n        else\n          valval = (thisTV.val())+ 1;\n        \n        attributeName = this.decodeUString(valval);\n      } \n      else if (XML_DATTR == thisTV.type()) {\n        // DKS TODO are attributes same or different dictionary?\n        attributeName = tagToString(thisTV.val());\n        if (null == attributeName)\n          throw new DecodingException(new Error("Unknown DATTR value" + thisTV.val()));\n      }\n      \n      // Attribute values are always UDATA\n      //String\n      var attributeValue = this.decodeUString();\n\n      attributes.push([attributeName, attributeValue]);\n      nextTV = this.peekTypeAndVal();\n    }\n  } \n  catch (e) {\n    throw new DecodingException(new Error("readStartElement", e));\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsString = function() \n{\n  //String \n  var decodedTag = null;\n  var previousOffset = this.offset;\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal \n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        // Tag value represents length-1 as tags can never be empty.\n        var valval ;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        decodedTag = this.decodeUString(valval);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tagToString(tv.val());          \n    } // else, not a type and val, probably an end element. rewind and return false.\n  } \n  catch (e) {\n  } \n  finally {\n    try {\n      this.offset = previousOffset;\n    } \n    catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new DecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,\n * then set return true.  Do not update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {boolean} True if the tag is the expected tag, otherwise false.\n */\nBinaryXMLDecoder.prototype.peekDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset)\n    // We already decoded this DTag.\n    return this.previouslyPeekedDTag == expectedTag;\n  else {\n    // First check if it is an element close (which cannot be the expected tag).  \n    if (this.input[this.offset] == XML_CLOSE)\n      return false;\n\n    var saveOffset = this.offset;\n    var typeAndValue = this.decodeTypeAndVal();\n    // readElementStartDTag will use this to fast forward.\n    this.previouslyPeekedDTagEndOffset = this.offset;\n    // Restore the position.\n    this.offset = saveOffset;\n\n    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {\n      this.previouslyPeekedDTagStartOffset = saveOffset;\n      this.previouslyPeekedDTag = typeAndValue.val();\n\n      return typeAndValue.val() == expectedTag;\n    }\n    else\n      return false;\n  }  \n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElement = function(\n    //String \n    startTag) \n{\n  //String \n  if (typeof startTag == \'string\') {\n    var decodedTag = this.peekStartElementAsString();\n    \n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else if (typeof startTag == \'number\') {\n    var decodedTag = this.peekStartElementAsLong();\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else\n    throw new DecodingException(new Error("SHOULD BE STRING OR NUMBER"));\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsLong = function() \n{\n  //Long\n  var decodedTag = null;    \n  var previousOffset = this.offset;\n  \n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        if (tv.val() + 1 > DEBUG_MAX_LEN)\n          throw new DecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));\n\n        var valval;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        // Tag value represents length-1 as tags can never be empty.\n        //String \n        var strTag = this.decodeUString(valval);\n        \n        decodedTag = stringToTag(strTag);\n      } \n      else if (tv.type() == XML_DTAG)\n        decodedTag = tv.val();          \n    } // else, not a type and val, probably an end element. rewind and return false.\n\n  } \n  catch (e) {  \n  } \n  finally {\n    try {\n      //this.input.reset();\n      this.offset = previousOffset;\n    } catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new Error("Cannot reset stream! " + e.getMessage(), e);\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a \n * customBuf. However, if allowNull is true, then the item may be absent.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @param {boolean} allowNull True if the binary item may be missing.\n * @returns {Buffer} A customBuf which is a slice on the data inside the input buffer. However, \n * if allowNull is true and the binary data item is absent, then return null.\n */\nBinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readBinaryElement = function(\n    //long \n    startTag,\n    //TreeMap<String, String> \n    attributes,\n    //boolean\n    allowNull) \n{\n  this.readStartElement(startTag, attributes);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * Read one byte from the input starting at its offset, expecting it to be the element close.\n * Update the input\'s offset.\n */\nBinaryXMLDecoder.prototype.readElementClose = function() \n{\n  var next = this.input[this.offset++];     \n  if (next != XML_CLOSE)\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n};\n\n/**\n * @deprecated Use readElementClose.\n */\nBinaryXMLDecoder.prototype.readEndElement = function() \n{\n  if (LOG > 4) console.log(\'this.offset is \'+this.offset);\n  \n  var next = this.input[this.offset]; \n  \n  this.offset++;\n  \n  if (LOG > 4) console.log(\'XML_CLOSE IS \'+XML_CLOSE);\n  if (LOG > 4) console.log(\'next is \'+next);\n  \n  if (next != XML_CLOSE) {\n    console.log("Expected end element, got: " + next);\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n  }\n};\n\n//String  \nBinaryXMLDecoder.prototype.readUString = function() \n{\n  //String \n  var ustring = this.decodeUString();  \n  this.readElementClose();\n  return ustring;\n};\n  \n/**\n * Read a blob as well as the end element. Returns a customBuf (or null for missing blob).\n * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,\n *   just read the end element and return null.\n */\nBinaryXMLDecoder.prototype.readBlob = function(allowNull) \n{\n  if (this.input[this.offset] == XML_CLOSE && allowNull) {\n    this.readElementClose();\n    return null;\n  }\n    \n  var blob = this.decodeBlob();  \n  this.readElementClose();\n  return blob;\n};\n\n/**\n * Decode the header from the input starting at its offset, expecting the type to be \n * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned \n * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {NDNTime} The dateTime value.\n */\nBinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)  \n{\n  var byteTimestamp = this.readBinaryDTagElement(expectedTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\n/**\n * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readDateTime = function(\n  //long \n  startTag)  \n{\n  var byteTimestamp = this.readBinaryElement(startTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  if (LOG > 4) console.log(\'DECODED DATE WITH VALUE\');\n  if (LOG > 4) console.log(lontimestamp);\n  \n  //NDNTime \n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\nBinaryXMLDecoder.prototype.decodeTypeAndVal = function() \n{\n  \n  /*int*/ var type = -1;\n  /*long*/ var val = 0;\n  /*boolean*/ var more = true;\n\n  do {\n    var next = this.input[this.offset ];\n    if (next == null)\n      // Quit the loop.\n      return null; \n    \n    if (next < 0)\n      return null; \n\n    if (0 == next && 0 == val)\n      return null;\n    \n    more = (0 == (next & XML_TT_NO_MORE));\n    \n    if  (more) {\n      val = val << XML_REG_VAL_BITS;\n      val |= (next & XML_REG_VAL_MASK);\n    } \n    else {\n      type = next & XML_TT_MASK;\n      val = val << XML_TT_VAL_BITS;\n      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);\n    }\n    \n    this.offset++;\n  } while (more);\n  \n  if (LOG > 4) console.log(\'TYPE is \'+ type + \' VAL is \'+ val);\n\n  return new TypeAndVal(type, val);\n};\n\n//TypeAndVal\nBinaryXMLDecoder.prototype.peekTypeAndVal = function() \n{\n  //TypeAndVal \n  var tv = null;\n  var previousOffset = this.offset;\n  \n  try {\n    tv = this.decodeTypeAndVal();\n  } \n  finally {\n    this.offset = previousOffset;\n  }\n  \n  return tv;\n};\n\n//Buffer\nBinaryXMLDecoder.prototype.decodeBlob = function(\n    //int \n    blobLength) \n{  \n  if (null == blobLength) {\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    var valval ;\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val()));\n    else\n      valval = (tv.val());\n    \n    return this.decodeBlob(valval);\n  }\n  \n  //Buffer\n  var bytes = new customBuf(this.input.slice(this.offset, this.offset+ blobLength));\n  this.offset += blobLength;\n  \n  return bytes;\n};\n\n//String\nBinaryXMLDecoder.prototype.decodeUString = function(\n    //int \n    byteLength) \n{\n  if (null == byteLength) {\n    var tempStreamPosition = this.offset;\n      \n    //TypeAndVal \n    var tv = this.decodeTypeAndVal();\n    \n    if (LOG > 4) console.log(\'TV is \'+tv);\n    if (LOG > 4) console.log(tv);\n    \n    if (LOG > 4) console.log(\'Type of TV is \'+typeof tv);\n  \n    // if we just have closers left, will get back null\n    if (null == tv || XML_UDATA != tv.type()) {\n      this.offset = tempStreamPosition;      \n      return "";\n    }\n      \n    return this.decodeUString(tv.val());\n  }\n  else {\n    //Buffer \n    var stringBytes = this.decodeBlob(byteLength);\n    \n    // TODO: Should this parse as UTF8?\n    return DataUtils.toString(stringBytes);    \n  }\n};\n\n//OBject containg a pair of type and value\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.t = _type;\n  this.v = _val;\n};\n\nTypeAndVal.prototype.type = function() \n{\n  return this.t;\n};\n\nTypeAndVal.prototype.val = function() \n{\n  return this.v;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {number} The parsed integer.\n */\nBinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)\n{\n  return parseInt(this.readUTF8DTagElement(expectedTag));\n};\n\n/**\n * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readIntegerElement = function(\n  //String \n  startTag) \n{\n  //String \n  if (LOG > 4) console.log(\'READING INTEGER \'+ startTag);\n  if (LOG > 4) console.log(\'TYPE OF \'+ typeof startTag);\n  \n  var strVal = this.readUTF8Element(startTag);\n  \n  return parseInt(strVal);\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item and return a string. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {string} The UDATA string.\n */\nBinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readUString();;\n};\n\n/**\n * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readUTF8Element = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes) \n{\n  //throws Error where name == "DecodingException" \n\n  // can\'t use getElementText, can\'t get attributes\n  this.readStartElement(startTag, attributes);\n  //String \n  var strElementText = this.readUString();\n  return strElementText;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nBinaryXMLDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n})()\n},{"../buffer.js":54,"../log.js":89,"../util/ndn-protoco-id-tags.js":87,"../util/ndn-time.js":51,"./data-utils.js":47,"./decoding-exception.js":126}],86:[function(require,module,exports){\n(function(){/**\n * This class is used to encode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n/**\n * @constructor\n */\nvar BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength) \n{\n  if (!initiaLength)\n    initiaLength = 16;\n  \n  this.ostream = new DynamicBuffer(initiaLength);\n  this.offset = 0;\n  this.CODEC_NAME = "Binary";\n};\n\nexports.BinaryXMLEncoder = BinaryXMLEncoder;\n\n/**\n * Encode utf8Content as utf8 and write to the output buffer as a UDATA.\n * @param {string} utf8Content The string to convert to utf8.\n */\nBinaryXMLEncoder.prototype.writeUString = function(utf8Content) \n{\n  this.encodeUString(utf8Content, XML_UDATA);\n};\n\nBinaryXMLEncoder.prototype.writeBlob = function(\n    /*Buffer*/ binaryContent) \n{  \n  if (LOG >3) console.log(binaryContent);\n  \n  this.encodeBlob(binaryContent, binaryContent.length);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer.\n * @param {number} tag The DTAG tag.\n */\nBinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)\n{\n  this.encodeTypeAndVal(XML_DTAG, tag);\n};\n\n/**\n * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeStartElement = function(\n  /*String*/ tag, \n  /*TreeMap<String,String>*/ attributes) \n{\n  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);\n  \n  if (null == dictionaryVal)\n    this.encodeUString(tag, XML_TAG);\n  else\n    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);\n  \n  if (null != attributes)\n    this.writeAttributes(attributes); \n};\n\n/**\n * Write an element close to the output buffer.\n */\nBinaryXMLEncoder.prototype.writeElementClose = function() \n{\n  this.ostream.ensureLength(this.offset + 1);\n  this.ostream.array[this.offset] = XML_CLOSE;\n  this.offset += 1;\n};\n\n/**\n * @deprecated Use writeElementClose.\n */\nBinaryXMLEncoder.prototype.writeEndElement = function() \n{\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes) \n{\n  if (null == attributes)\n    return;\n\n  // the keySet of a TreeMap is sorted.\n\n  for (var i = 0; i< attributes.length;i++) {\n    var strAttr = attributes[i].k;\n    var strValue = attributes[i].v;\n\n    var dictionaryAttr = stringToTag(strAttr);\n    if (null == dictionaryAttr)\n      // not in dictionary, encode as attr\n      // compressed format wants length of tag represented as length-1\n      // to save that extra bit, as tag cannot be 0 length.\n      // encodeUString knows to do that.\n      this.encodeUString(strAttr, XML_ATTR);\n    else\n      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);\n\n    // Write value\n    this.encodeUString(strValue);    \n  }\n};\n\n//returns a string\nstringToTag = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)\n    return NDNProtocolDTagsStrings[tagVal];\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  \n  return null;\n};\n\n//returns a Long\ntagToString =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  \n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n\n  return null;\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the content as explained below, \n * then an element close.\n * @param {number} tag The DTAG tag.\n * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,\n * call writeUString.  Otherwise, call writeBlob.\n */\nBinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)\n{\n  this.writeElementStartDTag(tag);\n  \n  if (typeof content === \'number\')\n    this.writeUString(content.toString());\n  else if (typeof content === \'string\')\n    this.writeUString(content);\n  else\n    this.writeBlob(content);\n  \n  this.writeElementClose();\n};\n\n/**\n * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n * If Content is a string, then encode as utf8 and write UDATA.\n */\nBinaryXMLEncoder.prototype.writeElement = function(\n    //long \n    tag, \n    //byte[] \n    Content,\n    //TreeMap<String, String> \n    attributes) \n{\n  this.writeStartElement(tag, attributes);\n  // Will omit if 0-length\n  \n  if (typeof Content === \'number\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER .charCodeAt(0) \' + Content.toString().charCodeAt(0));\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER \' + Content.toString());\n    if (LOG > 4) console.log(\'type of number is \' + typeof Content.toString());\n    \n    this.writeUString(Content.toString());\n  }\n  else if (typeof Content === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE STRING  \' + Content);\n    if (LOG > 4) console.log(\'type of STRING is \' + typeof Content);\n    \n    this.writeUString(Content);\n  }\n  else {\n    if (LOG > 4) console.log(\'GOING TO WRITE A BLOB  \' + Content);\n\n    this.writeBlob(Content);\n  }\n  \n  this.writeElementClose();\n};\n\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.type = _type;\n  this.val = _val;  \n};\n\nBinaryXMLEncoder.prototype.encodeTypeAndVal = function(\n    //int\n    type, \n    //long \n    val) \n{  \n  if (LOG > 4) console.log(\'Encoding type \'+ type+ \' and value \'+ val);\n  \n  if (LOG > 4) console.log(\'OFFSET IS \' + this.offset);\n  \n  if (type > XML_UDATA || type < 0 || val < 0)\n    throw new Error("Tag and value must be positive, and tag valid.");\n  \n  // Encode backwards. Calculate how many bytes we need:\n  var numEncodingBytes = this.numEncodingBytes(val);\n  this.ostream.ensureLength(this.offset + numEncodingBytes);\n\n  // Bottom 4 bits of val go in last byte with tag.\n  this.ostream.array[this.offset + numEncodingBytes - 1] = \n    //(byte)\n      (BYTE_MASK &\n          (((XML_TT_MASK & type) | \n           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n           XML_TT_NO_MORE); // set top bit for last byte\n  val = val >>> XML_TT_VAL_BITS;\n  \n  // Rest of val goes into preceding bytes, 7 bits per byte, top bit\n  // is "more" flag.\n  var i = this.offset + numEncodingBytes - 2;\n  while (0 != val && i >= this.offset) {\n    this.ostream.array[i] = //(byte)\n        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset\n    val = val >>> XML_REG_VAL_BITS;\n    --i;\n  }\n  \n  if (val != 0)\n    throw new Error("This should not happen: miscalculated encoding");\n\n  this.offset+= numEncodingBytes;\n  \n  return numEncodingBytes;\n};\n\n/**\n * Encode ustring as utf8.\n */\nBinaryXMLEncoder.prototype.encodeUString = function(\n    //String \n    ustring, \n    //byte \n    type) \n{  \n  if (null == ustring)\n    return;\n  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)\n    return;\n  \n  if (LOG > 3) console.log("The string to write is ");\n  if (LOG > 3) console.log(ustring);\n\n  var strBytes = DataUtils.stringToUtf8Array(ustring);\n  \n  this.encodeTypeAndVal(type, \n            (((type == XML_TAG) || (type == XML_ATTR)) ?\n                (strBytes.length-1) :\n                strBytes.length));\n  \n  if (LOG > 3) console.log("THE string to write is ");\n  \n  if (LOG > 3) console.log(strBytes);\n  \n  this.writeString(strBytes);\n  this.offset+= strBytes.length;\n};\n\n\nBinaryXMLEncoder.prototype.encodeBlob = function(\n    //Buffer \n    blob, \n    //int \n    length) \n{\n  if (null == blob)\n    return;\n  \n  if (LOG > 4) console.log(\'LENGTH OF XML_BLOB IS \'+length);\n  \n  this.encodeTypeAndVal(XML_BLOB, length);\n  this.writeBlobArray(blob);\n  this.offset += length;\n};\n\nvar ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);\n\nBinaryXMLEncoder.prototype.numEncodingBytes = function(\n    //long\n    x) \n{\n  if (x <= ENCODING_LIMIT_1_BYTE) return (1);\n  if (x <= ENCODING_LIMIT_2_BYTES) return (2);\n  if (x <= ENCODING_LIMIT_3_BYTES) return (3);\n  \n  var numbytes = 1;\n  \n  // Last byte gives you XML_TT_VAL_BITS\n  // Remainder each give you XML_REG_VAL_BITS\n  x = x >>> XML_TT_VAL_BITS;\n  while (x != 0) {\n        numbytes++;\n    x = x >>> XML_REG_VAL_BITS;\n  }\n  return (numbytes);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the dateTime\n   * as a big endian BLOB converted to 4096 ticks per second, then an element close.\n * @param {number} tag The DTAG tag.\n * @param {NDNTime} dateTime\n */\nBinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)\n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n/**\n * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeDateTime = function(\n    //String \n    tag, \n    //NDNTime \n    dateTime) \n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n// This does not update this.offset.\nBinaryXMLEncoder.prototype.writeString = function(input) \n{\n  if (typeof input === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING\');\n    if (LOG > 4) console.log(input);\n        \n    this.ostream.ensureLength(this.offset + input.length);\n    for (var i = 0; i < input.length; i++) {\n      if (LOG > 4) console.log(\'input.charCodeAt(i)=\' + input.charCodeAt(i));\n      this.ostream.array[this.offset + i] = (input.charCodeAt(i));\n    }\n  }\n  else\n  {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING IN BINARY FORM\');\n    if (LOG > 4) console.log(input);\n    \n    this.writeBlobArray(input);\n  }\n};\n\nBinaryXMLEncoder.prototype.writeBlobArray = function(\n    //Buffer \n    blob) \n{  \n  if (LOG > 4) console.log(\'GOING TO WRITE A BLOB\');\n    \n  this.ostream.copy(blob, this.offset);\n};\n\nBinaryXMLEncoder.prototype.getReducedOstream = function() \n{\n  return this.ostream.slice(0, this.offset);\n};\n\n})()\n},{"../buffer.js":54,"../log.js":89,"../util/dynamic-buffer.js":147,"../util/ndn-protoco-id-tags.js":87,"./data-utils.js":47}],90:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar Blob = require(\'./blob.js\').Blob;\n\n/**\n * A SignedBlob extends Blob to keep the offsets of a signed portion (e.g., the \n * bytes of Data packet). This inherits from Blob, including Blob.size and Blob.buf.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {number} signedPortionBeginOffset (optional) The offset in the \n * encoding of the beginning of the signed portion. If omitted, set to 0.\n * @param {number} signedPortionEndOffset (optional) The offset in the encoding \n * of the end of the signed portion. If omitted, set to 0.\n */\nvar SignedBlob = function SignedBlob(value, signedPortionBeginOffset, signedPortionEndOffset) \n{\n  // Call the base constructor.\n  Blob.call(this, value);\n  \n  if (this.buffer == null) {\n    this.signedPortionBeginOffset = 0;\n    this.signedPortionEndOffset = 0;\n  }\n  else if (typeof value === \'object\' && value instanceof SignedBlob) {\n    // Copy the SignedBlob, allowing override for offsets.\n    this.signedPortionBeginOffset = signedPortionBeginOffset == null ? \n      value.signedPortionBeginOffset : signedPortionBeginOffset;\n    this.signedPortionEndOffset = signedPortionEndOffset == null ? \n      value.signedPortionEndOffset : signedPortionEndOffset;\n  }\n  else {\n    this.signedPortionBeginOffset = signedPortionBeginOffset || 0;\n    this.signedPortionEndOffset = signedPortionEndOffset || 0;\n  }\n  \n  if (this.buffer == null)\n    this.signedBuffer = null;\n  else\n    this.signedBuffer = this.buffer.slice\n      (this.signedPortionBeginOffset, this.signedPortionEndOffset);\n};\n\nSignedBlob.prototype = new Blob();\nSignedBlob.prototype.name = "SignedBlob";\n\nexports.SignedBlob = SignedBlob;\n\n/**\n * Return the length of the signed portion of the immutable byte array.\n * @returns {number} The length of the signed portion.  If signedBuf() is null, \n * return 0.\n */\nSignedBlob.prototype.signedSize = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return a the signed portion of the immutable byte array.\n * @returns {Buffer} A slice into the customBuf which is the signed portion.  \n * If the pointer to the array is null, return null.\n */\nSignedBlob.prototype.signedBuf = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer;\n  else\n    return null;\n};\n\n/**\n * Return the offset in the array of the beginning of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionBeginOffset = function()\n{\n  return this.signedPortionBeginOffset;\n};\n\n/**\n * Return the offset in the array of the end of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionEndOffset = function()\n{\n  return this.signedPortionEndOffset;\n};\n\n})()\n},{"../buffer.js":54,"./blob.js":49}],122:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Face Instances\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\n\n/**\n * @constructor\n */\nvar FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,\n    multicastTTL, freshnessSeconds) \n{\n  this.action = action;\n  this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n  this.faceID = faceID;\n  this.ipProto = ipProto;\n  this.host = host;\n  this.Port = port;\n  this.multicastInterface =multicastInterface;\n  this.multicastTTL =multicastTTL;\n  this.freshnessSeconds = freshnessSeconds;\n};\n\nexports.FaceInstance = FaceInstance;\n\nFaceInstance.NetworkProtocol = { TCP:6, UDP:17};\n\n/**\n * Used by NetworkObject to decode the object from a network stream.\n */\nFaceInstance.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Action))   \n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    this.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {\n    //int\n    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);\n    \n    this.ipProto = null;\n    \n    if (FaceInstance.NetworkProtocol.TCP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.TCP;\n    else if (FaceInstance.NetworkProtocol.UDP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.UDP;\n    else\n      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Host))\n    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);\n  if (decoder.peekDTag(NDNProtocolDTags.Port))\n    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))\n    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))\n    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\n/**\n * Used by NetworkObject to encode the object to a network stream.\n */\nFaceInstance.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.publisherPublicKeyDigest)\n    this.publisherPublicKeyDigest.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.ipProto)\n    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);\n  if (null != this.host && this.host.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);  \n  if (null != this.Port)\n    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);\n  if (null != this.multicastInterface && this.multicastInterface.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);\n  if (null !=  this.multicastTTL)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  encoder.writeElementClose();         \n};\n\nFaceInstance.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.FaceInstance;\n};\n\n\n},{"./publisher-public-key-digest.js":41,"./util/ndn-protoco-id-tags.js":87}],104:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like TlvWireFormat.\n * @constructor\n */\nvar WireFormat = function WireFormat() {\n};\n\nexports.WireFormat = WireFormat;\n\n/**\n * Encode interest and return the encoding.  Your derived class should override.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeInterest = function(interest) \n{\n  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as an interest and set the fields of the interest object. \n * Your derived class should override.\n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Encode data and return the encoding and signed offsets. Your derived class \n * should override.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeData = function(data) \n{\n  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Decode input as a data packet, set the fields in the data object, and return \n * the signed offsets.  Your derived class should override.\n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeData = function(data, input) \n{\n  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * Set the static default WireFormat used by default encoding and decoding \n * methods.\n * @param wireFormat {a subclass of WireFormat} An object of a subclass of \n * WireFormat.\n */\nWireFormat.setDefaultWireFormat = function(wireFormat)\n{\n  WireFormat.defaultWireFormat = wireFormat;\n};\n\n/**\n * Return the default WireFormat used by default encoding and decoding methods \n * which was set with setDefaultWireFormat.\n * @returns {a subclass of WireFormat} The WireFormat object.\n */\nWireFormat.getDefaultWireFormat = function()\n{\n  return WireFormat.defaultWireFormat;\n};\n\n// Invoke TlvWireFormat to set the default format.\n// Since tlv-wire-format.js includes this file, put this at the bottom \n// to avoid problems with cycles of require.\nvar TlvWireFormat = require(\'./tlv-wire-format.js\').TlvWireFormat;\n\n})()\n},{"../buffer.js":116,"./tlv-wire-format.js":106}],105:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar Blob = require(\'../util/blob.js\').Blob;\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Name = require(\'../name.js\').Name;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar Signature = require(\'../signature.js\').Signature;\nvar MetaInfo = require(\'../meta-info.js\').MetaInfo;\nvar PublisherPublicKeyDigest = require(\'../publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\n\n/**\n * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.\n * @constructor\n */\nvar BinaryXmlWireFormat = function BinaryXmlWireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nexports.BinaryXmlWireFormat = BinaryXmlWireFormat;\n\n// Default object.\nBinaryXmlWireFormat.instance = null;\n\n/**\n * Encode interest as Binary XML and return the encoding.\n * @param {Interest} interest The Interest to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nBinaryXmlWireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new BinaryXMLEncoder();\n  BinaryXmlWireFormat.encodeInterest(interest, encoder);  \n  return new Blob(encoder.getReducedOstream(), false);  \n};\n\n/**\n * Decode input as a Binary XML interest and set the fields of the interest object. \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nBinaryXmlWireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeInterest(interest, decoder);\n};\n\n/**\n * Encode data as Binary XML and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nBinaryXmlWireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new BinaryXMLEncoder(1500);\n  var result = BinaryXmlWireFormat.encodeData(data, encoder);\n  result.encoding = new Blob(encoder.getReducedOstream(), false);\n  return result;\n};\n\n/**\n * @deprecated Use encodeData(data).\n */\nBinaryXmlWireFormat.prototype.encodeContentObject = function(data)\n{\n  return this.encodeData(data);\n};\n\n/**\n * Decode input as a Binary XML data packet, set the fields in the data object, and return \n * the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new BinaryXMLDecoder(input);\n  return BinaryXmlWireFormat.decodeData(data, decoder);\n};\n\n/**\n * @deprecated Use decodeData(data, input).\n */\nBinaryXmlWireFormat.prototype.decodeContentObject = function(data, input) \n{\n  this.decodeData(data, input);\n};\n\n/**\n * Get a singleton instance of a BinaryXmlWireFormat.  Assuming that the default \n * wire format was set with \n * WireFormat.setDefaultWireFormat(BinaryXmlWireFormat.get()), you can check if \n * this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == BinaryXmlWireFormat.get().\n * @returns {BinaryXmlWireFormat} The singleton instance.\n */\nBinaryXmlWireFormat.get = function()\n{\n  if (BinaryXmlWireFormat.instance === null)\n    BinaryXmlWireFormat.instance = new BinaryXmlWireFormat();\n  return BinaryXmlWireFormat.instance;\n};\n\n/**\n * Encode the interest by calling the operations on the encoder.\n * @param {Interest} interest\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeInterest = function(interest, encoder) \n{\n  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);\n    \n  interest.name.to_ndnb(encoder);\n  \n  if (null != interest.minSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);  \n\n  if (null != interest.maxSuffixComponents) \n    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);\n\n  if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && \n      interest.getKeyLocator().getKeyData() != null &&\n      interest.getKeyLocator().getKeyData().length > 0)\n    // There is a KEY_LOCATOR_DIGEST. Use this instead of the publisherPublicKeyDigest.\n    encoder.writeDTagElement\n      (NDNProtocolDTags.PublisherPublicKeyDigest, \n       interest.getKeyLocator().getKeyData());\n  else {\n    if (null != interest.publisherPublicKeyDigest)\n      interest.publisherPublicKeyDigest.to_ndnb(encoder);\n  }\n    \n  if (null != interest.exclude)\n    interest.exclude.to_ndnb(encoder);\n    \n  if (null != interest.childSelector) \n    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);\n\n  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null) \n    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);\n    \n  if (null != interest.scope) \n    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);\n    \n  if (null != interest.interestLifetime) \n    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime, \n                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));\n    \n  if (null != interest.nonce)\n    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);\n    \n  encoder.writeElementClose();\n};\n\n/**\n * Use the decoder to place the result in interest.\n * @param {Interest} interest\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeInterest = function(interest, decoder) \n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name = new Name();\n  interest.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))\n    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);\n  else\n    interest.minSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents)) \n    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);\n  else\n    interest.maxSuffixComponents = null;\n      \n  // Initially clear the keyLocator.\n  interest.getKeyLocator().clear();\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    interest.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  else\n    interest.publisherPublicKeyDigest = null;\n  if (interest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest != null &&\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest.length > 0) {\n    // We keep the deprecated publisherPublicKeyDigest for backwards \n    //   compatibility.  Also set the key locator.\n    interest.getKeyLocator().setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    interest.getKeyLocator().setKeyData\n      (interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {\n    interest.exclude = new Exclude();\n    interest.exclude.from_ndnb(decoder);\n  }\n  else\n    interest.exclude = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))\n    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);\n  else\n    interest.childSelector = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))\n    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);\n  else\n    interest.answerOriginKind = null;\n    \n  if (decoder.peekDTag(NDNProtocolDTags.Scope))\n    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);\n  else\n    interest.scope = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))\n    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt\n               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;\n  else\n    interest.interestLifetime = null;              \n    \n  if (decoder.peekDTag(NDNProtocolDTags.Nonce))\n    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);\n  else\n    interest.nonce = null;\n    \n  decoder.readElementClose();\n};\n\n/**\n * Encode the data by calling the operations on the encoder.\n * @param {Data} data\n * @param {BinaryXMLEncoder} encoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.encodeData = function(data, encoder)  \n{\n  //TODO verify name, MetaInfo and Signature is present\n  encoder.writeElementStartDTag(data.getElementLabel());\n\n  if (null != data.signature) \n    data.signature.to_ndnb(encoder);\n    \n  var signedPortionBeginOffset = encoder.offset;\n\n  if (null != data.name) \n    data.name.to_ndnb(encoder);\n  \n  if (null != data.signedInfo) \n    // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n    //   the key locator from the MetaInfo to the Signauture object.\n    data.signedInfo.to_ndnb(encoder, data.getSignatureOrMetaInfoKeyLocator());\n\n  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);\n  \n  var signedPortionEndOffset = encoder.offset;\n  \n  encoder.writeElementClose();\n  \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Use the decoder to place the result in data.\n * @param {Data} data\n * @param {BinaryXMLDecoder} decoder\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nBinaryXmlWireFormat.decodeData = function(data, decoder) \n{\n  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT\n  decoder.readElementStartDTag(data.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {\n    data.signature = new Signature();\n    data.signature.from_ndnb(decoder);\n  }\n  else\n    data.signature = null;\n    \n  var signedPortionBeginOffset = decoder.offset;\n\n  data.name = new Name();\n  data.name.from_ndnb(decoder);\n    \n  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {\n    data.signedInfo = new MetaInfo();\n    data.signedInfo.from_ndnb(decoder);\n    if (data.signedInfo.locator != null && data.getSignature() != null)\n      // Copy the key locator pointer to the Signature object for the transition \n      //   of moving the key locator from the MetaInfo to the Signature object.\n      data.getSignature().keyLocator = data.signedInfo.locator;\n  }\n  else\n    data.signedInfo = null;\n\n  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);\n    \n  var signedPortionEndOffset = decoder.offset;\n    \n  decoder.readElementClose();\n    \n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n})()\n},{"../exclude.js":98,"../key-locator.js":102,"../meta-info.js":100,"../name.js":95,"../publisher-public-key-digest.js":103,"../signature.js":141,"../util/blob.js":111,"../util/ndn-protoco-id-tags.js":137,"./binary-xml-decoder.js":135,"./binary-xml-encoder.js":136,"./data-utils.js":109,"./wire-format.js":104}],106:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Tlv0_1a2WireFormat = require(\'./tlv-0_1a2-wire-format.js\').Tlv0_1a2WireFormat;\n\n/**\n * A TlvWireFormat extends Tlv0_1a2WireFormat to override its methods to \n * implement encoding and decoding using the preferred implementation of NDN-TLV.\n * @constructor\n */\nvar TlvWireFormat = function TlvWireFormat() \n{\n  // Inherit from Tlv0_1a2WireFormat.\n  Tlv0_1a2WireFormat.call(this);\n};\n\nTlvWireFormat.prototype = new Tlv0_1a2WireFormat();\nTlvWireFormat.prototype.name = "TlvWireFormat";\n\nexports.TlvWireFormat = TlvWireFormat;\n\n// Default object.\nTlvWireFormat.instance = null;\n\n/**\n * Get a singleton instance of a TlvWireFormat.  Assuming that the default \n * wire format was set with WireFormat.setDefaultWireFormat(TlvWireFormat.get()), \n * you can check if this is the default wire encoding with\n * if WireFormat.getDefaultWireFormat() == TlvWireFormat.get().\n * @returns {TlvWireFormat} The singleton instance.\n */\nTlvWireFormat.get = function()\n{\n  if (TlvWireFormat.instance === null)\n    TlvWireFormat.instance = new TlvWireFormat();\n  return TlvWireFormat.instance;\n};\n\n// On loading this module, make this the default wire format.\n// This module will be loaded because WireFormat loads it.\nWireFormat.setDefaultWireFormat(TlvWireFormat.get());\n\n},{"./tlv-0_1a2-wire-format.js":148,"./wire-format.js":104}],109:[function(require,module,exports){\n(function(){/**\n * This class contains utilities to help parse the data\n *\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n\n/**\n * A DataUtils has static methods for converting data.\n * @constructor\n */\n\n\nvar DataUtils = function()\n{\n};\n\nexports.DataUtils = new DataUtils();\n\n/*\n * NOTE THIS IS CURRENTLY NOT BEING USED\n *\n */\n\nDataUtils.prototype.keyStr = "ABCDEFGHIJKLMNOP" +\n                   "QRSTUVWXYZabcdef" +\n                   "ghijklmnopqrstuv" +\n                   "wxyz0123456789+/" +\n                   "=";\n\n/**\n * Raw String to Base 64\n */\nDataUtils.prototype.stringtoBase64 = function stringtoBase64(input)\n{\n   //input = escape(input);\n   var output = "";\n   var chr1, chr2, chr3 = "";\n   var enc1, enc2, enc3, enc4 = "";\n   var i = 0;\n\n   do {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2))\n       enc3 = enc4 = 64;\n    else if (isNaN(chr3))\n       enc4 = 64;\n\n    output = output +\n       DataUtils.keyStr.charAt(enc1) +\n       DataUtils.keyStr.charAt(enc2) +\n       DataUtils.keyStr.charAt(enc3) +\n       DataUtils.keyStr.charAt(enc4);\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n   } while (i < input.length);\n\n   return output;\n};\n\n/**\n * Base 64 to Raw String\n */\nDataUtils.prototype.base64toString = function base64toString(input)\n{\n  var output = "";\n  var chr1, chr2, chr3 = "";\n  var enc1, enc2, enc3, enc4 = "";\n  var i = 0;\n\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n  /* Test for invalid characters. */\n  if (base64test.exec(input)) {\n    alert("There were invalid base64 characters in the input text.\\n" +\n          "Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\\n" +\n          "Expect errors in decoding.");\n  }\n\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");\n\n  do {\n    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 != 64)\n      output = output + String.fromCharCode(chr2);\n\n    if (enc4 != 64)\n      output = output + String.fromCharCode(chr3);\n\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n  } while (i < input.length);\n\n  return output;\n};\n\n/**\n * customBuf to Hex String\n */\nDataUtils.prototype.toHex = function(buffer)\n{\n  return buffer.toString(\'hex\');\n};\n\n/**\n * Raw string to hex string.\n */\nDataUtils.prototype.stringToHex = function(args)\n{\n  var ret = "";\n  for (var i = 0; i < args.length; ++i) {\n    var value = args.charCodeAt(i);\n    ret += (value < 16 ? "0" : "") + value.toString(16);\n  }\n  return ret;\n};\n\n/**\n * customBuf to raw string.\n */\nDataUtils.prototype.toString = function(buffer)\n{\n  return buffer.toString(\'binary\');\n};\n\n/**\n * Hex String to customBuf.\n */\nDataUtils.prototype.toNumbers = function(str)\n{\n  return new customBuf(str, \'hex\');\n};\n\n/**\n * Hex String to raw string.\n */\nDataUtils.prototype.hexToRawString = function(str)\n{\n  if (typeof str ==\'string\') {\n  var ret = "";\n  str.replace(/(..)/g, function(s) {\n    ret += String.fromCharCode(parseInt(s, 16));\n  });\n  return ret;\n  }\n};\n\n/**\n * Raw String to customBuf.\n */\nDataUtils.prototype.toNumbersFromString = function(str)\n{\n  return new customBuf(str, \'binary\');\n};\n\n/**\n * Encode str as utf8 and return as customBuf.\n * If value is a string, then interpret it as a raw string and convert to\n * a Buffer. Otherwise assume it is a Buffer or array type and just return it.\n * @param {string|any} value\n * @returns {Buffer}\n */\nDataUtils.prototype.toNumbersIfString = function(value)\n{\n  if (typeof value === \'string\')\n    return new customBuf(value, \'binary\');\n  else\n    return value;\n};\n\n/**\n * Encode str as utf8 and return as Buffer.\n */\nDataUtils.prototype.stringToUtf8Array = function(str)\n{\n  return new customBuf(str, \'utf8\');\n};\n\n/**\n * arrays is an array of customBuf. Return a new customBuf which is the concatenation of all.\n */\nDataUtils.prototype.concatArrays = function(arrays)\n{\n  return customBuf.concat(arrays);\n};\n\n// TODO: Take customBuf and use TextDecoder when available.\nDataUtils.prototype.decodeUtf8 = function(utftext)\n{\n  var string = "";\n  var i = 0;\n  var c = 0;\n    var c1 = 0;\n    var c2 = 0;\n\n  while (i < utftext.length) {\n    c = utftext.charCodeAt(i);\n\n    if (c < 128) {\n      string += String.fromCharCode(c);\n      i++;\n    }\n    else if (c > 191 && c < 224) {\n      c2 = utftext.charCodeAt(i + 1);\n      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n      i += 2;\n    }\n    else {\n      c2 = utftext.charCodeAt(i+1);\n      var c3 = utftext.charCodeAt(i+2);\n      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n      i += 3;\n    }\n  }\n\n  return string;\n};\n\n/**\n * Return true if a1 and a2 are the same length with equal elements.\n */\nDataUtils.prototype.arraysEqual = function(a1, a2)\n{\n  // A simple sanity check that it is an array.\n  if (!a1.slice)\n    throw new Error("DataUtils.arraysEqual: a1 is not an array");\n  if (!a2.slice)\n    throw new Error("DataUtils.arraysEqual: a2 is not an array");\n\n  if (a1.length != a2.length)\n    return false;\n\n  for (var i = 0; i < a1.length; ++i) {\n    if (a1[i] != a2[i])\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Convert the big endian customBuf to an unsigned int.\n * Don\'t check for overflow.\n */\nDataUtils.prototype.bigEndianToUnsignedInt = function(bytes)\n{\n  var result = 0;\n  for (var i = 0; i < bytes.length; ++i) {\n    result <<= 8;\n    result += bytes[i];\n  }\n  return result;\n};\n\n/**\n * Convert the int value to a new big endian customBuf and return.\n * If value is 0 or negative, return new customBuf(0).\n */\nDataUtils.prototype.nonNegativeIntToBigEndian = function(value)\n{\n  value = Math.round(value);\n  if (value <= 0)\n    return new customBuf(0);\n\n  // Assume value is not over 64 bits.\n  var size = 8;\n  var result = new customBuf(size);\n  var i = 0;\n  while (value != 0) {\n    ++i;\n    result[size - i] = value & 0xff;\n    value >>= 8;\n  }\n  return result.slice(size - i, size);\n};\n\n/**\n * Modify array to randomly shuffle the elements.\n */\nDataUtils.prototype.shuffle = function(array)\n{\n  for (var i = array.length - 1; i >= 1; --i) {\n    // j is from 0 to i.\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n};\n\n})()\n},{"../buffer.js":116}],110:[function(require,module,exports){\n(function(){/**\n * This file contains utilities to help encode and decode NDN objects.\n * Copyright (C) 2013-2014 Regents of the University of California.\n * author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLEncoder = require(\'./binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar Key = require(\'../key.js\').Key;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Interest = require(\'../interest.js\').Interest;\nvar Data = require(\'../data.js\').Data;\nvar FaceInstance = require(\'../face-instance.js\').FaceInstance;\nvar ForwardingEntry = require(\'../forwarding-entry.js\').ForwardingEntry;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * An EncodingUtils has static methods for encoding data.\n * @constructor\n */\nvar EncodingUtils = function EncodingUtils() \n{\n};\n\nexports.EncodingUtils = EncodingUtils;\n\nEncodingUtils.encodeToHexInterest = function(interest, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(interest.wireEncode(wireFormat).buf());\n};\n\nEncodingUtils.encodeToHexData = function(data, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  return DataUtils.toHex(data.wireEncode(wireFormat).buf());\n};\n\n/**\n * @deprecated Use EncodingUtils.encodeToHexData(data).\n */\nEncodingUtils.encodeToHexContentObject = function(data, wireFormat) \n{\n  return EncodingUtils.encodeToHexData(data, wireFormat);\n}\n\nEncodingUtils.encodeForwardingEntry = function(data) \n{\n  var enc = new BinaryXMLEncoder();\n  data.to_ndnb(enc);\n  var bytes = enc.getReducedOstream();\n\n  return bytes;\n};\n\nEncodingUtils.decodeHexFaceInstance = function(result) \n{  \n  var numbers = DataUtils.toNumbers(result); \n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODING HEX FACE INSTANCE  \\n\'+numbers);\n\n  var faceInstance = new FaceInstance();\n  faceInstance.from_ndnb(decoder);\n  \n  return faceInstance;\n};\n\nEncodingUtils.decodeHexInterest = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var interest = new Interest();\n  interest.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return interest;\n};\n\nEncodingUtils.decodeHexData = function(input, wireFormat) \n{\n  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());\n  var data = new Data();\n  data.wireDecode(DataUtils.toNumbers(input), wireFormat);\n  return data;\n};\n\n/**\n * @deprecated Use EncodingUtils.decodeHexData(input).\n */\nEncodingUtils.decodeHexContentObject = function(input, wireFormat) \n{\n  return EncodingUtils.decodeHexData(input, wireFormat);\n}\n\nEncodingUtils.decodeHexForwardingEntry = function(result) \n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n  \n  if (LOG > 3) console.log(\'DECODED HEX FORWARDING ENTRY \\n\'+numbers);\n  \n  var forwardingEntry = new ForwardingEntry();\n  forwardingEntry.from_ndnb(decoder);\n  return forwardingEntry;\n};\n\n/**\n * Decode the customBuf array which holds SubjectPublicKeyInfo and return an RSAKey.\n */\nEncodingUtils.decodeSubjectPublicKeyInfo = function(array) \n{\n  var hex = DataUtils.toHex(array).toLowerCase();\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));\n  var rsaKey = new RSAKey();\n  rsaKey.setPublic(a[0], a[1]);\n  return rsaKey;\n}\n\n/**\n * Return a user friendly HTML string with the contents of data.\n * This also outputs to console.log.\n */\nEncodingUtils.dataToHtml = function(/* Data */ data) \n{\n  var output ="";\n      \n  if (data == -1)\n    output+= "NO CONTENT FOUND"\n  else if (data == -2)\n    output+= "CONTENT NAME IS EMPTY"\n  else {\n    if (data.name != null && data.name.components != null) {\n      output+= "NAME: " + data.name.toUri();\n        \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.digestAlgorithm != null) {\n      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.witness != null) {\n      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.signature != null) {\n      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {\n      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);\n      \n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.timestamp != null) {\n      var d = new Date();\n      d.setTime(data.signedInfo.timestamp.msec);\n      \n      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];\n      \n      output += "TimeStamp: "+d;\n      output+= "<br />";\n      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;\n      \n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {\n      output += "keyLocator: ";\n      if (data.signedInfo.locator.type == KeyLocatorType.KEY)\n        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEY_LOCATOR_DIGEST)\n        output += "KeyLocatorDigest: " + DataUtils.toHex(data.signedInfo.locator.getKeyData()).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)\n        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)\n        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";\n      else\n        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";      \n    }\n  }\n\n  return output;\n};\n\n/**\n * @deprecated Use return EncodingUtils.dataToHtml(data).\n */\nEncodingUtils.contentObjectToHtml = function(data) \n{\n  return EncodingUtils.dataToHtml(data);\n}\n\n//\n// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.\n//\n\nvar encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }\nvar encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }\nvar encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }\nvar decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }\nvar decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }\nvar decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }\nvar decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }\nvar decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }\nvar contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }\n\n/**\n * @deprecated Use interest.wireEncode().\n */\nfunction encodeToBinaryInterest(interest) { return interest.wireEncode().buf(); }\n/**\n * @deprecated Use data.wireEncode().\n */\nfunction encodeToBinaryContentObject(data) { return data.wireEncode().buf(); }\n\n})()\n},{"../data.js":99,"../face-instance.js":149,"../forwarding-entry.js":134,"../interest.js":97,"../key-locator.js":102,"../key.js":101,"../log.js":139,"./binary-xml-decoder.js":135,"./binary-xml-encoder.js":136,"./data-utils.js":109,"./wire-format.js":104}],111:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * A Blob holds an immutable byte array implemented as a customBuf.  This should be \n * treated like a string which is a pointer to an immutable string. (It is OK to \n * pass a pointer to the string because the new owner can\u2019t change the bytes of \n * the string.)  Blob does not inherit from customBuf. Instead you must call buf() \n * to get the byte array which reminds you that you should not change the \n * contents.  Also remember that buf() can return null.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {boolean} copy (optional) (optional) If true, copy the contents of \n * value into a new customBuf.  If false, just use the existing value without \n * copying. If omitted, then copy the contents (unless value is already a Blob).\n * IMPORTANT: If copy is false, if you keep a pointer to the value then you must\n * treat the value as immutable and promise not to change it.\n */\nvar Blob = function Blob(value, copy) \n{\n  if (copy == null)\n    copy = true;\n  \n  if (value == null)\n    this.buffer = null;\n  else if (typeof value === \'object\' && value instanceof Blob)\n    // Use the existing buffer.  Don\'t need to check for copy.\n    this.buffer = value.buffer;\n  else {\n    if (typeof value === \'string\')\n      // Convert from a string to utf-8 byte encoding.\n      this.buffer = new customBuf(value, \'utf8\');\n    else {\n      if (copy)\n        // We are copying, so just make another customBuf.\n        this.buffer = new customBuf(value);\n      else {\n        if (typeof value === \'object\' && value instanceof customBuf)\n          // We can use as-is.\n          this.buffer = value;\n        else\n          // We need a customBuf, so copy.\n          this.buffer = new customBuf(value);\n      }\n    }\n  }\n};\n\nexports.Blob = Blob;\n\n/**\n * Return the length of the immutable byte array.\n * @returns {number} The length of the array.  If buf() is null, return 0.\n */\nBlob.prototype.size = function()\n{\n  if (this.buffer != null)\n    return this.buffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return the immutable byte array.  DO NOT change the contents of the customBuf.  \n * If you need to change it, make a copy.\n * @returns {Buffer} The customBuf holding the immutable byte array, or null.\n */\nBlob.prototype.buf = function()\n{\n  return this.buffer;\n};\n\n/**\n * Return true if the array is null, otherwise false.\n * @returns {boolean} True if the array is null.\n */\nBlob.prototype.isNull = function()\n{\n  return this.buffer == null;\n};\n\n/**\n * Return the hex representation of the bytes in the byte array.\n * @returns {string} The hex string.\n */\nBlob.prototype.toHex = function() \n{  \n  if (this.buffer == null)\n    return "";\n  else\n    return this.buffer.toString(\'hex\');\n};\n\n})()\n},{"../buffer.js":116}],112:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar BinaryXMLDecoder = require(\'../encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar Name = require(\'../name.js\').Name;\n\n/**\n * Create a context for getting the response from the name enumeration command, as neede by getComponents.\n * (To do name enumeration, call the static method NameEnumeration.getComponents.)\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nvar NameEnumeration = function NameEnumeration(face, onComponents) \n{\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n  \n  var self = this;\n  this.onData = function(interest, data) { self.processData(data); };\n  this.onTimeout = function(interest) { self.processTimeout(); };\n};\n\nexports.NameEnumeration = NameEnumeration;\n\n/**\n * Use the name enumeration protocol to get the child components of the name prefix.\n * @param {Face} face The Face object for using expressInterest.\n * @param {Name} name The name prefix for finding the child components.\n * @param {function} onComponents On getting the response, this calls onComponents(components) where\n * components is an array of customBuf name components.  If there is no response, this calls onComponents(null). \n */\nNameEnumeration.getComponents = function(face, prefix, onComponents)\n{\n  var command = new Name(prefix);\n  // Add %C1.E.be\n  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])\n  \n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n/**\n * Parse the response from the name enumeration command and call this.onComponents.\n * @param {Data} data\n */\nNameEnumeration.prototype.processData = function(data) \n{\n  try {\n    if (!NameEnumeration.endsWithSegmentNumber(data.name))\n      // We don\'t expect a name without a segment number.  Treat it as a bad packet.\n      this.onComponents(null);\n    else {\n      var segmentNumber = DataUtils.bigEndianToUnsignedInt\n          (data.name.get(data.name.size() - 1).getValue());\n\n      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.\n      var expectedSegmentNumber = this.contentParts.length;\n      if (segmentNumber != expectedSegmentNumber)\n        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);\n      else {\n        // Save the content and check if we are finished.\n        this.contentParts.push(data.content);\n\n        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);\n          if (segmentNumber == finalSegmentNumber) {\n            // We are finished.  Parse and return the result.\n            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));\n            return;\n          }\n        }\n\n        // Fetch the next segment.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);\n      }\n    }\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Just call onComponents(null).\n */\nNameEnumeration.prototype.processTimeout = function()\n{\n  try {\n    this.onComponents(null);\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.\n * @param {Uint8Array} content The content to parse.\n * @returns {Array<Buffer>} The array of components.\n */\nNameEnumeration.parseComponents = function(content)\n{\n  var components = [];\n  var decoder = new BinaryXMLDecoder(content);\n  \n  decoder.readElementStartDTag(NDNProtocolDTags.Collection);\n \n  while (decoder.peekDTag(NDNProtocolDTags.Link)) {\n    decoder.readElementStartDTag(NDNProtocolDTags.Link);    \n    decoder.readElementStartDTag(NDNProtocolDTags.Name);\n    \n    components.push(new customBuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));\n    \n    decoder.readElementClose();  \n    decoder.readElementClose();  \n  }\n\n  decoder.readElementClose();\n  return components;\n};\n\n/**\n * Check if the last component in the name is a segment number.\n * TODO: Move to Name class.\n * @param {Name} name\n * @returns {Boolean} True if the name ends with a segment number, otherwise false.\n */\nNameEnumeration.endsWithSegmentNumber = function(name) {\n  return name.components != null && name.size() >= 1 &&\n         name.get(name.size() - 1).getValue().length >= 1 &&\n         name.get(name.size() - 1).getValue()[0] == 0;\n};\n\n})(require("__browserify_buffer").Buffer)\n},{"../buffer.js":116,"../encoding/binary-xml-decoder.js":135,"../encoding/data-utils.js":109,"../name.js":95,"./ndn-protoco-id-tags.js":137,"__browserify_buffer":73}],113:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents NDNTime Objects\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * @constructor\n */\nvar NDNTime = function NDNTime(input) \n{\n  this.NANOS_MAX = 999877929;\n  \n  if (typeof input ==\'number\')\n    this.msec = input;\n  else {\n    if (LOG > 1) console.log(\'UNRECOGNIZED TYPE FOR TIME\');\n  }\n};\n\nexports.NDNTime = NDNTime;\n\nNDNTime.prototype.getJavascriptDate = function() \n{\n  var d = new Date();\n  d.setTime(this.msec);\n  return d\n};  \n\n},{"../log.js":139}],114:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar Key = require(\'../key.js\').Key;\n\n/**\n * @constructor\n */\nvar KeyManager = function KeyManager()\n{\n  this.certificate = \n  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +\n  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +\n  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +\n  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +\n  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +\n  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +\n  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +\n  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +\n  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";\n\n  // Public Key\n    this.publicKey = \n  "-----BEGIN PUBLIC KEY-----\\n" +\n  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\\n" +\n  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\\n" +\n  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\\n" +\n  "WFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "-----END PUBLIC KEY-----";\n  // Private Key\n    this.privateKey = \n  "-----BEGIN RSA PRIVATE KEY-----\\n" +\n  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\\n" +\n  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\\n" +\n  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\\n" +\n  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\\n" +\n  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\\n" +\n  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\\n" +\n  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\\n" +\n  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\\n" +\n  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\\n" +\n  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\\n" +\n  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\\n" +\n  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\\n" +\n  "-----END RSA PRIVATE KEY-----";\n  \n  this.key = null;\n};\n\n/**\n * Return a Key object for the keys in this KeyManager.  This creates the Key on the first\n * call and returns a cached copy after that.\n * @returns {Key}\n */\nKeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n  \n  return this.key;\n}\n\nvar globalKeyManager = globalKeyManager || new KeyManager();\nexports.globalKeyManager = globalKeyManager;\n\n},{"../key.js":101}],115:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar BinaryXMLStructureDecoder = require(\'./binary-xml-structure-decoder.js\').BinaryXMLStructureDecoder;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvStructureDecoder = require(\'./tlv/tlv-structure-decoder.js\').TlvStructureDecoder;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n/**\n * A ElementReader lets you call onReceivedData multiple times which uses a\n * BinaryXMLStructureDecoder or TlvStructureDecoder to detect the end of a\n * binary XML or TLV element and calls elementListener.onReceivedElement(element)\n * with the element.  This handles the case where a single call to\n * onReceivedData may contain multiple elements.\n * @constructor\n * @param {{onReceivedElement:function}} elementListener\n */\nvar ElementReader = function ElementReader(elementListener)\n{\n  this.elementListener = elementListener;\n  this.dataParts = [];\n  this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n  this.tlvStructureDecoder = new TlvStructureDecoder();\n  this.useTlv = null;\n};\n\nexports.ElementReader = ElementReader;\n\nElementReader.prototype.onReceivedData = function(/* customBuf */ data)\n{\n  // Process multiple objects in the data.\n  while (true) {\n    if (this.dataParts.length == 0) {\n      // This is the beginning of an element.  Check whether it is binaryXML or TLV.\n      if (data.length <= 0)\n        // Wait for more data.\n        return;\n\n      // The type codes for TLV Interest and Data packets are chosen to not\n      //   conflict with the first byte of a binary XML packet, so we can\n      //   just look at the first byte.\n      if (data[0] == Tlv.Interest || data[0] == Tlv.Data || data[0] == 0x80)\n        this.useTlv = true;\n      else\n        // Binary XML.\n        this.useTlv = false;\n    }\n\n    var gotElementEnd;\n    var offset;\n    if (this.useTlv) {\n      // Scan the input to check if a whole TLV object has been read.\n      this.tlvStructureDecoder.seek(0);\n      gotElementEnd = this.tlvStructureDecoder.findElementEnd(data);\n      offset = this.tlvStructureDecoder.getOffset();\n    }\n    else {\n      // Scan the input to check if a whole Binary XML object has been read.\n      this.binaryXmlStructureDecoder.seek(0);\n      gotElementEnd = this.binaryXmlStructureDecoder.findElementEnd(data);\n      offset = this.binaryXmlStructureDecoder.offset;\n    }\n\n    if (gotElementEnd) {\n      // Got the remainder of an object.  Report to the caller.\n      this.dataParts.push(data.slice(0, offset));\n      var element = DataUtils.concatArrays(this.dataParts);\n      this.dataParts = [];\n      try {\n        this.elementListener.onReceivedElement(element);\n      } catch (ex) {\n          console.log("ElementReader: ignoring exception from onReceivedElement: " , ex);\n      }\n\n      // Need to read a new object.\n      data = data.slice(offset, data.length);\n      this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();\n      this.tlvStructureDecoder = new TlvStructureDecoder();\n      if (data.length == 0)\n        // No more data in the packet.\n        return;\n\n      // else loop back to decode.\n    }\n    else {\n      // Save for a later call to concatArrays so that we only copy data once.\n      this.dataParts.push(data);\n      if (LOG > 3) console.log(\'Incomplete packet received. Length \' + data.length + \'. Wait for more input.\');\n        return;\n    }\n  }\n};\n\n})()\n},{"../buffer.js":116,"../log.js":139,"./binary-xml-structure-decoder.js":150,"./data-utils.js":109,"./tlv/tlv-structure-decoder.js":151,"./tlv/tlv.js":108}],132:[function(require,module,exports){\n(function(){var Buffer = require(\'buffer\').Buffer;\nvar intSize = 4;\nvar zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);\nvar chrsz = 8;\n\nfunction toArray(buf, bigEndian) {\n  if ((buf.length % intSize) !== 0) {\n    var len = buf.length + (intSize - (buf.length % intSize));\n    buf = Buffer.concat([buf, zeroBuffer], len);\n  }\n\n  var arr = [];\n  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n  for (var i = 0; i < buf.length; i += intSize) {\n    arr.push(fn.call(buf, i));\n  }\n  return arr;\n}\n\nfunction toBuffer(arr, size, bigEndian) {\n  var buf = new Buffer(size);\n  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n  for (var i = 0; i < arr.length; i++) {\n    fn.call(buf, arr[i], i * 4, true);\n  }\n  return buf;\n}\n\nfunction hash(buf, fn, hashSize, bigEndian) {\n  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);\n  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);\n  return toBuffer(arr, hashSize, bigEndian);\n}\n\nmodule.exports = { hash: hash };\n\n})()\n},{"buffer":63}],121:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar crypto = require(\'../crypto.js\');\nvar Blob = require(\'../util/blob.js\').Blob;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvEncoder = require(\'./tlv/tlv-encoder.js\').TlvEncoder;\nvar TlvDecoder = require(\'./tlv/tlv-decoder.js\').TlvDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar ContentType = require(\'../meta-info.js\').ContentType;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Signature = require(\'../signature.js\').Signature;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\n\n/**\n * A Tlv0_1a2WireFormat implements the WireFormat interface for encoding and \n * decoding with the NDN-TLV wire format, version 0.1a2\n * @constructor\n */\nvar Tlv0_1a2WireFormat = function Tlv0_1a2WireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nTlv0_1a2WireFormat.prototype = new WireFormat();\nTlv0_1a2WireFormat.prototype.name = "Tlv0_1a2WireFormat";\n\nexports.Tlv0_1a2WireFormat = Tlv0_1a2WireFormat;\n\n// Default object.\nTlv0_1a2WireFormat.instance = null;\n\n/**\n * Encode the interest using NDN-TLV and return a customBuf.\n * @param {Interest} interest The Interest object to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nTlv0_1a2WireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new TlvEncoder();\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.InterestLifetime, interest.getInterestLifetimeMilliseconds());\n  encoder.writeOptionalNonNegativeIntegerTlv(Tlv.Scope, interest.getScope());\n  \n  // Encode the Nonce as 4 bytes.\n  if (interest.getNonce() == null || interest.getNonce().length == 0)\n    // This is the most common case. Generate a nonce.\n    encoder.writeBlobTlv(Tlv.Nonce, require("../crypto.js").randomBytes(4));\n  else if (interest.getNonce().length < 4) {\n    var nonce = customBuf(4);\n    // Copy existing nonce bytes.\n    interest.getNonce().copy(nonce);\n\n    // Generate random bytes for remaining bytes in the nonce.\n    for (var i = interest.getNonce().length; i < 4; ++i)\n      nonce[i] = require("crypto").randomBytes(1)[0];\n\n    encoder.writeBlobTlv(Tlv.Nonce, nonce);\n  }\n  else if (interest.getNonce().length == 4)\n    // Use the nonce as-is.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce());\n  else\n    // Truncate.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce().slice(0, 4));\n  \n  Tlv0_1a2WireFormat.encodeSelectors(interest, encoder);\n  Tlv0_1a2WireFormat.encodeName(interest.getName(), encoder);\n  \n  encoder.writeTypeAndLength(Tlv.Interest, encoder.getLength() - saveLength);\n      \n  return new Blob(encoder.getOutput(), false);\n};\n\n/**\n * Decode input as an NDN-TLV interest and set the fields of the interest \n * object.  \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nTlv0_1a2WireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Interest);\n  Tlv0_1a2WireFormat.decodeName(interest.getName(), decoder);\n  if (decoder.peekType(Tlv.Selectors, endOffset))\n    Tlv0_1a2WireFormat.decodeSelectors(interest, decoder);\n  // Require a Nonce, but don\'t force it to be 4 bytes.\n  var nonce = decoder.readBlobTlv(Tlv.Nonce);\n  interest.setScope(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.Scope, endOffset));\n  interest.setInterestLifetimeMilliseconds\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.InterestLifetime, endOffset));\n\n  // Set the nonce last because setting other interest fields clears it.\n  interest.setNonce(nonce);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode data as NDN-TLV and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nTlv0_1a2WireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new TlvEncoder(1500);\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  encoder.writeBlobTlv(Tlv.SignatureValue, data.getSignature().getSignature());\n  var signedPortionEndOffsetFromBack = encoder.getLength();\n\n  // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n  //   the key locator from the MetaInfo to the Signauture object.\n  Tlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue\n    (data.getSignature(), encoder, data.getSignatureOrMetaInfoKeyLocator());\n  encoder.writeBlobTlv(Tlv.Content, data.getContent());\n  Tlv0_1a2WireFormat.encodeMetaInfo(data.getMetaInfo(), encoder);\n  Tlv0_1a2WireFormat.encodeName(data.getName(), encoder);\n  var signedPortionBeginOffsetFromBack = encoder.getLength();\n\n  encoder.writeTypeAndLength(Tlv.Data, encoder.getLength() - saveLength);\n  var signedPortionBeginOffset = \n    encoder.getLength() - signedPortionBeginOffsetFromBack;\n  var signedPortionEndOffset = encoder.getLength() - signedPortionEndOffsetFromBack;\n\n  return { encoding: new Blob(encoder.getOutput(), false),\n           signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Decode input as an NDN-TLV data packet, set the fields in the data object, \n * and return the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nTlv0_1a2WireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Data);\n  var signedPortionBeginOffset = decoder.getOffset();\n\n  Tlv0_1a2WireFormat.decodeName(data.getName(), decoder);\n  Tlv0_1a2WireFormat.decodeMetaInfo(data.getMetaInfo(), decoder);\n  data.setContent(decoder.readBlobTlv(Tlv.Content));\n  Tlv0_1a2WireFormat.decodeSignatureInfo(data, decoder);\n  if (data.getSignature() != null && \n      data.getSignature().getKeyLocator() != null && \n      data.getMetaInfo() != null)\n    // Copy the key locator pointer to the MetaInfo object for the transition of \n    //   moving the key locator from the MetaInfo to the Signature object.\n    data.getMetaInfo().locator = data.getSignature().getKeyLocator();\n\n  var signedPortionEndOffset = decoder.getOffset();\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  data.getSignature().setSignature(decoder.readBlobTlv(Tlv.SignatureValue));\n\n  decoder.finishNestedTlvs(endOffset);\n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Get a singleton instance of a Tlv1_0a2WireFormat.  To always use the\n * preferred version NDN-TLV, you should use TlvWireFormat.get().\n * @returns {Tlv0_1a2WireFormat} The singleton instance.\n */\nTlv0_1a2WireFormat.get = function()\n{\n  if (Tlv0_1a2WireFormat.instance === null)\n    Tlv0_1a2WireFormat.instance = new Tlv0_1a2WireFormat();\n  return Tlv0_1a2WireFormat.instance;\n};\n\nTlv0_1a2WireFormat.encodeName = function(name, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode the components backwards.\n  for (var i = name.size() - 1; i >= 0; --i)\n    encoder.writeBlobTlv(Tlv.NameComponent, name.get(i).getValue());\n\n  encoder.writeTypeAndLength(Tlv.Name, encoder.getLength() - saveLength);\n};\n        \nTlv0_1a2WireFormat.decodeName = function(name, decoder)\n{\n  name.clear();\n  \n  var endOffset = decoder.readNestedTlvsStart(Tlv.Name);      \n  while (decoder.getOffset() < endOffset)\n      name.append(decoder.readBlobTlv(Tlv.NameComponent));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the interest selectors.  If no selectors are written, do not output a \n * Selectors TLV.\n */\nTlv0_1a2WireFormat.encodeSelectors = function(interest, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (interest.getMustBeFresh())\n    encoder.writeTypeAndLength(Tlv.MustBeFresh, 0);\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.ChildSelector, interest.getChildSelector());\n  if (interest.getExclude().size() > 0)\n    Tlv0_1a2WireFormat.encodeExclude(interest.getExclude(), encoder);\n  \n  if (interest.getKeyLocator().getType() != null)\n    Tlv0_1a2WireFormat.encodeKeyLocator(interest.getKeyLocator(), encoder);\n  else {\n    // There is no keyLocator. If there is a publisherPublicKeyDigest, then \n    //   encode as KEY_LOCATOR_DIGEST. (When we remove the deprecated \n    //   publisherPublicKeyDigest, we don\'t need this.)\n    if (null != interest.publisherPublicKeyDigest) {\n      var savePublisherPublicKeyDigestLength = encoder.getLength();\n      encoder.writeBlobTlv\n        (Tlv.KeyLocatorDigest, \n         interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n      encoder.writeTypeAndLength\n        (Tlv.KeyLocator, encoder.getLength() - savePublisherPublicKeyDigestLength);\n    }\n  }\n  \n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MaxSuffixComponents, interest.getMaxSuffixComponents());\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MinSuffixComponents, interest.getMinSuffixComponents());\n\n  // Only output the type and length if values were written.\n  if (encoder.getLength() != saveLength)\n    encoder.writeTypeAndLength(Tlv.Selectors, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSelectors = function(interest, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Selectors);\n\n  interest.setMinSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MinSuffixComponents, endOffset));\n  interest.setMaxSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MaxSuffixComponents, endOffset));\n\n  // Initially set publisherPublicKeyDigest to none.\n  interest.publisherPublicKeyDigest = null;\n  if (decoder.peekType(Tlv.KeyLocator, endOffset)) {\n    Tlv0_1a2WireFormat.decodeKeyLocator(interest.getKeyLocator(), decoder);\n    if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST) {\n      // For backwards compatibility, also set the publisherPublicKeyDigest.\n      interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest =\n        interest.getKeyLocator().getKeyData();\n    }\n  }\n  else\n    interest.getKeyLocator().clear();\n\n  if (decoder.peekType(Tlv.Exclude, endOffset))\n    Tlv0_1a2WireFormat.decodeExclude(interest.getExclude(), decoder);\n  else\n    interest.getExclude().clear();\n\n  interest.setChildSelector(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ChildSelector, endOffset));\n  interest.setMustBeFresh(decoder.readBooleanTlv(Tlv.MustBeFresh, endOffset));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n  \nTlv0_1a2WireFormat.encodeExclude = function(exclude, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // TODO: Do we want to order the components (except for ANY)?\n  // Encode the entries backwards.\n  for (var i = exclude.size() - 1; i >= 0; --i) {\n    var entry = exclude.get(i);\n\n    if (entry == Exclude.ANY)\n      encoder.writeTypeAndLength(Tlv.Any, 0);\n    else\n      encoder.writeBlobTlv(Tlv.NameComponent, entry.getValue());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.Exclude, encoder.getLength() - saveLength);\n};\n  \nTlv0_1a2WireFormat.decodeExclude = function(exclude, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Exclude);\n\n  exclude.clear();\n  while (true) {\n    if (decoder.peekType(Tlv.NameComponent, endOffset))\n      exclude.appendComponent(decoder.readBlobTlv(Tlv.NameComponent));\n    else if (decoder.readBooleanTlv(Tlv.Any, endOffset))\n      exclude.appendAny();\n    else\n      // Else no more entries.\n      break;\n  }\n  \n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeKeyLocator = function(keyLocator, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (keyLocator.getType() != null) {\n    if (keyLocator.getType() == KeyLocatorType.KEYNAME)\n      Tlv0_1a2WireFormat.encodeName(keyLocator.getKeyName(), encoder);\n    else if (keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST &&\n             keyLocator.getKeyData().length > 0)\n      encoder.writeBlobTlv(Tlv.KeyLocatorDigest, keyLocator.getKeyData());\n    else\n      throw new Error("Unrecognized KeyLocatorType " + keyLocator.getType());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.KeyLocator, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeKeyLocator = function(keyLocator, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.KeyLocator);\n\n  keyLocator.clear();\n\n  if (decoder.getOffset() == endOffset)\n    // The KeyLocator is omitted, so leave the fields as none.\n    return;\n\n  if (decoder.peekType(Tlv.Name, endOffset)) {\n    // KeyLocator is a Name.\n    keyLocator.setType(KeyLocatorType.KEYNAME);\n    Tlv0_1a2WireFormat.decodeName(keyLocator.getKeyName(), decoder);\n  }\n  else if (decoder.peekType(Tlv.KeyLocatorDigest, endOffset)) {\n    // KeyLocator is a KeyLocatorDigest.\n    keyLocator.setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    keyLocator.setKeyData(decoder.readBlobTlv(Tlv.KeyLocatorDigest));\n  }\n  else\n    throw new DecodingException\n      ("decodeKeyLocator: Unrecognized key locator type");\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the signature object in TLV, using the given keyLocator instead of the\n * locator in this object.\n * @param {Signature} signature The Signature object to encode.\n * @param {TlvEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nTlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue = function\n  (signature, encoder, keyLocator)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  Tlv0_1a2WireFormat.encodeKeyLocator(keyLocator, encoder);\n  encoder.writeNonNegativeIntegerTlv\n    (Tlv.SignatureType, Tlv.SignatureType_SignatureSha256WithRsa);\n\n  encoder.writeTypeAndLength(Tlv.SignatureInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSignatureInfo = function(data, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.SignatureInfo);\n\n  var signatureType = decoder.readNonNegativeIntegerTlv(Tlv.SignatureType);\n  // TODO: The library needs to handle other signature types than \n  //     SignatureSha256WithRsa.\n  if (signatureType == Tlv.SignatureType_SignatureSha256WithRsa) {\n      var signature = {}\n      signature.sig = Signature\n      data.setSignature(signature.sig());\n      // Modify data\'s signature object because if we create an object\n      //   and set it, then data will have to copy all the fields.\n      var signatureInfo = data.getSignature();\n      Tlv0_1a2WireFormat.decodeKeyLocator\n        (signatureInfo.getKeyLocator(), decoder);\n  }\n  else\n      throw new DecodingException\n       ("decodeSignatureInfo: unrecognized SignatureInfo type" + signatureType);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeMetaInfo = function(metaInfo, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  var finalBlockIdBuf = metaInfo.getFinalBlockID();\n  if (finalBlockIdBuf != null && finalBlockIdBuf.length > 0) {\n    // FinalBlockId has an inner NameComponent.\n    var finalBlockIdSaveLength = encoder.getLength();\n    encoder.writeBlobTlv(Tlv.NameComponent, finalBlockIdBuf);\n    encoder.writeTypeAndLength\n      (Tlv.FinalBlockId, encoder.getLength() - finalBlockIdSaveLength);\n  }\n\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.FreshnessPeriod, metaInfo.getFreshnessPeriod());\n  if (metaInfo.getType() != ContentType.BLOB) {\n    // Not the default, so we need to encode the type.\n    if (metaInfo.getType() == ContentType.LINK ||\n        metaInfo.getType() == ContentType.KEY)\n      // The ContentType enum is set up with the correct integer for \n      // each NDN-TLV ContentType.\n      encoder.writeNonNegativeIntegerTlv(Tlv.ContentType, metaInfo.getType());\n    else\n      throw new Error("unrecognized TLV ContentType");\n  }\n\n  encoder.writeTypeAndLength(Tlv.MetaInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeMetaInfo = function(metaInfo, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.MetaInfo);  \n\n  // The ContentType enum is set up with the correct integer for each \n  // NDN-TLV ContentType.  If readOptionalNonNegativeIntegerTlv returns\n  // None, then setType will convert it to BLOB.\n  metaInfo.setType(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ContentType, endOffset));\n  metaInfo.setFreshnessPeriod\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.FreshnessPeriod, endOffset));\n  if (decoder.peekType(Tlv.FinalBlockId, endOffset)) {\n    var finalBlockIdEndOffset = decoder.readNestedTlvsStart(Tlv.FinalBlockId);\n    metaInfo.setFinalBlockID(decoder.readBlobTlv(Tlv.NameComponent));\n    decoder.finishNestedTlvs(finalBlockIdEndOffset);\n  }\n  else\n    metaInfo.setFinalBlockID(null);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n})()\n},{"../crypto.js":54,"../exclude.js":36,"../key-locator.js":40,"../meta-info.js":38,"../signature.js":91,"../util/blob.js":49,"./decoding-exception.js":126,"./tlv/tlv-decoder.js":45,"./tlv/tlv-encoder.js":152,"./tlv/tlv.js":46,"./wire-format.js":42,"crypto":56}],123:[function(require,module,exports){\n/**\n * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to \n * determine its end.\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\n\nvar XML_EXT = 0x00; \nvar XML_TAG = 0x01; \nvar XML_DTAG = 0x02; \nvar XML_ATTR = 0x03; \nvar XML_DATTR = 0x04; \nvar XML_BLOB = 0x05; \nvar XML_UDATA = 0x06;   \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\n\n/**\n * @constructor\n */\nvar BinaryXMLStructureDecoder = function BinaryXMLDecoder() \n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.level = 0;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.headerBuffer = new DynamicBuffer(5);\n  this.nBytesToRead = 0;\n};\n\nexports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;\n\nBinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;\nBinaryXMLStructureDecoder.READ_BYTES = 1;\n\n/**\n * Continue scanning input starting from this.offset.  If found the end of the element\n *   which started at offset 0 then return true, else false.\n * If this returns false, you should read more into input and call again.\n * You have to pass in input each time because the array could be reallocated.\n * This throws an exception for badly formed ndnb.\n */\nBinaryXMLStructureDecoder.prototype.findElementEnd = function(\n  // customBuf\n  input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new BinaryXMLDecoder(input);\n  \n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input.\n      return false;\n  \n    switch (this.state) {\n      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:               \n        // First check for XML_CLOSE.\n        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {\n          ++this.offset;\n          // Close the level.\n          --this.level;\n          if (this.level == 0) {\n            // Finished.\n            this.gotElementEnd = true;\n            return true;\n          }\n          if (this.level < 0)\n            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));\n              \n          // Get ready for the next header.\n          this.startHeader();\n          break;\n        }\n        \n        var startingHeaderLength = this.headerLength;\n        while (true) {\n          if (this.offset >= input.length) {\n            // We can\'t get all of the header bytes from this input. Save in headerBuffer.\n            this.useHeaderBuffer = true;\n            var nNewBytes = this.headerLength - startingHeaderLength;\n            this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n              \n            return false;\n          }\n          var headerByte = input[this.offset++];\n          ++this.headerLength;\n          if (headerByte & XML_TT_NO_MORE)\n            // Break and read the header.\n            break;\n        }\n        \n        var typeAndVal;\n        if (this.useHeaderBuffer) {\n          // Copy the remaining bytes into headerBuffer.\n          nNewBytes = this.headerLength - startingHeaderLength;\n          this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();\n        }\n        else {\n          // We didn\'t have to use the headerBuffer.\n          decoder.seek(this.offset - this.headerLength);\n          typeAndVal = decoder.decodeTypeAndVal();\n        }\n        \n        if (typeAndVal == null)\n          throw new Error("BinaryXMLStructureDecoder: Can\'t read header starting at offset " +\n                          (this.offset - this.headerLength));\n        \n        // Set the next state based on the type.\n        var type = typeAndVal.t;\n        if (type == XML_DATTR)\n          // We already consumed the item. READ_HEADER_OR_CLOSE again.\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n          this.startHeader();\n        else if (type == XML_DTAG || type == XML_EXT) {\n          // Start a new level and READ_HEADER_OR_CLOSE again.\n          ++this.level;\n          this.startHeader();\n        }\n        else if (type == XML_TAG || type == XML_ATTR) {\n          if (type == XML_TAG)\n            // Start a new level and read the tag.\n            ++this.level;\n          // Minimum tag or attribute length is 1.\n          this.nBytesToRead = typeAndVal.v + 1;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n        }\n        else if (type == XML_BLOB || type == XML_UDATA) {\n          this.nBytesToRead = typeAndVal.v;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n        }\n        else\n          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);\n        break;\n    \n      case BinaryXMLStructureDecoder.READ_BYTES:\n        var nRemainingBytes = input.length - this.offset;\n        if (nRemainingBytes < this.nBytesToRead) {\n          // Need more.\n          this.offset += nRemainingBytes;\n          this.nBytesToRead -= nRemainingBytes;\n          return false;\n        }\n        // Got the bytes.  Read a new header or close.\n        this.offset += this.nBytesToRead;\n        this.startHeader();\n        break;\n    \n      default:\n        // We don\'t expect this to happen.\n        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);\n    }\n  }\n};\n\n/**\n * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header\n */\nBinaryXMLStructureDecoder.prototype.startHeader = function() \n{\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;    \n};\n\n/**\n *  Set the offset into the input, used for the next read.\n */\nBinaryXMLStructureDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n},{"../util/dynamic-buffer.js":147,"./binary-xml-decoder.js":85}],107:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DecodingException = require(\'../decoding-exception.js\').DecodingException;\n\n/**\n * Create a new TlvDecoder for decoding the input in the NDN-TLV wire format.\n * @constructor\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nvar TlvDecoder = function TlvDecoder(input)\n{\n  this.input = input;\n  this.offset = 0;\n};\n\nexports.TlvDecoder = TlvDecoder;\n\n/**\n * Decode VAR-NUMBER in NDN-TLV and return it. Update offset.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readVarNumber = function() \n{\n  // Assume array values are in the range 0 to 255.\n  var firstOctet = this.input[this.offset];\n  this.offset += 1;\n  if (firstOctet < 253)\n    return firstOctet;\n  else\n    return this.readExtendedVarNumber(firstOctet);\n};\n\n/**\n * A private function to do the work of readVarNumber, given the firstOctet\n * which is >= 253.\n * @param {number} firstOctet The first octet which is >= 253, used to decode \n * the remaining bytes.\n * @returns {number} The decoded VAR-NUMBER.\n */\nTlvDecoder.prototype.readExtendedVarNumber = function(firstOctet) \n{\n  // This is a private function so we know firstOctet >= 253.\n  if (firstOctet == 253) {\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n    this.offset += 2;\n  }\n  else if (firstOctet == 254) {\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n    this.offset += 4;\n  }\n  else {\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n    this.offset += 8;\n  }\n  \n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType and return the length. Update offset.  Also make \n * sure the decoded length does not exceed the number of bytes remaining in the \n * input.\n * @param {number} expectedType The expected type.\n * @returns {number} The length of the TLV.\n * @throws DecodingException if (did not get the expected TLV type or the TLV length \n * exceeds the buffer length.\n */\nTlvDecoder.prototype.readTypeAndLength = function(expectedType) \n{\n  var type = this.readVarNumber();\n  if (type != expectedType)\n    throw new DecodingException("Did not get the expected TLV type");\n\n  var length = this.readVarNumber();\n  if (this.offset + length > this.input.length)\n    throw new DecodingException("TLV length exceeds the buffer length");\n\n  return length;\n};\n\n/**\n * Decode the type and length from the input starting at offset, expecting the \n * type to be expectedType.  Update offset.  Also make sure the decoded length \n * does not exceed the number of bytes remaining in the input. Return the offset \n * of the end of this parent TLV, which is used in decoding optional nested \n * TLVs. After reading all nested TLVs, call finishNestedTlvs.\n * @param {number} expectedType The expected type.\n * @returns {number} The offset of the end of the parent TLV.\n * @throws DecodingException if did not get the expected TLV type or the TLV \n * length exceeds the buffer length.\n */\nTlvDecoder.prototype.readNestedTlvsStart = function(expectedType) \n{\n  return this.readTypeAndLength(expectedType) + this.offset;\n};\n\n/**\n * Call this after reading all nested TLVs to skip any remaining unrecognized \n * TLVs and to check if the offset after the final nested TLV matches the \n * endOffset returned by readNestedTlvsStart.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @throws DecodingException if the TLV length does not equal the total length \n * of the nested TLVs.\n */\nTlvDecoder.prototype.finishNestedTlvs = function(endOffset) \n{\n  // We expect offset to be endOffset, so check this first.\n  if (this.offset == endOffset)\n    return;\n\n  // Skip remaining TLVs.\n  while (this.offset < endOffset) {\n    // Skip the type VAR-NUMBER.\n    this.readVarNumber();\n    // Read the length and update offset.\n    var length = this.readVarNumber();\n    this.offset += length;\n\n    if (this.offset > this.input.length)\n      throw new DecodingException("TLV length exceeds the buffer length");\n  }\n  \n  if (this.offset != endOffset)\n    throw new DecodingException\n      ("TLV length does not equal the total length of the nested TLVs");\n};\n\n/**\n * Decode the type from this\'s input starting at offset, and if it is the \n * expectedType, then return true, else false.  However, if this\'s offset is \n * greater than or equal to endOffset, then return false and don\'t try to read \n * the type. Do not update offset.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true if the type of the next TLV is the expectedType, \n *  otherwise false.\n */\nTlvDecoder.prototype.peekType = function(expectedType, endOffset) \n{\n  if (this.offset >= endOffset)\n    // No more sub TLVs to look at.\n    return false;\n  else {\n    var saveOffset = this.offset;\n    var type = this.readVarNumber();\n    // Restore offset.\n    this.offset = saveOffset;\n\n    return type == expectedType;\n  }\n};\n\n/**\n * Decode a non-negative integer in NDN-TLV and return it. Update offset by \n * length.\n * @param {number} length The number of bytes in the encoded integer.\n * @returns {number} The integer.\n * @throws DecodingException if length is an invalid length for a TLV \n * non-negative integer.\n */\nTlvDecoder.prototype.readNonNegativeInteger = function(length) \n{\n  var result;\n  if (length == 1)\n    result = this.input[this.offset];\n  else if (length == 2)\n    result = ((this.input[this.offset] << 8) +\n           this.input[this.offset + 1]);\n  else if (length == 4)\n    result = ((this.input[this.offset] << 24) +\n          (this.input[this.offset + 1] << 16) +\n          (this.input[this.offset + 2] << 8) +\n           this.input[this.offset + 3]);\n  else if (length == 8)\n    result = ((this.input[this.offset] << 56) +\n          (this.input[this.offset + 1] << 48) +\n          (this.input[this.offset + 2] << 40) +\n          (this.input[this.offset + 3] << 32) +\n          (this.input[this.offset + 4] << 24) +\n          (this.input[this.offset + 5] << 16) +\n          (this.input[this.offset + 6] << 8) +\n           this.input[this.offset + 7]);\n  else\n    throw new DecodingException("Invalid length for a TLV nonNegativeInteger");\n\n  this.offset += length;\n  return result;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then decode a non-negative integer in NDN-TLV \n * and return it.  Update offset.\n * @param {number} expectedType The expected type.\n * @returns {number} The integer.\n * @throws DecodingException if did not get the expected TLV type or can\'t \n * decode the value.\n */\nTlvDecoder.prototype.readNonNegativeIntegerTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  return this.readNonNegativeInteger(length);\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call \n * readNonNegativeIntegerTlv and return the integer.  Otherwise, return null.  \n * However, if this\'s offset is greater than or equal to endOffset, then return \n * null and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {number} The integer or null if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readOptionalNonNegativeIntegerTlv = function\n  (expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readNonNegativeIntegerTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Decode the type and length from this\'s input starting at offset, expecting \n * the type to be expectedType. Then return an array of the bytes in the value.\n * Update offset.\n * @param {number} expectedType The expected type.\n * @returns {Buffer} The bytes in the value as a slice on the buffer.  This is\n * not a copy of the bytes in the input buffer.  If you need a copy, then you \n * must make a copy of the return value.\n * @throws DecodingException if did not get the expected TLV type.\n */\nTlvDecoder.prototype.readBlobTlv = function(expectedType) \n{\n  var length = this.readTypeAndLength(expectedType);\n  var result = this.input.slice(this.offset, this.offset + length);\n\n  // readTypeAndLength already checked if length exceeds the input buffer.\n  this.offset += length;\n  return result;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then call readBlobTlv \n * and return the value.  Otherwise, return null. However, if this\'s offset is \n * greater than or equal to endOffset, then return null and don\'t try to read \n * the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {Buffer} The bytes in the value as a slice on the buffer or null if \n * the next TLV doesn\'t have the expected type.  This is not a copy of the bytes \n * in the input buffer.  If you need a copy, then you must make a copy of the \n * return value.\n */\nTlvDecoder.prototype.readOptionalBlobTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset))\n    return this.readBlobTlv(expectedType);\n  else\n    return null;\n};\n\n/**\n * Peek at the next TLV, and if it has the expectedType then read a type and \n * value, ignoring the value, and return true. Otherwise, return false.\n * However, if this\'s offset is greater than or equal to endOffset, then return \n * false and don\'t try to read the type.\n * @param {number} expectedType The expected type.\n * @param {number} endOffset The offset of the end of the parent TLV, returned \n * by readNestedTlvsStart.\n * @returns {boolean} true, or else false if the next TLV doesn\'t have the \n * expected type.\n */\nTlvDecoder.prototype.readBooleanTlv = function(expectedType, endOffset) \n{\n  if (this.peekType(expectedType, endOffset)) {\n    var length = this.readTypeAndLength(expectedType);\n    // We expect the length to be 0, but update offset anyway.\n    this.offset += length;\n    return true;\n  }\n  else\n    return false;\n};\n\n/**\n * Get the offset into the input, used for the next read.\n * @returns {number} The offset.\n */\nTlvDecoder.prototype.getOffset = function() \n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};  \n\n})()\n},{"../../buffer.js":116,"../decoding-exception.js":153}],124:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar TlvDecoder = require(\'./tlv-decoder.js\').TlvDecoder;\nvar customBuf = require(\'../../buffer.js\').Buffer\n/**\n * Create and initialize a TlvStructureDecoder.\n */\nvar TlvStructureDecoder = function TlvStructureDecoder()\n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.state = TlvStructureDecoder.READ_TYPE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  // 8 bytes is enough to hold the extended bytes in the length encoding \n  // where it is an 8-byte number.\n  this.headerBuffer = new customBuf(8);\n  this.nBytesToRead = 0;\n};\n\nexports.TlvStructureDecoder = TlvStructureDecoder;\n\nTlvStructureDecoder.READ_TYPE =         0;\nTlvStructureDecoder.READ_TYPE_BYTES =   1;\nTlvStructureDecoder.READ_LENGTH =       2;\nTlvStructureDecoder.READ_LENGTH_BYTES = 3;\nTlvStructureDecoder.READ_VALUE_BYTES =  4;\n\n/**\n * Continue scanning input starting from this.offset to find the element end.  \n * If the end of the element which started at offset 0 is found, this returns \n * true and getOffset() is the length of the element.  Otherwise, this returns \n * false which means you should read more into input and call again.\n * @param {Buffer} input The input buffer. You have to pass in input each time\n * because the buffer could be reallocated.\n * @returns {boolean} true if found the element end, false if not.\n */\nTlvStructureDecoder.prototype.findElementEnd = function(input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new TlvDecoder(input);\n\n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input. Return and wait for more.\n      return false;\n\n    if (this.state == TlvStructureDecoder.READ_TYPE) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253)\n        // The value is simple, so we can skip straight to reading the length.\n        this.state = TlvStructureDecoder.READ_LENGTH;\n      else {\n        // Set up to skip the type bytes.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        this.state = TlvStructureDecoder.READ_TYPE_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_TYPE_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the type bytes. Move on to read the length.\n      this.offset += this.nBytesToRead;\n      this.state = TlvStructureDecoder.READ_LENGTH;\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253) {\n        // The value is simple, so we can skip straight to reading \n        //  the value bytes.\n        this.nBytesToRead = firstOctet;\n        if (this.nBytesToRead == 0) {\n          // No value bytes to read. We\'re finished.\n          this.gotElementEnd = true;\n          return true;\n        }\n\n        this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n      }\n      else {\n        // We need to read the bytes in the extended encoding of \n        //  the length.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        // We need to use firstOctet in the next state.\n        this.firstOctet = firstOctet;\n        this.state = TlvStructureDecoder.READ_LENGTH_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (!this.useHeaderBuffer && nRemainingBytes >= this.nBytesToRead) {\n        // We don\'t have to use the headerBuffer. Set nBytesToRead.\n        decoder.seek(this.offset);\n\n        this.nBytesToRead = decoder.readExtendedVarNumber(this.firstOctet);\n        // Update this.offset to the decoder\'s offset after reading.\n        this.offset = decoder.getOffset();\n      }\n      else {\n        this.useHeaderBuffer = true;\n\n        var nNeededBytes = this.nBytesToRead - this.headerLength;\n        if (nNeededBytes > nRemainingBytes) {\n          // We can\'t get all of the header bytes from this input. \n          // Save in headerBuffer.\n          if (this.headerLength + nRemainingBytes > this.headerBuffer.length)\n            // We don\'t expect this to happen.\n            throw new Error\n              ("Cannot store more header bytes than the size of headerBuffer");\n          input.slice(this.offset, this.offset + nRemainingBytes).copy\n            (this.headerBuffer, this.headerLength);\n          this.offset += nRemainingBytes;\n          this.headerLength += nRemainingBytes;\n\n          return false;\n        }\n\n        // Copy the remaining bytes into headerBuffer, read the \n        //   length and set nBytesToRead.\n        if (this.headerLength + nNeededBytes > this.headerBuffer.length)\n          // We don\'t expect this to happen.\n          throw new Error\n            ("Cannot store more header bytes than the size of headerBuffer");\n        input.slice(this.offset, this.offset + nNeededBytes).copy\n          (this.headerBuffer, this.headerLength);\n        this.offset += nNeededBytes;\n\n        // Use a local decoder just for the headerBuffer.\n        var bufferDecoder = new TlvDecoder(this.headerBuffer);\n        // Replace nBytesToRead with the length of the value.\n        this.nBytesToRead = bufferDecoder.readExtendedVarNumber(this.firstOctet);\n      }\n      \n      if (this.nBytesToRead == 0) {\n        // No value bytes to read. We\'re finished.\n        this.gotElementEnd = true;\n        return true;\n      }\n\n      // Get ready to read the value bytes.\n      this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n    }\n    else if (this.state == TlvStructureDecoder.READ_VALUE_BYTES) {\n      nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the bytes. We\'re finished.\n      this.offset += this.nBytesToRead;\n      this.gotElementEnd = true;\n      return true;\n    }\n    else\n      // We don\'t expect this to happen.\n      throw new Error("findElementEnd: unrecognized state");\n  }\n};\n\n/**\n * Get the current offset into the input buffer.\n * @returns {number} The offset.\n */\nTlvStructureDecoder.prototype.getOffset = function()\n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvStructureDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n\n})()\n},{"../../buffer.js":54,"./tlv-decoder.js":45}],137:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class contains all NDNx tags\n */\n\n\nvar NDNProtocolDTags = {\n\n  /**\n   * Note if you add one of these, add it to the reverse string map as well.\n   * Emphasize getting the work done at compile time over trying to make something\n   * flexible and developer error-proof.\n   */\n\n   Any : 13,\n   Name : 14,\n   Component : 15,\n   Certificate : 16,\n   Collection : 17,\n   CompleteName : 18,\n   Content : 19,\n   SignedInfo : 20,\n   ContentDigest : 21,\n   ContentHash : 22,\n   Count : 24,\n   Header : 25,\n   Interest : 26,  /* 20090915 */\n   Key : 27,\n   KeyLocator : 28,\n   KeyName : 29,\n   Length : 30,\n   Link : 31,\n   LinkAuthenticator : 32,\n   NameComponentCount : 33,  /* DeprecatedInInterest */\n   RootDigest : 36,\n   Signature : 37,\n   Start : 38,\n   Timestamp : 39,\n   Type : 40,\n   Nonce : 41,\n   Scope : 42,\n   Exclude : 43,\n   Bloom : 44,\n   BloomSeed : 45,\n   AnswerOriginKind : 47,\n   InterestLifetime : 48,\n   Witness : 53,\n   SignatureBits : 54,\n   DigestAlgorithm : 55,\n   BlockSize : 56,\n   FreshnessSeconds : 58,\n   FinalBlockID : 59,\n   PublisherPublicKeyDigest : 60,\n   PublisherCertificateDigest : 61,\n   PublisherIssuerKeyDigest : 62,\n   PublisherIssuerCertificateDigest : 63,\n   Data : 64,  /* 20090915 */\n   WrappedKey : 65,\n   WrappingKeyIdentifier : 66,\n   WrapAlgorithm : 67,\n   KeyAlgorithm : 68,\n   Label : 69,\n   EncryptedKey : 70,\n   EncryptedNonceKey : 71,\n   WrappingKeyName : 72,\n   Action : 73,\n   FaceID : 74,\n   IPProto : 75,\n   Host : 76,\n   Port : 77,\n   MulticastInterface : 78,\n   ForwardingFlags : 79,\n   FaceInstance : 80,\n   ForwardingEntry : 81,\n   MulticastTTL : 82,\n   MinSuffixComponents : 83,\n   MaxSuffixComponents : 84,\n   ChildSelector : 85,\n   RepositoryInfo : 86,\n   Version : 87,\n   RepositoryVersion : 88,\n   GlobalPrefix : 89,\n   LocalName : 90,\n   Policy : 91,\n   Namespace : 92,\n   GlobalPrefixName : 93,\n   PolicyVersion : 94,\n   KeyValueSet : 95,\n   KeyValuePair : 96,\n   IntegerValue : 97,\n   DecimalValue : 98,\n   StringValue : 99,\n   BinaryValue : 100,\n   NameValue : 101,\n   Entry : 102,\n   ACL : 103,\n   ParameterizedName : 104,\n   Prefix : 105,\n   Suffix : 106,\n   Root : 107,\n   ProfileName : 108,\n   Parameters : 109,\n   InfoString : 110,\n  // 111 unallocated\n   StatusResponse : 112,\n   StatusCode : 113,\n   StatusText : 114,\n\n  // Sync protocol\n   SyncNode : 115,\n   SyncNodeKind : 116,\n   SyncNodeElement : 117,\n   SyncVersion : 118,\n   SyncNodeElements : 119,\n   SyncContentHash : 120,\n   SyncLeafCount : 121,\n   SyncTreeDepth : 122,\n   SyncByteCount : 123,\n   ConfigSlice : 124,\n   ConfigSliceList : 125,\n   ConfigSliceOp : 126,\n\n  // Remember to keep in sync with schema/tagnames.csvsdict\n   NDNProtocolDataUnit : 17702112,\n   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"\n};\n\nexports.NDNProtocolDTags = NDNProtocolDTags;\n\nvar NDNProtocolDTagsStrings = [\n  null, null, null, null, null, null, null, null, null, null, null,\n  null, null,\n  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",\n  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",\n  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",\n  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",\n  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",\n  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",\n  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",\n  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",\n  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",\n  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",\n  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",\n  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",\n  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",\n  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",\n  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",\n  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",\n  "InfoString", null,\n    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",\n    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",\n    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];\n\nexports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;\n\n},{}],139:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Log class holds the global static variable LOG.\n */\nvar Log = function Log()\n{\n}\n\nexports.Log = Log;\n\n/**\n * LOG is the level for logging debugging statements.  0 means no log messages.\n * @type Number\n */\nLog.LOG = 0;\n\n})()\n},{}],146:[function(require,module,exports){\nvar b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\nvar b64pad="=";\nvar BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction hex2b64(h) {\n  var i;\n  var c;\n  var ret = "";\n  for(i = 0; i+3 <= h.length; i+=3) {\n    c = parseInt(h.substring(i,i+3),16);\n    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n  }\n  if(i+1 == h.length) {\n    c = parseInt(h.substring(i,i+1),16);\n    ret += b64map.charAt(c << 2);\n  }\n  else if(i+2 == h.length) {\n    c = parseInt(h.substring(i,i+2),16);\n    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n  }\n  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n  return ret;\n}\n\n// convert a base64 string to hex\nfunction b64tohex(s) {\n  var ret = ""\n  var i;\n  var k = 0; // b64 state, 0-3\n  var slop;\n  for(i = 0; i < s.length; ++i) {\n    if(s.charAt(i) == b64pad) break;\n    v = b64map.indexOf(s.charAt(i));\n    if(v < 0) continue;\n    if(k == 0) {\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 1;\n    }\n    else if(k == 1) {\n      ret += int2char((slop << 2) | (v >> 4));\n      slop = v & 0xf;\n      k = 2;\n    }\n    else if(k == 2) {\n      ret += int2char(slop);\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 3;\n    }\n    else {\n      ret += int2char((slop << 2) | (v >> 4));\n      ret += int2char(v & 0xf);\n      k = 0;\n    }\n  }\n  if(k == 1)\n    ret += int2char(slop << 2);\n  return ret;\n}\n\n// convert a base64 string to a byte/number array\nfunction b64toBA(s) {\n  //piggyback on b64tohex for now, optimize later\n  var h = b64tohex(s);\n  var i;\n  var a = new Array();\n  for(i = 0; 2*i < h.length; ++i) {\n    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n  }\n  return a;\n}\n\nmodule.exports = {b64tohex: b64tohex, b64toBA: b64toBA, hex2b64: hex2b64};\n\n},{}],127:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar ElementReader = require(\'../encoding/element-reader.js\').ElementReader;\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n\nfunction makeShuffledGetHostAndPort (hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n\n/**\n * @constructor\n */\nvar WebSocketTransport = function WebSocketTransport() \n{    \n  if (!WebSocket)\n    throw new Error("WebSocket support is not available on this platform.");\n    \n  this.ws = null;\n  this.connectedHost = null; // Read by Face.\n  this.connectedPort = null; // Read by Face.\n  this.elementReader = null;\n  this.defaultGetHostAndPort = makeShuffledGetHostAndPort\n    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu", \n      "E.ws.ndn.ucla.edu", "F.ws.ndn.ucla.edu", "G.ws.ndn.ucla.edu", "H.ws.ndn.ucla.edu", \n      "I.ws.ndn.ucla.edu", "J.ws.ndn.ucla.edu", "K.ws.ndn.ucla.edu", "L.ws.ndn.ucla.edu", \n      "M.ws.ndn.ucla.edu", "N.ws.ndn.ucla.edu"],\n     9696);\n};\n\nexports.WebSocketTransport = WebSocketTransport;\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nWebSocketTransport.prototype.connect = function(face, onopenCallback) \n{\n  this.close();\n  \n  this.ws = new WebSocket(\'ws:\' + face.host + \':\' + face.port);\n  if (LOG > 0) console.log(\'ws connection created.\');\n    this.connectedHost = face.host;\n    this.connectedPort = face.port;\n  \n  this.ws.binaryType = "arraybuffer";\n  \n  this.elementReader = new ElementReader(face);\n  var self = this;\n  this.ws.onmessage = function(ev) {\n    var result = ev.data;\n    //console.log(\'RecvHandle called.\');\n      \n    if (result == null || result == undefined || result == "") {\n      console.log(\'INVALID ANSWER\');\n    } \n    else if (result instanceof ArrayBuffer) {\n      var bytearray = new customBuf(result);\n          \n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n      \n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n    }\n  }\n  \n  this.ws.onopen = function(ev) {\n    if (LOG > 3) console.log(ev);\n    if (LOG > 3) console.log(\'ws.onopen: WebSocket connection opened.\');\n    if (LOG > 3) console.log(\'ws.onopen: ReadyState: \' + this.readyState);\n    // Face.registerPrefix will fetch the ndndid when needed.\n\n    onopenCallback();\n  }\n  \n  this.ws.onerror = function(ev) {\n    console.log(\'ws.onerror: ReadyState: \' + this.readyState);\n    console.log(ev);\n    console.log(\'ws.onerror: WebSocket error: \' + ev.data);\n  }\n  \n  this.ws.onclose = function(ev) {\n    console.log(\'ws.onclose: WebSocket connection closed.\');\n    self.ws = null;\n    \n    // Close Face when WebSocket is closed\n    face.readyStatus = 2; //Face.CLOSED\n    face.onclose();\n    //console.log("NDN.onclose event fired.");\n  }\n};\n\n/**\n * Send the Uint8Array data.\n */\nWebSocketTransport.prototype.send = function(data) \n{\n  if (this.ws != null) {\n    // If we directly use data.buffer to feed ws.send(), \n    // WebSocket may end up sending a packet with 10000 bytes of data.\n    // That is, WebSocket will flush the entire buffer\n    // regardless of the offset of the Uint8Array. So we have to create\n    // a new Uint8Array buffer with just the right size and copy the \n    // content from binaryInterest to the new buffer.\n    //    ---Wentao\n    var bytearray = new Uint8Array(data.length);\n    bytearray.set(data);\n    this.ws.send(bytearray.buffer);\n    if (LOG > 3) console.log(\'ws.send() returned.\');\n  }\n  else\n    console.log(\'WebSocket connection is not established.\');\n};\n\n/**\n * Close the connection.\n */\nWebSocketTransport.prototype.close = function()\n{\n  if (this.ws != null)\n    delete this.ws;\n}\n\n\n})()\n},{"../buffer.js":30,"../encoding/data-utils.js":23,"../encoding/element-reader.js":29,"../log.js":62}],130:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Encapsulate a customBuf and support dynamic reallocation.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a DynamicBuffer where this.array is a customBuf of size length.\n * To access the array, use this.array or call slice.\n * @constructor\n * @param {number} length the initial length of the array.  If null, use a default.\n */\nvar DynamicBuffer = function DynamicBuffer(length) \n{\n  if (!length)\n    length = 16;\n    \n  this.array = new customBuf(length);\n};\n\nexports.DynamicBuffer = DynamicBuffer;\n\n/**\n * Ensure that this.array has the length, reallocate and copy if necessary.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLength = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  this.array.copy(newArray);\n  this.array = newArray;\n};\n\n/**\n * Copy the value to this.array at offset, reallocating if necessary. \n * @param {Buffer} value The buffer to copy.\n * @param {number} offset The offset in the buffer to start copying into.\n */\nDynamicBuffer.prototype.copy = function(value, offset) \n{\n  this.ensureLength(value.length + offset);\n    \n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, offset);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, offset);\n};\n\n/**\n * Ensure that this.array has the length. If necessary, reallocate the array\n *   and shift existing data to the back of the new array.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLengthFromBack = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  // Copy to the back of newArray.\n  this.array.copy(newArray, newArray.length - this.array.length);\n  this.array = newArray;\n};\n\n/**\n * First call ensureLengthFromBack to make sure the bytearray has\n * offsetFromBack bytes, then copy value into the array starting\n * offsetFromBack bytes from the back of the array.\n * @param {Buffer} value The buffer to copy.\n * @param {offsetFromBack} offset The offset from the back of the array to start\n * copying.\n */\nDynamicBuffer.prototype.copyFromBack = function(value, offsetFromBack) \n{\n  this.ensureLengthFromBack(offsetFromBack);\n\n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, this.array.length - offsetFromBack);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, this.array.length - offsetFromBack);\n};\n\n/**\n * Return this.array.slice(begin, end);\n * @param {number} begin The begin index for the slice.\n * @param {number} end The end index for the slice.\n * @returns {Buffer} The buffer slice.\n */\nDynamicBuffer.prototype.slice = function(begin, end) \n{\n  return this.array.slice(begin, end);\n};\n\n})()\n},{"../buffer.js":30}],154:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n    // Shortcuts\n    var C = require(\'./core.js\');\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var Hasher = C_lib.Hasher;\n    var C_algo = C.algo;\n\n    // Initialization and round constants tables\n    var H = [];\n    var K = [];\n\n    // Compute constants\n    (function () {\n        function isPrime(n) {\n            var sqrtN = Math.sqrt(n);\n            for (var factor = 2; factor <= sqrtN; factor++) {\n                if (!(n % factor)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function getFractionalBits(n) {\n            return ((n - (n | 0)) * 0x100000000) | 0;\n        }\n\n        var n = 2;\n        var nPrime = 0;\n        while (nPrime < 64) {\n            if (isPrime(n)) {\n                if (nPrime < 8) {\n                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                }\n                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n                nPrime++;\n            }\n\n            n++;\n        }\n    }());\n\n    // Reusable object\n    var W = [];\n\n    /**\n     * SHA-256 hash algorithm.\n     */\n    var SHA256 = C_algo.SHA256 = Hasher.extend({\n        _doReset: function () {\n            this._hash = new WordArray.init(H.slice(0));\n        },\n\n        _doProcessBlock: function (M, offset) {\n            // Shortcut\n            var H = this._hash.words;\n\n            // Working variables\n            var a = H[0];\n            var b = H[1];\n            var c = H[2];\n            var d = H[3];\n            var e = H[4];\n            var f = H[5];\n            var g = H[6];\n            var h = H[7];\n\n            // Computation\n            for (var i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                } else {\n                    var gamma0x = W[i - 15];\n                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                                   (gamma0x >>> 3);\n\n                    var gamma1x = W[i - 2];\n                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                                   (gamma1x >>> 10);\n\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n\n                var ch  = (e & f) ^ (~e & g);\n                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n                var t1 = h + sigma1 + ch + K[i] + W[i];\n                var t2 = sigma0 + maj;\n\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n            H[4] = (H[4] + e) | 0;\n            H[5] = (H[5] + f) | 0;\n            H[6] = (H[6] + g) | 0;\n            H[7] = (H[7] + h) | 0;\n        },\n\n        _doFinalize: function () {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n\n            var nBitsTotal = this._nDataBytes * 8;\n            var nBitsLeft = data.sigBytes * 8;\n\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            data.sigBytes = dataWords.length * 4;\n\n            // Hash final blocks\n            this._process();\n\n            // Return final computed hash\n            return this._hash;\n        },\n\n        clone: function () {\n            var clone = Hasher.clone.call(this);\n            clone._hash = this._hash.clone();\n\n            return clone;\n        }\n    });\n\n    /**\n     * Shortcut function to the hasher\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     *\n     * @return {WordArray} The hash.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hash = CryptoJS.SHA256(\'message\');\n     *     var hash = CryptoJS.SHA256(wordArray);\n     */\n    C.SHA256 = Hasher._createHelper(SHA256);\n\n    /**\n     * Shortcut function to the HMAC\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     * @param {WordArray|string} key The secret key.\n     *\n     * @return {WordArray} The HMAC.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hmac = CryptoJS.HmacSHA256(message, key);\n     */\n    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\nmodule.exports = C\n\n},{"./core.js":155}],156:[function(require,module,exports){\n/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key\n//              to RSAKey class.\n//\n// version: 1.1.1 (2013-Apr-12)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n// \n//\n// Depends on:\n//\n//\n//\n// _RSApem_pemToBase64(sPEM)\n//\n//   removing PEM header, PEM footer and space characters including\n//   new lines from PEM formatted RSA private key string.\n//\nvar ASN1HEX = require(\'./asn1hex-1.1.js\')\nvar b64tohex = require(\'./base64.js\').b64tohex\nvar RSAKey = require(\'./rsa2.js\')\n/**\n * @fileOverview\n * @name rsapem-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nfunction _rsapem_pemToBase64(sPEMPrivateKey) {\n  var s = sPEMPrivateKey;\n  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");\n  s = s.replace("-----END RSA PRIVATE KEY-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {\n  var a = new Array();\n  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);\n  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);\n  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);\n  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);\n  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);\n  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);\n  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);\n  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);\n  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);\n  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);\n  return a;\n}\n\nfunction _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {\n  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);\n  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);\n  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);\n  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);\n  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);\n  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);\n  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);\n  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);\n  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);\n  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);\n  var a = new Array();\n  a.push(v, n, e, d, p, q, dp, dq, co);\n  return a;\n}\n\n/**\n * read RSA private key from a ASN.1 hexadecimal string\n * @name readPrivateKeyFromASN1HexString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.\n * @since 1.1.1\n */\nfunction _rsapem_readPrivateKeyFromASN1HexString(keyHex) {\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\n/**\n * read PKCS#1 private key from a string\n * @name readPrivateKeyFromPEMString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyPEM string of PKCS#1 private key.\n */\nfunction _rsapem_readPrivateKeyFromPEMString(keyPEM) {\n  var keyB64 = _rsapem_pemToBase64(keyPEM);\n  var keyHex = b64tohex(keyB64) // depends base64.js\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\nRSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;\nRSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;\n\nmodule.exports = RSAKey\n\n},{"./asn1hex-1.1.js":67,"./base64.js":70,"./rsa2.js":157}],153:[function(require,module,exports){\n/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * Create a new DecodingException wrapping the given error object.\n * Call with: throw new DecodingException(new Error("message")).\n * @constructor\n * @param {string} error The exception created with new Error.\n */\nfunction DecodingException(error) \n{\n  this.message = error.message;\n  // Copy lineNumber, etc. from where new Error was called.\n  for (var prop in error)\n      this[prop] = error[prop];\n}\nDecodingException.prototype = new Error();\nDecodingException.prototype.name = "DecodingException";\n\nexports.DecodingException = DecodingException;\n\n},{}],131:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DynamicBuffer = require(\'../../util/dynamic-buffer.js\').DynamicBuffer;\n\n/**\n * Create a new TlvEncoder with an initialCapacity for the encoding buffer.\n * @constructor\n * @param {number} initialCapacity (optional) The initial capacity of the \n * encoding buffer. If omitted, use a default value.\n */\nvar TlvEncoder = function TlvEncoder(initialCapacity)\n{\n  initialCapacity = initialCapacity || 16;\n  this.output = new DynamicBuffer(initialCapacity);\n  // length is the number of bytes that have been written to the back of \n  //  this.output.array.\n  this.length = 0;\n};\n\nexports.TlvEncoder = TlvEncoder;\n\n/**\n * Get the number of bytes that have been written to the output.  You can\n * save this number, write sub TLVs, then subtract the new length from this\n * to get the total length of the sub TLVs.\n * @returns {number} The number of bytes that have been written to the output.\n */\nTlvEncoder.prototype.getLength = function()\n{\n  return this.length;\n};\n\n/**\n * Encode varNumber as a VAR-NUMBER in NDN-TLV and write it to this.output just \n * before this.length from the back.  Advance this.length.\n * @param {number} varNumber The non-negative number to encode.\n */\nTlvEncoder.prototype.writeVarNumber = function(varNumber)\n{\n  if (varNumber < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffff) {\n    this.length += 3;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 253;\n    this.output.array[offset + 1] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 2] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffffffff) {\n    this.length += 5;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 254;\n    this.output.array[offset + 1] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 4] = varNumber & 0xff;\n  }\n  else {\n    this.length += 9;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 255;\n    this.output.array[offset + 1] = (varNumber >> 56) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 48) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 40) & 0xff;\n    this.output.array[offset + 4] = (varNumber >> 32) & 0xff;\n    this.output.array[offset + 5] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 6] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 7] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 8] = varNumber & 0xff;\n  }\n};\n\n/**\n * Encode the type and length as VAR-NUMBER and write to this.output just before \n * this.length from the back.  Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} length The non-negative length of the TLV.\n */\nTlvEncoder.prototype.writeTypeAndLength = function(type, length)\n{\n  // Write backwards.\n  this.writeVarNumber(length);\n  this.writeVarNumber(type);\n};\n\n/**\n * Write the type, then the length of the encoded value then encode value as a \n * non-negative integer and write it to this.output just before this.length from \n * the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} value The non-negative integer to encode.\n */\nTlvEncoder.prototype.writeNonNegativeIntegerTlv = function(type, value)\n{\n  if (value < 0)\n    throw new Error("TLV integer value may not be negative");\n\n  // JavaScript doesn\'t distinguish int from float, so round.\n  value = Math.round(value)\n\n  // Write backwards.\n  var saveNBytes = this.length;\n  if (value < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = value & 0xff;\n  }\n  else if (value <= 0xffff) {\n    this.length += 2;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 8) & 0xff;\n    this.output.array[offset + 1] = value & 0xff;\n  }\n  else if (value <= 0xffffffff) {\n    this.length += 4;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 24) & 0xff;\n    this.output.array[offset + 1] = (value >> 16) & 0xff;\n    this.output.array[offset + 2] = (value >> 8) & 0xff;\n    this.output.array[offset + 3] = value & 0xff;\n  }\n  else {\n    this.length += 8;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 56) & 0xff;\n    this.output.array[offset + 1] = (value >> 48) & 0xff;\n    this.output.array[offset + 2] = (value >> 40) & 0xff;\n    this.output.array[offset + 3] = (value >> 32) & 0xff;\n    this.output.array[offset + 4] = (value >> 24) & 0xff;\n    this.output.array[offset + 5] = (value >> 16) & 0xff;\n    this.output.array[offset + 6] = (value >> 8) & 0xff;\n    this.output.array[offset + 7] = value & 0xff;\n  }\n\n  this.writeTypeAndLength(type, this.length - saveNBytes);\n};\n\n/**\n * If value is negative or null then do nothing, otherwise call \n * writeNonNegativeIntegerTlv.\n * @param {number} type The type of the TLV.\n * @param {number} value If negative or None do nothing, otherwise the integer \n *   to encode.\n */\nTlvEncoder.prototype.writeOptionalNonNegativeIntegerTlv = function(type, value)\n{\n  if (value != null && value >= 0)\n    this.writeNonNegativeIntegerTlv(type, value);\n};\n\n/**\n * Write the type, then the length of the buffer then the buffer value to \n * this.output just before this.length from the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value The byte array with the bytes of the blob.  If value is\n    null, then just write the type and length 0.\n */\nTlvEncoder.prototype.writeBlobTlv = function(type, value)\n{\n  if (value == null) {\n    this.writeTypeAndLength(type, 0);\n    return;\n  }\n\n  // Write backwards, starting with the blob array.    \n  this.length += value.length;\n  this.output.copyFromBack(value, this.length);\n\n  this.writeTypeAndLength(type, value.length);\n};\n\n/**\n * If the byte array is null or zero length then do nothing, otherwise call \n * writeBlobTlv.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value If null or zero length do nothing, otherwise the byte \n * array with the bytes of the blob.\n */\nTlvEncoder.prototype.writeOptionalBlobTlv = function(type, value)\n{\n  if (value != null && value.length > 0)\n    this.writeBlobTlv(type, value);\n};\n\n/**\n * Get a slice of the encoded bytes.\n * @returns {Buffer} A slice backed by the encoding customBuf.\n */\nTlvEncoder.prototype.getOutput = function()\n{\n  return this.output.array.slice(this.output.array.length - this.length);\n};\n\n})()\n},{"../../buffer.js":30,"../../util/dynamic-buffer.js":130}],155:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/**\n * CryptoJS core components.\n */\nvar CryptoJS = CryptoJS || (function (Math, undefined) {\n    /**\n     * CryptoJS namespace.\n     */\n    var C = {};\n\n    /**\n     * Library namespace.\n     */\n    var C_lib = C.lib = {};\n\n    /**\n     * Base object for prototypal inheritance.\n     */\n    var Base = C_lib.Base = (function () {\n        function F() {}\n\n        return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: \'value\',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function (overrides) {\n                // Spawn\n                F.prototype = this;\n                var subtype = new F();\n\n                // Augment\n                if (overrides) {\n                    subtype.mixIn(overrides);\n                }\n\n                // Create default initializer\n                if (!subtype.hasOwnProperty(\'init\')) {\n                    subtype.init = function () {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                }\n\n                // Initializer\'s prototype is the subtype object\n                subtype.init.prototype = subtype;\n\n                // Reference supertype\n                subtype.$super = this;\n\n                return subtype;\n            },\n\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function () {\n                var instance = this.extend();\n                instance.init.apply(instance, arguments);\n\n                return instance;\n            },\n\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function () {\n            },\n\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: \'value\'\n             *     });\n             */\n            mixIn: function (properties) {\n                for (var propertyName in properties) {\n                    if (properties.hasOwnProperty(propertyName)) {\n                        this[propertyName] = properties[propertyName];\n                    }\n                }\n\n                // IE won\'t copy toString using the loop above\n                if (properties.hasOwnProperty(\'toString\')) {\n                    this.toString = properties.toString;\n                }\n            },\n\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function () {\n                return this.init.prototype.extend(this);\n            }\n        };\n    }());\n\n    /**\n     * An array of 32-bit words.\n     *\n     * @property {Array} words The array of 32-bit words.\n     * @property {number} sigBytes The number of significant bytes in this word array.\n     */\n    var WordArray = C_lib.WordArray = Base.extend({\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param {Array} words (Optional) An array of 32-bit words.\n         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.create();\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n         */\n        init: function (words, sigBytes) {\n            words = this.words = words || [];\n\n            if (sigBytes != undefined) {\n                this.sigBytes = sigBytes;\n            } else {\n                this.sigBytes = words.length * 4;\n            }\n        },\n\n        /**\n         * Converts this word array to a string.\n         *\n         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {string} The stringified word array.\n         *\n         * @example\n         *\n         *     var string = wordArray + \'\';\n         *     var string = wordArray.toString();\n         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        toString: function (encoder) {\n            return (encoder || Hex).stringify(this);\n        },\n\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param {WordArray} wordArray The word array to append.\n         *\n         * @return {WordArray} This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        concat: function (wordArray) {\n            // Shortcuts\n            var thisWords = this.words;\n            var thatWords = wordArray.words;\n            var thisSigBytes = this.sigBytes;\n            var thatSigBytes = wordArray.sigBytes;\n\n            // Clamp excess bits\n            this.clamp();\n\n            // Concat\n            if (thisSigBytes % 4) {\n                // Copy one byte at a time\n                for (var i = 0; i < thatSigBytes; i++) {\n                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n                }\n            } else if (thatWords.length > 0xffff) {\n                // Copy one word at a time\n                for (var i = 0; i < thatSigBytes; i += 4) {\n                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n                }\n            } else {\n                // Copy all words at once\n                thisWords.push.apply(thisWords, thatWords);\n            }\n            this.sigBytes += thatSigBytes;\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        clamp: function () {\n            // Shortcuts\n            var words = this.words;\n            var sigBytes = this.sigBytes;\n\n            // Clamp\n            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n            words.length = Math.ceil(sigBytes / 4);\n        },\n\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return {WordArray} The clone.\n         *\n         * @example\n         *\n         *     var clone = wordArray.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone.words = this.words.slice(0);\n\n            return clone;\n        },\n\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * @param {number} nBytes The number of random bytes to generate.\n         *\n         * @return {WordArray} The random word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n         */\n        random: function (nBytes) {\n            var words = [];\n            for (var i = 0; i < nBytes; i += 4) {\n                words.push((Math.random() * 0x100000000) | 0);\n            }\n\n            return new WordArray.init(words, nBytes);\n        }\n    });\n\n    /**\n     * Encoder namespace.\n     */\n    var C_enc = C.enc = {};\n\n    /**\n     * Hex encoding strategy.\n     */\n    var Hex = C_enc.Hex = {\n        /**\n         * Converts a word array to a hex string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The hex string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var hexChars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n\n            return hexChars.join(\'\');\n        },\n\n        /**\n         * Converts a hex string to a word array.\n         *\n         * @param {string} hexStr The hex string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n         */\n        parse: function (hexStr) {\n            // Shortcut\n            var hexStrLength = hexStr.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n\n            return new WordArray.init(words, hexStrLength / 2);\n        }\n    };\n\n    /**\n     * Latin1 encoding strategy.\n     */\n    var Latin1 = C_enc.Latin1 = {\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Latin1 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var latin1Chars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n\n            return latin1Chars.join(\'\');\n        },\n\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * @param {string} latin1Str The Latin1 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n         */\n        parse: function (latin1Str) {\n            // Shortcut\n            var latin1StrLength = latin1Str.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n\n            return new WordArray.init(words, latin1StrLength);\n        }\n    };\n\n    /**\n     * UTF-8 encoding strategy.\n     */\n    var Utf8 = C_enc.Utf8 = {\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The UTF-8 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            } catch (e) {\n                throw new Error(\'Malformed UTF-8 data\');\n            }\n        },\n\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * @param {string} utf8Str The UTF-8 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n         */\n        parse: function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        }\n    };\n\n    /**\n     * Abstract buffered block algorithm template.\n     *\n     * The property blockSize must be implemented in a concrete subtype.\n     *\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n     */\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n        /**\n         * Resets this block algorithm\'s data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        reset: function () {\n            // Initial values\n            this._data = new WordArray.init();\n            this._nDataBytes = 0;\n        },\n\n        /**\n         * Adds new data to this block algorithm\'s buffer.\n         *\n         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append(\'data\');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        _append: function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data == \'string\') {\n                data = Utf8.parse(data);\n            }\n\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        },\n\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {WordArray} The processed data.\n         *\n         * @example\n         *\n         *     var processedData = bufferedBlockAlgorithm._process();\n         *     var processedData = bufferedBlockAlgorithm._process(!!\'flush\');\n         */\n        _process: function (doFlush) {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n            var dataSigBytes = data.sigBytes;\n            var blockSize = this.blockSize;\n            var blockSizeBytes = blockSize * 4;\n\n            // Count blocks ready\n            var nBlocksReady = dataSigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            } else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n\n            // Count words ready\n            var nWordsReady = nBlocksReady * blockSize;\n\n            // Count bytes ready\n            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n            // Process blocks\n            if (nWordsReady) {\n                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                }\n\n                // Remove processed words\n                var processedWords = dataWords.splice(0, nWordsReady);\n                data.sigBytes -= nBytesReady;\n            }\n\n            // Return processed words\n            return new WordArray.init(processedWords, nBytesReady);\n        },\n\n        /**\n         * Creates a copy of this object.\n         *\n         * @return {Object} The clone.\n         *\n         * @example\n         *\n         *     var clone = bufferedBlockAlgorithm.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone._data = this._data.clone();\n\n            return clone;\n        },\n\n        _minBufferSize: 0\n    });\n\n    /**\n     * Abstract hasher template.\n     *\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n     */\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n        /**\n         * Configuration options.\n         */\n        cfg: Base.extend(),\n\n        /**\n         * Initializes a newly created hasher.\n         *\n         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n         *\n         * @example\n         *\n         *     var hasher = CryptoJS.algo.SHA256.create();\n         */\n        init: function (cfg) {\n            // Apply config defaults\n            this.cfg = this.cfg.extend(cfg);\n\n            // Set initial values\n            this.reset();\n        },\n\n        /**\n         * Resets this hasher to its initial state.\n         *\n         * @example\n         *\n         *     hasher.reset();\n         */\n        reset: function () {\n            // Reset data buffer\n            BufferedBlockAlgorithm.reset.call(this);\n\n            // Perform concrete-hasher logic\n            this._doReset();\n        },\n\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param {WordArray|string} messageUpdate The message to append.\n         *\n         * @return {Hasher} This hasher.\n         *\n         * @example\n         *\n         *     hasher.update(\'message\');\n         *     hasher.update(wordArray);\n         */\n        update: function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n\n            // Update the hash\n            this._process();\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n         *\n         * @return {WordArray} The hash.\n         *\n         * @example\n         *\n         *     var hash = hasher.finalize();\n         *     var hash = hasher.finalize(\'message\');\n         *     var hash = hasher.finalize(wordArray);\n         */\n        finalize: function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n\n            // Perform concrete-hasher logic\n            var hash = this._doFinalize();\n\n            return hash;\n        },\n\n        blockSize: 512/32,\n\n        /**\n         * Creates a shortcut function to a hasher\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to create a helper for.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n         */\n        _createHelper: function (hasher) {\n            return function (message, cfg) {\n                return new hasher.init(cfg).finalize(message);\n            };\n        },\n\n        /**\n         * Creates a shortcut function to the HMAC\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n         */\n        _createHmacHelper: function (hasher) {\n            return function (message, key) {\n                return new C_algo.HMAC.init(hasher, key).finalize(message);\n            };\n        }\n    });\n\n    /**\n     * Algorithm namespace.\n     */\n    var C_algo = C.algo = {};\n\n    return C;\n}(Math));\n\nmodule.exports = CryptoJS\n\n},{}],134:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Forwarding Entries\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\nvar Name = require(\'./name.js\').Name;\n\n/**\n * Create a new ForwardingEntry with the optional arguments.\n * @constructor\n * @param {String} action\n * @param {Name} prefixName\n * @param {PublisherPublicKeyDigest} ndndId\n * @param {number} faceID\n * @param {number} flags\n * @param {number} lifetime in seconds\n */\nvar ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime) \n{\n  this.action = action;\n  this.prefixName = prefixName;\n  this.ndndID = ndndId;\n  this.faceID = faceID;\n  this.flags = flags;\n  this.lifetime = lifetime;\n};\n\nexports.ForwardingEntry = ForwardingEntry;\n\nForwardingEntry.ACTIVE         = 1;\nForwardingEntry.CHILD_INHERIT  = 2;\nForwardingEntry.ADVERTISE      = 4;\nForwardingEntry.LAST           = 8;\nForwardingEntry.CAPTURE       = 16;\nForwardingEntry.LOCAL         = 32;\nForwardingEntry.TAP           = 64;\nForwardingEntry.CAPTURE_OK   = 128;\n\nForwardingEntry.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n  //throws DecodingException\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action); \n  if (decoder.peekDTag(NDNProtocolDTags.Name)) {\n    this.prefixName = new Name();\n    this.prefixName.from_ndnb(decoder) ;\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.NdndId = new PublisherPublicKeyDigest();\n    this.NdndId.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID); \n  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))\n    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\nForwardingEntry.prototype.to_ndnb = function(\n  //XMLEncoder \n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.prefixName)\n    this.prefixName.to_ndnb(encoder);\n  if (null != this.NdndId)\n    this.NdndId.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.flags)\n    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);\n  if (null != this.lifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);\n\n  encoder.writeElementClose();         \n};\n\nForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }\n\n},{"./name.js":95,"./publisher-public-key-digest.js":103,"./util/ndn-protoco-id-tags.js":137}],138:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.\nexports.TcpTransport = require(\'./transport/web-socket-transport.js\').WebSocketTransport;\n\n},{"./transport/web-socket-transport.js":158}],141:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents an NDN Data Signature object.\n */\n\nvar Blob = require(\'./util/blob.js\').Blob;\nvar BinaryXMLEncoder = require(\'./encoding/binary-xml-encoder.js\').BinaryXMLEncoder;\nvar BinaryXMLDecoder = require(\'./encoding/binary-xml-decoder.js\').BinaryXMLDecoder;\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar KeyLocator = require(\'./key-locator.js\').KeyLocator;\nvar customBuf = require(\'./buffer.js\').Buffer\nvar LOG = require(\'./log.js\').Log.LOG;\n\n/**\n * Create a new Signature with the optional values.\n * @constructor\n */\nvar Signature = function Signature(witnessOrSignatureObject, signature, digestAlgorithm) \n{\n  if (typeof witnessOrSignatureObject === \'object\' && \n      witnessOrSignatureObject instanceof Signature) {\n    // Copy the values.\n    this.keyLocator = new KeyLocator(witnessOrSignatureObject.keyLocator);\n    this.signature = witnessOrSignatureObject.signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject.witness;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = witnessOrSignatureObject.digestAlgorithm;\n  }\n  else {\n    this.keyLocator = new KeyLocator();\n    this.signature = signature;\n    // witness is deprecated.\n    this.witness = witnessOrSignatureObject;\n    // digestAlgorithm is deprecated.\n    this.digestAlgorithm = digestAlgorithm;\n  }\n};\n\nexports.Signature = Signature;\n\n/**\n * Create a new Signature which is a copy of this object.\n * @returns {Signature} A new object which is a copy of this object.\n */\nSignature.prototype.clone = function()\n{\n  return new Signature(this);\n};\n\n/**\n * Get the key locator.\n * @returns {KeyLocator} The key locator.\n */\nSignature.prototype.getKeyLocator = function()\n{\n  return this.keyLocator;\n};\n\n/**\n * Get the data packet\'s signature bytes.\n * @returns {Buffer} The signature bytes.\n */\nSignature.prototype.getSignature = function()\n{\n  return this.signature;\n};\n\n/**\n * Set the key locator to a copy of the given keyLocator.\n * @param {KeyLocator} keyLocator The KeyLocator to copy.\n */\nSignature.prototype.setKeyLocator = function(keyLocator)\n{\n  this.keyLocator = typeof keyLocator === \'object\' && keyLocator instanceof KeyLocator ?\n                    new KeyLocator(keyLocator) : new KeyLocator();\n};\n  \n/**\n * Set the data packet\'s signature bytes.\n * @param {type} signature\n */\nSignature.prototype.setSignature = function(signature)\n{\n  if (signature == null)\n    this.signature = null;\n  else if (typeof signature === \'object\' && signature instanceof Blob)\n    this.signature = new customBuf(signature.buf());\n  else\n    this.signature = new customBuf(signature);\n};\n\nSignature.prototype.from_ndnb = function(decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n    \n  if (LOG > 4) console.log(\'STARTED DECODING SIGNATURE\');\n    \n  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {\n    if (LOG > 4) console.log(\'DIGIEST ALGORITHM FOUND\');\n    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm); \n  }\n  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {\n    if (LOG > 4) console.log(\'WITNESS FOUND\');\n    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness); \n  }\n    \n  //FORCE TO READ A SIGNATURE\n\n  if (LOG > 4) console.log(\'SIGNATURE FOUND\');\n  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);\n\n  decoder.readElementClose();\n};\n\nSignature.prototype.to_ndnb = function(encoder) \n{      \n  if (!this.validate())\n    throw new Error("Cannot encode: field values missing.");\n  \n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))\n    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));\n  \n  if (null != this.witness)\n    // needs to handle null witness\n    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);\n\n  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);\n\n  encoder.writeElementClose();       \n};\n\nSignature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };\n\nSignature.prototype.validate = function() \n{\n  return null != this.signature;\n};\n\n})()\n},{"./buffer.js":116,"./encoding/binary-xml-decoder.js":135,"./encoding/binary-xml-encoder.js":136,"./key-locator.js":102,"./log.js":139,"./util/blob.js":111,"./util/ndn-protoco-id-tags.js":137}],142:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Publisher and PublisherType Objects\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNProtocolDTagsStrings = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTagsStrings;\nvar DecodingException = require(\'./encoding/decoding-exception.js\').DecodingException;\n\n/**\n * @constructor\n */\nvar PublisherType = function PublisherType(tag) \n{\n  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;\n  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;\n  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;\n  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  this.Tag = tag;\n}; \n\n/**\n * @constructor\n */\nvar PublisherID = function PublisherID() \n{\n  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";\n  this.PUBLISHER_ID_LEN = 256/8;\n    \n  //TODO, implement publisherID creation and key creation\n\n  //TODO implement generatePublicKeyDigest\n  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray\n    \n  //TODO implement generate key\n  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);\n  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type   \n};\n\nexports.PublisherID = PublisherID;\n\nPublisherID.prototype.from_ndnb = function(decoder) \n{    \n  // We have a choice here of one of 4 binary element types.\n  var nextTag = PublisherID.peekAndGetNextDTag(decoder);\n    \n  this.publisherType = new PublisherType(nextTag); \n    \n  if (nextTag < 0)\n    throw new Error("Invalid publisher ID, got unexpected type");\n\n  this.publisherID = decoder.readBinaryDTagElement(nextTag);\n  if (null == this.publisherID)\n    throw new DecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));\n};\n\nPublisherID.prototype.to_ndnb = function(encoder) \n{\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);\n};\n\n/**\n * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.\n * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.\n * @returns {number} The PublisherID DTag or -1 if it is not one of them.\n */\nPublisherID.peekAndGetNextDTag = function(decoder) \n{\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))\n    return             NDNProtocolDTags.PublisherPublicKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))\n    return             NDNProtocolDTags.PublisherCertificateDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))\n    return             NDNProtocolDTags.PublisherIssuerKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))\n    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;\n  \n  return -1;\n};\n  \nPublisherID.peek = function(/* XMLDecoder */ decoder) \n{\n  return PublisherID.peekAndGetNextDTag(decoder) >= 0;\n};\n\nPublisherID.prototype.getElementLabel = function()\n{ \n  return this.publisherType.Tag;\n};\n\nPublisherID.prototype.validate = function() \n{\n  return null != id() && null != type();\n};\n\n},{"./encoding/decoding-exception.js":153,"./util/ndn-protoco-id-tags.js":137}],133:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar ElementReader = require(\'../encoding/element-reader.js\').ElementReader;\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n\nfunction makeShuffledGetHostAndPort (hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n\n/**\n * @constructor\n */\nvar WebSocketTransport = function WebSocketTransport() \n{    \n  if (!WebSocket)\n    throw new Error("WebSocket support is not available on this platform.");\n    \n  this.ws = null;\n  this.connectedHost = null; // Read by Face.\n  this.connectedPort = null; // Read by Face.\n  this.elementReader = null;\n  this.defaultGetHostAndPort = makeShuffledGetHostAndPort\n    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu", \n      "E.ws.ndn.ucla.edu", "F.ws.ndn.ucla.edu", "G.ws.ndn.ucla.edu", "H.ws.ndn.ucla.edu", \n      "I.ws.ndn.ucla.edu", "J.ws.ndn.ucla.edu", "K.ws.ndn.ucla.edu", "L.ws.ndn.ucla.edu", \n      "M.ws.ndn.ucla.edu", "N.ws.ndn.ucla.edu"],\n     9696);\n};\n\nexports.WebSocketTransport = WebSocketTransport;\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nWebSocketTransport.prototype.connect = function(face, onopenCallback) \n{\n  this.close();\n  \n  this.ws = new WebSocket(\'ws:\' + face.host + \':\' + face.port);\n  if (LOG > 0) console.log(\'ws connection created.\');\n    this.connectedHost = face.host;\n    this.connectedPort = face.port;\n  \n  this.ws.binaryType = "arraybuffer";\n  \n  this.elementReader = new ElementReader(face);\n  var self = this;\n  this.ws.onmessage = function(ev) {\n    var result = ev.data;\n    //console.log(\'RecvHandle called.\');\n      \n    if (result == null || result == undefined || result == "") {\n      console.log(\'INVALID ANSWER\');\n    } \n    else if (result instanceof ArrayBuffer) {\n      var bytearray = new customBuf(result);\n          \n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n      \n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n    }\n  }\n  \n  this.ws.onopen = function(ev) {\n    if (LOG > 3) console.log(ev);\n    if (LOG > 3) console.log(\'ws.onopen: WebSocket connection opened.\');\n    if (LOG > 3) console.log(\'ws.onopen: ReadyState: \' + this.readyState);\n    // Face.registerPrefix will fetch the ndndid when needed.\n\n    onopenCallback();\n  }\n  \n  this.ws.onerror = function(ev) {\n    console.log(\'ws.onerror: ReadyState: \' + this.readyState);\n    console.log(ev);\n    console.log(\'ws.onerror: WebSocket error: \' + ev.data);\n  }\n  \n  this.ws.onclose = function(ev) {\n    console.log(\'ws.onclose: WebSocket connection closed.\');\n    self.ws = null;\n    \n    // Close Face when WebSocket is closed\n    face.readyStatus = 2; //Face.CLOSED\n    face.onclose();\n    //console.log("NDN.onclose event fired.");\n  }\n};\n\n/**\n * Send the Uint8Array data.\n */\nWebSocketTransport.prototype.send = function(data) \n{\n  if (this.ws != null) {\n    // If we directly use data.buffer to feed ws.send(), \n    // WebSocket may end up sending a packet with 10000 bytes of data.\n    // That is, WebSocket will flush the entire buffer\n    // regardless of the offset of the Uint8Array. So we have to create\n    // a new Uint8Array buffer with just the right size and copy the \n    // content from binaryInterest to the new buffer.\n    //    ---Wentao\n    var bytearray = new Uint8Array(data.length);\n    bytearray.set(data);\n    this.ws.send(bytearray.buffer);\n    if (LOG > 3) console.log(\'ws.send() returned.\');\n  }\n  else\n    console.log(\'WebSocket connection is not established.\');\n};\n\n/**\n * Close the connection.\n */\nWebSocketTransport.prototype.close = function()\n{\n  if (this.ws != null)\n    delete this.ws;\n}\n\n\n})()\n},{"../buffer.js":54,"../encoding/data-utils.js":47,"../encoding/element-reader.js":53,"../log.js":89}],135:[function(require,module,exports){\n(function(){/**\n * This class is used to decode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar NDNTime = require(\'../util/ndn-time.js\').NDNTime;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n  \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n\n\n//returns a string\ntagToString = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {\n    return NDNProtocolDTagsStrings[tagVal];\n  } \n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  }\n  \n  return null;\n};\n\n//returns a Long\nstringToTag =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n  }\n  \n  return null;\n};\n\n/**\n * @constructor\n */\nvar BinaryXMLDecoder = function BinaryXMLDecoder(input) \n{\n  var MARK_LEN=512;\n  var DEBUG_MAX_LEN =  32768;\n  \n  this.input = input;\n  this.offset = 0;\n  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.\n  this.previouslyPeekedDTagStartOffset = -1;\n};\n\nexports.BinaryXMLDecoder = BinaryXMLDecoder;\n\n/**\n * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.\n   * Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n */\nBinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset) {\n    // peekDTag already decoded this DTag.\n    if (this.previouslyPeekedDTag != expectedTag)\n      throw new DecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));\n\n    // Fast forward past the header.\n    this.offset = this.previouslyPeekedDTagEndOffset;\n  }\n  else {\n    var typeAndValue = this.decodeTypeAndVal();\n    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)\n      throw new DecodingException(new Error("Header type is not a DTAG"));\n\n    if (typeAndValue.val() != expectedTag)\n      throw new DecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));\n  }  \n};\n\n/**\n * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readStartElement = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes)\n{\n  //TypeAndVal \n  var tv = this.decodeTypeAndVal();\n      \n  if (null == tv)\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));\n      \n  //String \n  var decodedTag = null;\n      \n  if (tv.type() == XML_TAG) {\n    // Tag value represents length-1 as tags can never be empty.\n    var valval;\n        \n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val())) + 1;\n    else\n      valval = (tv.val())+ 1;\n        \n    decodedTag = this.decodeUString(valval);\n  } \n  else if (tv.type() == XML_DTAG)\n    decodedTag = tv.val();\n      \n  if (null ==  decodedTag || decodedTag != startTag) {\n    console.log(\'expecting \'+ startTag + \' but got \'+ decodedTag);\n    throw new DecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));\n  }\n      \n  // DKS: does not read attributes out of stream if caller doesn\'t\n  // ask for them. Should possibly peek and skip over them regardless.\n  // TODO: fix this\n  if (null != attributes)\n    readAttributes(attributes); \n};\n  \n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readAttributes = function(\n  // array of [attributeName, attributeValue] \n  attributes) \n{\n  if (null == attributes)\n    return;\n\n  try {\n    // Now need to get attributes.\n    //TypeAndVal \n    var nextTV = this.peekTypeAndVal();\n\n    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {\n      // Decode this attribute. First, really read the type and value.\n      //this.TypeAndVal \n      var thisTV = this.decodeTypeAndVal();\n\n      //String \n      var attributeName = null;\n      if (XML_ATTR == thisTV.type()) {\n        // Tag value represents length-1 as attribute names cannot be empty.\n        var valval ;\n        if (typeof thisTV.val() == \'string\')\n          valval = (parseInt(thisTV.val())) + 1;\n        else\n          valval = (thisTV.val())+ 1;\n        \n        attributeName = this.decodeUString(valval);\n      } \n      else if (XML_DATTR == thisTV.type()) {\n        // DKS TODO are attributes same or different dictionary?\n        attributeName = tagToString(thisTV.val());\n        if (null == attributeName)\n          throw new DecodingException(new Error("Unknown DATTR value" + thisTV.val()));\n      }\n      \n      // Attribute values are always UDATA\n      //String\n      var attributeValue = this.decodeUString();\n\n      attributes.push([attributeName, attributeValue]);\n      nextTV = this.peekTypeAndVal();\n    }\n  } \n  catch (e) {\n    throw new DecodingException(new Error("readStartElement", e));\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsString = function() \n{\n  //String \n  var decodedTag = null;\n  var previousOffset = this.offset;\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal \n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        // Tag value represents length-1 as tags can never be empty.\n        var valval ;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        decodedTag = this.decodeUString(valval);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tagToString(tv.val());          \n    } // else, not a type and val, probably an end element. rewind and return false.\n  } \n  catch (e) {\n  } \n  finally {\n    try {\n      this.offset = previousOffset;\n    } \n    catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new DecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,\n * then set return true.  Do not update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {boolean} True if the tag is the expected tag, otherwise false.\n */\nBinaryXMLDecoder.prototype.peekDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset)\n    // We already decoded this DTag.\n    return this.previouslyPeekedDTag == expectedTag;\n  else {\n    // First check if it is an element close (which cannot be the expected tag).  \n    if (this.input[this.offset] == XML_CLOSE)\n      return false;\n\n    var saveOffset = this.offset;\n    var typeAndValue = this.decodeTypeAndVal();\n    // readElementStartDTag will use this to fast forward.\n    this.previouslyPeekedDTagEndOffset = this.offset;\n    // Restore the position.\n    this.offset = saveOffset;\n\n    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {\n      this.previouslyPeekedDTagStartOffset = saveOffset;\n      this.previouslyPeekedDTag = typeAndValue.val();\n\n      return typeAndValue.val() == expectedTag;\n    }\n    else\n      return false;\n  }  \n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElement = function(\n    //String \n    startTag) \n{\n  //String \n  if (typeof startTag == \'string\') {\n    var decodedTag = this.peekStartElementAsString();\n    \n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else if (typeof startTag == \'number\') {\n    var decodedTag = this.peekStartElementAsLong();\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else\n    throw new DecodingException(new Error("SHOULD BE STRING OR NUMBER"));\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsLong = function() \n{\n  //Long\n  var decodedTag = null;    \n  var previousOffset = this.offset;\n  \n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        if (tv.val() + 1 > DEBUG_MAX_LEN)\n          throw new DecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));\n\n        var valval;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n        \n        // Tag value represents length-1 as tags can never be empty.\n        //String \n        var strTag = this.decodeUString(valval);\n        \n        decodedTag = stringToTag(strTag);\n      } \n      else if (tv.type() == XML_DTAG)\n        decodedTag = tv.val();          \n    } // else, not a type and val, probably an end element. rewind and return false.\n\n  } \n  catch (e) {  \n  } \n  finally {\n    try {\n      //this.input.reset();\n      this.offset = previousOffset;\n    } catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new Error("Cannot reset stream! " + e.getMessage(), e);\n    }\n  }\n  \n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a \n * customBuf. However, if allowNull is true, then the item may be absent.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @param {boolean} allowNull True if the binary item may be missing.\n * @returns {Buffer} A customBuf which is a slice on the data inside the input buffer. However, \n * if allowNull is true and the binary data item is absent, then return null.\n */\nBinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readBinaryElement = function(\n    //long \n    startTag,\n    //TreeMap<String, String> \n    attributes,\n    //boolean\n    allowNull) \n{\n  this.readStartElement(startTag, attributes);\n  return this.readBlob(allowNull);  \n};\n\n/**\n * Read one byte from the input starting at its offset, expecting it to be the element close.\n * Update the input\'s offset.\n */\nBinaryXMLDecoder.prototype.readElementClose = function() \n{\n  var next = this.input[this.offset++];     \n  if (next != XML_CLOSE)\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n};\n\n/**\n * @deprecated Use readElementClose.\n */\nBinaryXMLDecoder.prototype.readEndElement = function() \n{\n  if (LOG > 4) console.log(\'this.offset is \'+this.offset);\n  \n  var next = this.input[this.offset]; \n  \n  this.offset++;\n  \n  if (LOG > 4) console.log(\'XML_CLOSE IS \'+XML_CLOSE);\n  if (LOG > 4) console.log(\'next is \'+next);\n  \n  if (next != XML_CLOSE) {\n    console.log("Expected end element, got: " + next);\n    throw new DecodingException(new Error("Expected end element, got: " + next));\n  }\n};\n\n//String  \nBinaryXMLDecoder.prototype.readUString = function() \n{\n  //String \n  var ustring = this.decodeUString();  \n  this.readElementClose();\n  return ustring;\n};\n  \n/**\n * Read a blob as well as the end element. Returns a customBuf (or null for missing blob).\n * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,\n *   just read the end element and return null.\n */\nBinaryXMLDecoder.prototype.readBlob = function(allowNull) \n{\n  if (this.input[this.offset] == XML_CLOSE && allowNull) {\n    this.readElementClose();\n    return null;\n  }\n    \n  var blob = this.decodeBlob();  \n  this.readElementClose();\n  return blob;\n};\n\n/**\n * Decode the header from the input starting at its offset, expecting the type to be \n * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned \n * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {NDNTime} The dateTime value.\n */\nBinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)  \n{\n  var byteTimestamp = this.readBinaryDTagElement(expectedTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\n/**\n * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readDateTime = function(\n  //long \n  startTag)  \n{\n  var byteTimestamp = this.readBinaryElement(startTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n  \n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  if (LOG > 4) console.log(\'DECODED DATE WITH VALUE\');\n  if (LOG > 4) console.log(lontimestamp);\n  \n  //NDNTime \n  var timestamp = new NDNTime(lontimestamp);  \n  if (null == timestamp)\n    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\nBinaryXMLDecoder.prototype.decodeTypeAndVal = function() \n{\n  \n  /*int*/ var type = -1;\n  /*long*/ var val = 0;\n  /*boolean*/ var more = true;\n\n  do {\n    var next = this.input[this.offset ];\n    if (next == null)\n      // Quit the loop.\n      return null; \n    \n    if (next < 0)\n      return null; \n\n    if (0 == next && 0 == val)\n      return null;\n    \n    more = (0 == (next & XML_TT_NO_MORE));\n    \n    if  (more) {\n      val = val << XML_REG_VAL_BITS;\n      val |= (next & XML_REG_VAL_MASK);\n    } \n    else {\n      type = next & XML_TT_MASK;\n      val = val << XML_TT_VAL_BITS;\n      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);\n    }\n    \n    this.offset++;\n  } while (more);\n  \n  if (LOG > 4) console.log(\'TYPE is \'+ type + \' VAL is \'+ val);\n\n  return new TypeAndVal(type, val);\n};\n\n//TypeAndVal\nBinaryXMLDecoder.prototype.peekTypeAndVal = function() \n{\n  //TypeAndVal \n  var tv = null;\n  var previousOffset = this.offset;\n  \n  try {\n    tv = this.decodeTypeAndVal();\n  } \n  finally {\n    this.offset = previousOffset;\n  }\n  \n  return tv;\n};\n\n//Buffer\nBinaryXMLDecoder.prototype.decodeBlob = function(\n    //int \n    blobLength) \n{  \n  if (null == blobLength) {\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    var valval ;\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val()));\n    else\n      valval = (tv.val());\n    \n    return this.decodeBlob(valval);\n  }\n  \n  //Buffer\n  var bytes = new customBuf(this.input.slice(this.offset, this.offset+ blobLength));\n  this.offset += blobLength;\n  \n  return bytes;\n};\n\n//String\nBinaryXMLDecoder.prototype.decodeUString = function(\n    //int \n    byteLength) \n{\n  if (null == byteLength) {\n    var tempStreamPosition = this.offset;\n      \n    //TypeAndVal \n    var tv = this.decodeTypeAndVal();\n    \n    if (LOG > 4) console.log(\'TV is \'+tv);\n    if (LOG > 4) console.log(tv);\n    \n    if (LOG > 4) console.log(\'Type of TV is \'+typeof tv);\n  \n    // if we just have closers left, will get back null\n    if (null == tv || XML_UDATA != tv.type()) {\n      this.offset = tempStreamPosition;      \n      return "";\n    }\n      \n    return this.decodeUString(tv.val());\n  }\n  else {\n    //Buffer \n    var stringBytes = this.decodeBlob(byteLength);\n    \n    // TODO: Should this parse as UTF8?\n    return DataUtils.toString(stringBytes);    \n  }\n};\n\n//OBject containg a pair of type and value\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.t = _type;\n  this.v = _val;\n};\n\nTypeAndVal.prototype.type = function() \n{\n  return this.t;\n};\n\nTypeAndVal.prototype.val = function() \n{\n  return this.v;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {number} The parsed integer.\n */\nBinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)\n{\n  return parseInt(this.readUTF8DTagElement(expectedTag));\n};\n\n/**\n * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readIntegerElement = function(\n  //String \n  startTag) \n{\n  //String \n  if (LOG > 4) console.log(\'READING INTEGER \'+ startTag);\n  if (LOG > 4) console.log(\'TYPE OF \'+ typeof startTag);\n  \n  var strVal = this.readUTF8Element(startTag);\n  \n  return parseInt(strVal);\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item and return a string. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {string} The UDATA string.\n */\nBinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readUString();;\n};\n\n/**\n * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readUTF8Element = function(\n    //String \n    startTag,\n    //TreeMap<String, String> \n    attributes) \n{\n  //throws Error where name == "DecodingException" \n\n  // can\'t use getElementText, can\'t get attributes\n  this.readStartElement(startTag, attributes);\n  //String \n  var strElementText = this.readUString();\n  return strElementText;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nBinaryXMLDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n})()\n},{"../buffer.js":116,"../log.js":139,"../util/ndn-protoco-id-tags.js":137,"../util/ndn-time.js":113,"./data-utils.js":109,"./decoding-exception.js":153}],136:[function(require,module,exports){\n(function(){/**\n * This class is used to encode ndnb binary elements (blob, type/value pairs).\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar NDNProtocolDTags = require(\'../util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\nvar DataUtils = require(\'./data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\nvar XML_EXT = 0x00; \n  \nvar XML_TAG = 0x01; \n  \nvar XML_DTAG = 0x02; \n  \nvar XML_ATTR = 0x03; \n \nvar XML_DATTR = 0x04; \n  \nvar XML_BLOB = 0x05; \n  \nvar XML_UDATA = 0x06; \n  \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n  \nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n/**\n * @constructor\n */\nvar BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength) \n{\n  if (!initiaLength)\n    initiaLength = 16;\n  \n  this.ostream = new DynamicBuffer(initiaLength);\n  this.offset = 0;\n  this.CODEC_NAME = "Binary";\n};\n\nexports.BinaryXMLEncoder = BinaryXMLEncoder;\n\n/**\n * Encode utf8Content as utf8 and write to the output buffer as a UDATA.\n * @param {string} utf8Content The string to convert to utf8.\n */\nBinaryXMLEncoder.prototype.writeUString = function(utf8Content) \n{\n  this.encodeUString(utf8Content, XML_UDATA);\n};\n\nBinaryXMLEncoder.prototype.writeBlob = function(\n    /*Buffer*/ binaryContent) \n{  \n  if (LOG >3) console.log(binaryContent);\n  \n  this.encodeBlob(binaryContent, binaryContent.length);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer.\n * @param {number} tag The DTAG tag.\n */\nBinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)\n{\n  this.encodeTypeAndVal(XML_DTAG, tag);\n};\n\n/**\n * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeStartElement = function(\n  /*String*/ tag, \n  /*TreeMap<String,String>*/ attributes) \n{\n  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);\n  \n  if (null == dictionaryVal)\n    this.encodeUString(tag, XML_TAG);\n  else\n    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);\n  \n  if (null != attributes)\n    this.writeAttributes(attributes); \n};\n\n/**\n * Write an element close to the output buffer.\n */\nBinaryXMLEncoder.prototype.writeElementClose = function() \n{\n  this.ostream.ensureLength(this.offset + 1);\n  this.ostream.array[this.offset] = XML_CLOSE;\n  this.offset += 1;\n};\n\n/**\n * @deprecated Use writeElementClose.\n */\nBinaryXMLEncoder.prototype.writeEndElement = function() \n{\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes) \n{\n  if (null == attributes)\n    return;\n\n  // the keySet of a TreeMap is sorted.\n\n  for (var i = 0; i< attributes.length;i++) {\n    var strAttr = attributes[i].k;\n    var strValue = attributes[i].v;\n\n    var dictionaryAttr = stringToTag(strAttr);\n    if (null == dictionaryAttr)\n      // not in dictionary, encode as attr\n      // compressed format wants length of tag represented as length-1\n      // to save that extra bit, as tag cannot be 0 length.\n      // encodeUString knows to do that.\n      this.encodeUString(strAttr, XML_ATTR);\n    else\n      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);\n\n    // Write value\n    this.encodeUString(strValue);    \n  }\n};\n\n//returns a string\nstringToTag = function(/*long*/ tagVal) \n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)\n    return NDNProtocolDTagsStrings[tagVal];\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  \n  return null;\n};\n\n//returns a Long\ntagToString =  function(/*String*/ tagName) \n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  \n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n\n  return null;\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the content as explained below, \n * then an element close.\n * @param {number} tag The DTAG tag.\n * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,\n * call writeUString.  Otherwise, call writeBlob.\n */\nBinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)\n{\n  this.writeElementStartDTag(tag);\n  \n  if (typeof content === \'number\')\n    this.writeUString(content.toString());\n  else if (typeof content === \'string\')\n    this.writeUString(content);\n  else\n    this.writeBlob(content);\n  \n  this.writeElementClose();\n};\n\n/**\n * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n * If Content is a string, then encode as utf8 and write UDATA.\n */\nBinaryXMLEncoder.prototype.writeElement = function(\n    //long \n    tag, \n    //byte[] \n    Content,\n    //TreeMap<String, String> \n    attributes) \n{\n  this.writeStartElement(tag, attributes);\n  // Will omit if 0-length\n  \n  if (typeof Content === \'number\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER .charCodeAt(0) \' + Content.toString().charCodeAt(0));\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER \' + Content.toString());\n    if (LOG > 4) console.log(\'type of number is \' + typeof Content.toString());\n    \n    this.writeUString(Content.toString());\n  }\n  else if (typeof Content === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE STRING  \' + Content);\n    if (LOG > 4) console.log(\'type of STRING is \' + typeof Content);\n    \n    this.writeUString(Content);\n  }\n  else {\n    if (LOG > 4) console.log(\'GOING TO WRITE A BLOB  \' + Content);\n\n    this.writeBlob(Content);\n  }\n  \n  this.writeElementClose();\n};\n\nvar TypeAndVal = function TypeAndVal(_type,_val) \n{\n  this.type = _type;\n  this.val = _val;  \n};\n\nBinaryXMLEncoder.prototype.encodeTypeAndVal = function(\n    //int\n    type, \n    //long \n    val) \n{  \n  if (LOG > 4) console.log(\'Encoding type \'+ type+ \' and value \'+ val);\n  \n  if (LOG > 4) console.log(\'OFFSET IS \' + this.offset);\n  \n  if (type > XML_UDATA || type < 0 || val < 0)\n    throw new Error("Tag and value must be positive, and tag valid.");\n  \n  // Encode backwards. Calculate how many bytes we need:\n  var numEncodingBytes = this.numEncodingBytes(val);\n  this.ostream.ensureLength(this.offset + numEncodingBytes);\n\n  // Bottom 4 bits of val go in last byte with tag.\n  this.ostream.array[this.offset + numEncodingBytes - 1] = \n    //(byte)\n      (BYTE_MASK &\n          (((XML_TT_MASK & type) | \n           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n           XML_TT_NO_MORE); // set top bit for last byte\n  val = val >>> XML_TT_VAL_BITS;\n  \n  // Rest of val goes into preceding bytes, 7 bits per byte, top bit\n  // is "more" flag.\n  var i = this.offset + numEncodingBytes - 2;\n  while (0 != val && i >= this.offset) {\n    this.ostream.array[i] = //(byte)\n        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset\n    val = val >>> XML_REG_VAL_BITS;\n    --i;\n  }\n  \n  if (val != 0)\n    throw new Error("This should not happen: miscalculated encoding");\n\n  this.offset+= numEncodingBytes;\n  \n  return numEncodingBytes;\n};\n\n/**\n * Encode ustring as utf8.\n */\nBinaryXMLEncoder.prototype.encodeUString = function(\n    //String \n    ustring, \n    //byte \n    type) \n{  \n  if (null == ustring)\n    return;\n  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)\n    return;\n  \n  if (LOG > 3) console.log("The string to write is ");\n  if (LOG > 3) console.log(ustring);\n\n  var strBytes = DataUtils.stringToUtf8Array(ustring);\n  \n  this.encodeTypeAndVal(type, \n            (((type == XML_TAG) || (type == XML_ATTR)) ?\n                (strBytes.length-1) :\n                strBytes.length));\n  \n  if (LOG > 3) console.log("THE string to write is ");\n  \n  if (LOG > 3) console.log(strBytes);\n  \n  this.writeString(strBytes);\n  this.offset+= strBytes.length;\n};\n\n\nBinaryXMLEncoder.prototype.encodeBlob = function(\n    //Buffer \n    blob, \n    //int \n    length) \n{\n  if (null == blob)\n    return;\n  \n  if (LOG > 4) console.log(\'LENGTH OF XML_BLOB IS \'+length);\n  \n  this.encodeTypeAndVal(XML_BLOB, length);\n  this.writeBlobArray(blob);\n  this.offset += length;\n};\n\nvar ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);\n\nBinaryXMLEncoder.prototype.numEncodingBytes = function(\n    //long\n    x) \n{\n  if (x <= ENCODING_LIMIT_1_BYTE) return (1);\n  if (x <= ENCODING_LIMIT_2_BYTES) return (2);\n  if (x <= ENCODING_LIMIT_3_BYTES) return (3);\n  \n  var numbytes = 1;\n  \n  // Last byte gives you XML_TT_VAL_BITS\n  // Remainder each give you XML_REG_VAL_BITS\n  x = x >>> XML_TT_VAL_BITS;\n  while (x != 0) {\n        numbytes++;\n    x = x >>> XML_REG_VAL_BITS;\n  }\n  return (numbytes);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output buffer, then the dateTime\n   * as a big endian BLOB converted to 4096 ticks per second, then an element close.\n * @param {number} tag The DTAG tag.\n * @param {NDNTime} dateTime\n */\nBinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)\n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n/**\n * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and \n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeDateTime = function(\n    //String \n    tag, \n    //NDNTime \n    dateTime) \n{  \n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n// This does not update this.offset.\nBinaryXMLEncoder.prototype.writeString = function(input) \n{\n  if (typeof input === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING\');\n    if (LOG > 4) console.log(input);\n        \n    this.ostream.ensureLength(this.offset + input.length);\n    for (var i = 0; i < input.length; i++) {\n      if (LOG > 4) console.log(\'input.charCodeAt(i)=\' + input.charCodeAt(i));\n      this.ostream.array[this.offset + i] = (input.charCodeAt(i));\n    }\n  }\n  else\n  {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING IN BINARY FORM\');\n    if (LOG > 4) console.log(input);\n    \n    this.writeBlobArray(input);\n  }\n};\n\nBinaryXMLEncoder.prototype.writeBlobArray = function(\n    //Buffer \n    blob) \n{  \n  if (LOG > 4) console.log(\'GOING TO WRITE A BLOB\');\n    \n  this.ostream.copy(blob, this.offset);\n};\n\nBinaryXMLEncoder.prototype.getReducedOstream = function() \n{\n  return this.ostream.slice(0, this.offset);\n};\n\n})()\n},{"../buffer.js":116,"../log.js":139,"../util/dynamic-buffer.js":159,"../util/ndn-protoco-id-tags.js":137,"./data-utils.js":109}],140:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\nvar Blob = require(\'./blob.js\').Blob;\n\n/**\n * A SignedBlob extends Blob to keep the offsets of a signed portion (e.g., the \n * bytes of Data packet). This inherits from Blob, including Blob.size and Blob.buf.\n * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take \n * another pointer to the customBuf without copying. If value is a customBuf or byte \n * array, copy to create a new customBuf.  If omitted, buf() will return null.\n * @param {number} signedPortionBeginOffset (optional) The offset in the \n * encoding of the beginning of the signed portion. If omitted, set to 0.\n * @param {number} signedPortionEndOffset (optional) The offset in the encoding \n * of the end of the signed portion. If omitted, set to 0.\n */\nvar SignedBlob = function SignedBlob(value, signedPortionBeginOffset, signedPortionEndOffset) \n{\n  // Call the base constructor.\n  Blob.call(this, value);\n  \n  if (this.buffer == null) {\n    this.signedPortionBeginOffset = 0;\n    this.signedPortionEndOffset = 0;\n  }\n  else if (typeof value === \'object\' && value instanceof SignedBlob) {\n    // Copy the SignedBlob, allowing override for offsets.\n    this.signedPortionBeginOffset = signedPortionBeginOffset == null ? \n      value.signedPortionBeginOffset : signedPortionBeginOffset;\n    this.signedPortionEndOffset = signedPortionEndOffset == null ? \n      value.signedPortionEndOffset : signedPortionEndOffset;\n  }\n  else {\n    this.signedPortionBeginOffset = signedPortionBeginOffset || 0;\n    this.signedPortionEndOffset = signedPortionEndOffset || 0;\n  }\n  \n  if (this.buffer == null)\n    this.signedBuffer = null;\n  else\n    this.signedBuffer = this.buffer.slice\n      (this.signedPortionBeginOffset, this.signedPortionEndOffset);\n};\n\nSignedBlob.prototype = new Blob();\nSignedBlob.prototype.name = "SignedBlob";\n\nexports.SignedBlob = SignedBlob;\n\n/**\n * Return the length of the signed portion of the immutable byte array.\n * @returns {number} The length of the signed portion.  If signedBuf() is null, \n * return 0.\n */\nSignedBlob.prototype.signedSize = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer.length;\n  else\n    return 0;\n};\n\n/**\n * Return a the signed portion of the immutable byte array.\n * @returns {Buffer} A slice into the customBuf which is the signed portion.  \n * If the pointer to the array is null, return null.\n */\nSignedBlob.prototype.signedBuf = function()\n{\n  if (this.signedBuffer != null)\n    return this.signedBuffer;\n  else\n    return null;\n};\n\n/**\n * Return the offset in the array of the beginning of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionBeginOffset = function()\n{\n  return this.signedPortionBeginOffset;\n};\n\n/**\n * Return the offset in the array of the end of the signed portion.\n * @returns {number} The offset in the array.\n */\nSignedBlob.prototype.getSignedPortionEndOffset = function()\n{\n  return this.signedPortionEndOffset;\n};\n\n})()\n},{"../buffer.js":116,"./blob.js":111}],149:[function(require,module,exports){\n/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Face Instances\n */\n\nvar NDNProtocolDTags = require(\'./util/ndn-protoco-id-tags.js\').NDNProtocolDTags;\nvar PublisherPublicKeyDigest = require(\'./publisher-public-key-digest.js\').PublisherPublicKeyDigest;\n\n/**\n * @constructor\n */\nvar FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,\n    multicastTTL, freshnessSeconds) \n{\n  this.action = action;\n  this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n  this.faceID = faceID;\n  this.ipProto = ipProto;\n  this.host = host;\n  this.Port = port;\n  this.multicastInterface =multicastInterface;\n  this.multicastTTL =multicastTTL;\n  this.freshnessSeconds = freshnessSeconds;\n};\n\nexports.FaceInstance = FaceInstance;\n\nFaceInstance.NetworkProtocol = { TCP:6, UDP:17};\n\n/**\n * Used by NetworkObject to decode the object from a network stream.\n */\nFaceInstance.prototype.from_ndnb = function(\n  //XMLDecoder \n  decoder) \n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Action))   \n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    this.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {\n    //int\n    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);\n    \n    this.ipProto = null;\n    \n    if (FaceInstance.NetworkProtocol.TCP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.TCP;\n    else if (FaceInstance.NetworkProtocol.UDP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.UDP;\n    else\n      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);\n  }\n  \n  if (decoder.peekDTag(NDNProtocolDTags.Host))\n    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);\n  if (decoder.peekDTag(NDNProtocolDTags.Port))\n    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))\n    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface); \n  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))\n    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL); \n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); \n\n  decoder.readElementClose();\n};\n\n/**\n * Used by NetworkObject to encode the object to a network stream.\n */\nFaceInstance.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder) \n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  \n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  \n  if (null != this.publisherPublicKeyDigest)\n    this.publisherPublicKeyDigest.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.ipProto)\n    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);\n  if (null != this.host && this.host.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);  \n  if (null != this.Port)\n    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);\n  if (null != this.multicastInterface && this.multicastInterface.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);\n  if (null !=  this.multicastTTL)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  encoder.writeElementClose();         \n};\n\nFaceInstance.prototype.getElementLabel = function() \n{\n  return NDNProtocolDTags.FaceInstance;\n};\n\n\n},{"./publisher-public-key-digest.js":103,"./util/ndn-protoco-id-tags.js":137}],67:[function(require,module,exports){\n/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// asn1hex.js - Hexadecimal represented ASN.1 string library\n//\n// version: 1.1 (09-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n//\n// Depends on:\n//\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n// MEMO:\n//   f(\'3082025b02...\', 2) ... 82025b ... 3bytes\n//   f(\'020100\', 2) ... 01 ... 1byte\n//   f(\'0203001...\', 2) ... 03 ... 1byte\n//   f(\'02818003...\', 2) ... 8180 ... 2bytes\n//   f(\'3080....0000\', 2) ... 80 ... -1\n//\n//   Requirements:\n//   - ASN.1 type octet length MUST be 1. \n//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)\n//   - \n\n/**\n * @fileOverview\n * @name asn1hex-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * get byte length for ASN.1 L(length) bytes\n * @name getByteLengthOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return byte length for ASN.1 L(length) bytes\n */\nfunction _asnhex_getByteLengthOfL_AtObj(s, pos) {\n  if (s.substring(pos + 2, pos + 3) != \'8\') return 1;\n  var i = parseInt(s.substring(pos + 3, pos + 4));\n  if (i == 0) return -1; \t\t// length octet \'80\' indefinite length\n  if (0 < i && i < 10) return i + 1;\t// including \'8?\' octet;\n  return -2;\t\t\t\t// malformed format\n}\n\n\n/**\n * get hexadecimal string for ASN.1 L(length) bytes\n * @name getHexOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string for ASN.1 L(length) bytes\n */\nfunction _asnhex_getHexOfL_AtObj(s, pos) {\n  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (len < 1) return \'\';\n  return s.substring(pos + 2, pos + 2 + len * 2);\n}\n\n//\n//   getting ASN.1 length value at the position \'idx\' of\n//   hexa decimal string \'s\'.\n//\n//   f(\'3082025b02...\', 0) ... 82025b ... ???\n//   f(\'020100\', 0) ... 01 ... 1\n//   f(\'0203001...\', 0) ... 03 ... 3\n//   f(\'02818003...\', 0) ... 8180 ... 128\n/**\n * get integer value of ASN.1 length for ASN.1 data\n * @name getIntOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return ASN.1 L(length) integer value\n */\nfunction _asnhex_getIntOfL_AtObj(s, pos) {\n  var hLength = _asnhex_getHexOfL_AtObj(s, pos);\n  if (hLength == \'\') return -1;\n  var bi;\n  if (parseInt(hLength.substring(0, 1)) < 8) {\n     bi = parseBigInt(hLength, 16);\n  } else {\n     bi = parseBigInt(hLength.substring(2), 16);\n  }\n  return bi.intValue();\n}\n\n/**\n * get ASN.1 value starting string position for ASN.1 object refered by index \'idx\'.\n * @name getStartPosOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n */\nfunction _asnhex_getStartPosOfV_AtObj(s, pos) {\n  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (l_len < 0) return l_len;\n  return pos + (l_len + 1) * 2;\n}\n\n/**\n * get hexadecimal string of ASN.1 V(value)\n * @name getHexOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 value.\n */\nfunction _asnhex_getHexOfV_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return s.substring(pos1, pos1 + len * 2);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV at\n * @name getHexOfTLV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 TLV.\n * @since 1.1\n */\nfunction _asnhex_getHexOfTLV_AtObj(s, pos) {\n  var hT = s.substr(pos, 2);\n  var hL = _asnhex_getHexOfL_AtObj(s, pos);\n  var hV = _asnhex_getHexOfV_AtObj(s, pos);\n  return hT + hL + hV;\n}\n\n/**\n * get next sibling starting index for ASN.1 object string\n * @name getPosOfNextSibling_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return next sibling starting index for ASN.1 object string\n */\nfunction _asnhex_getPosOfNextSibling_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return pos1 + len * 2;\n}\n\n/**\n * get array of indexes of child ASN.1 objects\n * @name getPosArrayOfChildren_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} start string index of ASN.1 object\n * @return {Array of Number} array of indexes for childen of ASN.1 objects\n */\nfunction _asnhex_getPosArrayOfChildren_AtObj(h, pos) {\n  var a = new Array();\n  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);\n  a.push(p0);\n\n  var len = _asnhex_getIntOfL_AtObj(h, pos);\n  var p = p0;\n  var k = 0;\n  while (1) {\n    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);\n    if (pNext == null || (pNext - p0  >= (len * 2))) break;\n    if (k >= 200) break;\n\n    a.push(pNext);\n    p = pNext;\n\n    k++;\n  }\n\n  return a;\n}\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getNthChildIndex_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} idx start string index of ASN.1 object\n * @param {Number} nth for child\n * @return {Number} string index of nth child.\n * @since 1.1\n */\nfunction _asnhex_getNthChildIndex_AtObj(h, idx, nth) {\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);\n  return a[nth];\n}\n\n// ========== decendant methods ==============================\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getDecendantIndexByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} string index refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {\n  if (nthList.length == 0) {\n    return currentIndex;\n  }\n  var firstNth = nthList.shift();\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);\n  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.\n * @name getDecendantHexTLVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfTLV_AtObj(h, idx);\n}\n\n/**\n * get hexadecimal string of ASN.1 V refered by current index and nth index list.\n * @name getDecendantHexVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 V refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfV_AtObj(h, idx);\n}\n\n// ========== class definition ==============================\n\n/**\n * ASN.1 DER encoded hexadecimal string utility class\n * @class ASN.1 DER encoded hexadecimal string utility class\n * @author Kenji Urushima\n * @version 1.1 (09 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n * @since 1.1\n */\nfunction ASN1HEX() {\n  return ASN1HEX;\n}\n\nASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;\nASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;\nASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;\nASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;\nASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;\nASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;\nASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;\nASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;\nASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;\nASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;\nASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;\nASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;\n\nmodule.exports = ASN1HEX;\n\n},{"jsbn":160}],68:[function(require,module,exports){\n/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * crypto.js - Cryptographic Algorithm Provider class\n *\n * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name crypto-1.0.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.0.4 (2013-Mar-28)\n * @since 2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nvar CryptoJS = require(\'./sha256.js\')\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n/** \n * kjur\'s class library name space\n * @name KJUR\n * @namespace kjur\'s class library name space\n */\nif (typeof KJUR == "undefined" || !KJUR) KJUR = {};\n/**\n * kjur\'s cryptographic algorithm provider library name space\n * <p>\n * This namespace privides following crytpgrahic classes.\n * <ul>\n * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.crypto\n * @namespace\n */\nif (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.Util\n * @class static object for cryptographic function utilities\n * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n * @description\n */\nKJUR.crypto.Util = new function() {\n    this.DIGESTINFOHEAD = {\n\t\'sha1\':      "3021300906052b0e03021a05000414",\n        \'sha224\':    "302d300d06096086480165030402040500041c",\n\t\'sha256\':    "3031300d060960864801650304020105000420",\n\t\'sha384\':    "3041300d060960864801650304020205000430",\n\t\'sha512\':    "3051300d060960864801650304020305000440",\n\t\'md2\':       "3020300c06082a864886f70d020205000410",\n\t\'md5\':       "3020300c06082a864886f70d020505000410",\n\t\'ripemd160\': "3021300906052b2403020105000414"\n    };\n\n    /**\n     * get hexadecimal DigestInfo\n     * @name getDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n     */\n    this.getDigestInfoHex = function(hHash, alg) {\n\tif (typeof this.DIGESTINFOHEAD[alg] == "undefined")\n\t    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;\n\treturn this.DIGESTINFOHEAD[alg] + hHash;\n    };\n\n    /**\n     * get PKCS#1 padded hexadecimal DigestInfo\n     * @name getPaddedDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @param {Integer} keySize key bit length (ex. 1024)\n     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n     */\n    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\tvar pmStrLen = keySize / 4; // minimum PM length\n\n\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;\n\n\tvar hHead = "0001";\n\tvar hTail = "00" + hDigestInfo;\n\tvar hMid = "";\n\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\tfor (var i = 0; i < fLen; i += 2) {\n\t    hMid += "ff";\n\t}\n\tvar hPaddedMessage = hHead + hMid + hTail;\n\treturn hPaddedMessage;\n    };\n\n    /**\n     * get hexadecimal SHA1 hash of string\n     * @name sha1\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha1 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha1\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA256 hash of string\n     * @name sha256\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha256 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha256\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA512 hash of string\n     * @name sha512\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha512 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha512\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal MD5 hash of string\n     * @name md5\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.md5 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'md5\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal RIPEMD160 hash of string\n     * @name ripemd160\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.ripemd160 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'ripemd160\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n};\n\n/**\n * MessageDigest class which is very similar to java.security.MessageDigest class\n * @name KJUR.crypto.MessageDigest\n * @class MessageDigest class which is very similar to java.security.MessageDigest class\n * @param {Array} params parameters for constructor\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>md5 - cryptojs</li>\n * <li>sha1 - cryptojs</li>\n * <li>sha224 - cryptojs</li>\n * <li>sha256 - cryptojs</li>\n * <li>sha384 - cryptojs</li>\n * <li>sha512 - cryptojs</li>\n * <li>ripemd160 - cryptojs</li>\n * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n * </ul>\n * @example\n * // CryptoJS provider sample\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n *\n * // SJCL(Stanford JavaScript Crypto Library) provider sample\n * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n */\nKJUR.crypto.MessageDigest = function(params) {\n    var md = null;\n    var algName = null;\n    var provName = null;\n    var _CryptoJSMdName = {\n\t\'md5\': \'CryptoJS.algo.MD5\',\n\t\'sha1\': \'CryptoJS.algo.SHA1\',\n\t\'sha224\': \'CryptoJS.algo.SHA224\',\n\t\'sha256\': \'CryptoJS.algo.SHA256\',\n\t\'sha384\': \'CryptoJS.algo.SHA384\',\n\t\'sha512\': \'CryptoJS.algo.SHA512\',\n\t\'ripemd160\': \'CryptoJS.algo.RIPEMD160\'\n    };\n\n    /**\n     * set hash algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} alg hash algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * // for SHA1\n     * md.setAlgAndProvider(\'sha1\', \'cryptojs\');\n     * // for RIPEMD160\n     * md.setAlgAndProvider(\'ripemd160\', \'cryptojs\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(alg) != -1 &&\n\t    prov == \'cryptojs\') {\n\t    try {\n\t\tthis.md = eval(_CryptoJSMdName[alg]).create();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.md.update(wHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n\tif (\':sha256:\'.indexOf(alg) != -1 &&\n\t    prov == \'sjcl\') {\n\t    try {\n\t\tthis.md = new sjcl.hash.sha256();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\tthis.md.update(baHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn sjcl.codec.hex.fromBits(hash);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString(\'New York\');\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex(\'0afe36\');\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name digest\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.digest = function() {\n\tthrow "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name digestString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString(\'aaa\')\n     */\n    this.digestString = function(str) {\n\tthrow "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, then completes the digest computation\n     * @name digestHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex(\'0f2abd\')\n     */\n    this.digestHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t}\n    }\n};\n\n\n/**\n * Signature class which is very similar to java.security.Signature class\n * @name KJUR.crypto.Signature\n * @class Signature class which is very similar to java.security.Signature class\n * @param {Array} params parameters for constructor\n * @property {String} state Current state of this signature object whether \'SIGN\', \'VERIFY\' or null\n * @description\n * <br/>\n * As for params of constructor\'s argument, it can be specify following attributes:\n * <ul>\n * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>\n * <li>provider - currently \'cryptojs/jsrsa\' only</li>\n * <li>prvkeypem - PEM string of signer\'s private key. If this specified, no need to call initSign(prvKey).</li>\n * </ul>\n * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}\n * withRSA algorithm in \'cryptojs/jsrsa\' provider.\n * <h4>EXAMPLES</h4>\n * @example\n * // signature generation\n * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig.initSign(prvKey);\n * sig.updateString(\'aaa\');\n * var hSigVal = sig.sign();\n *\n * // signature validation\n * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig2.initVerifyByCertificatePEM(cert)\n * sig.updateString(\'aaa\');\n * var isValid = sig2.verify(hSigVal);\n */\nKJUR.crypto.Signature = function(params) {\n    var prvKey = null; // RSAKey for signing\n    var pubKey = null; // RSAKey for verifying\n\n    var md = null; // KJUR.crypto.MessageDigest object\n    var sig = null;\n    var algName = null;\n    var provName = null;\n    var algProvName = null;\n    var mdAlgName = null;\n    var pubkeyAlgName = null;\n    var state = null;\n\n    var sHashHex = null; // hex hash value for hex\n    var hDigestInfo = null;\n    var hPaddedDigestInfo = null;\n    var hSign = null;\n\n    this._setAlgNames = function() {\n\tif (this.algName.match(/^(.+)with(.+)$/)) {\n\t    this.mdAlgName = RegExp.$1.toLowerCase();\n\t    this.pubkeyAlgName = RegExp.$2.toLowerCase();\n\t}\n    };\n\n    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\tvar s = "";\n\tvar nZero = bitLength / 4 - hex.length;\n\tfor (var i = 0; i < nZero; i++) {\n\t    s = s + "0";\n\t}\n\treturn s + hex;\n    };\n\n    /**\n     * set signature algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} alg signature algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * md.setAlgAndProvider(\'SHA1withRSA\', \'cryptojs/jsrsa\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tthis._setAlgNames();\n\tif (prov != \'cryptojs/jsrsa\')\n\t    throw "provider not supported: " + prov;\n\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(this.mdAlgName) != -1) {\n\t    try {\n\t\tthis.md = new KJUR.crypto.MessageDigest({\'alg\':this.mdAlgName,\'prov\':\'cryptojs\'});\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;\n\t    }\n\n\t    this.initSign = function(prvKey) {\n\t\tthis.prvKey = prvKey;\n\t\tthis.state = "SIGN";\n\t    };\n\n\t    this.initVerifyByPublicKey = function(rsaPubKey) {\n\t\tthis.pubKey = rsaPubKey;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tvar x509 = new X509();\n\t\tx509.readCertPEM(certPEM);\n\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.updateString = function(str) {\n\t\tthis.md.updateString(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tthis.md.updateHex(hex);\n\t    };\n\t    this.sign = function() {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.prvKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\t\tthis.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);\n\t\tthis.hPaddedDigestInfo = \n                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);\n\n\t\tvar biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);\n\t\tthis.hoge = biPaddedDigestInfo.toString(16);\n\n\t\tvar biSign = this.prvKey.doPrivate(biPaddedDigestInfo);\n\t\tthis.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);\n\t\treturn this.hSign;\n\t    };\n\t    this.signString = function(str) {\n\t\tthis.updateString(str);\n\t\tthis.sign();\n\t    };\n\t    this.signHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\tthis.sign();\n\t    };\n\t    this.verify = function(hSigVal) {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.pubKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\n\t\tvar biSigVal = parseBigInt(hSigVal, 16);\n\t\tvar biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);\n\t\tthis.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);\n                var s = this.hPaddedDigestInfo;\n                s = s.replace(/^1ff+00/, \'\');\n\n\t\tvar hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];\n                if (s.indexOf(hDIHEAD) != 0) {\n\t\t    return false;\n\t\t}\n\t\tvar hHashFromDI = s.substr(hDIHEAD.length);\n\t\t//alert(hHashFromDI + "\\n" + this.sHashHex);\n\t\treturn (hHashFromDI == this.sHashHex);\n\t    };\n\t}\n    };\n\n    /**\n     * Initialize this object for verifying with a public key\n     * @name initVerifyByPublicKey\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} rsaPubKey RSAKey object of public key\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByPublicKey(prvKey)\n     */\n    this.initVerifyByPublicKey = function(rsaPubKey) {\n\tthrow "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a certficate\n     * @name initVerifyByCertificatePEM\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} certPEM PEM formatted string of certificate\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByCertificatePEM(certPEM)\n     */\n    this.initVerifyByCertificatePEM = function(certPEM) {\n\tthrow "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for signing\n     * @name initSign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} prvKey RSAKey object of private key\n     * @description\n     * @example\n     * sig.initSign(prvKey)\n     */\n    this.initSign = function(prvKey) {\n\tthrow "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a string\n     * @name updateString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to use for the update\n     * @description\n     * @example\n     * sig.updateString(\'aaa\')\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to use for the update\n     * @description\n     * @example\n     * sig.updateHex(\'1f2f3f\')\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Returns the signature bytes of all data updates as a hexadecimal string\n     * @name sign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @return the signature bytes as a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.sign()\n     */\n    this.sign = function() {\n\tthrow "sign() not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signString(\'aaa\')\n     */\n    this.signString = function(str) {\n\tthrow "digestString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signHex(\'1fdc33\')\n     */\n    this.signHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * verifies the passed-in signature.\n     * @name verify\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return {Boolean} true if the signature was verified, otherwise false\n     * @description\n     * @example\n     * var isValid = sig.verify(\'1fbcefdca4823a7(snip)\')\n     */\n    this.verify = function(hSigVal) {\n\tthrow "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.algProvName = params[\'alg\'] + ":" + params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t    this._setAlgNames();\n\t}\n\tif (typeof params[\'prvkeypem\'] != "undefined") {\n\t    if (typeof params[\'prvkeypas\'] != "undefined") {\n\t\tthrow "both prvkeypem and prvkeypas parameters not supported";\n\t    } else {\n\t\ttry {\n\t\t    var prvKey = new RSAKey();\n\t\t    prvKey.readPrivateKeyFromPEMString(params[\'prvkeypem\']);\n\t\t    this.initSign(prvKey);\n\t\t} catch (ex) {\n\t\t    throw "fatal error to load pem private key: " + ex;\n\t\t}\n\t    }\n\t}\n    }\n};\nmodule.exports = KJUR\n\n},{"./sha256.js":154,"jsbn":160}],147:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Encapsulate a customBuf and support dynamic reallocation.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a DynamicBuffer where this.array is a customBuf of size length.\n * To access the array, use this.array or call slice.\n * @constructor\n * @param {number} length the initial length of the array.  If null, use a default.\n */\nvar DynamicBuffer = function DynamicBuffer(length) \n{\n  if (!length)\n    length = 16;\n    \n  this.array = new customBuf(length);\n};\n\nexports.DynamicBuffer = DynamicBuffer;\n\n/**\n * Ensure that this.array has the length, reallocate and copy if necessary.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLength = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  this.array.copy(newArray);\n  this.array = newArray;\n};\n\n/**\n * Copy the value to this.array at offset, reallocating if necessary. \n * @param {Buffer} value The buffer to copy.\n * @param {number} offset The offset in the buffer to start copying into.\n */\nDynamicBuffer.prototype.copy = function(value, offset) \n{\n  this.ensureLength(value.length + offset);\n    \n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, offset);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, offset);\n};\n\n/**\n * Ensure that this.array has the length. If necessary, reallocate the array\n *   and shift existing data to the back of the new array.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLengthFromBack = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  // Copy to the back of newArray.\n  this.array.copy(newArray, newArray.length - this.array.length);\n  this.array = newArray;\n};\n\n/**\n * First call ensureLengthFromBack to make sure the bytearray has\n * offsetFromBack bytes, then copy value into the array starting\n * offsetFromBack bytes from the back of the array.\n * @param {Buffer} value The buffer to copy.\n * @param {offsetFromBack} offset The offset from the back of the array to start\n * copying.\n */\nDynamicBuffer.prototype.copyFromBack = function(value, offsetFromBack) \n{\n  this.ensureLengthFromBack(offsetFromBack);\n\n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, this.array.length - offsetFromBack);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, this.array.length - offsetFromBack);\n};\n\n/**\n * Return this.array.slice(begin, end);\n * @param {number} begin The begin index for the slice.\n * @param {number} end The end index for the slice.\n * @returns {Buffer} The buffer slice.\n */\nDynamicBuffer.prototype.slice = function(begin, end) \n{\n  return this.array.slice(begin, end);\n};\n\n})()\n},{"../buffer.js":54}],69:[function(require,module,exports){\n/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-sign.js - adding signing functions to RSAKey class.\n//\n//\n// version: 1.2.2 (13 May 2013)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n\n//\n// Depends on:\n//   function sha1.hex(s) of sha1.js\n//   jsbn.js\n//   jsbn2.js\n//   rsa.js\n//   rsa2.js\n//\nvar BigInteger = require(\'jsbn\')\nvar RSAKey= require(\'./rsapem-1.1.js\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// keysize / pmstrlen\n//  512 /  128\n// 1024 /  256\n// 2048 /  512\n// 4096 / 1024\n\n/**\n * @fileOverview\n * @name rsasign-1.2.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * @property {Dictionary} _RSASIGN_DIHEAD\n * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.\n * You can add any DigestInfo hash algorith for signing.\n * See PKCS#1 v2.1 spec (p38).\n */\nvar _RSASIGN_DIHEAD = [];\n_RSASIGN_DIHEAD[\'sha1\'] =      "3021300906052b0e03021a05000414";\n_RSASIGN_DIHEAD[\'sha256\'] =    "3031300d060960864801650304020105000420";\n_RSASIGN_DIHEAD[\'sha384\'] =    "3041300d060960864801650304020205000430";\n_RSASIGN_DIHEAD[\'sha512\'] =    "3051300d060960864801650304020305000440";\n_RSASIGN_DIHEAD[\'md2\'] =       "3020300c06082a864886f70d020205000410";\n_RSASIGN_DIHEAD[\'md5\'] =       "3020300c06082a864886f70d020505000410";\n_RSASIGN_DIHEAD[\'ripemd160\'] = "3021300906052b2403020105000414";\n\n/**\n * @property {Dictionary} _RSASIGN_HASHHEXFUNC\n * @description Array of functions which calculate hash and returns it as hexadecimal.\n * You can add any hash algorithm implementations.\n */\nvar _RSASIGN_HASHHEXFUNC = [];\n_RSASIGN_HASHHEXFUNC[\'sha1\'] =      function(s){return KJUR.crypto.Util.sha1(s);};\n_RSASIGN_HASHHEXFUNC[\'sha256\'] =    function(s){return KJUR.crypto.Util.sha256(s);}\n_RSASIGN_HASHHEXFUNC[\'sha512\'] =    function(s){return KJUR.crypto.Util.sha512(s);}\n_RSASIGN_HASHHEXFUNC[\'md5\'] =       function(s){return KJUR.crypto.Util.md5(s);};\n_RSASIGN_HASHHEXFUNC[\'ripemd160\'] = function(s){return KJUR.crypto.Util.ripemd160(s);};\n\n//_RSASIGN_HASHHEXFUNC[\'sha1\'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n//_RSASIGN_HASHHEXFUNC[\'sha256\'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n\nvar _RE_HEXDECONLY = new RegExp("");\n_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");\n\n// ========================================================================\n// Signature Generation\n// ========================================================================\n\nfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n    var pmStrLen = keySize / 4;\n    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];\n    var sHashHex = hashFunc(s);\n\n    var sHead = "0001";\n    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;\n    var sMid = "";\n    var fLen = pmStrLen - sHead.length - sTail.length;\n    for (var i = 0; i < fLen; i += 2) {\n\tsMid += "ff";\n    }\n    sPaddedMessageHex = sHead + sMid + sTail;\n    return sPaddedMessageHex;\n}\n\nfunction _zeroPaddingOfSignature(hex, bitLength) {\n    var s = "";\n    var nZero = bitLength / 4 - hex.length;\n    for (var i = 0; i < nZero; i++) {\n\ts = s + "0";\n    }\n    return s + hex;\n}\n\n/**\n * sign for a message string with RSA private key.<br/>\n * @name signString\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signString(s, hashAlg) {\n    //alert("this.n.bitLength() = " + this.n.bitLength());\n    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);\n    var biPaddedMessage = parseBigInt(hPM, 16);\n    var biSign = this.doPrivate(biPaddedMessage);\n    var hexSign = biSign.toString(16);\n    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n}\n\nfunction _rsasign_signStringWithSHA1(s) {\n    return _rsasign_signString.call(this, s, \'sha1\');\n}\n\nfunction _rsasign_signStringWithSHA256(s) {\n    return _rsasign_signString.call(this, s, \'sha256\');\n}\n\n// PKCS#1 (PSS) mask generation function\nfunction pss_mgf1_str(seed, len, hash) {\n    var mask = \'\', i = 0;\n\n    while (mask.length < len) {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(s);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var salt = \'\';\n\n    if (sLen > 0) {\n        salt = new Array(sLen);\n        new SecureRandom().nextBytes(salt);\n        salt = String.fromCharCode.apply(String, salt);\n    }\n\n    var H = hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash + salt);\n    var PS = [];\n\n    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n        PS[i] = 0x00;\n    }\n\n    var DB = String.fromCharCode.apply(String, PS) + \'\\x01\' + salt;\n    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n    maskedDB[0] &= ~mask;\n\n    for (i = 0; i < hLen; i++) {\n        maskedDB.push(H.charCodeAt(i));\n    }\n\n    maskedDB.push(0xbc);\n\n    return _zeroPaddingOfSignature(\n            this.doPrivate(new BigInteger(maskedDB)).toString(16),\n            this.n.bitLength());\n}\n\n// ========================================================================\n// Signature Verification\n// ========================================================================\n\nfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n    var rsa = new RSAKey();\n    rsa.setPublic(hN, hE);\n    var biDecryptedSig = rsa.doPublic(biSig);\n    return biDecryptedSig;\n}\n\nfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    return hDigestInfo;\n}\n\nfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n    for (var algName in _RSASIGN_DIHEAD) {\n\tvar head = _RSASIGN_DIHEAD[algName];\n\tvar len = head.length;\n\tif (hDigestInfo.substring(0, len) == head) {\n\t    var a = [algName, hDigestInfo.substring(len)];\n\t    return a;\n\t}\n    }\n    return [];\n}\n\nfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\nfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n    var biSig = parseBigInt(hSig, 16);\n    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t  this.e.toString(16));\n    return result;\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyString\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyString(sMsg, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, \'\');\n    if (hSig.length != this.n.bitLength() / 4) return 0;\n    hSig = hSig.replace(/[ \\n]+/g, "");\n    var biSig = parseBigInt(hSig, 16);\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n  \n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n    if (hSig.length !== this.n.bitLength() / 4) {\n        return false;\n    }\n\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(sMsg);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();\n\n    for (i = 0; i < em.length; i += 1) {\n        em[i] &= 0xff;\n    }\n\n    while (em.length < emLen) {\n        em.unshift(0);\n    }\n\n    if (em[emLen -1] !== 0xbc) {\n        throw "encoded message does not end in 0xbc";\n    }\n\n    em = String.fromCharCode.apply(String, em);\n\n    var maskedDB = em.substr(0, emLen - hLen - 1);\n    var H = em.substr(maskedDB.length, hLen);\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n        throw "bits beyond keysize not zero";\n    }\n\n    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1) {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB[0] &= ~mask;\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i += 1) {\n        if (DB[i] !== 0x00) {\n            throw "leftmost octets not zero";\n        }\n    }\n\n    if (DB[checkLen] !== 0x01) {\n        throw "0x01 marker not found";\n    }\n\n    return H === hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash +\n                          String.fromCharCode.apply(String, DB.slice(-sLen)));\n}\n\nRSAKey.prototype.signString = _rsasign_signString;\nRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.sign = _rsasign_signString;\nRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\nRSAKey.prototype.signPSS = _rsasign_signStringPSS;\nRSAKey.SALT_LEN_HLEN = -1;\nRSAKey.SALT_LEN_MAX = -2;\n\nRSAKey.prototype.verifyString = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verify = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\nRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\nRSAKey.SALT_LEN_RECOVER = -2;\n\n/**\n * @name RSAKey\n * @class key of RSA public key algorithm\n * @description Tom Wu\'s RSA Key class and extension\n */\n\nmodule.exports = RSAKey\n\n},{"./rsapem-1.1.js":156,"jsbn":160}],161:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n    // Shortcuts\n    var C = require(\'./core.js\');\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var Hasher = C_lib.Hasher;\n    var C_algo = C.algo;\n\n    // Initialization and round constants tables\n    var H = [];\n    var K = [];\n\n    // Compute constants\n    (function () {\n        function isPrime(n) {\n            var sqrtN = Math.sqrt(n);\n            for (var factor = 2; factor <= sqrtN; factor++) {\n                if (!(n % factor)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function getFractionalBits(n) {\n            return ((n - (n | 0)) * 0x100000000) | 0;\n        }\n\n        var n = 2;\n        var nPrime = 0;\n        while (nPrime < 64) {\n            if (isPrime(n)) {\n                if (nPrime < 8) {\n                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                }\n                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n                nPrime++;\n            }\n\n            n++;\n        }\n    }());\n\n    // Reusable object\n    var W = [];\n\n    /**\n     * SHA-256 hash algorithm.\n     */\n    var SHA256 = C_algo.SHA256 = Hasher.extend({\n        _doReset: function () {\n            this._hash = new WordArray.init(H.slice(0));\n        },\n\n        _doProcessBlock: function (M, offset) {\n            // Shortcut\n            var H = this._hash.words;\n\n            // Working variables\n            var a = H[0];\n            var b = H[1];\n            var c = H[2];\n            var d = H[3];\n            var e = H[4];\n            var f = H[5];\n            var g = H[6];\n            var h = H[7];\n\n            // Computation\n            for (var i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                } else {\n                    var gamma0x = W[i - 15];\n                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                                   (gamma0x >>> 3);\n\n                    var gamma1x = W[i - 2];\n                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                                   (gamma1x >>> 10);\n\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n\n                var ch  = (e & f) ^ (~e & g);\n                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n                var t1 = h + sigma1 + ch + K[i] + W[i];\n                var t2 = sigma0 + maj;\n\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n            H[4] = (H[4] + e) | 0;\n            H[5] = (H[5] + f) | 0;\n            H[6] = (H[6] + g) | 0;\n            H[7] = (H[7] + h) | 0;\n        },\n\n        _doFinalize: function () {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n\n            var nBitsTotal = this._nDataBytes * 8;\n            var nBitsLeft = data.sigBytes * 8;\n\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            data.sigBytes = dataWords.length * 4;\n\n            // Hash final blocks\n            this._process();\n\n            // Return final computed hash\n            return this._hash;\n        },\n\n        clone: function () {\n            var clone = Hasher.clone.call(this);\n            clone._hash = this._hash.clone();\n\n            return clone;\n        }\n    });\n\n    /**\n     * Shortcut function to the hasher\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     *\n     * @return {WordArray} The hash.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hash = CryptoJS.SHA256(\'message\');\n     *     var hash = CryptoJS.SHA256(wordArray);\n     */\n    C.SHA256 = Hasher._createHelper(SHA256);\n\n    /**\n     * Shortcut function to the HMAC\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     * @param {WordArray|string} key The secret key.\n     *\n     * @return {WordArray} The HMAC.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hmac = CryptoJS.HmacSHA256(message, key);\n     */\n    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\nmodule.exports = C\n\n},{"./core.js":162}],163:[function(require,module,exports){\n/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key\n//              to RSAKey class.\n//\n// version: 1.1.1 (2013-Apr-12)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n// \n//\n// Depends on:\n//\n//\n//\n// _RSApem_pemToBase64(sPEM)\n//\n//   removing PEM header, PEM footer and space characters including\n//   new lines from PEM formatted RSA private key string.\n//\nvar ASN1HEX = require(\'./asn1hex-1.1.js\')\nvar b64tohex = require(\'./base64.js\').b64tohex\nvar RSAKey = require(\'./rsa2.js\')\n/**\n * @fileOverview\n * @name rsapem-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nfunction _rsapem_pemToBase64(sPEMPrivateKey) {\n  var s = sPEMPrivateKey;\n  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");\n  s = s.replace("-----END RSA PRIVATE KEY-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {\n  var a = new Array();\n  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);\n  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);\n  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);\n  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);\n  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);\n  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);\n  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);\n  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);\n  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);\n  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);\n  return a;\n}\n\nfunction _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {\n  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);\n  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);\n  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);\n  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);\n  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);\n  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);\n  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);\n  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);\n  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);\n  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);\n  var a = new Array();\n  a.push(v, n, e, d, p, q, dp, dq, co);\n  return a;\n}\n\n/**\n * read RSA private key from a ASN.1 hexadecimal string\n * @name readPrivateKeyFromASN1HexString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.\n * @since 1.1.1\n */\nfunction _rsapem_readPrivateKeyFromASN1HexString(keyHex) {\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\n/**\n * read PKCS#1 private key from a string\n * @name readPrivateKeyFromPEMString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyPEM string of PKCS#1 private key.\n */\nfunction _rsapem_readPrivateKeyFromPEMString(keyPEM) {\n  var keyB64 = _rsapem_pemToBase64(keyPEM);\n  var keyHex = b64tohex(keyB64) // depends base64.js\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\nRSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;\nRSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;\n\nmodule.exports = RSAKey\n\n},{"./asn1hex-1.1.js":117,"./base64.js":120,"./rsa2.js":164}],148:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar crypto = require(\'../crypto.js\');\nvar Blob = require(\'../util/blob.js\').Blob;\nvar Tlv = require(\'./tlv/tlv.js\').Tlv;\nvar TlvEncoder = require(\'./tlv/tlv-encoder.js\').TlvEncoder;\nvar TlvDecoder = require(\'./tlv/tlv-decoder.js\').TlvDecoder;\nvar WireFormat = require(\'./wire-format.js\').WireFormat;\nvar Exclude = require(\'../exclude.js\').Exclude;\nvar ContentType = require(\'../meta-info.js\').ContentType;\nvar KeyLocatorType = require(\'../key-locator.js\').KeyLocatorType;\nvar Signature = require(\'../signature.js\').Signature;\nvar DecodingException = require(\'./decoding-exception.js\').DecodingException;\n\n/**\n * A Tlv0_1a2WireFormat implements the WireFormat interface for encoding and \n * decoding with the NDN-TLV wire format, version 0.1a2\n * @constructor\n */\nvar Tlv0_1a2WireFormat = function Tlv0_1a2WireFormat() \n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nTlv0_1a2WireFormat.prototype = new WireFormat();\nTlv0_1a2WireFormat.prototype.name = "Tlv0_1a2WireFormat";\n\nexports.Tlv0_1a2WireFormat = Tlv0_1a2WireFormat;\n\n// Default object.\nTlv0_1a2WireFormat.instance = null;\n\n/**\n * Encode the interest using NDN-TLV and return a customBuf.\n * @param {Interest} interest The Interest object to encode.\n * @returns {Blob} A Blob containing the encoding.\n */\nTlv0_1a2WireFormat.prototype.encodeInterest = function(interest) \n{\n  var encoder = new TlvEncoder();\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.InterestLifetime, interest.getInterestLifetimeMilliseconds());\n  encoder.writeOptionalNonNegativeIntegerTlv(Tlv.Scope, interest.getScope());\n  \n  // Encode the Nonce as 4 bytes.\n  if (interest.getNonce() == null || interest.getNonce().length == 0)\n    // This is the most common case. Generate a nonce.\n    encoder.writeBlobTlv(Tlv.Nonce, require("../crypto.js").randomBytes(4));\n  else if (interest.getNonce().length < 4) {\n    var nonce = customBuf(4);\n    // Copy existing nonce bytes.\n    interest.getNonce().copy(nonce);\n\n    // Generate random bytes for remaining bytes in the nonce.\n    for (var i = interest.getNonce().length; i < 4; ++i)\n      nonce[i] = require("crypto").randomBytes(1)[0];\n\n    encoder.writeBlobTlv(Tlv.Nonce, nonce);\n  }\n  else if (interest.getNonce().length == 4)\n    // Use the nonce as-is.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce());\n  else\n    // Truncate.\n    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce().slice(0, 4));\n  \n  Tlv0_1a2WireFormat.encodeSelectors(interest, encoder);\n  Tlv0_1a2WireFormat.encodeName(interest.getName(), encoder);\n  \n  encoder.writeTypeAndLength(Tlv.Interest, encoder.getLength() - saveLength);\n      \n  return new Blob(encoder.getOutput(), false);\n};\n\n/**\n * Decode input as an NDN-TLV interest and set the fields of the interest \n * object.  \n * @param {Interest} interest The Interest object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n */\nTlv0_1a2WireFormat.prototype.decodeInterest = function(interest, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Interest);\n  Tlv0_1a2WireFormat.decodeName(interest.getName(), decoder);\n  if (decoder.peekType(Tlv.Selectors, endOffset))\n    Tlv0_1a2WireFormat.decodeSelectors(interest, decoder);\n  // Require a Nonce, but don\'t force it to be 4 bytes.\n  var nonce = decoder.readBlobTlv(Tlv.Nonce);\n  interest.setScope(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.Scope, endOffset));\n  interest.setInterestLifetimeMilliseconds\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.InterestLifetime, endOffset));\n\n  // Set the nonce last because setting other interest fields clears it.\n  interest.setNonce(nonce);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode data as NDN-TLV and return the encoding and signed offsets.\n * @param {Data} data The Data object to encode.\n * @returns {object with (Blob, int, int)} An associative array with fields\n * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding \n * is a Blob containing the encoding, signedPortionBeginOffset is the offset in \n * the encoding of the beginning of the signed portion, and \n * signedPortionEndOffset is the offset in the encoding of the end of the \n * signed portion.\n */\nTlv0_1a2WireFormat.prototype.encodeData = function(data) \n{\n  var encoder = new TlvEncoder(1500);\n  var saveLength = encoder.getLength();\n  \n  // Encode backwards.\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  encoder.writeBlobTlv(Tlv.SignatureValue, data.getSignature().getSignature());\n  var signedPortionEndOffsetFromBack = encoder.getLength();\n\n  // Use getSignatureOrMetaInfoKeyLocator for the transition of moving\n  //   the key locator from the MetaInfo to the Signauture object.\n  Tlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue\n    (data.getSignature(), encoder, data.getSignatureOrMetaInfoKeyLocator());\n  encoder.writeBlobTlv(Tlv.Content, data.getContent());\n  Tlv0_1a2WireFormat.encodeMetaInfo(data.getMetaInfo(), encoder);\n  Tlv0_1a2WireFormat.encodeName(data.getName(), encoder);\n  var signedPortionBeginOffsetFromBack = encoder.getLength();\n\n  encoder.writeTypeAndLength(Tlv.Data, encoder.getLength() - saveLength);\n  var signedPortionBeginOffset = \n    encoder.getLength() - signedPortionBeginOffsetFromBack;\n  var signedPortionEndOffset = encoder.getLength() - signedPortionEndOffsetFromBack;\n\n  return { encoding: new Blob(encoder.getOutput(), false),\n           signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Decode input as an NDN-TLV data packet, set the fields in the data object, \n * and return the signed offsets. \n * @param {Data} data The Data object whose fields are updated.\n * @param {Buffer} input The buffer with the bytes to decode.\n * @returns {object with (int, int)} An associative array with fields\n * (signedPortionBeginOffset, signedPortionEndOffset) where \n * signedPortionBeginOffset is the offset in the encoding of the beginning of \n * the signed portion, and signedPortionEndOffset is the offset in the encoding \n * of the end of the signed portion.\n */\nTlv0_1a2WireFormat.prototype.decodeData = function(data, input) \n{\n  var decoder = new TlvDecoder(input);\n\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Data);\n  var signedPortionBeginOffset = decoder.getOffset();\n\n  Tlv0_1a2WireFormat.decodeName(data.getName(), decoder);\n  Tlv0_1a2WireFormat.decodeMetaInfo(data.getMetaInfo(), decoder);\n  data.setContent(decoder.readBlobTlv(Tlv.Content));\n  Tlv0_1a2WireFormat.decodeSignatureInfo(data, decoder);\n  if (data.getSignature() != null && \n      data.getSignature().getKeyLocator() != null && \n      data.getMetaInfo() != null)\n    // Copy the key locator pointer to the MetaInfo object for the transition of \n    //   moving the key locator from the MetaInfo to the Signature object.\n    data.getMetaInfo().locator = data.getSignature().getKeyLocator();\n\n  var signedPortionEndOffset = decoder.getOffset();\n  // TODO: The library needs to handle other signature types than \n  //   SignatureSha256WithRsa.\n  data.getSignature().setSignature(decoder.readBlobTlv(Tlv.SignatureValue));\n\n  decoder.finishNestedTlvs(endOffset);\n  return { signedPortionBeginOffset: signedPortionBeginOffset, \n           signedPortionEndOffset: signedPortionEndOffset };  \n};\n\n/**\n * Get a singleton instance of a Tlv1_0a2WireFormat.  To always use the\n * preferred version NDN-TLV, you should use TlvWireFormat.get().\n * @returns {Tlv0_1a2WireFormat} The singleton instance.\n */\nTlv0_1a2WireFormat.get = function()\n{\n  if (Tlv0_1a2WireFormat.instance === null)\n    Tlv0_1a2WireFormat.instance = new Tlv0_1a2WireFormat();\n  return Tlv0_1a2WireFormat.instance;\n};\n\nTlv0_1a2WireFormat.encodeName = function(name, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode the components backwards.\n  for (var i = name.size() - 1; i >= 0; --i)\n    encoder.writeBlobTlv(Tlv.NameComponent, name.get(i).getValue());\n\n  encoder.writeTypeAndLength(Tlv.Name, encoder.getLength() - saveLength);\n};\n        \nTlv0_1a2WireFormat.decodeName = function(name, decoder)\n{\n  name.clear();\n  \n  var endOffset = decoder.readNestedTlvsStart(Tlv.Name);      \n  while (decoder.getOffset() < endOffset)\n      name.append(decoder.readBlobTlv(Tlv.NameComponent));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the interest selectors.  If no selectors are written, do not output a \n * Selectors TLV.\n */\nTlv0_1a2WireFormat.encodeSelectors = function(interest, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (interest.getMustBeFresh())\n    encoder.writeTypeAndLength(Tlv.MustBeFresh, 0);\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.ChildSelector, interest.getChildSelector());\n  if (interest.getExclude().size() > 0)\n    Tlv0_1a2WireFormat.encodeExclude(interest.getExclude(), encoder);\n  \n  if (interest.getKeyLocator().getType() != null)\n    Tlv0_1a2WireFormat.encodeKeyLocator(interest.getKeyLocator(), encoder);\n  else {\n    // There is no keyLocator. If there is a publisherPublicKeyDigest, then \n    //   encode as KEY_LOCATOR_DIGEST. (When we remove the deprecated \n    //   publisherPublicKeyDigest, we don\'t need this.)\n    if (null != interest.publisherPublicKeyDigest) {\n      var savePublisherPublicKeyDigestLength = encoder.getLength();\n      encoder.writeBlobTlv\n        (Tlv.KeyLocatorDigest, \n         interest.publisherPublicKeyDigest.publisherPublicKeyDigest);\n      encoder.writeTypeAndLength\n        (Tlv.KeyLocator, encoder.getLength() - savePublisherPublicKeyDigestLength);\n    }\n  }\n  \n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MaxSuffixComponents, interest.getMaxSuffixComponents());\n  encoder.writeOptionalNonNegativeIntegerTlv(\n    Tlv.MinSuffixComponents, interest.getMinSuffixComponents());\n\n  // Only output the type and length if values were written.\n  if (encoder.getLength() != saveLength)\n    encoder.writeTypeAndLength(Tlv.Selectors, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSelectors = function(interest, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Selectors);\n\n  interest.setMinSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MinSuffixComponents, endOffset));\n  interest.setMaxSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.MaxSuffixComponents, endOffset));\n\n  // Initially set publisherPublicKeyDigest to none.\n  interest.publisherPublicKeyDigest = null;\n  if (decoder.peekType(Tlv.KeyLocator, endOffset)) {\n    Tlv0_1a2WireFormat.decodeKeyLocator(interest.getKeyLocator(), decoder);\n    if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST) {\n      // For backwards compatibility, also set the publisherPublicKeyDigest.\n      interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n      interest.publisherPublicKeyDigest.publisherPublicKeyDigest =\n        interest.getKeyLocator().getKeyData();\n    }\n  }\n  else\n    interest.getKeyLocator().clear();\n\n  if (decoder.peekType(Tlv.Exclude, endOffset))\n    Tlv0_1a2WireFormat.decodeExclude(interest.getExclude(), decoder);\n  else\n    interest.getExclude().clear();\n\n  interest.setChildSelector(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ChildSelector, endOffset));\n  interest.setMustBeFresh(decoder.readBooleanTlv(Tlv.MustBeFresh, endOffset));\n\n  decoder.finishNestedTlvs(endOffset);\n};\n  \nTlv0_1a2WireFormat.encodeExclude = function(exclude, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // TODO: Do we want to order the components (except for ANY)?\n  // Encode the entries backwards.\n  for (var i = exclude.size() - 1; i >= 0; --i) {\n    var entry = exclude.get(i);\n\n    if (entry == Exclude.ANY)\n      encoder.writeTypeAndLength(Tlv.Any, 0);\n    else\n      encoder.writeBlobTlv(Tlv.NameComponent, entry.getValue());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.Exclude, encoder.getLength() - saveLength);\n};\n  \nTlv0_1a2WireFormat.decodeExclude = function(exclude, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.Exclude);\n\n  exclude.clear();\n  while (true) {\n    if (decoder.peekType(Tlv.NameComponent, endOffset))\n      exclude.appendComponent(decoder.readBlobTlv(Tlv.NameComponent));\n    else if (decoder.readBooleanTlv(Tlv.Any, endOffset))\n      exclude.appendAny();\n    else\n      // Else no more entries.\n      break;\n  }\n  \n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeKeyLocator = function(keyLocator, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  if (keyLocator.getType() != null) {\n    if (keyLocator.getType() == KeyLocatorType.KEYNAME)\n      Tlv0_1a2WireFormat.encodeName(keyLocator.getKeyName(), encoder);\n    else if (keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST &&\n             keyLocator.getKeyData().length > 0)\n      encoder.writeBlobTlv(Tlv.KeyLocatorDigest, keyLocator.getKeyData());\n    else\n      throw new Error("Unrecognized KeyLocatorType " + keyLocator.getType());\n  }\n  \n  encoder.writeTypeAndLength(Tlv.KeyLocator, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeKeyLocator = function(keyLocator, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.KeyLocator);\n\n  keyLocator.clear();\n\n  if (decoder.getOffset() == endOffset)\n    // The KeyLocator is omitted, so leave the fields as none.\n    return;\n\n  if (decoder.peekType(Tlv.Name, endOffset)) {\n    // KeyLocator is a Name.\n    keyLocator.setType(KeyLocatorType.KEYNAME);\n    Tlv0_1a2WireFormat.decodeName(keyLocator.getKeyName(), decoder);\n  }\n  else if (decoder.peekType(Tlv.KeyLocatorDigest, endOffset)) {\n    // KeyLocator is a KeyLocatorDigest.\n    keyLocator.setType(KeyLocatorType.KEY_LOCATOR_DIGEST);\n    keyLocator.setKeyData(decoder.readBlobTlv(Tlv.KeyLocatorDigest));\n  }\n  else\n    throw new DecodingException\n      ("decodeKeyLocator: Unrecognized key locator type");\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n/**\n * Encode the signature object in TLV, using the given keyLocator instead of the\n * locator in this object.\n * @param {Signature} signature The Signature object to encode.\n * @param {TlvEncoder} encoder The encoder.\n * @param {KeyLocator} keyLocator The key locator to use (from \n * Data.getSignatureOrMetaInfoKeyLocator).\n */\nTlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue = function\n  (signature, encoder, keyLocator)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  Tlv0_1a2WireFormat.encodeKeyLocator(keyLocator, encoder);\n  encoder.writeNonNegativeIntegerTlv\n    (Tlv.SignatureType, Tlv.SignatureType_SignatureSha256WithRsa);\n\n  encoder.writeTypeAndLength(Tlv.SignatureInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeSignatureInfo = function(data, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.SignatureInfo);\n\n  var signatureType = decoder.readNonNegativeIntegerTlv(Tlv.SignatureType);\n  // TODO: The library needs to handle other signature types than \n  //     SignatureSha256WithRsa.\n  if (signatureType == Tlv.SignatureType_SignatureSha256WithRsa) {\n      var signature = {}\n      signature.sig = Signature\n      data.setSignature(signature.sig());\n      // Modify data\'s signature object because if we create an object\n      //   and set it, then data will have to copy all the fields.\n      var signatureInfo = data.getSignature();\n      Tlv0_1a2WireFormat.decodeKeyLocator\n        (signatureInfo.getKeyLocator(), decoder);\n  }\n  else\n      throw new DecodingException\n       ("decodeSignatureInfo: unrecognized SignatureInfo type" + signatureType);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\nTlv0_1a2WireFormat.encodeMetaInfo = function(metaInfo, encoder)\n{\n  var saveLength = encoder.getLength();\n\n  // Encode backwards.\n  // TODO: finalBlockID should be a Name.Component, not customBuf.\n  var finalBlockIdBuf = metaInfo.getFinalBlockID();\n  if (finalBlockIdBuf != null && finalBlockIdBuf.length > 0) {\n    // FinalBlockId has an inner NameComponent.\n    var finalBlockIdSaveLength = encoder.getLength();\n    encoder.writeBlobTlv(Tlv.NameComponent, finalBlockIdBuf);\n    encoder.writeTypeAndLength\n      (Tlv.FinalBlockId, encoder.getLength() - finalBlockIdSaveLength);\n  }\n\n  encoder.writeOptionalNonNegativeIntegerTlv\n    (Tlv.FreshnessPeriod, metaInfo.getFreshnessPeriod());\n  if (metaInfo.getType() != ContentType.BLOB) {\n    // Not the default, so we need to encode the type.\n    if (metaInfo.getType() == ContentType.LINK ||\n        metaInfo.getType() == ContentType.KEY)\n      // The ContentType enum is set up with the correct integer for \n      // each NDN-TLV ContentType.\n      encoder.writeNonNegativeIntegerTlv(Tlv.ContentType, metaInfo.getType());\n    else\n      throw new Error("unrecognized TLV ContentType");\n  }\n\n  encoder.writeTypeAndLength(Tlv.MetaInfo, encoder.getLength() - saveLength);\n};\n\nTlv0_1a2WireFormat.decodeMetaInfo = function(metaInfo, decoder)\n{\n  var endOffset = decoder.readNestedTlvsStart(Tlv.MetaInfo);  \n\n  // The ContentType enum is set up with the correct integer for each \n  // NDN-TLV ContentType.  If readOptionalNonNegativeIntegerTlv returns\n  // None, then setType will convert it to BLOB.\n  metaInfo.setType(decoder.readOptionalNonNegativeIntegerTlv\n    (Tlv.ContentType, endOffset));\n  metaInfo.setFreshnessPeriod\n    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.FreshnessPeriod, endOffset));\n  if (decoder.peekType(Tlv.FinalBlockId, endOffset)) {\n    var finalBlockIdEndOffset = decoder.readNestedTlvsStart(Tlv.FinalBlockId);\n    metaInfo.setFinalBlockID(decoder.readBlobTlv(Tlv.NameComponent));\n    decoder.finishNestedTlvs(finalBlockIdEndOffset);\n  }\n  else\n    metaInfo.setFinalBlockID(null);\n\n  decoder.finishNestedTlvs(endOffset);\n};\n\n})()\n},{"../crypto.js":116,"../exclude.js":98,"../key-locator.js":102,"../meta-info.js":100,"../signature.js":141,"../util/blob.js":111,"./decoding-exception.js":153,"./tlv/tlv-decoder.js":107,"./tlv/tlv-encoder.js":165,"./tlv/tlv.js":108,"./wire-format.js":104,"crypto":56}],150:[function(require,module,exports){\n/**\n * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to \n * determine its end.\n * \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar BinaryXMLDecoder = require(\'./binary-xml-decoder.js\').BinaryXMLDecoder;\nvar DynamicBuffer = require(\'../util/dynamic-buffer.js\').DynamicBuffer;\n\nvar XML_EXT = 0x00; \nvar XML_TAG = 0x01; \nvar XML_DTAG = 0x02; \nvar XML_ATTR = 0x03; \nvar XML_DATTR = 0x04; \nvar XML_BLOB = 0x05; \nvar XML_UDATA = 0x06;   \nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; \n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\n\n/**\n * @constructor\n */\nvar BinaryXMLStructureDecoder = function BinaryXMLDecoder() \n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.level = 0;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.headerBuffer = new DynamicBuffer(5);\n  this.nBytesToRead = 0;\n};\n\nexports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;\n\nBinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;\nBinaryXMLStructureDecoder.READ_BYTES = 1;\n\n/**\n * Continue scanning input starting from this.offset.  If found the end of the element\n *   which started at offset 0 then return true, else false.\n * If this returns false, you should read more into input and call again.\n * You have to pass in input each time because the array could be reallocated.\n * This throws an exception for badly formed ndnb.\n */\nBinaryXMLStructureDecoder.prototype.findElementEnd = function(\n  // customBuf\n  input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new BinaryXMLDecoder(input);\n  \n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input.\n      return false;\n  \n    switch (this.state) {\n      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:               \n        // First check for XML_CLOSE.\n        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {\n          ++this.offset;\n          // Close the level.\n          --this.level;\n          if (this.level == 0) {\n            // Finished.\n            this.gotElementEnd = true;\n            return true;\n          }\n          if (this.level < 0)\n            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));\n              \n          // Get ready for the next header.\n          this.startHeader();\n          break;\n        }\n        \n        var startingHeaderLength = this.headerLength;\n        while (true) {\n          if (this.offset >= input.length) {\n            // We can\'t get all of the header bytes from this input. Save in headerBuffer.\n            this.useHeaderBuffer = true;\n            var nNewBytes = this.headerLength - startingHeaderLength;\n            this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n              \n            return false;\n          }\n          var headerByte = input[this.offset++];\n          ++this.headerLength;\n          if (headerByte & XML_TT_NO_MORE)\n            // Break and read the header.\n            break;\n        }\n        \n        var typeAndVal;\n        if (this.useHeaderBuffer) {\n          // Copy the remaining bytes into headerBuffer.\n          nNewBytes = this.headerLength - startingHeaderLength;\n          this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();\n        }\n        else {\n          // We didn\'t have to use the headerBuffer.\n          decoder.seek(this.offset - this.headerLength);\n          typeAndVal = decoder.decodeTypeAndVal();\n        }\n        \n        if (typeAndVal == null)\n          throw new Error("BinaryXMLStructureDecoder: Can\'t read header starting at offset " +\n                          (this.offset - this.headerLength));\n        \n        // Set the next state based on the type.\n        var type = typeAndVal.t;\n        if (type == XML_DATTR)\n          // We already consumed the item. READ_HEADER_OR_CLOSE again.\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n          this.startHeader();\n        else if (type == XML_DTAG || type == XML_EXT) {\n          // Start a new level and READ_HEADER_OR_CLOSE again.\n          ++this.level;\n          this.startHeader();\n        }\n        else if (type == XML_TAG || type == XML_ATTR) {\n          if (type == XML_TAG)\n            // Start a new level and read the tag.\n            ++this.level;\n          // Minimum tag or attribute length is 1.\n          this.nBytesToRead = typeAndVal.v + 1;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n        }\n        else if (type == XML_BLOB || type == XML_UDATA) {\n          this.nBytesToRead = typeAndVal.v;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n        }\n        else\n          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);\n        break;\n    \n      case BinaryXMLStructureDecoder.READ_BYTES:\n        var nRemainingBytes = input.length - this.offset;\n        if (nRemainingBytes < this.nBytesToRead) {\n          // Need more.\n          this.offset += nRemainingBytes;\n          this.nBytesToRead -= nRemainingBytes;\n          return false;\n        }\n        // Got the bytes.  Read a new header or close.\n        this.offset += this.nBytesToRead;\n        this.startHeader();\n        break;\n    \n      default:\n        // We don\'t expect this to happen.\n        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);\n    }\n  }\n};\n\n/**\n * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header\n */\nBinaryXMLStructureDecoder.prototype.startHeader = function() \n{\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;    \n};\n\n/**\n *  Set the offset into the input, used for the next read.\n */\nBinaryXMLStructureDecoder.prototype.seek = function(offset) \n{\n  this.offset = offset;\n};\n\n},{"../util/dynamic-buffer.js":159,"./binary-xml-decoder.js":135}],151:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\nvar TlvDecoder = require(\'./tlv-decoder.js\').TlvDecoder;\nvar customBuf = require(\'../../buffer.js\').Buffer\n/**\n * Create and initialize a TlvStructureDecoder.\n */\nvar TlvStructureDecoder = function TlvStructureDecoder()\n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.state = TlvStructureDecoder.READ_TYPE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  // 8 bytes is enough to hold the extended bytes in the length encoding \n  // where it is an 8-byte number.\n  this.headerBuffer = new customBuf(8);\n  this.nBytesToRead = 0;\n};\n\nexports.TlvStructureDecoder = TlvStructureDecoder;\n\nTlvStructureDecoder.READ_TYPE =         0;\nTlvStructureDecoder.READ_TYPE_BYTES =   1;\nTlvStructureDecoder.READ_LENGTH =       2;\nTlvStructureDecoder.READ_LENGTH_BYTES = 3;\nTlvStructureDecoder.READ_VALUE_BYTES =  4;\n\n/**\n * Continue scanning input starting from this.offset to find the element end.  \n * If the end of the element which started at offset 0 is found, this returns \n * true and getOffset() is the length of the element.  Otherwise, this returns \n * false which means you should read more into input and call again.\n * @param {Buffer} input The input buffer. You have to pass in input each time\n * because the buffer could be reallocated.\n * @returns {boolean} true if found the element end, false if not.\n */\nTlvStructureDecoder.prototype.findElementEnd = function(input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new TlvDecoder(input);\n\n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input. Return and wait for more.\n      return false;\n\n    if (this.state == TlvStructureDecoder.READ_TYPE) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253)\n        // The value is simple, so we can skip straight to reading the length.\n        this.state = TlvStructureDecoder.READ_LENGTH;\n      else {\n        // Set up to skip the type bytes.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        this.state = TlvStructureDecoder.READ_TYPE_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_TYPE_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the type bytes. Move on to read the length.\n      this.offset += this.nBytesToRead;\n      this.state = TlvStructureDecoder.READ_LENGTH;\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH) {\n      var firstOctet = input[this.offset];\n      this.offset += 1;\n      if (firstOctet < 253) {\n        // The value is simple, so we can skip straight to reading \n        //  the value bytes.\n        this.nBytesToRead = firstOctet;\n        if (this.nBytesToRead == 0) {\n          // No value bytes to read. We\'re finished.\n          this.gotElementEnd = true;\n          return true;\n        }\n\n        this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n      }\n      else {\n        // We need to read the bytes in the extended encoding of \n        //  the length.\n        if (firstOctet == 253)\n          this.nBytesToRead = 2;\n        else if (firstOctet == 254)\n          this.nBytesToRead = 4;\n        else\n          // value == 255.\n          this.nBytesToRead = 8;\n\n        // We need to use firstOctet in the next state.\n        this.firstOctet = firstOctet;\n        this.state = TlvStructureDecoder.READ_LENGTH_BYTES;\n      }\n    }\n    else if (this.state == TlvStructureDecoder.READ_LENGTH_BYTES) {\n      var nRemainingBytes = input.length - this.offset;\n      if (!this.useHeaderBuffer && nRemainingBytes >= this.nBytesToRead) {\n        // We don\'t have to use the headerBuffer. Set nBytesToRead.\n        decoder.seek(this.offset);\n\n        this.nBytesToRead = decoder.readExtendedVarNumber(this.firstOctet);\n        // Update this.offset to the decoder\'s offset after reading.\n        this.offset = decoder.getOffset();\n      }\n      else {\n        this.useHeaderBuffer = true;\n\n        var nNeededBytes = this.nBytesToRead - this.headerLength;\n        if (nNeededBytes > nRemainingBytes) {\n          // We can\'t get all of the header bytes from this input. \n          // Save in headerBuffer.\n          if (this.headerLength + nRemainingBytes > this.headerBuffer.length)\n            // We don\'t expect this to happen.\n            throw new Error\n              ("Cannot store more header bytes than the size of headerBuffer");\n          input.slice(this.offset, this.offset + nRemainingBytes).copy\n            (this.headerBuffer, this.headerLength);\n          this.offset += nRemainingBytes;\n          this.headerLength += nRemainingBytes;\n\n          return false;\n        }\n\n        // Copy the remaining bytes into headerBuffer, read the \n        //   length and set nBytesToRead.\n        if (this.headerLength + nNeededBytes > this.headerBuffer.length)\n          // We don\'t expect this to happen.\n          throw new Error\n            ("Cannot store more header bytes than the size of headerBuffer");\n        input.slice(this.offset, this.offset + nNeededBytes).copy\n          (this.headerBuffer, this.headerLength);\n        this.offset += nNeededBytes;\n\n        // Use a local decoder just for the headerBuffer.\n        var bufferDecoder = new TlvDecoder(this.headerBuffer);\n        // Replace nBytesToRead with the length of the value.\n        this.nBytesToRead = bufferDecoder.readExtendedVarNumber(this.firstOctet);\n      }\n      \n      if (this.nBytesToRead == 0) {\n        // No value bytes to read. We\'re finished.\n        this.gotElementEnd = true;\n        return true;\n      }\n\n      // Get ready to read the value bytes.\n      this.state = TlvStructureDecoder.READ_VALUE_BYTES;\n    }\n    else if (this.state == TlvStructureDecoder.READ_VALUE_BYTES) {\n      nRemainingBytes = input.length - this.offset;\n      if (nRemainingBytes < this.nBytesToRead) {\n        // Need more.\n        this.offset += nRemainingBytes;\n        this.nBytesToRead -= nRemainingBytes;\n        return false;\n      }\n\n      // Got the bytes. We\'re finished.\n      this.offset += this.nBytesToRead;\n      this.gotElementEnd = true;\n      return true;\n    }\n    else\n      // We don\'t expect this to happen.\n      throw new Error("findElementEnd: unrecognized state");\n  }\n};\n\n/**\n * Get the current offset into the input buffer.\n * @returns {number} The offset.\n */\nTlvStructureDecoder.prototype.getOffset = function()\n{\n  return this.offset;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nTlvStructureDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n\n})()\n},{"../../buffer.js":116,"./tlv-decoder.js":107}],152:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DynamicBuffer = require(\'../../util/dynamic-buffer.js\').DynamicBuffer;\n\n/**\n * Create a new TlvEncoder with an initialCapacity for the encoding buffer.\n * @constructor\n * @param {number} initialCapacity (optional) The initial capacity of the \n * encoding buffer. If omitted, use a default value.\n */\nvar TlvEncoder = function TlvEncoder(initialCapacity)\n{\n  initialCapacity = initialCapacity || 16;\n  this.output = new DynamicBuffer(initialCapacity);\n  // length is the number of bytes that have been written to the back of \n  //  this.output.array.\n  this.length = 0;\n};\n\nexports.TlvEncoder = TlvEncoder;\n\n/**\n * Get the number of bytes that have been written to the output.  You can\n * save this number, write sub TLVs, then subtract the new length from this\n * to get the total length of the sub TLVs.\n * @returns {number} The number of bytes that have been written to the output.\n */\nTlvEncoder.prototype.getLength = function()\n{\n  return this.length;\n};\n\n/**\n * Encode varNumber as a VAR-NUMBER in NDN-TLV and write it to this.output just \n * before this.length from the back.  Advance this.length.\n * @param {number} varNumber The non-negative number to encode.\n */\nTlvEncoder.prototype.writeVarNumber = function(varNumber)\n{\n  if (varNumber < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffff) {\n    this.length += 3;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 253;\n    this.output.array[offset + 1] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 2] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffffffff) {\n    this.length += 5;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 254;\n    this.output.array[offset + 1] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 4] = varNumber & 0xff;\n  }\n  else {\n    this.length += 9;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 255;\n    this.output.array[offset + 1] = (varNumber >> 56) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 48) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 40) & 0xff;\n    this.output.array[offset + 4] = (varNumber >> 32) & 0xff;\n    this.output.array[offset + 5] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 6] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 7] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 8] = varNumber & 0xff;\n  }\n};\n\n/**\n * Encode the type and length as VAR-NUMBER and write to this.output just before \n * this.length from the back.  Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} length The non-negative length of the TLV.\n */\nTlvEncoder.prototype.writeTypeAndLength = function(type, length)\n{\n  // Write backwards.\n  this.writeVarNumber(length);\n  this.writeVarNumber(type);\n};\n\n/**\n * Write the type, then the length of the encoded value then encode value as a \n * non-negative integer and write it to this.output just before this.length from \n * the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} value The non-negative integer to encode.\n */\nTlvEncoder.prototype.writeNonNegativeIntegerTlv = function(type, value)\n{\n  if (value < 0)\n    throw new Error("TLV integer value may not be negative");\n\n  // JavaScript doesn\'t distinguish int from float, so round.\n  value = Math.round(value)\n\n  // Write backwards.\n  var saveNBytes = this.length;\n  if (value < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = value & 0xff;\n  }\n  else if (value <= 0xffff) {\n    this.length += 2;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 8) & 0xff;\n    this.output.array[offset + 1] = value & 0xff;\n  }\n  else if (value <= 0xffffffff) {\n    this.length += 4;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 24) & 0xff;\n    this.output.array[offset + 1] = (value >> 16) & 0xff;\n    this.output.array[offset + 2] = (value >> 8) & 0xff;\n    this.output.array[offset + 3] = value & 0xff;\n  }\n  else {\n    this.length += 8;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 56) & 0xff;\n    this.output.array[offset + 1] = (value >> 48) & 0xff;\n    this.output.array[offset + 2] = (value >> 40) & 0xff;\n    this.output.array[offset + 3] = (value >> 32) & 0xff;\n    this.output.array[offset + 4] = (value >> 24) & 0xff;\n    this.output.array[offset + 5] = (value >> 16) & 0xff;\n    this.output.array[offset + 6] = (value >> 8) & 0xff;\n    this.output.array[offset + 7] = value & 0xff;\n  }\n\n  this.writeTypeAndLength(type, this.length - saveNBytes);\n};\n\n/**\n * If value is negative or null then do nothing, otherwise call \n * writeNonNegativeIntegerTlv.\n * @param {number} type The type of the TLV.\n * @param {number} value If negative or None do nothing, otherwise the integer \n *   to encode.\n */\nTlvEncoder.prototype.writeOptionalNonNegativeIntegerTlv = function(type, value)\n{\n  if (value != null && value >= 0)\n    this.writeNonNegativeIntegerTlv(type, value);\n};\n\n/**\n * Write the type, then the length of the buffer then the buffer value to \n * this.output just before this.length from the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value The byte array with the bytes of the blob.  If value is\n    null, then just write the type and length 0.\n */\nTlvEncoder.prototype.writeBlobTlv = function(type, value)\n{\n  if (value == null) {\n    this.writeTypeAndLength(type, 0);\n    return;\n  }\n\n  // Write backwards, starting with the blob array.    \n  this.length += value.length;\n  this.output.copyFromBack(value, this.length);\n\n  this.writeTypeAndLength(type, value.length);\n};\n\n/**\n * If the byte array is null or zero length then do nothing, otherwise call \n * writeBlobTlv.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value If null or zero length do nothing, otherwise the byte \n * array with the bytes of the blob.\n */\nTlvEncoder.prototype.writeOptionalBlobTlv = function(type, value)\n{\n  if (value != null && value.length > 0)\n    this.writeBlobTlv(type, value);\n};\n\n/**\n * Get a slice of the encoded bytes.\n * @returns {Buffer} A slice backed by the encoding customBuf.\n */\nTlvEncoder.prototype.getOutput = function()\n{\n  return this.output.array.slice(this.output.array.length - this.length);\n};\n\n})()\n},{"../../buffer.js":54,"../../util/dynamic-buffer.js":147}],160:[function(require,module,exports){\n(function(){\n    \n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary&0xffffff)==0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a,b,c) {\n      if(a != null)\n        if("number" == typeof a) this.fromNumber(a,b,c);\n        else if(b == null && "string" != typeof a) this.fromString(a,256);\n        else this.fromString(a,b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i,x,w,j,c,n) {\n      while(--n >= 0) {\n        var v = x*this[i++]+w[j]+c;\n        c = Math.floor(v/0x4000000);\n        w[j++] = v&0x3ffffff;\n      }\n      return c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i,x,w,j,c,n) {\n      var xl = x&0x7fff, xh = x>>15;\n      while(--n >= 0) {\n        var l = this[i]&0x7fff;\n        var h = this[i++]>>15;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n        w[j++] = l&0x3fffffff;\n      }\n      return c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i,x,w,j,c,n) {\n      var xl = x&0x3fff, xh = x>>14;\n      while(--n >= 0) {\n        var l = this[i]&0x3fff;\n        var h = this[i++]>>14;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n        c = (l>>28)+(m>>14)+xh*h;\n        w[j++] = l&0xfffffff;\n      }\n      return c;\n    }\n    var inBrowser = typeof navigator !== "undefined";\n    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\n      BigInteger.prototype.am = am2;\n      dbits = 30;\n    }\n    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {\n      BigInteger.prototype.am = am1;\n      dbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1<<dbits)-1);\n    BigInteger.prototype.DV = (1<<dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n    BigInteger.prototype.F1 = BI_FP-dbits;\n    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n    // Digit conversions\n    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\n    var BI_RC = new Array();\n    var rr,vv;\n    rr = "0".charCodeAt(0);\n    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = "a".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = "A".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s,i) {\n      var c = BI_RC[s.charCodeAt(i)];\n      return (c==null)?-1:c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n      r.t = this.t;\n      r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n      this.t = 1;\n      this.s = (x<0)?-1:0;\n      if(x > 0) this[0] = x;\n      else if(x < -1) this[0] = x+DV;\n      else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n    function bnpFromString(s,b) {\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 256) k = 8; // byte array\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else { this.fromRadix(s,b); return; }\n      this.t = 0;\n      this.s = 0;\n      var i = s.length, mi = false, sh = 0;\n      while(--i >= 0) {\n        var x = (k==8)?s[i]&0xff:intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-") mi = true;\n          continue;\n        }\n        mi = false;\n        if(sh == 0)\n          this[this.t++] = x;\n        else if(sh+k > this.DB) {\n          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n          this[this.t++] = (x>>(this.DB-sh));\n        }\n        else\n          this[this.t-1] |= x<<sh;\n        sh += k;\n        if(sh >= this.DB) sh -= this.DB;\n      }\n      if(k == 8 && (s[0]&0x80) != 0) {\n        this.s = -1;\n        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n      }\n      this.clamp();\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n      var c = this.s&this.DM;\n      while(this.t > 0 && this[this.t-1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n      if(this.s < 0) return "-"+this.negate().toString(b);\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else return this.toRadix(b);\n      var km = (1<<k)-1, d, m = false, r = "", i = this.t;\n      var p = this.DB-(i*this.DB)%k;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n        while(i >= 0) {\n          if(p < k) {\n            d = (this[i]&((1<<p)-1))<<(k-p);\n            d |= this[--i]>>(p+=this.DB-k);\n          }\n          else {\n            d = (this[i]>>(p-=k))&km;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if(d > 0) m = true;\n          if(m) r += int2char(d);\n        }\n      }\n      return m?r:"0";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s<0)?this.negate():this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n      var r = this.s-a.s;\n      if(r != 0) return r;\n      var i = this.t;\n      r = i-a.t;\n      if(r != 0) return (this.s<0)?-r:r;\n      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n      return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n      var r = 1, t;\n      if((t=x>>>16) != 0) { x = t; r += 16; }\n      if((t=x>>8) != 0) { x = t; r += 8; }\n      if((t=x>>4) != 0) { x = t; r += 4; }\n      if((t=x>>2) != 0) { x = t; r += 2; }\n      if((t=x>>1) != 0) { x = t; r += 1; }\n      return r;\n    }\n\n    // (public) return the number of bits in "this"\n    function bnBitLength() {\n      if(this.t <= 0) return 0;\n      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n,r) {\n      var i;\n      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n      for(i = n-1; i >= 0; --i) r[i] = 0;\n      r.t = this.t+n;\n      r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n,r) {\n      for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n      r.t = Math.max(this.t-n,0);\n      r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n,r) {\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<cbs)-1;\n      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n      for(i = this.t-1; i >= 0; --i) {\n        r[i+ds+1] = (this[i]>>cbs)|c;\n        c = (this[i]&bm)<<bs;\n      }\n      for(i = ds-1; i >= 0; --i) r[i] = 0;\n      r[ds] = c;\n      r.t = this.t+ds+1;\n      r.s = this.s;\n      r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n,r) {\n      r.s = this.s;\n      var ds = Math.floor(n/this.DB);\n      if(ds >= this.t) { r.t = 0; return; }\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<bs)-1;\n      r[0] = this[ds]>>bs;\n      for(var i = ds+1; i < this.t; ++i) {\n        r[i-ds-1] |= (this[i]&bm)<<cbs;\n        r[i-ds] = this[i]>>bs;\n      }\n      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n      r.t = this.t-ds;\n      r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]-a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c -= a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c -= a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c -= a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c < -1) r[i++] = this.DV+c;\n      else if(c > 0) r[i++] = c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyTo(a,r) {\n      var x = this.abs(), y = a.abs();\n      var i = x.t;\n      r.t = i+y.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n      r.s = 0;\n      r.clamp();\n      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n      var x = this.abs();\n      var i = r.t = 2*x.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < x.t-1; ++i) {\n        var c = x.am(i,x[i],r,2*i,0,1);\n        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n          r[i+x.t] -= x.DV;\n          r[i+x.t+1] = 1;\n        }\n      }\n      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n      r.s = 0;\n      r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m,q,r) {\n      var pm = m.abs();\n      if(pm.t <= 0) return;\n      var pt = this.abs();\n      if(pt.t < pm.t) {\n        if(q != null) q.fromInt(0);\n        if(r != null) this.copyTo(r);\n        return;\n      }\n      if(r == null) r = nbi();\n      var y = nbi(), ts = this.s, ms = m.s;\n      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n      else { pm.copyTo(y); pt.copyTo(r); }\n      var ys = y.t;\n      var y0 = y[ys-1];\n      if(y0 == 0) return;\n      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n      var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n      y.dlShiftTo(j,t);\n      if(r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t,r);\n      }\n      BigInteger.ONE.dlShiftTo(ys,t);\n      t.subTo(y,y);  // "negative" y so we can replace sub with am later\n      while(y.t < ys) y[y.t++] = 0;\n      while(--j >= 0) {\n        // Estimate quotient digit\n        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n          y.dlShiftTo(j,t);\n          r.subTo(t,r);\n          while(r[i] < --qd) r.subTo(t,r);\n        }\n      }\n      if(q != null) {\n        r.drShiftTo(ys,q);\n        if(ts != ms) BigInteger.ZERO.subTo(q,q);\n      }\n      r.t = ys;\n      r.clamp();\n      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n      if(ts < 0) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n      var r = nbi();\n      this.abs().divRemTo(a,null,r);\n      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n      return r;\n    }\n\n    // Modular reduction using "classic" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n      else return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m,null,x); }\n    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply "overflows" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n      if(this.t < 1) return 0;\n      var x = this[0];\n      if((x&1) == 0) return 0;\n      var y = x&3;       // y == 1/x mod 2^2\n      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n      // last step - calculate inverse mod DV directly;\n      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n      // we really want the negative inverse, and -DV < y < DV\n      return (y>0)?this.DV-y:-y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n      this.m = m;\n      this.mp = m.invDigit();\n      this.mpl = this.mp&0x7fff;\n      this.mph = this.mp>>15;\n      this.um = (1<<(m.DB-15))-1;\n      this.mt2 = 2*m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n      var r = nbi();\n      x.abs().dlShiftTo(this.m.t,r);\n      r.divRemTo(this.m,null,r);\n      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n      return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n      while(x.t <= this.mt2) // pad x so am has enough room later\n        x[x.t++] = 0;\n      for(var i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        var j = x[i]&0x7fff;\n        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i+this.m.t;\n        x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n        // propagate carry\n        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n      }\n      x.clamp();\n      x.drShiftTo(this.m.t,x);\n      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = "x^2/R mod m"; x != r\n    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = "xy/R mod m"; x,y != r\n    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)\n    function bnpExp(e,z) {\n      if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n      g.copyTo(r);\n      while(--i >= 0) {\n        z.sqrTo(r,r2);\n        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n        else { var t = r; r = r2; r2 = t; }\n      }\n      return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e,m) {\n      var z;\n      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n      return this.exp(e,z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // "constants"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger("0", 10) returns "proper" zero\n    // Version 1.2: square() API, isProbablePrime fix\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n      if(this.s < 0) {\n        if(this.t == 1) return this[0]-this.DV;\n        else if(this.t == 0) return -1;\n      }\n      else if(this.t == 1) return this[0];\n      else if(this.t == 0) return 0;\n      // assumes 16 < DB < 32\n      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n      if(this.s < 0) return -1;\n      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n      else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n      if(b == null) b = 10;\n      if(this.signum() == 0 || b < 2 || b > 36) return "0";\n      var cs = this.chunkSize(b);\n      var a = Math.pow(b,cs);\n      var d = nbv(a), y = nbi(), z = nbi(), r = "";\n      this.divRemTo(d,y,z);\n      while(y.signum() > 0) {\n        r = (a+z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d,y,z);\n      }\n      return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s,b) {\n      this.fromInt(0);\n      if(b == null) b = 10;\n      var cs = this.chunkSize(b);\n      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n      for(var i = 0; i < s.length; ++i) {\n        var x = intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;\n          continue;\n        }\n        w = b*w+x;\n        if(++j >= cs) {\n          this.dMultiply(d);\n          this.dAddOffset(w,0);\n          j = 0;\n          w = 0;\n        }\n      }\n      if(j > 0) {\n        this.dMultiply(Math.pow(b,j));\n        this.dAddOffset(w,0);\n      }\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a,b,c) {\n      if("number" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if(a < 2) this.fromInt(1);\n        else {\n          this.fromNumber(a,c);\n          if(!this.testBit(a-1))\t// force MSB set\n            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n          if(this.isEven()) this.dAddOffset(1,0); // force odd\n          while(!this.isProbablePrime(b)) {\n            this.dAddOffset(2,0);\n            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n          }\n        }\n      }\n      else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a&7;\n        x.length = (a>>3)+1;\n        b.nextBytes(x);\n        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n        this.fromString(x,256);\n      }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n      var i = this.t, r = new Array();\n      r[0] = this.s;\n      var p = this.DB-(i*this.DB)%8, d, k = 0;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n          r[k++] = d|(this.s<<(this.DB-p));\n        while(i >= 0) {\n          if(p < 8) {\n            d = (this[i]&((1<<p)-1))<<(8-p);\n            d |= this[--i]>>(p+=this.DB-8);\n          }\n          else {\n            d = (this[i]>>(p-=8))&0xff;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if((d&0x80) != 0) d |= -256;\n          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n          if(k > 0 || d != this.s) r[k++] = d;\n        }\n      }\n      return r;\n    }\n\n    function bnEquals(a) { return(this.compareTo(a)==0); }\n    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a,op,r) {\n      var i, f, m = Math.min(a.t,this.t);\n      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n      if(a.t < this.t) {\n        f = a.s&this.DM;\n        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n        r.t = this.t;\n      }\n      else {\n        f = this.s&this.DM;\n        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n        r.t = a.t;\n      }\n      r.s = op(this.s,a.s);\n      r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x,y) { return x&y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n    // (public) this | a\n    function op_or(x,y) { return x|y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x,y) { return x^y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x,y) { return x&~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n      var r = nbi();\n      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n      r.t = this.t;\n      r.s = ~this.s;\n      return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n      var r = nbi();\n      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n      return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n      var r = nbi();\n      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n      return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n      if(x == 0) return -1;\n      var r = 0;\n      if((x&0xffff) == 0) { x >>= 16; r += 16; }\n      if((x&0xff) == 0) { x >>= 8; r += 8; }\n      if((x&0xf) == 0) { x >>= 4; r += 4; }\n      if((x&3) == 0) { x >>= 2; r += 2; }\n      if((x&1) == 0) ++r;\n      return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n      for(var i = 0; i < this.t; ++i)\n        if(this[i] != 0) return i*this.DB+lbit(this[i]);\n      if(this.s < 0) return this.t*this.DB;\n      return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n      var r = 0;\n      while(x != 0) { x &= x-1; ++r; }\n      return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n      var r = 0, x = this.s&this.DM;\n      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n      return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n      var j = Math.floor(n/this.DB);\n      if(j >= this.t) return(this.s!=0);\n      return((this[j]&(1<<(n%this.DB)))!=0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n,op) {\n      var r = BigInteger.ONE.shiftLeft(n);\n      this.bitwiseTo(r,op,r);\n      return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]+a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c += a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c += a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c > 0) r[i++] = c;\n      else if(c < -1) r[i++] = this.DV+c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n    // (public) this^2\n    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n      var q = nbi(), r = nbi();\n      this.divRemTo(a,q,r);\n      return new Array(q,r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n      this[this.t] = this.am(0,n-1,this,0,0,this.t);\n      ++this.t;\n      this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n,w) {\n      if(n == 0) return;\n      while(this.t <= w) this[this.t++] = 0;\n      this[w] += n;\n      while(this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if(++w >= this.t) this[this.t++] = 0;\n        ++this[w];\n      }\n    }\n\n    // A "null" reducer\n    function NullExp() {}\n    function nNop(x) { return x; }\n    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n    function nSqrTo(x,r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.exp(e,new NullExp()); }\n\n    // (protected) r = lower n words of "this * a", a.t <= n\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a,n,r) {\n      var i = Math.min(this.t+a.t,n);\n      r.s = 0; // assumes a,this >= 0\n      r.t = i;\n      while(i > 0) r[--i] = 0;\n      var j;\n      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n      r.clamp();\n    }\n\n    // (protected) r = "this * a" without lower n words, n > 0\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a,n,r) {\n      --n;\n      var i = r.t = this.t+a.t-n;\n      r.s = 0; // assumes a,this >= 0\n      while(--i >= 0) r[i] = 0;\n      for(i = Math.max(n-this.t,0); i < a.t; ++i)\n        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n      r.clamp();\n      r.drShiftTo(1,r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n      // setup Barrett\n      this.r2 = nbi();\n      this.q3 = nbi();\n      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n      this.mu = this.r2.divide(m);\n      this.m = m;\n    }\n\n    function barrettConvert(x) {\n      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n      else if(x.compareTo(this.m) < 0) return x;\n      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n      x.drShiftTo(this.m.t-1,this.r2);\n      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n      x.subTo(this.r2,x);\n      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e,m) {\n      var i = e.bitLength(), k, r = nbv(1), z;\n      if(i <= 0) return r;\n      else if(i < 18) k = 1;\n      else if(i < 48) k = 3;\n      else if(i < 144) k = 4;\n      else if(i < 768) k = 5;\n      else k = 6;\n      if(i < 8)\n        z = new Classic(m);\n      else if(m.isEven())\n        z = new Barrett(m);\n      else\n        z = new Montgomery(m);\n\n      // precomputation\n      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n      g[1] = z.convert(this);\n      if(k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1],g2);\n        while(n <= km) {\n          g[n] = nbi();\n          z.mulTo(g2,g[n-2],g[n]);\n          n += 2;\n        }\n      }\n\n      var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n      i = nbits(e[j])-1;\n      while(j >= 0) {\n        if(i >= k1) w = (e[j]>>(i-k1))&km;\n        else {\n          w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n        }\n\n        n = k;\n        while((w&1) == 0) { w >>= 1; --n; }\n        if((i -= n) < 0) { i += this.DB; --j; }\n        if(is1) {\t// ret == 1, don\'t bother squaring or multiplying it\n          g[w].copyTo(r);\n          is1 = false;\n        }\n        else {\n          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n          z.mulTo(r2,g[w],r);\n        }\n\n        while(j >= 0 && (e[j]&(1<<i)) == 0) {\n          z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n          if(--i < 0) { i = this.DB-1; --j; }\n        }\n      }\n      return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n      var x = (this.s<0)?this.negate():this.clone();\n      var y = (a.s<0)?a.negate():a.clone();\n      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n      if(g < 0) return x;\n      if(i < g) g = i;\n      if(g > 0) {\n        x.rShiftTo(g,x);\n        y.rShiftTo(g,y);\n      }\n      while(x.signum() > 0) {\n        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n        if(x.compareTo(y) >= 0) {\n          x.subTo(y,x);\n          x.rShiftTo(1,x);\n        }\n        else {\n          y.subTo(x,y);\n          y.rShiftTo(1,y);\n        }\n      }\n      if(g > 0) y.lShiftTo(g,y);\n      return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n      if(n <= 0) return 0;\n      var d = this.DV%n, r = (this.s<0)?n-1:0;\n      if(this.t > 0)\n        if(d == 0) r = this[0]%n;\n        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n      return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n      var ac = m.isEven();\n      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n      var u = m.clone(), v = this.clone();\n      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n      while(u.signum() != 0) {\n        while(u.isEven()) {\n          u.rShiftTo(1,u);\n          if(ac) {\n            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n            a.rShiftTo(1,a);\n          }\n          else if(!b.isEven()) b.subTo(m,b);\n          b.rShiftTo(1,b);\n        }\n        while(v.isEven()) {\n          v.rShiftTo(1,v);\n          if(ac) {\n            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n            c.rShiftTo(1,c);\n          }\n          else if(!d.isEven()) d.subTo(m,d);\n          d.rShiftTo(1,d);\n        }\n        if(u.compareTo(v) >= 0) {\n          u.subTo(v,u);\n          if(ac) a.subTo(c,a);\n          b.subTo(d,b);\n        }\n        else {\n          v.subTo(u,v);\n          if(ac) c.subTo(a,c);\n          d.subTo(b,d);\n        }\n      }\n      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n      if(d.compareTo(m) >= 0) return d.subtract(m);\n      if(d.signum() < 0) d.addTo(m,d); else return d;\n      if(d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n      var i, x = this.abs();\n      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n        for(i = 0; i < lowprimes.length; ++i)\n          if(x[0] == lowprimes[i]) return true;\n        return false;\n      }\n      if(x.isEven()) return false;\n      i = 1;\n      while(i < lowprimes.length) {\n        var m = lowprimes[i], j = i+1;\n        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j) if(m%lowprimes[i++] == 0) return false;\n      }\n      return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n      var n1 = this.subtract(BigInteger.ONE);\n      var k = n1.getLowestSetBit();\n      if(k <= 0) return false;\n      var r = n1.shiftRight(k);\n      t = (t+1)>>1;\n      if(t > lowprimes.length) t = lowprimes.length;\n      var a = nbi();\n      for(var i = 0; i < t; ++i) {\n        //Pick bases at random, instead of starting at 2\n        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n        var y = a.modPow(r,this);\n        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n          var j = 1;\n          while(j++ < k && y.compareTo(n1) != 0) {\n            y = y.modPowInt(2,this);\n            if(y.compareTo(BigInteger.ONE) == 0) return false;\n          }\n          if(y.compareTo(n1) != 0) return false;\n        }\n      }\n      return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // JSBN-specific extension\n    BigInteger.prototype.square = bnSquare;\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n    if (typeof exports !== \'undefined\') {\n        exports = module.exports = BigInteger;\n    } else {\n        this.BigInteger = BigInteger;\n    }\n    \n}).call(this);\n},{}],162:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/**\n * CryptoJS core components.\n */\nvar CryptoJS = CryptoJS || (function (Math, undefined) {\n    /**\n     * CryptoJS namespace.\n     */\n    var C = {};\n\n    /**\n     * Library namespace.\n     */\n    var C_lib = C.lib = {};\n\n    /**\n     * Base object for prototypal inheritance.\n     */\n    var Base = C_lib.Base = (function () {\n        function F() {}\n\n        return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: \'value\',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function (overrides) {\n                // Spawn\n                F.prototype = this;\n                var subtype = new F();\n\n                // Augment\n                if (overrides) {\n                    subtype.mixIn(overrides);\n                }\n\n                // Create default initializer\n                if (!subtype.hasOwnProperty(\'init\')) {\n                    subtype.init = function () {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                }\n\n                // Initializer\'s prototype is the subtype object\n                subtype.init.prototype = subtype;\n\n                // Reference supertype\n                subtype.$super = this;\n\n                return subtype;\n            },\n\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function () {\n                var instance = this.extend();\n                instance.init.apply(instance, arguments);\n\n                return instance;\n            },\n\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function () {\n            },\n\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: \'value\'\n             *     });\n             */\n            mixIn: function (properties) {\n                for (var propertyName in properties) {\n                    if (properties.hasOwnProperty(propertyName)) {\n                        this[propertyName] = properties[propertyName];\n                    }\n                }\n\n                // IE won\'t copy toString using the loop above\n                if (properties.hasOwnProperty(\'toString\')) {\n                    this.toString = properties.toString;\n                }\n            },\n\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function () {\n                return this.init.prototype.extend(this);\n            }\n        };\n    }());\n\n    /**\n     * An array of 32-bit words.\n     *\n     * @property {Array} words The array of 32-bit words.\n     * @property {number} sigBytes The number of significant bytes in this word array.\n     */\n    var WordArray = C_lib.WordArray = Base.extend({\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param {Array} words (Optional) An array of 32-bit words.\n         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.create();\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n         */\n        init: function (words, sigBytes) {\n            words = this.words = words || [];\n\n            if (sigBytes != undefined) {\n                this.sigBytes = sigBytes;\n            } else {\n                this.sigBytes = words.length * 4;\n            }\n        },\n\n        /**\n         * Converts this word array to a string.\n         *\n         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {string} The stringified word array.\n         *\n         * @example\n         *\n         *     var string = wordArray + \'\';\n         *     var string = wordArray.toString();\n         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        toString: function (encoder) {\n            return (encoder || Hex).stringify(this);\n        },\n\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param {WordArray} wordArray The word array to append.\n         *\n         * @return {WordArray} This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        concat: function (wordArray) {\n            // Shortcuts\n            var thisWords = this.words;\n            var thatWords = wordArray.words;\n            var thisSigBytes = this.sigBytes;\n            var thatSigBytes = wordArray.sigBytes;\n\n            // Clamp excess bits\n            this.clamp();\n\n            // Concat\n            if (thisSigBytes % 4) {\n                // Copy one byte at a time\n                for (var i = 0; i < thatSigBytes; i++) {\n                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n                }\n            } else if (thatWords.length > 0xffff) {\n                // Copy one word at a time\n                for (var i = 0; i < thatSigBytes; i += 4) {\n                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n                }\n            } else {\n                // Copy all words at once\n                thisWords.push.apply(thisWords, thatWords);\n            }\n            this.sigBytes += thatSigBytes;\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        clamp: function () {\n            // Shortcuts\n            var words = this.words;\n            var sigBytes = this.sigBytes;\n\n            // Clamp\n            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n            words.length = Math.ceil(sigBytes / 4);\n        },\n\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return {WordArray} The clone.\n         *\n         * @example\n         *\n         *     var clone = wordArray.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone.words = this.words.slice(0);\n\n            return clone;\n        },\n\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * @param {number} nBytes The number of random bytes to generate.\n         *\n         * @return {WordArray} The random word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n         */\n        random: function (nBytes) {\n            var words = [];\n            for (var i = 0; i < nBytes; i += 4) {\n                words.push((Math.random() * 0x100000000) | 0);\n            }\n\n            return new WordArray.init(words, nBytes);\n        }\n    });\n\n    /**\n     * Encoder namespace.\n     */\n    var C_enc = C.enc = {};\n\n    /**\n     * Hex encoding strategy.\n     */\n    var Hex = C_enc.Hex = {\n        /**\n         * Converts a word array to a hex string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The hex string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var hexChars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n\n            return hexChars.join(\'\');\n        },\n\n        /**\n         * Converts a hex string to a word array.\n         *\n         * @param {string} hexStr The hex string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n         */\n        parse: function (hexStr) {\n            // Shortcut\n            var hexStrLength = hexStr.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n\n            return new WordArray.init(words, hexStrLength / 2);\n        }\n    };\n\n    /**\n     * Latin1 encoding strategy.\n     */\n    var Latin1 = C_enc.Latin1 = {\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Latin1 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var latin1Chars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n\n            return latin1Chars.join(\'\');\n        },\n\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * @param {string} latin1Str The Latin1 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n         */\n        parse: function (latin1Str) {\n            // Shortcut\n            var latin1StrLength = latin1Str.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n\n            return new WordArray.init(words, latin1StrLength);\n        }\n    };\n\n    /**\n     * UTF-8 encoding strategy.\n     */\n    var Utf8 = C_enc.Utf8 = {\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The UTF-8 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            } catch (e) {\n                throw new Error(\'Malformed UTF-8 data\');\n            }\n        },\n\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * @param {string} utf8Str The UTF-8 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n         */\n        parse: function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        }\n    };\n\n    /**\n     * Abstract buffered block algorithm template.\n     *\n     * The property blockSize must be implemented in a concrete subtype.\n     *\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n     */\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n        /**\n         * Resets this block algorithm\'s data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        reset: function () {\n            // Initial values\n            this._data = new WordArray.init();\n            this._nDataBytes = 0;\n        },\n\n        /**\n         * Adds new data to this block algorithm\'s buffer.\n         *\n         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append(\'data\');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        _append: function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data == \'string\') {\n                data = Utf8.parse(data);\n            }\n\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        },\n\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {WordArray} The processed data.\n         *\n         * @example\n         *\n         *     var processedData = bufferedBlockAlgorithm._process();\n         *     var processedData = bufferedBlockAlgorithm._process(!!\'flush\');\n         */\n        _process: function (doFlush) {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n            var dataSigBytes = data.sigBytes;\n            var blockSize = this.blockSize;\n            var blockSizeBytes = blockSize * 4;\n\n            // Count blocks ready\n            var nBlocksReady = dataSigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            } else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n\n            // Count words ready\n            var nWordsReady = nBlocksReady * blockSize;\n\n            // Count bytes ready\n            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n            // Process blocks\n            if (nWordsReady) {\n                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                }\n\n                // Remove processed words\n                var processedWords = dataWords.splice(0, nWordsReady);\n                data.sigBytes -= nBytesReady;\n            }\n\n            // Return processed words\n            return new WordArray.init(processedWords, nBytesReady);\n        },\n\n        /**\n         * Creates a copy of this object.\n         *\n         * @return {Object} The clone.\n         *\n         * @example\n         *\n         *     var clone = bufferedBlockAlgorithm.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone._data = this._data.clone();\n\n            return clone;\n        },\n\n        _minBufferSize: 0\n    });\n\n    /**\n     * Abstract hasher template.\n     *\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n     */\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n        /**\n         * Configuration options.\n         */\n        cfg: Base.extend(),\n\n        /**\n         * Initializes a newly created hasher.\n         *\n         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n         *\n         * @example\n         *\n         *     var hasher = CryptoJS.algo.SHA256.create();\n         */\n        init: function (cfg) {\n            // Apply config defaults\n            this.cfg = this.cfg.extend(cfg);\n\n            // Set initial values\n            this.reset();\n        },\n\n        /**\n         * Resets this hasher to its initial state.\n         *\n         * @example\n         *\n         *     hasher.reset();\n         */\n        reset: function () {\n            // Reset data buffer\n            BufferedBlockAlgorithm.reset.call(this);\n\n            // Perform concrete-hasher logic\n            this._doReset();\n        },\n\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param {WordArray|string} messageUpdate The message to append.\n         *\n         * @return {Hasher} This hasher.\n         *\n         * @example\n         *\n         *     hasher.update(\'message\');\n         *     hasher.update(wordArray);\n         */\n        update: function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n\n            // Update the hash\n            this._process();\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n         *\n         * @return {WordArray} The hash.\n         *\n         * @example\n         *\n         *     var hash = hasher.finalize();\n         *     var hash = hasher.finalize(\'message\');\n         *     var hash = hasher.finalize(wordArray);\n         */\n        finalize: function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n\n            // Perform concrete-hasher logic\n            var hash = this._doFinalize();\n\n            return hash;\n        },\n\n        blockSize: 512/32,\n\n        /**\n         * Creates a shortcut function to a hasher\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to create a helper for.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n         */\n        _createHelper: function (hasher) {\n            return function (message, cfg) {\n                return new hasher.init(cfg).finalize(message);\n            };\n        },\n\n        /**\n         * Creates a shortcut function to the HMAC\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n         */\n        _createHmacHelper: function (hasher) {\n            return function (message, key) {\n                return new C_algo.HMAC.init(hasher, key).finalize(message);\n            };\n        }\n    });\n\n    /**\n     * Algorithm namespace.\n     */\n    var C_algo = C.algo = {};\n\n    return C;\n}(Math));\n\nmodule.exports = CryptoJS\n\n},{}],118:[function(require,module,exports){\n/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * crypto.js - Cryptographic Algorithm Provider class\n *\n * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name crypto-1.0.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.0.4 (2013-Mar-28)\n * @since 2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nvar CryptoJS = require(\'./sha256.js\')\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n/** \n * kjur\'s class library name space\n * @name KJUR\n * @namespace kjur\'s class library name space\n */\nif (typeof KJUR == "undefined" || !KJUR) KJUR = {};\n/**\n * kjur\'s cryptographic algorithm provider library name space\n * <p>\n * This namespace privides following crytpgrahic classes.\n * <ul>\n * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.crypto\n * @namespace\n */\nif (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.Util\n * @class static object for cryptographic function utilities\n * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n * @description\n */\nKJUR.crypto.Util = new function() {\n    this.DIGESTINFOHEAD = {\n\t\'sha1\':      "3021300906052b0e03021a05000414",\n        \'sha224\':    "302d300d06096086480165030402040500041c",\n\t\'sha256\':    "3031300d060960864801650304020105000420",\n\t\'sha384\':    "3041300d060960864801650304020205000430",\n\t\'sha512\':    "3051300d060960864801650304020305000440",\n\t\'md2\':       "3020300c06082a864886f70d020205000410",\n\t\'md5\':       "3020300c06082a864886f70d020505000410",\n\t\'ripemd160\': "3021300906052b2403020105000414"\n    };\n\n    /**\n     * get hexadecimal DigestInfo\n     * @name getDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n     */\n    this.getDigestInfoHex = function(hHash, alg) {\n\tif (typeof this.DIGESTINFOHEAD[alg] == "undefined")\n\t    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;\n\treturn this.DIGESTINFOHEAD[alg] + hHash;\n    };\n\n    /**\n     * get PKCS#1 padded hexadecimal DigestInfo\n     * @name getPaddedDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @param {Integer} keySize key bit length (ex. 1024)\n     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n     */\n    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\tvar pmStrLen = keySize / 4; // minimum PM length\n\n\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;\n\n\tvar hHead = "0001";\n\tvar hTail = "00" + hDigestInfo;\n\tvar hMid = "";\n\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\tfor (var i = 0; i < fLen; i += 2) {\n\t    hMid += "ff";\n\t}\n\tvar hPaddedMessage = hHead + hMid + hTail;\n\treturn hPaddedMessage;\n    };\n\n    /**\n     * get hexadecimal SHA1 hash of string\n     * @name sha1\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha1 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha1\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA256 hash of string\n     * @name sha256\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha256 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha256\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA512 hash of string\n     * @name sha512\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha512 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha512\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal MD5 hash of string\n     * @name md5\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.md5 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'md5\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal RIPEMD160 hash of string\n     * @name ripemd160\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.ripemd160 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'ripemd160\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n};\n\n/**\n * MessageDigest class which is very similar to java.security.MessageDigest class\n * @name KJUR.crypto.MessageDigest\n * @class MessageDigest class which is very similar to java.security.MessageDigest class\n * @param {Array} params parameters for constructor\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>md5 - cryptojs</li>\n * <li>sha1 - cryptojs</li>\n * <li>sha224 - cryptojs</li>\n * <li>sha256 - cryptojs</li>\n * <li>sha384 - cryptojs</li>\n * <li>sha512 - cryptojs</li>\n * <li>ripemd160 - cryptojs</li>\n * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n * </ul>\n * @example\n * // CryptoJS provider sample\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n *\n * // SJCL(Stanford JavaScript Crypto Library) provider sample\n * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n */\nKJUR.crypto.MessageDigest = function(params) {\n    var md = null;\n    var algName = null;\n    var provName = null;\n    var _CryptoJSMdName = {\n\t\'md5\': \'CryptoJS.algo.MD5\',\n\t\'sha1\': \'CryptoJS.algo.SHA1\',\n\t\'sha224\': \'CryptoJS.algo.SHA224\',\n\t\'sha256\': \'CryptoJS.algo.SHA256\',\n\t\'sha384\': \'CryptoJS.algo.SHA384\',\n\t\'sha512\': \'CryptoJS.algo.SHA512\',\n\t\'ripemd160\': \'CryptoJS.algo.RIPEMD160\'\n    };\n\n    /**\n     * set hash algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} alg hash algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * // for SHA1\n     * md.setAlgAndProvider(\'sha1\', \'cryptojs\');\n     * // for RIPEMD160\n     * md.setAlgAndProvider(\'ripemd160\', \'cryptojs\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(alg) != -1 &&\n\t    prov == \'cryptojs\') {\n\t    try {\n\t\tthis.md = eval(_CryptoJSMdName[alg]).create();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.md.update(wHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n\tif (\':sha256:\'.indexOf(alg) != -1 &&\n\t    prov == \'sjcl\') {\n\t    try {\n\t\tthis.md = new sjcl.hash.sha256();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\tthis.md.update(baHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn sjcl.codec.hex.fromBits(hash);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString(\'New York\');\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex(\'0afe36\');\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name digest\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.digest = function() {\n\tthrow "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name digestString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString(\'aaa\')\n     */\n    this.digestString = function(str) {\n\tthrow "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, then completes the digest computation\n     * @name digestHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex(\'0f2abd\')\n     */\n    this.digestHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t}\n    }\n};\n\n\n/**\n * Signature class which is very similar to java.security.Signature class\n * @name KJUR.crypto.Signature\n * @class Signature class which is very similar to java.security.Signature class\n * @param {Array} params parameters for constructor\n * @property {String} state Current state of this signature object whether \'SIGN\', \'VERIFY\' or null\n * @description\n * <br/>\n * As for params of constructor\'s argument, it can be specify following attributes:\n * <ul>\n * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>\n * <li>provider - currently \'cryptojs/jsrsa\' only</li>\n * <li>prvkeypem - PEM string of signer\'s private key. If this specified, no need to call initSign(prvKey).</li>\n * </ul>\n * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}\n * withRSA algorithm in \'cryptojs/jsrsa\' provider.\n * <h4>EXAMPLES</h4>\n * @example\n * // signature generation\n * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig.initSign(prvKey);\n * sig.updateString(\'aaa\');\n * var hSigVal = sig.sign();\n *\n * // signature validation\n * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig2.initVerifyByCertificatePEM(cert)\n * sig.updateString(\'aaa\');\n * var isValid = sig2.verify(hSigVal);\n */\nKJUR.crypto.Signature = function(params) {\n    var prvKey = null; // RSAKey for signing\n    var pubKey = null; // RSAKey for verifying\n\n    var md = null; // KJUR.crypto.MessageDigest object\n    var sig = null;\n    var algName = null;\n    var provName = null;\n    var algProvName = null;\n    var mdAlgName = null;\n    var pubkeyAlgName = null;\n    var state = null;\n\n    var sHashHex = null; // hex hash value for hex\n    var hDigestInfo = null;\n    var hPaddedDigestInfo = null;\n    var hSign = null;\n\n    this._setAlgNames = function() {\n\tif (this.algName.match(/^(.+)with(.+)$/)) {\n\t    this.mdAlgName = RegExp.$1.toLowerCase();\n\t    this.pubkeyAlgName = RegExp.$2.toLowerCase();\n\t}\n    };\n\n    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\tvar s = "";\n\tvar nZero = bitLength / 4 - hex.length;\n\tfor (var i = 0; i < nZero; i++) {\n\t    s = s + "0";\n\t}\n\treturn s + hex;\n    };\n\n    /**\n     * set signature algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} alg signature algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * md.setAlgAndProvider(\'SHA1withRSA\', \'cryptojs/jsrsa\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tthis._setAlgNames();\n\tif (prov != \'cryptojs/jsrsa\')\n\t    throw "provider not supported: " + prov;\n\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(this.mdAlgName) != -1) {\n\t    try {\n\t\tthis.md = new KJUR.crypto.MessageDigest({\'alg\':this.mdAlgName,\'prov\':\'cryptojs\'});\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;\n\t    }\n\n\t    this.initSign = function(prvKey) {\n\t\tthis.prvKey = prvKey;\n\t\tthis.state = "SIGN";\n\t    };\n\n\t    this.initVerifyByPublicKey = function(rsaPubKey) {\n\t\tthis.pubKey = rsaPubKey;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tvar x509 = new X509();\n\t\tx509.readCertPEM(certPEM);\n\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.updateString = function(str) {\n\t\tthis.md.updateString(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tthis.md.updateHex(hex);\n\t    };\n\t    this.sign = function() {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.prvKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\t\tthis.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);\n\t\tthis.hPaddedDigestInfo = \n                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);\n\n\t\tvar biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);\n\t\tthis.hoge = biPaddedDigestInfo.toString(16);\n\n\t\tvar biSign = this.prvKey.doPrivate(biPaddedDigestInfo);\n\t\tthis.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);\n\t\treturn this.hSign;\n\t    };\n\t    this.signString = function(str) {\n\t\tthis.updateString(str);\n\t\tthis.sign();\n\t    };\n\t    this.signHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\tthis.sign();\n\t    };\n\t    this.verify = function(hSigVal) {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.pubKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\n\t\tvar biSigVal = parseBigInt(hSigVal, 16);\n\t\tvar biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);\n\t\tthis.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);\n                var s = this.hPaddedDigestInfo;\n                s = s.replace(/^1ff+00/, \'\');\n\n\t\tvar hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];\n                if (s.indexOf(hDIHEAD) != 0) {\n\t\t    return false;\n\t\t}\n\t\tvar hHashFromDI = s.substr(hDIHEAD.length);\n\t\t//alert(hHashFromDI + "\\n" + this.sHashHex);\n\t\treturn (hHashFromDI == this.sHashHex);\n\t    };\n\t}\n    };\n\n    /**\n     * Initialize this object for verifying with a public key\n     * @name initVerifyByPublicKey\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} rsaPubKey RSAKey object of public key\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByPublicKey(prvKey)\n     */\n    this.initVerifyByPublicKey = function(rsaPubKey) {\n\tthrow "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a certficate\n     * @name initVerifyByCertificatePEM\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} certPEM PEM formatted string of certificate\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByCertificatePEM(certPEM)\n     */\n    this.initVerifyByCertificatePEM = function(certPEM) {\n\tthrow "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for signing\n     * @name initSign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} prvKey RSAKey object of private key\n     * @description\n     * @example\n     * sig.initSign(prvKey)\n     */\n    this.initSign = function(prvKey) {\n\tthrow "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a string\n     * @name updateString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to use for the update\n     * @description\n     * @example\n     * sig.updateString(\'aaa\')\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to use for the update\n     * @description\n     * @example\n     * sig.updateHex(\'1f2f3f\')\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Returns the signature bytes of all data updates as a hexadecimal string\n     * @name sign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @return the signature bytes as a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.sign()\n     */\n    this.sign = function() {\n\tthrow "sign() not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signString(\'aaa\')\n     */\n    this.signString = function(str) {\n\tthrow "digestString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signHex(\'1fdc33\')\n     */\n    this.signHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * verifies the passed-in signature.\n     * @name verify\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return {Boolean} true if the signature was verified, otherwise false\n     * @description\n     * @example\n     * var isValid = sig.verify(\'1fbcefdca4823a7(snip)\')\n     */\n    this.verify = function(hSigVal) {\n\tthrow "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.algProvName = params[\'alg\'] + ":" + params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t    this._setAlgNames();\n\t}\n\tif (typeof params[\'prvkeypem\'] != "undefined") {\n\t    if (typeof params[\'prvkeypas\'] != "undefined") {\n\t\tthrow "both prvkeypem and prvkeypas parameters not supported";\n\t    } else {\n\t\ttry {\n\t\t    var prvKey = new RSAKey();\n\t\t    prvKey.readPrivateKeyFromPEMString(params[\'prvkeypem\']);\n\t\t    this.initSign(prvKey);\n\t\t} catch (ex) {\n\t\t    throw "fatal error to load pem private key: " + ex;\n\t\t}\n\t    }\n\t}\n    }\n};\nmodule.exports = KJUR\n\n},{"./sha256.js":161,"jsbn":166}],117:[function(require,module,exports){\n/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// asn1hex.js - Hexadecimal represented ASN.1 string library\n//\n// version: 1.1 (09-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n//\n// Depends on:\n//\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n// MEMO:\n//   f(\'3082025b02...\', 2) ... 82025b ... 3bytes\n//   f(\'020100\', 2) ... 01 ... 1byte\n//   f(\'0203001...\', 2) ... 03 ... 1byte\n//   f(\'02818003...\', 2) ... 8180 ... 2bytes\n//   f(\'3080....0000\', 2) ... 80 ... -1\n//\n//   Requirements:\n//   - ASN.1 type octet length MUST be 1. \n//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)\n//   - \n\n/**\n * @fileOverview\n * @name asn1hex-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * get byte length for ASN.1 L(length) bytes\n * @name getByteLengthOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return byte length for ASN.1 L(length) bytes\n */\nfunction _asnhex_getByteLengthOfL_AtObj(s, pos) {\n  if (s.substring(pos + 2, pos + 3) != \'8\') return 1;\n  var i = parseInt(s.substring(pos + 3, pos + 4));\n  if (i == 0) return -1; \t\t// length octet \'80\' indefinite length\n  if (0 < i && i < 10) return i + 1;\t// including \'8?\' octet;\n  return -2;\t\t\t\t// malformed format\n}\n\n\n/**\n * get hexadecimal string for ASN.1 L(length) bytes\n * @name getHexOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string for ASN.1 L(length) bytes\n */\nfunction _asnhex_getHexOfL_AtObj(s, pos) {\n  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (len < 1) return \'\';\n  return s.substring(pos + 2, pos + 2 + len * 2);\n}\n\n//\n//   getting ASN.1 length value at the position \'idx\' of\n//   hexa decimal string \'s\'.\n//\n//   f(\'3082025b02...\', 0) ... 82025b ... ???\n//   f(\'020100\', 0) ... 01 ... 1\n//   f(\'0203001...\', 0) ... 03 ... 3\n//   f(\'02818003...\', 0) ... 8180 ... 128\n/**\n * get integer value of ASN.1 length for ASN.1 data\n * @name getIntOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return ASN.1 L(length) integer value\n */\nfunction _asnhex_getIntOfL_AtObj(s, pos) {\n  var hLength = _asnhex_getHexOfL_AtObj(s, pos);\n  if (hLength == \'\') return -1;\n  var bi;\n  if (parseInt(hLength.substring(0, 1)) < 8) {\n     bi = parseBigInt(hLength, 16);\n  } else {\n     bi = parseBigInt(hLength.substring(2), 16);\n  }\n  return bi.intValue();\n}\n\n/**\n * get ASN.1 value starting string position for ASN.1 object refered by index \'idx\'.\n * @name getStartPosOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n */\nfunction _asnhex_getStartPosOfV_AtObj(s, pos) {\n  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (l_len < 0) return l_len;\n  return pos + (l_len + 1) * 2;\n}\n\n/**\n * get hexadecimal string of ASN.1 V(value)\n * @name getHexOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 value.\n */\nfunction _asnhex_getHexOfV_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return s.substring(pos1, pos1 + len * 2);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV at\n * @name getHexOfTLV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 TLV.\n * @since 1.1\n */\nfunction _asnhex_getHexOfTLV_AtObj(s, pos) {\n  var hT = s.substr(pos, 2);\n  var hL = _asnhex_getHexOfL_AtObj(s, pos);\n  var hV = _asnhex_getHexOfV_AtObj(s, pos);\n  return hT + hL + hV;\n}\n\n/**\n * get next sibling starting index for ASN.1 object string\n * @name getPosOfNextSibling_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return next sibling starting index for ASN.1 object string\n */\nfunction _asnhex_getPosOfNextSibling_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return pos1 + len * 2;\n}\n\n/**\n * get array of indexes of child ASN.1 objects\n * @name getPosArrayOfChildren_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} start string index of ASN.1 object\n * @return {Array of Number} array of indexes for childen of ASN.1 objects\n */\nfunction _asnhex_getPosArrayOfChildren_AtObj(h, pos) {\n  var a = new Array();\n  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);\n  a.push(p0);\n\n  var len = _asnhex_getIntOfL_AtObj(h, pos);\n  var p = p0;\n  var k = 0;\n  while (1) {\n    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);\n    if (pNext == null || (pNext - p0  >= (len * 2))) break;\n    if (k >= 200) break;\n\n    a.push(pNext);\n    p = pNext;\n\n    k++;\n  }\n\n  return a;\n}\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getNthChildIndex_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} idx start string index of ASN.1 object\n * @param {Number} nth for child\n * @return {Number} string index of nth child.\n * @since 1.1\n */\nfunction _asnhex_getNthChildIndex_AtObj(h, idx, nth) {\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);\n  return a[nth];\n}\n\n// ========== decendant methods ==============================\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getDecendantIndexByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} string index refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {\n  if (nthList.length == 0) {\n    return currentIndex;\n  }\n  var firstNth = nthList.shift();\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);\n  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.\n * @name getDecendantHexTLVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfTLV_AtObj(h, idx);\n}\n\n/**\n * get hexadecimal string of ASN.1 V refered by current index and nth index list.\n * @name getDecendantHexVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 V refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfV_AtObj(h, idx);\n}\n\n// ========== class definition ==============================\n\n/**\n * ASN.1 DER encoded hexadecimal string utility class\n * @class ASN.1 DER encoded hexadecimal string utility class\n * @author Kenji Urushima\n * @version 1.1 (09 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n * @since 1.1\n */\nfunction ASN1HEX() {\n  return ASN1HEX;\n}\n\nASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;\nASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;\nASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;\nASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;\nASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;\nASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;\nASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;\nASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;\nASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;\nASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;\nASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;\nASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;\n\nmodule.exports = ASN1HEX;\n\n},{"jsbn":166}],119:[function(require,module,exports){\n/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-sign.js - adding signing functions to RSAKey class.\n//\n//\n// version: 1.2.2 (13 May 2013)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n\n//\n// Depends on:\n//   function sha1.hex(s) of sha1.js\n//   jsbn.js\n//   jsbn2.js\n//   rsa.js\n//   rsa2.js\n//\nvar BigInteger = require(\'jsbn\')\nvar RSAKey= require(\'./rsapem-1.1.js\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// keysize / pmstrlen\n//  512 /  128\n// 1024 /  256\n// 2048 /  512\n// 4096 / 1024\n\n/**\n * @fileOverview\n * @name rsasign-1.2.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * @property {Dictionary} _RSASIGN_DIHEAD\n * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.\n * You can add any DigestInfo hash algorith for signing.\n * See PKCS#1 v2.1 spec (p38).\n */\nvar _RSASIGN_DIHEAD = [];\n_RSASIGN_DIHEAD[\'sha1\'] =      "3021300906052b0e03021a05000414";\n_RSASIGN_DIHEAD[\'sha256\'] =    "3031300d060960864801650304020105000420";\n_RSASIGN_DIHEAD[\'sha384\'] =    "3041300d060960864801650304020205000430";\n_RSASIGN_DIHEAD[\'sha512\'] =    "3051300d060960864801650304020305000440";\n_RSASIGN_DIHEAD[\'md2\'] =       "3020300c06082a864886f70d020205000410";\n_RSASIGN_DIHEAD[\'md5\'] =       "3020300c06082a864886f70d020505000410";\n_RSASIGN_DIHEAD[\'ripemd160\'] = "3021300906052b2403020105000414";\n\n/**\n * @property {Dictionary} _RSASIGN_HASHHEXFUNC\n * @description Array of functions which calculate hash and returns it as hexadecimal.\n * You can add any hash algorithm implementations.\n */\nvar _RSASIGN_HASHHEXFUNC = [];\n_RSASIGN_HASHHEXFUNC[\'sha1\'] =      function(s){return KJUR.crypto.Util.sha1(s);};\n_RSASIGN_HASHHEXFUNC[\'sha256\'] =    function(s){return KJUR.crypto.Util.sha256(s);}\n_RSASIGN_HASHHEXFUNC[\'sha512\'] =    function(s){return KJUR.crypto.Util.sha512(s);}\n_RSASIGN_HASHHEXFUNC[\'md5\'] =       function(s){return KJUR.crypto.Util.md5(s);};\n_RSASIGN_HASHHEXFUNC[\'ripemd160\'] = function(s){return KJUR.crypto.Util.ripemd160(s);};\n\n//_RSASIGN_HASHHEXFUNC[\'sha1\'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n//_RSASIGN_HASHHEXFUNC[\'sha256\'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n\nvar _RE_HEXDECONLY = new RegExp("");\n_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");\n\n// ========================================================================\n// Signature Generation\n// ========================================================================\n\nfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n    var pmStrLen = keySize / 4;\n    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];\n    var sHashHex = hashFunc(s);\n\n    var sHead = "0001";\n    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;\n    var sMid = "";\n    var fLen = pmStrLen - sHead.length - sTail.length;\n    for (var i = 0; i < fLen; i += 2) {\n\tsMid += "ff";\n    }\n    sPaddedMessageHex = sHead + sMid + sTail;\n    return sPaddedMessageHex;\n}\n\nfunction _zeroPaddingOfSignature(hex, bitLength) {\n    var s = "";\n    var nZero = bitLength / 4 - hex.length;\n    for (var i = 0; i < nZero; i++) {\n\ts = s + "0";\n    }\n    return s + hex;\n}\n\n/**\n * sign for a message string with RSA private key.<br/>\n * @name signString\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signString(s, hashAlg) {\n    //alert("this.n.bitLength() = " + this.n.bitLength());\n    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);\n    var biPaddedMessage = parseBigInt(hPM, 16);\n    var biSign = this.doPrivate(biPaddedMessage);\n    var hexSign = biSign.toString(16);\n    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n}\n\nfunction _rsasign_signStringWithSHA1(s) {\n    return _rsasign_signString.call(this, s, \'sha1\');\n}\n\nfunction _rsasign_signStringWithSHA256(s) {\n    return _rsasign_signString.call(this, s, \'sha256\');\n}\n\n// PKCS#1 (PSS) mask generation function\nfunction pss_mgf1_str(seed, len, hash) {\n    var mask = \'\', i = 0;\n\n    while (mask.length < len) {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(s);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var salt = \'\';\n\n    if (sLen > 0) {\n        salt = new Array(sLen);\n        new SecureRandom().nextBytes(salt);\n        salt = String.fromCharCode.apply(String, salt);\n    }\n\n    var H = hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash + salt);\n    var PS = [];\n\n    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n        PS[i] = 0x00;\n    }\n\n    var DB = String.fromCharCode.apply(String, PS) + \'\\x01\' + salt;\n    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n    maskedDB[0] &= ~mask;\n\n    for (i = 0; i < hLen; i++) {\n        maskedDB.push(H.charCodeAt(i));\n    }\n\n    maskedDB.push(0xbc);\n\n    return _zeroPaddingOfSignature(\n            this.doPrivate(new BigInteger(maskedDB)).toString(16),\n            this.n.bitLength());\n}\n\n// ========================================================================\n// Signature Verification\n// ========================================================================\n\nfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n    var rsa = new RSAKey();\n    rsa.setPublic(hN, hE);\n    var biDecryptedSig = rsa.doPublic(biSig);\n    return biDecryptedSig;\n}\n\nfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    return hDigestInfo;\n}\n\nfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n    for (var algName in _RSASIGN_DIHEAD) {\n\tvar head = _RSASIGN_DIHEAD[algName];\n\tvar len = head.length;\n\tif (hDigestInfo.substring(0, len) == head) {\n\t    var a = [algName, hDigestInfo.substring(len)];\n\t    return a;\n\t}\n    }\n    return [];\n}\n\nfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\nfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n    var biSig = parseBigInt(hSig, 16);\n    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t  this.e.toString(16));\n    return result;\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyString\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyString(sMsg, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, \'\');\n    if (hSig.length != this.n.bitLength() / 4) return 0;\n    hSig = hSig.replace(/[ \\n]+/g, "");\n    var biSig = parseBigInt(hSig, 16);\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n  \n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n    if (hSig.length !== this.n.bitLength() / 4) {\n        return false;\n    }\n\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(sMsg);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();\n\n    for (i = 0; i < em.length; i += 1) {\n        em[i] &= 0xff;\n    }\n\n    while (em.length < emLen) {\n        em.unshift(0);\n    }\n\n    if (em[emLen -1] !== 0xbc) {\n        throw "encoded message does not end in 0xbc";\n    }\n\n    em = String.fromCharCode.apply(String, em);\n\n    var maskedDB = em.substr(0, emLen - hLen - 1);\n    var H = em.substr(maskedDB.length, hLen);\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n        throw "bits beyond keysize not zero";\n    }\n\n    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1) {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB[0] &= ~mask;\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i += 1) {\n        if (DB[i] !== 0x00) {\n            throw "leftmost octets not zero";\n        }\n    }\n\n    if (DB[checkLen] !== 0x01) {\n        throw "0x01 marker not found";\n    }\n\n    return H === hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash +\n                          String.fromCharCode.apply(String, DB.slice(-sLen)));\n}\n\nRSAKey.prototype.signString = _rsasign_signString;\nRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.sign = _rsasign_signString;\nRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\nRSAKey.prototype.signPSS = _rsasign_signStringPSS;\nRSAKey.SALT_LEN_HLEN = -1;\nRSAKey.SALT_LEN_MAX = -2;\n\nRSAKey.prototype.verifyString = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verify = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\nRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\nRSAKey.SALT_LEN_RECOVER = -2;\n\n/**\n * @name RSAKey\n * @class key of RSA public key algorithm\n * @description Tom Wu\'s RSA Key class and extension\n */\n\nmodule.exports = RSAKey\n\n},{"./rsapem-1.1.js":163,"jsbn":166}],158:[function(require,module,exports){\n(function(){/** \n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\nvar customBuf = require(\'../buffer.js\').Buffer\nvar ElementReader = require(\'../encoding/element-reader.js\').ElementReader;\nvar DataUtils = require(\'../encoding/data-utils.js\').DataUtils;\nvar LOG = require(\'../log.js\').Log.LOG;\n\n\nfunction makeShuffledGetHostAndPort (hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n\n/**\n * @constructor\n */\nvar WebSocketTransport = function WebSocketTransport() \n{    \n  if (!WebSocket)\n    throw new Error("WebSocket support is not available on this platform.");\n    \n  this.ws = null;\n  this.connectedHost = null; // Read by Face.\n  this.connectedPort = null; // Read by Face.\n  this.elementReader = null;\n  this.defaultGetHostAndPort = makeShuffledGetHostAndPort\n    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu", \n      "E.ws.ndn.ucla.edu", "F.ws.ndn.ucla.edu", "G.ws.ndn.ucla.edu", "H.ws.ndn.ucla.edu", \n      "I.ws.ndn.ucla.edu", "J.ws.ndn.ucla.edu", "K.ws.ndn.ucla.edu", "L.ws.ndn.ucla.edu", \n      "M.ws.ndn.ucla.edu", "N.ws.ndn.ucla.edu"],\n     9696);\n};\n\nexports.WebSocketTransport = WebSocketTransport;\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nWebSocketTransport.prototype.connect = function(face, onopenCallback) \n{\n  this.close();\n  \n  this.ws = new WebSocket(\'ws:\' + face.host + \':\' + face.port);\n  if (LOG > 0) console.log(\'ws connection created.\');\n    this.connectedHost = face.host;\n    this.connectedPort = face.port;\n  \n  this.ws.binaryType = "arraybuffer";\n  \n  this.elementReader = new ElementReader(face);\n  var self = this;\n  this.ws.onmessage = function(ev) {\n    var result = ev.data;\n    //console.log(\'RecvHandle called.\');\n      \n    if (result == null || result == undefined || result == "") {\n      console.log(\'INVALID ANSWER\');\n    } \n    else if (result instanceof ArrayBuffer) {\n      var bytearray = new customBuf(result);\n          \n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n      \n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n    }\n  }\n  \n  this.ws.onopen = function(ev) {\n    if (LOG > 3) console.log(ev);\n    if (LOG > 3) console.log(\'ws.onopen: WebSocket connection opened.\');\n    if (LOG > 3) console.log(\'ws.onopen: ReadyState: \' + this.readyState);\n    // Face.registerPrefix will fetch the ndndid when needed.\n\n    onopenCallback();\n  }\n  \n  this.ws.onerror = function(ev) {\n    console.log(\'ws.onerror: ReadyState: \' + this.readyState);\n    console.log(ev);\n    console.log(\'ws.onerror: WebSocket error: \' + ev.data);\n  }\n  \n  this.ws.onclose = function(ev) {\n    console.log(\'ws.onclose: WebSocket connection closed.\');\n    self.ws = null;\n    \n    // Close Face when WebSocket is closed\n    face.readyStatus = 2; //Face.CLOSED\n    face.onclose();\n    //console.log("NDN.onclose event fired.");\n  }\n};\n\n/**\n * Send the Uint8Array data.\n */\nWebSocketTransport.prototype.send = function(data) \n{\n  if (this.ws != null) {\n    // If we directly use data.buffer to feed ws.send(), \n    // WebSocket may end up sending a packet with 10000 bytes of data.\n    // That is, WebSocket will flush the entire buffer\n    // regardless of the offset of the Uint8Array. So we have to create\n    // a new Uint8Array buffer with just the right size and copy the \n    // content from binaryInterest to the new buffer.\n    //    ---Wentao\n    var bytearray = new Uint8Array(data.length);\n    bytearray.set(data);\n    this.ws.send(bytearray.buffer);\n    if (LOG > 3) console.log(\'ws.send() returned.\');\n  }\n  else\n    console.log(\'WebSocket connection is not established.\');\n};\n\n/**\n * Close the connection.\n */\nWebSocketTransport.prototype.close = function()\n{\n  if (this.ws != null)\n    delete this.ws;\n}\n\n\n})()\n},{"../buffer.js":116,"../encoding/data-utils.js":109,"../encoding/element-reader.js":115,"../log.js":139}],159:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2013-2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Encapsulate a customBuf and support dynamic reallocation.\n */\nvar customBuf = require(\'../buffer.js\').Buffer\n/**\n * Create a DynamicBuffer where this.array is a customBuf of size length.\n * To access the array, use this.array or call slice.\n * @constructor\n * @param {number} length the initial length of the array.  If null, use a default.\n */\nvar DynamicBuffer = function DynamicBuffer(length) \n{\n  if (!length)\n    length = 16;\n    \n  this.array = new customBuf(length);\n};\n\nexports.DynamicBuffer = DynamicBuffer;\n\n/**\n * Ensure that this.array has the length, reallocate and copy if necessary.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLength = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  this.array.copy(newArray);\n  this.array = newArray;\n};\n\n/**\n * Copy the value to this.array at offset, reallocating if necessary. \n * @param {Buffer} value The buffer to copy.\n * @param {number} offset The offset in the buffer to start copying into.\n */\nDynamicBuffer.prototype.copy = function(value, offset) \n{\n  this.ensureLength(value.length + offset);\n    \n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, offset);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, offset);\n};\n\n/**\n * Ensure that this.array has the length. If necessary, reallocate the array\n *   and shift existing data to the back of the new array.\n * Update the length of this.array which may be greater than length.\n * @param {number} length The minimum length for the array.\n */\nDynamicBuffer.prototype.ensureLengthFromBack = function(length) \n{\n  if (this.array.length >= length)\n    return;\n    \n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n    \n  var newArray = new customBuf(newLength);\n  // Copy to the back of newArray.\n  this.array.copy(newArray, newArray.length - this.array.length);\n  this.array = newArray;\n};\n\n/**\n * First call ensureLengthFromBack to make sure the bytearray has\n * offsetFromBack bytes, then copy value into the array starting\n * offsetFromBack bytes from the back of the array.\n * @param {Buffer} value The buffer to copy.\n * @param {offsetFromBack} offset The offset from the back of the array to start\n * copying.\n */\nDynamicBuffer.prototype.copyFromBack = function(value, offsetFromBack) \n{\n  this.ensureLengthFromBack(offsetFromBack);\n\n  if (typeof value == \'object\' && value instanceof customBuf)\n    value.copy(this.array, this.array.length - offsetFromBack);\n  else\n    // Need to make value a customBuf to copy.\n    new customBuf(value).copy(this.array, this.array.length - offsetFromBack);\n};\n\n/**\n * Return this.array.slice(begin, end);\n * @param {number} begin The begin index for the slice.\n * @param {number} end The end index for the slice.\n * @returns {Buffer} The buffer slice.\n */\nDynamicBuffer.prototype.slice = function(begin, end) \n{\n  return this.array.slice(begin, end);\n};\n\n})()\n},{"../buffer.js":116}],166:[function(require,module,exports){\n(function(){\n    \n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary&0xffffff)==0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a,b,c) {\n      if(a != null)\n        if("number" == typeof a) this.fromNumber(a,b,c);\n        else if(b == null && "string" != typeof a) this.fromString(a,256);\n        else this.fromString(a,b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i,x,w,j,c,n) {\n      while(--n >= 0) {\n        var v = x*this[i++]+w[j]+c;\n        c = Math.floor(v/0x4000000);\n        w[j++] = v&0x3ffffff;\n      }\n      return c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i,x,w,j,c,n) {\n      var xl = x&0x7fff, xh = x>>15;\n      while(--n >= 0) {\n        var l = this[i]&0x7fff;\n        var h = this[i++]>>15;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n        w[j++] = l&0x3fffffff;\n      }\n      return c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i,x,w,j,c,n) {\n      var xl = x&0x3fff, xh = x>>14;\n      while(--n >= 0) {\n        var l = this[i]&0x3fff;\n        var h = this[i++]>>14;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n        c = (l>>28)+(m>>14)+xh*h;\n        w[j++] = l&0xfffffff;\n      }\n      return c;\n    }\n    var inBrowser = typeof navigator !== "undefined";\n    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\n      BigInteger.prototype.am = am2;\n      dbits = 30;\n    }\n    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {\n      BigInteger.prototype.am = am1;\n      dbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1<<dbits)-1);\n    BigInteger.prototype.DV = (1<<dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n    BigInteger.prototype.F1 = BI_FP-dbits;\n    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n    // Digit conversions\n    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\n    var BI_RC = new Array();\n    var rr,vv;\n    rr = "0".charCodeAt(0);\n    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = "a".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = "A".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s,i) {\n      var c = BI_RC[s.charCodeAt(i)];\n      return (c==null)?-1:c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n      r.t = this.t;\n      r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n      this.t = 1;\n      this.s = (x<0)?-1:0;\n      if(x > 0) this[0] = x;\n      else if(x < -1) this[0] = x+DV;\n      else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n    function bnpFromString(s,b) {\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 256) k = 8; // byte array\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else { this.fromRadix(s,b); return; }\n      this.t = 0;\n      this.s = 0;\n      var i = s.length, mi = false, sh = 0;\n      while(--i >= 0) {\n        var x = (k==8)?s[i]&0xff:intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-") mi = true;\n          continue;\n        }\n        mi = false;\n        if(sh == 0)\n          this[this.t++] = x;\n        else if(sh+k > this.DB) {\n          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n          this[this.t++] = (x>>(this.DB-sh));\n        }\n        else\n          this[this.t-1] |= x<<sh;\n        sh += k;\n        if(sh >= this.DB) sh -= this.DB;\n      }\n      if(k == 8 && (s[0]&0x80) != 0) {\n        this.s = -1;\n        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n      }\n      this.clamp();\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n      var c = this.s&this.DM;\n      while(this.t > 0 && this[this.t-1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n      if(this.s < 0) return "-"+this.negate().toString(b);\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else return this.toRadix(b);\n      var km = (1<<k)-1, d, m = false, r = "", i = this.t;\n      var p = this.DB-(i*this.DB)%k;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n        while(i >= 0) {\n          if(p < k) {\n            d = (this[i]&((1<<p)-1))<<(k-p);\n            d |= this[--i]>>(p+=this.DB-k);\n          }\n          else {\n            d = (this[i]>>(p-=k))&km;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if(d > 0) m = true;\n          if(m) r += int2char(d);\n        }\n      }\n      return m?r:"0";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s<0)?this.negate():this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n      var r = this.s-a.s;\n      if(r != 0) return r;\n      var i = this.t;\n      r = i-a.t;\n      if(r != 0) return (this.s<0)?-r:r;\n      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n      return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n      var r = 1, t;\n      if((t=x>>>16) != 0) { x = t; r += 16; }\n      if((t=x>>8) != 0) { x = t; r += 8; }\n      if((t=x>>4) != 0) { x = t; r += 4; }\n      if((t=x>>2) != 0) { x = t; r += 2; }\n      if((t=x>>1) != 0) { x = t; r += 1; }\n      return r;\n    }\n\n    // (public) return the number of bits in "this"\n    function bnBitLength() {\n      if(this.t <= 0) return 0;\n      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n,r) {\n      var i;\n      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n      for(i = n-1; i >= 0; --i) r[i] = 0;\n      r.t = this.t+n;\n      r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n,r) {\n      for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n      r.t = Math.max(this.t-n,0);\n      r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n,r) {\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<cbs)-1;\n      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n      for(i = this.t-1; i >= 0; --i) {\n        r[i+ds+1] = (this[i]>>cbs)|c;\n        c = (this[i]&bm)<<bs;\n      }\n      for(i = ds-1; i >= 0; --i) r[i] = 0;\n      r[ds] = c;\n      r.t = this.t+ds+1;\n      r.s = this.s;\n      r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n,r) {\n      r.s = this.s;\n      var ds = Math.floor(n/this.DB);\n      if(ds >= this.t) { r.t = 0; return; }\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<bs)-1;\n      r[0] = this[ds]>>bs;\n      for(var i = ds+1; i < this.t; ++i) {\n        r[i-ds-1] |= (this[i]&bm)<<cbs;\n        r[i-ds] = this[i]>>bs;\n      }\n      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n      r.t = this.t-ds;\n      r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]-a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c -= a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c -= a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c -= a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c < -1) r[i++] = this.DV+c;\n      else if(c > 0) r[i++] = c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyTo(a,r) {\n      var x = this.abs(), y = a.abs();\n      var i = x.t;\n      r.t = i+y.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n      r.s = 0;\n      r.clamp();\n      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n      var x = this.abs();\n      var i = r.t = 2*x.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < x.t-1; ++i) {\n        var c = x.am(i,x[i],r,2*i,0,1);\n        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n          r[i+x.t] -= x.DV;\n          r[i+x.t+1] = 1;\n        }\n      }\n      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n      r.s = 0;\n      r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m,q,r) {\n      var pm = m.abs();\n      if(pm.t <= 0) return;\n      var pt = this.abs();\n      if(pt.t < pm.t) {\n        if(q != null) q.fromInt(0);\n        if(r != null) this.copyTo(r);\n        return;\n      }\n      if(r == null) r = nbi();\n      var y = nbi(), ts = this.s, ms = m.s;\n      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n      else { pm.copyTo(y); pt.copyTo(r); }\n      var ys = y.t;\n      var y0 = y[ys-1];\n      if(y0 == 0) return;\n      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n      var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n      y.dlShiftTo(j,t);\n      if(r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t,r);\n      }\n      BigInteger.ONE.dlShiftTo(ys,t);\n      t.subTo(y,y);  // "negative" y so we can replace sub with am later\n      while(y.t < ys) y[y.t++] = 0;\n      while(--j >= 0) {\n        // Estimate quotient digit\n        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n          y.dlShiftTo(j,t);\n          r.subTo(t,r);\n          while(r[i] < --qd) r.subTo(t,r);\n        }\n      }\n      if(q != null) {\n        r.drShiftTo(ys,q);\n        if(ts != ms) BigInteger.ZERO.subTo(q,q);\n      }\n      r.t = ys;\n      r.clamp();\n      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n      if(ts < 0) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n      var r = nbi();\n      this.abs().divRemTo(a,null,r);\n      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n      return r;\n    }\n\n    // Modular reduction using "classic" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n      else return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m,null,x); }\n    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply "overflows" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n      if(this.t < 1) return 0;\n      var x = this[0];\n      if((x&1) == 0) return 0;\n      var y = x&3;       // y == 1/x mod 2^2\n      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n      // last step - calculate inverse mod DV directly;\n      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n      // we really want the negative inverse, and -DV < y < DV\n      return (y>0)?this.DV-y:-y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n      this.m = m;\n      this.mp = m.invDigit();\n      this.mpl = this.mp&0x7fff;\n      this.mph = this.mp>>15;\n      this.um = (1<<(m.DB-15))-1;\n      this.mt2 = 2*m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n      var r = nbi();\n      x.abs().dlShiftTo(this.m.t,r);\n      r.divRemTo(this.m,null,r);\n      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n      return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n      while(x.t <= this.mt2) // pad x so am has enough room later\n        x[x.t++] = 0;\n      for(var i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        var j = x[i]&0x7fff;\n        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i+this.m.t;\n        x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n        // propagate carry\n        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n      }\n      x.clamp();\n      x.drShiftTo(this.m.t,x);\n      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = "x^2/R mod m"; x != r\n    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = "xy/R mod m"; x,y != r\n    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)\n    function bnpExp(e,z) {\n      if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n      g.copyTo(r);\n      while(--i >= 0) {\n        z.sqrTo(r,r2);\n        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n        else { var t = r; r = r2; r2 = t; }\n      }\n      return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e,m) {\n      var z;\n      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n      return this.exp(e,z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // "constants"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger("0", 10) returns "proper" zero\n    // Version 1.2: square() API, isProbablePrime fix\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n      if(this.s < 0) {\n        if(this.t == 1) return this[0]-this.DV;\n        else if(this.t == 0) return -1;\n      }\n      else if(this.t == 1) return this[0];\n      else if(this.t == 0) return 0;\n      // assumes 16 < DB < 32\n      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n      if(this.s < 0) return -1;\n      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n      else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n      if(b == null) b = 10;\n      if(this.signum() == 0 || b < 2 || b > 36) return "0";\n      var cs = this.chunkSize(b);\n      var a = Math.pow(b,cs);\n      var d = nbv(a), y = nbi(), z = nbi(), r = "";\n      this.divRemTo(d,y,z);\n      while(y.signum() > 0) {\n        r = (a+z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d,y,z);\n      }\n      return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s,b) {\n      this.fromInt(0);\n      if(b == null) b = 10;\n      var cs = this.chunkSize(b);\n      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n      for(var i = 0; i < s.length; ++i) {\n        var x = intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;\n          continue;\n        }\n        w = b*w+x;\n        if(++j >= cs) {\n          this.dMultiply(d);\n          this.dAddOffset(w,0);\n          j = 0;\n          w = 0;\n        }\n      }\n      if(j > 0) {\n        this.dMultiply(Math.pow(b,j));\n        this.dAddOffset(w,0);\n      }\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a,b,c) {\n      if("number" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if(a < 2) this.fromInt(1);\n        else {\n          this.fromNumber(a,c);\n          if(!this.testBit(a-1))\t// force MSB set\n            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n          if(this.isEven()) this.dAddOffset(1,0); // force odd\n          while(!this.isProbablePrime(b)) {\n            this.dAddOffset(2,0);\n            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n          }\n        }\n      }\n      else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a&7;\n        x.length = (a>>3)+1;\n        b.nextBytes(x);\n        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n        this.fromString(x,256);\n      }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n      var i = this.t, r = new Array();\n      r[0] = this.s;\n      var p = this.DB-(i*this.DB)%8, d, k = 0;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n          r[k++] = d|(this.s<<(this.DB-p));\n        while(i >= 0) {\n          if(p < 8) {\n            d = (this[i]&((1<<p)-1))<<(8-p);\n            d |= this[--i]>>(p+=this.DB-8);\n          }\n          else {\n            d = (this[i]>>(p-=8))&0xff;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if((d&0x80) != 0) d |= -256;\n          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n          if(k > 0 || d != this.s) r[k++] = d;\n        }\n      }\n      return r;\n    }\n\n    function bnEquals(a) { return(this.compareTo(a)==0); }\n    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a,op,r) {\n      var i, f, m = Math.min(a.t,this.t);\n      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n      if(a.t < this.t) {\n        f = a.s&this.DM;\n        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n        r.t = this.t;\n      }\n      else {\n        f = this.s&this.DM;\n        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n        r.t = a.t;\n      }\n      r.s = op(this.s,a.s);\n      r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x,y) { return x&y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n    // (public) this | a\n    function op_or(x,y) { return x|y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x,y) { return x^y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x,y) { return x&~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n      var r = nbi();\n      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n      r.t = this.t;\n      r.s = ~this.s;\n      return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n      var r = nbi();\n      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n      return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n      var r = nbi();\n      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n      return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n      if(x == 0) return -1;\n      var r = 0;\n      if((x&0xffff) == 0) { x >>= 16; r += 16; }\n      if((x&0xff) == 0) { x >>= 8; r += 8; }\n      if((x&0xf) == 0) { x >>= 4; r += 4; }\n      if((x&3) == 0) { x >>= 2; r += 2; }\n      if((x&1) == 0) ++r;\n      return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n      for(var i = 0; i < this.t; ++i)\n        if(this[i] != 0) return i*this.DB+lbit(this[i]);\n      if(this.s < 0) return this.t*this.DB;\n      return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n      var r = 0;\n      while(x != 0) { x &= x-1; ++r; }\n      return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n      var r = 0, x = this.s&this.DM;\n      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n      return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n      var j = Math.floor(n/this.DB);\n      if(j >= this.t) return(this.s!=0);\n      return((this[j]&(1<<(n%this.DB)))!=0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n,op) {\n      var r = BigInteger.ONE.shiftLeft(n);\n      this.bitwiseTo(r,op,r);\n      return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]+a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c += a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c += a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c > 0) r[i++] = c;\n      else if(c < -1) r[i++] = this.DV+c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n    // (public) this^2\n    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n      var q = nbi(), r = nbi();\n      this.divRemTo(a,q,r);\n      return new Array(q,r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n      this[this.t] = this.am(0,n-1,this,0,0,this.t);\n      ++this.t;\n      this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n,w) {\n      if(n == 0) return;\n      while(this.t <= w) this[this.t++] = 0;\n      this[w] += n;\n      while(this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if(++w >= this.t) this[this.t++] = 0;\n        ++this[w];\n      }\n    }\n\n    // A "null" reducer\n    function NullExp() {}\n    function nNop(x) { return x; }\n    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n    function nSqrTo(x,r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.exp(e,new NullExp()); }\n\n    // (protected) r = lower n words of "this * a", a.t <= n\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a,n,r) {\n      var i = Math.min(this.t+a.t,n);\n      r.s = 0; // assumes a,this >= 0\n      r.t = i;\n      while(i > 0) r[--i] = 0;\n      var j;\n      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n      r.clamp();\n    }\n\n    // (protected) r = "this * a" without lower n words, n > 0\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a,n,r) {\n      --n;\n      var i = r.t = this.t+a.t-n;\n      r.s = 0; // assumes a,this >= 0\n      while(--i >= 0) r[i] = 0;\n      for(i = Math.max(n-this.t,0); i < a.t; ++i)\n        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n      r.clamp();\n      r.drShiftTo(1,r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n      // setup Barrett\n      this.r2 = nbi();\n      this.q3 = nbi();\n      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n      this.mu = this.r2.divide(m);\n      this.m = m;\n    }\n\n    function barrettConvert(x) {\n      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n      else if(x.compareTo(this.m) < 0) return x;\n      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n      x.drShiftTo(this.m.t-1,this.r2);\n      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n      x.subTo(this.r2,x);\n      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e,m) {\n      var i = e.bitLength(), k, r = nbv(1), z;\n      if(i <= 0) return r;\n      else if(i < 18) k = 1;\n      else if(i < 48) k = 3;\n      else if(i < 144) k = 4;\n      else if(i < 768) k = 5;\n      else k = 6;\n      if(i < 8)\n        z = new Classic(m);\n      else if(m.isEven())\n        z = new Barrett(m);\n      else\n        z = new Montgomery(m);\n\n      // precomputation\n      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n      g[1] = z.convert(this);\n      if(k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1],g2);\n        while(n <= km) {\n          g[n] = nbi();\n          z.mulTo(g2,g[n-2],g[n]);\n          n += 2;\n        }\n      }\n\n      var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n      i = nbits(e[j])-1;\n      while(j >= 0) {\n        if(i >= k1) w = (e[j]>>(i-k1))&km;\n        else {\n          w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n        }\n\n        n = k;\n        while((w&1) == 0) { w >>= 1; --n; }\n        if((i -= n) < 0) { i += this.DB; --j; }\n        if(is1) {\t// ret == 1, don\'t bother squaring or multiplying it\n          g[w].copyTo(r);\n          is1 = false;\n        }\n        else {\n          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n          z.mulTo(r2,g[w],r);\n        }\n\n        while(j >= 0 && (e[j]&(1<<i)) == 0) {\n          z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n          if(--i < 0) { i = this.DB-1; --j; }\n        }\n      }\n      return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n      var x = (this.s<0)?this.negate():this.clone();\n      var y = (a.s<0)?a.negate():a.clone();\n      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n      if(g < 0) return x;\n      if(i < g) g = i;\n      if(g > 0) {\n        x.rShiftTo(g,x);\n        y.rShiftTo(g,y);\n      }\n      while(x.signum() > 0) {\n        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n        if(x.compareTo(y) >= 0) {\n          x.subTo(y,x);\n          x.rShiftTo(1,x);\n        }\n        else {\n          y.subTo(x,y);\n          y.rShiftTo(1,y);\n        }\n      }\n      if(g > 0) y.lShiftTo(g,y);\n      return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n      if(n <= 0) return 0;\n      var d = this.DV%n, r = (this.s<0)?n-1:0;\n      if(this.t > 0)\n        if(d == 0) r = this[0]%n;\n        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n      return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n      var ac = m.isEven();\n      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n      var u = m.clone(), v = this.clone();\n      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n      while(u.signum() != 0) {\n        while(u.isEven()) {\n          u.rShiftTo(1,u);\n          if(ac) {\n            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n            a.rShiftTo(1,a);\n          }\n          else if(!b.isEven()) b.subTo(m,b);\n          b.rShiftTo(1,b);\n        }\n        while(v.isEven()) {\n          v.rShiftTo(1,v);\n          if(ac) {\n            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n            c.rShiftTo(1,c);\n          }\n          else if(!d.isEven()) d.subTo(m,d);\n          d.rShiftTo(1,d);\n        }\n        if(u.compareTo(v) >= 0) {\n          u.subTo(v,u);\n          if(ac) a.subTo(c,a);\n          b.subTo(d,b);\n        }\n        else {\n          v.subTo(u,v);\n          if(ac) c.subTo(a,c);\n          d.subTo(b,d);\n        }\n      }\n      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n      if(d.compareTo(m) >= 0) return d.subtract(m);\n      if(d.signum() < 0) d.addTo(m,d); else return d;\n      if(d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n      var i, x = this.abs();\n      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n        for(i = 0; i < lowprimes.length; ++i)\n          if(x[0] == lowprimes[i]) return true;\n        return false;\n      }\n      if(x.isEven()) return false;\n      i = 1;\n      while(i < lowprimes.length) {\n        var m = lowprimes[i], j = i+1;\n        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j) if(m%lowprimes[i++] == 0) return false;\n      }\n      return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n      var n1 = this.subtract(BigInteger.ONE);\n      var k = n1.getLowestSetBit();\n      if(k <= 0) return false;\n      var r = n1.shiftRight(k);\n      t = (t+1)>>1;\n      if(t > lowprimes.length) t = lowprimes.length;\n      var a = nbi();\n      for(var i = 0; i < t; ++i) {\n        //Pick bases at random, instead of starting at 2\n        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n        var y = a.modPow(r,this);\n        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n          var j = 1;\n          while(j++ < k && y.compareTo(n1) != 0) {\n            y = y.modPowInt(2,this);\n            if(y.compareTo(BigInteger.ONE) == 0) return false;\n          }\n          if(y.compareTo(n1) != 0) return false;\n        }\n      }\n      return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // JSBN-specific extension\n    BigInteger.prototype.square = bnSquare;\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n    if (typeof exports !== \'undefined\') {\n        exports = module.exports = BigInteger;\n    } else {\n        this.BigInteger = BigInteger;\n    }\n    \n}).call(this);\n},{}],167:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n    // Shortcuts\n    var C = require(\'./core.js\');\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var Hasher = C_lib.Hasher;\n    var C_algo = C.algo;\n\n    // Initialization and round constants tables\n    var H = [];\n    var K = [];\n\n    // Compute constants\n    (function () {\n        function isPrime(n) {\n            var sqrtN = Math.sqrt(n);\n            for (var factor = 2; factor <= sqrtN; factor++) {\n                if (!(n % factor)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function getFractionalBits(n) {\n            return ((n - (n | 0)) * 0x100000000) | 0;\n        }\n\n        var n = 2;\n        var nPrime = 0;\n        while (nPrime < 64) {\n            if (isPrime(n)) {\n                if (nPrime < 8) {\n                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                }\n                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n                nPrime++;\n            }\n\n            n++;\n        }\n    }());\n\n    // Reusable object\n    var W = [];\n\n    /**\n     * SHA-256 hash algorithm.\n     */\n    var SHA256 = C_algo.SHA256 = Hasher.extend({\n        _doReset: function () {\n            this._hash = new WordArray.init(H.slice(0));\n        },\n\n        _doProcessBlock: function (M, offset) {\n            // Shortcut\n            var H = this._hash.words;\n\n            // Working variables\n            var a = H[0];\n            var b = H[1];\n            var c = H[2];\n            var d = H[3];\n            var e = H[4];\n            var f = H[5];\n            var g = H[6];\n            var h = H[7];\n\n            // Computation\n            for (var i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                } else {\n                    var gamma0x = W[i - 15];\n                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                                   (gamma0x >>> 3);\n\n                    var gamma1x = W[i - 2];\n                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                                   (gamma1x >>> 10);\n\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n\n                var ch  = (e & f) ^ (~e & g);\n                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n                var t1 = h + sigma1 + ch + K[i] + W[i];\n                var t2 = sigma0 + maj;\n\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n            H[4] = (H[4] + e) | 0;\n            H[5] = (H[5] + f) | 0;\n            H[6] = (H[6] + g) | 0;\n            H[7] = (H[7] + h) | 0;\n        },\n\n        _doFinalize: function () {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n\n            var nBitsTotal = this._nDataBytes * 8;\n            var nBitsLeft = data.sigBytes * 8;\n\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            data.sigBytes = dataWords.length * 4;\n\n            // Hash final blocks\n            this._process();\n\n            // Return final computed hash\n            return this._hash;\n        },\n\n        clone: function () {\n            var clone = Hasher.clone.call(this);\n            clone._hash = this._hash.clone();\n\n            return clone;\n        }\n    });\n\n    /**\n     * Shortcut function to the hasher\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     *\n     * @return {WordArray} The hash.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hash = CryptoJS.SHA256(\'message\');\n     *     var hash = CryptoJS.SHA256(wordArray);\n     */\n    C.SHA256 = Hasher._createHelper(SHA256);\n\n    /**\n     * Shortcut function to the HMAC\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     * @param {WordArray|string} key The secret key.\n     *\n     * @return {WordArray} The HMAC.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hmac = CryptoJS.HmacSHA256(message, key);\n     */\n    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\nmodule.exports = C\n\n},{"./core.js":168}],169:[function(require,module,exports){\n/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key\n//              to RSAKey class.\n//\n// version: 1.1.1 (2013-Apr-12)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n// \n//\n// Depends on:\n//\n//\n//\n// _RSApem_pemToBase64(sPEM)\n//\n//   removing PEM header, PEM footer and space characters including\n//   new lines from PEM formatted RSA private key string.\n//\nvar ASN1HEX = require(\'./asn1hex-1.1.js\')\nvar b64tohex = require(\'./base64.js\').b64tohex\nvar RSAKey = require(\'./rsa2.js\')\n/**\n * @fileOverview\n * @name rsapem-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nfunction _rsapem_pemToBase64(sPEMPrivateKey) {\n  var s = sPEMPrivateKey;\n  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");\n  s = s.replace("-----END RSA PRIVATE KEY-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {\n  var a = new Array();\n  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);\n  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);\n  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);\n  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);\n  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);\n  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);\n  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);\n  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);\n  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);\n  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);\n  return a;\n}\n\nfunction _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {\n  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);\n  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);\n  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);\n  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);\n  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);\n  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);\n  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);\n  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);\n  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);\n  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);\n  var a = new Array();\n  a.push(v, n, e, d, p, q, dp, dq, co);\n  return a;\n}\n\n/**\n * read RSA private key from a ASN.1 hexadecimal string\n * @name readPrivateKeyFromASN1HexString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.\n * @since 1.1.1\n */\nfunction _rsapem_readPrivateKeyFromASN1HexString(keyHex) {\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\n/**\n * read PKCS#1 private key from a string\n * @name readPrivateKeyFromPEMString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyPEM string of PKCS#1 private key.\n */\nfunction _rsapem_readPrivateKeyFromPEMString(keyPEM) {\n  var keyB64 = _rsapem_pemToBase64(keyPEM);\n  var keyHex = b64tohex(keyB64) // depends base64.js\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\nRSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;\nRSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;\n\nmodule.exports = RSAKey\n\n},{"./asn1hex-1.1.js":143,"./base64.js":146,"./rsa2.js":170}],165:[function(require,module,exports){\n(function(){/**\n * Copyright (C) 2014 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\nvar customBuf = require(\'../../buffer.js\').Buffer\nvar DynamicBuffer = require(\'../../util/dynamic-buffer.js\').DynamicBuffer;\n\n/**\n * Create a new TlvEncoder with an initialCapacity for the encoding buffer.\n * @constructor\n * @param {number} initialCapacity (optional) The initial capacity of the \n * encoding buffer. If omitted, use a default value.\n */\nvar TlvEncoder = function TlvEncoder(initialCapacity)\n{\n  initialCapacity = initialCapacity || 16;\n  this.output = new DynamicBuffer(initialCapacity);\n  // length is the number of bytes that have been written to the back of \n  //  this.output.array.\n  this.length = 0;\n};\n\nexports.TlvEncoder = TlvEncoder;\n\n/**\n * Get the number of bytes that have been written to the output.  You can\n * save this number, write sub TLVs, then subtract the new length from this\n * to get the total length of the sub TLVs.\n * @returns {number} The number of bytes that have been written to the output.\n */\nTlvEncoder.prototype.getLength = function()\n{\n  return this.length;\n};\n\n/**\n * Encode varNumber as a VAR-NUMBER in NDN-TLV and write it to this.output just \n * before this.length from the back.  Advance this.length.\n * @param {number} varNumber The non-negative number to encode.\n */\nTlvEncoder.prototype.writeVarNumber = function(varNumber)\n{\n  if (varNumber < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffff) {\n    this.length += 3;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 253;\n    this.output.array[offset + 1] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 2] = varNumber & 0xff;\n  }\n  else if (varNumber <= 0xffffffff) {\n    this.length += 5;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 254;\n    this.output.array[offset + 1] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 4] = varNumber & 0xff;\n  }\n  else {\n    this.length += 9;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset] = 255;\n    this.output.array[offset + 1] = (varNumber >> 56) & 0xff;\n    this.output.array[offset + 2] = (varNumber >> 48) & 0xff;\n    this.output.array[offset + 3] = (varNumber >> 40) & 0xff;\n    this.output.array[offset + 4] = (varNumber >> 32) & 0xff;\n    this.output.array[offset + 5] = (varNumber >> 24) & 0xff;\n    this.output.array[offset + 6] = (varNumber >> 16) & 0xff;\n    this.output.array[offset + 7] = (varNumber >> 8) & 0xff;\n    this.output.array[offset + 8] = varNumber & 0xff;\n  }\n};\n\n/**\n * Encode the type and length as VAR-NUMBER and write to this.output just before \n * this.length from the back.  Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} length The non-negative length of the TLV.\n */\nTlvEncoder.prototype.writeTypeAndLength = function(type, length)\n{\n  // Write backwards.\n  this.writeVarNumber(length);\n  this.writeVarNumber(type);\n};\n\n/**\n * Write the type, then the length of the encoded value then encode value as a \n * non-negative integer and write it to this.output just before this.length from \n * the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {number} value The non-negative integer to encode.\n */\nTlvEncoder.prototype.writeNonNegativeIntegerTlv = function(type, value)\n{\n  if (value < 0)\n    throw new Error("TLV integer value may not be negative");\n\n  // JavaScript doesn\'t distinguish int from float, so round.\n  value = Math.round(value)\n\n  // Write backwards.\n  var saveNBytes = this.length;\n  if (value < 253) {\n    this.length += 1;\n    this.output.ensureLengthFromBack(this.length);\n    this.output.array[this.output.array.length - this.length] = value & 0xff;\n  }\n  else if (value <= 0xffff) {\n    this.length += 2;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 8) & 0xff;\n    this.output.array[offset + 1] = value & 0xff;\n  }\n  else if (value <= 0xffffffff) {\n    this.length += 4;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 24) & 0xff;\n    this.output.array[offset + 1] = (value >> 16) & 0xff;\n    this.output.array[offset + 2] = (value >> 8) & 0xff;\n    this.output.array[offset + 3] = value & 0xff;\n  }\n  else {\n    this.length += 8;\n    this.output.ensureLengthFromBack(this.length);\n    var offset = this.output.array.length - this.length;\n    this.output.array[offset]     = (value >> 56) & 0xff;\n    this.output.array[offset + 1] = (value >> 48) & 0xff;\n    this.output.array[offset + 2] = (value >> 40) & 0xff;\n    this.output.array[offset + 3] = (value >> 32) & 0xff;\n    this.output.array[offset + 4] = (value >> 24) & 0xff;\n    this.output.array[offset + 5] = (value >> 16) & 0xff;\n    this.output.array[offset + 6] = (value >> 8) & 0xff;\n    this.output.array[offset + 7] = value & 0xff;\n  }\n\n  this.writeTypeAndLength(type, this.length - saveNBytes);\n};\n\n/**\n * If value is negative or null then do nothing, otherwise call \n * writeNonNegativeIntegerTlv.\n * @param {number} type The type of the TLV.\n * @param {number} value If negative or None do nothing, otherwise the integer \n *   to encode.\n */\nTlvEncoder.prototype.writeOptionalNonNegativeIntegerTlv = function(type, value)\n{\n  if (value != null && value >= 0)\n    this.writeNonNegativeIntegerTlv(type, value);\n};\n\n/**\n * Write the type, then the length of the buffer then the buffer value to \n * this.output just before this.length from the back. Advance this.length.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value The byte array with the bytes of the blob.  If value is\n    null, then just write the type and length 0.\n */\nTlvEncoder.prototype.writeBlobTlv = function(type, value)\n{\n  if (value == null) {\n    this.writeTypeAndLength(type, 0);\n    return;\n  }\n\n  // Write backwards, starting with the blob array.    \n  this.length += value.length;\n  this.output.copyFromBack(value, this.length);\n\n  this.writeTypeAndLength(type, value.length);\n};\n\n/**\n * If the byte array is null or zero length then do nothing, otherwise call \n * writeBlobTlv.\n * @param {number} type The type of the TLV.\n * @param {Buffer} value If null or zero length do nothing, otherwise the byte \n * array with the bytes of the blob.\n */\nTlvEncoder.prototype.writeOptionalBlobTlv = function(type, value)\n{\n  if (value != null && value.length > 0)\n    this.writeBlobTlv(type, value);\n};\n\n/**\n * Get a slice of the encoded bytes.\n * @returns {Buffer} A slice backed by the encoding customBuf.\n */\nTlvEncoder.prototype.getOutput = function()\n{\n  return this.output.array.slice(this.output.array.length - this.length);\n};\n\n})()\n},{"../../buffer.js":116,"../../util/dynamic-buffer.js":159}],168:[function(require,module,exports){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/**\n * CryptoJS core components.\n */\nvar CryptoJS = CryptoJS || (function (Math, undefined) {\n    /**\n     * CryptoJS namespace.\n     */\n    var C = {};\n\n    /**\n     * Library namespace.\n     */\n    var C_lib = C.lib = {};\n\n    /**\n     * Base object for prototypal inheritance.\n     */\n    var Base = C_lib.Base = (function () {\n        function F() {}\n\n        return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: \'value\',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function (overrides) {\n                // Spawn\n                F.prototype = this;\n                var subtype = new F();\n\n                // Augment\n                if (overrides) {\n                    subtype.mixIn(overrides);\n                }\n\n                // Create default initializer\n                if (!subtype.hasOwnProperty(\'init\')) {\n                    subtype.init = function () {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                }\n\n                // Initializer\'s prototype is the subtype object\n                subtype.init.prototype = subtype;\n\n                // Reference supertype\n                subtype.$super = this;\n\n                return subtype;\n            },\n\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function () {\n                var instance = this.extend();\n                instance.init.apply(instance, arguments);\n\n                return instance;\n            },\n\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function () {\n            },\n\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: \'value\'\n             *     });\n             */\n            mixIn: function (properties) {\n                for (var propertyName in properties) {\n                    if (properties.hasOwnProperty(propertyName)) {\n                        this[propertyName] = properties[propertyName];\n                    }\n                }\n\n                // IE won\'t copy toString using the loop above\n                if (properties.hasOwnProperty(\'toString\')) {\n                    this.toString = properties.toString;\n                }\n            },\n\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function () {\n                return this.init.prototype.extend(this);\n            }\n        };\n    }());\n\n    /**\n     * An array of 32-bit words.\n     *\n     * @property {Array} words The array of 32-bit words.\n     * @property {number} sigBytes The number of significant bytes in this word array.\n     */\n    var WordArray = C_lib.WordArray = Base.extend({\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param {Array} words (Optional) An array of 32-bit words.\n         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.create();\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n         */\n        init: function (words, sigBytes) {\n            words = this.words = words || [];\n\n            if (sigBytes != undefined) {\n                this.sigBytes = sigBytes;\n            } else {\n                this.sigBytes = words.length * 4;\n            }\n        },\n\n        /**\n         * Converts this word array to a string.\n         *\n         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {string} The stringified word array.\n         *\n         * @example\n         *\n         *     var string = wordArray + \'\';\n         *     var string = wordArray.toString();\n         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        toString: function (encoder) {\n            return (encoder || Hex).stringify(this);\n        },\n\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param {WordArray} wordArray The word array to append.\n         *\n         * @return {WordArray} This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        concat: function (wordArray) {\n            // Shortcuts\n            var thisWords = this.words;\n            var thatWords = wordArray.words;\n            var thisSigBytes = this.sigBytes;\n            var thatSigBytes = wordArray.sigBytes;\n\n            // Clamp excess bits\n            this.clamp();\n\n            // Concat\n            if (thisSigBytes % 4) {\n                // Copy one byte at a time\n                for (var i = 0; i < thatSigBytes; i++) {\n                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n                }\n            } else if (thatWords.length > 0xffff) {\n                // Copy one word at a time\n                for (var i = 0; i < thatSigBytes; i += 4) {\n                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n                }\n            } else {\n                // Copy all words at once\n                thisWords.push.apply(thisWords, thatWords);\n            }\n            this.sigBytes += thatSigBytes;\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        clamp: function () {\n            // Shortcuts\n            var words = this.words;\n            var sigBytes = this.sigBytes;\n\n            // Clamp\n            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n            words.length = Math.ceil(sigBytes / 4);\n        },\n\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return {WordArray} The clone.\n         *\n         * @example\n         *\n         *     var clone = wordArray.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone.words = this.words.slice(0);\n\n            return clone;\n        },\n\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * @param {number} nBytes The number of random bytes to generate.\n         *\n         * @return {WordArray} The random word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n         */\n        random: function (nBytes) {\n            var words = [];\n            for (var i = 0; i < nBytes; i += 4) {\n                words.push((Math.random() * 0x100000000) | 0);\n            }\n\n            return new WordArray.init(words, nBytes);\n        }\n    });\n\n    /**\n     * Encoder namespace.\n     */\n    var C_enc = C.enc = {};\n\n    /**\n     * Hex encoding strategy.\n     */\n    var Hex = C_enc.Hex = {\n        /**\n         * Converts a word array to a hex string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The hex string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var hexChars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n\n            return hexChars.join(\'\');\n        },\n\n        /**\n         * Converts a hex string to a word array.\n         *\n         * @param {string} hexStr The hex string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n         */\n        parse: function (hexStr) {\n            // Shortcut\n            var hexStrLength = hexStr.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n\n            return new WordArray.init(words, hexStrLength / 2);\n        }\n    };\n\n    /**\n     * Latin1 encoding strategy.\n     */\n    var Latin1 = C_enc.Latin1 = {\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Latin1 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var latin1Chars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n\n            return latin1Chars.join(\'\');\n        },\n\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * @param {string} latin1Str The Latin1 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n         */\n        parse: function (latin1Str) {\n            // Shortcut\n            var latin1StrLength = latin1Str.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n\n            return new WordArray.init(words, latin1StrLength);\n        }\n    };\n\n    /**\n     * UTF-8 encoding strategy.\n     */\n    var Utf8 = C_enc.Utf8 = {\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The UTF-8 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            } catch (e) {\n                throw new Error(\'Malformed UTF-8 data\');\n            }\n        },\n\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * @param {string} utf8Str The UTF-8 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n         */\n        parse: function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        }\n    };\n\n    /**\n     * Abstract buffered block algorithm template.\n     *\n     * The property blockSize must be implemented in a concrete subtype.\n     *\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n     */\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n        /**\n         * Resets this block algorithm\'s data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        reset: function () {\n            // Initial values\n            this._data = new WordArray.init();\n            this._nDataBytes = 0;\n        },\n\n        /**\n         * Adds new data to this block algorithm\'s buffer.\n         *\n         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append(\'data\');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        _append: function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data == \'string\') {\n                data = Utf8.parse(data);\n            }\n\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        },\n\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {WordArray} The processed data.\n         *\n         * @example\n         *\n         *     var processedData = bufferedBlockAlgorithm._process();\n         *     var processedData = bufferedBlockAlgorithm._process(!!\'flush\');\n         */\n        _process: function (doFlush) {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n            var dataSigBytes = data.sigBytes;\n            var blockSize = this.blockSize;\n            var blockSizeBytes = blockSize * 4;\n\n            // Count blocks ready\n            var nBlocksReady = dataSigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            } else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n\n            // Count words ready\n            var nWordsReady = nBlocksReady * blockSize;\n\n            // Count bytes ready\n            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n            // Process blocks\n            if (nWordsReady) {\n                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                }\n\n                // Remove processed words\n                var processedWords = dataWords.splice(0, nWordsReady);\n                data.sigBytes -= nBytesReady;\n            }\n\n            // Return processed words\n            return new WordArray.init(processedWords, nBytesReady);\n        },\n\n        /**\n         * Creates a copy of this object.\n         *\n         * @return {Object} The clone.\n         *\n         * @example\n         *\n         *     var clone = bufferedBlockAlgorithm.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone._data = this._data.clone();\n\n            return clone;\n        },\n\n        _minBufferSize: 0\n    });\n\n    /**\n     * Abstract hasher template.\n     *\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n     */\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n        /**\n         * Configuration options.\n         */\n        cfg: Base.extend(),\n\n        /**\n         * Initializes a newly created hasher.\n         *\n         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n         *\n         * @example\n         *\n         *     var hasher = CryptoJS.algo.SHA256.create();\n         */\n        init: function (cfg) {\n            // Apply config defaults\n            this.cfg = this.cfg.extend(cfg);\n\n            // Set initial values\n            this.reset();\n        },\n\n        /**\n         * Resets this hasher to its initial state.\n         *\n         * @example\n         *\n         *     hasher.reset();\n         */\n        reset: function () {\n            // Reset data buffer\n            BufferedBlockAlgorithm.reset.call(this);\n\n            // Perform concrete-hasher logic\n            this._doReset();\n        },\n\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param {WordArray|string} messageUpdate The message to append.\n         *\n         * @return {Hasher} This hasher.\n         *\n         * @example\n         *\n         *     hasher.update(\'message\');\n         *     hasher.update(wordArray);\n         */\n        update: function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n\n            // Update the hash\n            this._process();\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n         *\n         * @return {WordArray} The hash.\n         *\n         * @example\n         *\n         *     var hash = hasher.finalize();\n         *     var hash = hasher.finalize(\'message\');\n         *     var hash = hasher.finalize(wordArray);\n         */\n        finalize: function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n\n            // Perform concrete-hasher logic\n            var hash = this._doFinalize();\n\n            return hash;\n        },\n\n        blockSize: 512/32,\n\n        /**\n         * Creates a shortcut function to a hasher\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to create a helper for.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n         */\n        _createHelper: function (hasher) {\n            return function (message, cfg) {\n                return new hasher.init(cfg).finalize(message);\n            };\n        },\n\n        /**\n         * Creates a shortcut function to the HMAC\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n         */\n        _createHmacHelper: function (hasher) {\n            return function (message, key) {\n                return new C_algo.HMAC.init(hasher, key).finalize(message);\n            };\n        }\n    });\n\n    /**\n     * Algorithm namespace.\n     */\n    var C_algo = C.algo = {};\n\n    return C;\n}(Math));\n\nmodule.exports = CryptoJS\n\n},{}],143:[function(require,module,exports){\n/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// asn1hex.js - Hexadecimal represented ASN.1 string library\n//\n// version: 1.1 (09-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n//\n// Depends on:\n//\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n// MEMO:\n//   f(\'3082025b02...\', 2) ... 82025b ... 3bytes\n//   f(\'020100\', 2) ... 01 ... 1byte\n//   f(\'0203001...\', 2) ... 03 ... 1byte\n//   f(\'02818003...\', 2) ... 8180 ... 2bytes\n//   f(\'3080....0000\', 2) ... 80 ... -1\n//\n//   Requirements:\n//   - ASN.1 type octet length MUST be 1. \n//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)\n//   - \n\n/**\n * @fileOverview\n * @name asn1hex-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * get byte length for ASN.1 L(length) bytes\n * @name getByteLengthOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return byte length for ASN.1 L(length) bytes\n */\nfunction _asnhex_getByteLengthOfL_AtObj(s, pos) {\n  if (s.substring(pos + 2, pos + 3) != \'8\') return 1;\n  var i = parseInt(s.substring(pos + 3, pos + 4));\n  if (i == 0) return -1; \t\t// length octet \'80\' indefinite length\n  if (0 < i && i < 10) return i + 1;\t// including \'8?\' octet;\n  return -2;\t\t\t\t// malformed format\n}\n\n\n/**\n * get hexadecimal string for ASN.1 L(length) bytes\n * @name getHexOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string for ASN.1 L(length) bytes\n */\nfunction _asnhex_getHexOfL_AtObj(s, pos) {\n  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (len < 1) return \'\';\n  return s.substring(pos + 2, pos + 2 + len * 2);\n}\n\n//\n//   getting ASN.1 length value at the position \'idx\' of\n//   hexa decimal string \'s\'.\n//\n//   f(\'3082025b02...\', 0) ... 82025b ... ???\n//   f(\'020100\', 0) ... 01 ... 1\n//   f(\'0203001...\', 0) ... 03 ... 3\n//   f(\'02818003...\', 0) ... 8180 ... 128\n/**\n * get integer value of ASN.1 length for ASN.1 data\n * @name getIntOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return ASN.1 L(length) integer value\n */\nfunction _asnhex_getIntOfL_AtObj(s, pos) {\n  var hLength = _asnhex_getHexOfL_AtObj(s, pos);\n  if (hLength == \'\') return -1;\n  var bi;\n  if (parseInt(hLength.substring(0, 1)) < 8) {\n     bi = parseBigInt(hLength, 16);\n  } else {\n     bi = parseBigInt(hLength.substring(2), 16);\n  }\n  return bi.intValue();\n}\n\n/**\n * get ASN.1 value starting string position for ASN.1 object refered by index \'idx\'.\n * @name getStartPosOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n */\nfunction _asnhex_getStartPosOfV_AtObj(s, pos) {\n  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (l_len < 0) return l_len;\n  return pos + (l_len + 1) * 2;\n}\n\n/**\n * get hexadecimal string of ASN.1 V(value)\n * @name getHexOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 value.\n */\nfunction _asnhex_getHexOfV_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return s.substring(pos1, pos1 + len * 2);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV at\n * @name getHexOfTLV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 TLV.\n * @since 1.1\n */\nfunction _asnhex_getHexOfTLV_AtObj(s, pos) {\n  var hT = s.substr(pos, 2);\n  var hL = _asnhex_getHexOfL_AtObj(s, pos);\n  var hV = _asnhex_getHexOfV_AtObj(s, pos);\n  return hT + hL + hV;\n}\n\n/**\n * get next sibling starting index for ASN.1 object string\n * @name getPosOfNextSibling_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return next sibling starting index for ASN.1 object string\n */\nfunction _asnhex_getPosOfNextSibling_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return pos1 + len * 2;\n}\n\n/**\n * get array of indexes of child ASN.1 objects\n * @name getPosArrayOfChildren_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} start string index of ASN.1 object\n * @return {Array of Number} array of indexes for childen of ASN.1 objects\n */\nfunction _asnhex_getPosArrayOfChildren_AtObj(h, pos) {\n  var a = new Array();\n  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);\n  a.push(p0);\n\n  var len = _asnhex_getIntOfL_AtObj(h, pos);\n  var p = p0;\n  var k = 0;\n  while (1) {\n    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);\n    if (pNext == null || (pNext - p0  >= (len * 2))) break;\n    if (k >= 200) break;\n\n    a.push(pNext);\n    p = pNext;\n\n    k++;\n  }\n\n  return a;\n}\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getNthChildIndex_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} idx start string index of ASN.1 object\n * @param {Number} nth for child\n * @return {Number} string index of nth child.\n * @since 1.1\n */\nfunction _asnhex_getNthChildIndex_AtObj(h, idx, nth) {\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);\n  return a[nth];\n}\n\n// ========== decendant methods ==============================\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getDecendantIndexByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} string index refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {\n  if (nthList.length == 0) {\n    return currentIndex;\n  }\n  var firstNth = nthList.shift();\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);\n  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.\n * @name getDecendantHexTLVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfTLV_AtObj(h, idx);\n}\n\n/**\n * get hexadecimal string of ASN.1 V refered by current index and nth index list.\n * @name getDecendantHexVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 V refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfV_AtObj(h, idx);\n}\n\n// ========== class definition ==============================\n\n/**\n * ASN.1 DER encoded hexadecimal string utility class\n * @class ASN.1 DER encoded hexadecimal string utility class\n * @author Kenji Urushima\n * @version 1.1 (09 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n * @since 1.1\n */\nfunction ASN1HEX() {\n  return ASN1HEX;\n}\n\nASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;\nASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;\nASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;\nASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;\nASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;\nASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;\nASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;\nASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;\nASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;\nASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;\nASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;\nASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;\n\nmodule.exports = ASN1HEX;\n\n},{"jsbn":171}],144:[function(require,module,exports){\n/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * crypto.js - Cryptographic Algorithm Provider class\n *\n * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be \n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name crypto-1.0.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.0.4 (2013-Mar-28)\n * @since 2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nvar CryptoJS = require(\'./sha256.js\')\nvar BigInteger = require(\'jsbn\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n/** \n * kjur\'s class library name space\n * @name KJUR\n * @namespace kjur\'s class library name space\n */\nif (typeof KJUR == "undefined" || !KJUR) KJUR = {};\n/**\n * kjur\'s cryptographic algorithm provider library name space\n * <p>\n * This namespace privides following crytpgrahic classes.\n * <ul>\n * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.crypto\n * @namespace\n */\nif (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.Util\n * @class static object for cryptographic function utilities\n * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n * @description\n */\nKJUR.crypto.Util = new function() {\n    this.DIGESTINFOHEAD = {\n\t\'sha1\':      "3021300906052b0e03021a05000414",\n        \'sha224\':    "302d300d06096086480165030402040500041c",\n\t\'sha256\':    "3031300d060960864801650304020105000420",\n\t\'sha384\':    "3041300d060960864801650304020205000430",\n\t\'sha512\':    "3051300d060960864801650304020305000440",\n\t\'md2\':       "3020300c06082a864886f70d020205000410",\n\t\'md5\':       "3020300c06082a864886f70d020505000410",\n\t\'ripemd160\': "3021300906052b2403020105000414"\n    };\n\n    /**\n     * get hexadecimal DigestInfo\n     * @name getDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n     */\n    this.getDigestInfoHex = function(hHash, alg) {\n\tif (typeof this.DIGESTINFOHEAD[alg] == "undefined")\n\t    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;\n\treturn this.DIGESTINFOHEAD[alg] + hHash;\n    };\n\n    /**\n     * get PKCS#1 padded hexadecimal DigestInfo\n     * @name getPaddedDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @param {Integer} keySize key bit length (ex. 1024)\n     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n     */\n    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\tvar pmStrLen = keySize / 4; // minimum PM length\n\n\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;\n\n\tvar hHead = "0001";\n\tvar hTail = "00" + hDigestInfo;\n\tvar hMid = "";\n\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\tfor (var i = 0; i < fLen; i += 2) {\n\t    hMid += "ff";\n\t}\n\tvar hPaddedMessage = hHead + hMid + hTail;\n\treturn hPaddedMessage;\n    };\n\n    /**\n     * get hexadecimal SHA1 hash of string\n     * @name sha1\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha1 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha1\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA256 hash of string\n     * @name sha256\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha256 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha256\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA512 hash of string\n     * @name sha512\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha512 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha512\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal MD5 hash of string\n     * @name md5\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.md5 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'md5\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal RIPEMD160 hash of string\n     * @name ripemd160\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.ripemd160 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'ripemd160\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n};\n\n/**\n * MessageDigest class which is very similar to java.security.MessageDigest class\n * @name KJUR.crypto.MessageDigest\n * @class MessageDigest class which is very similar to java.security.MessageDigest class\n * @param {Array} params parameters for constructor\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>md5 - cryptojs</li>\n * <li>sha1 - cryptojs</li>\n * <li>sha224 - cryptojs</li>\n * <li>sha256 - cryptojs</li>\n * <li>sha384 - cryptojs</li>\n * <li>sha512 - cryptojs</li>\n * <li>ripemd160 - cryptojs</li>\n * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n * </ul>\n * @example\n * // CryptoJS provider sample\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n *\n * // SJCL(Stanford JavaScript Crypto Library) provider sample\n * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n */\nKJUR.crypto.MessageDigest = function(params) {\n    var md = null;\n    var algName = null;\n    var provName = null;\n    var _CryptoJSMdName = {\n\t\'md5\': \'CryptoJS.algo.MD5\',\n\t\'sha1\': \'CryptoJS.algo.SHA1\',\n\t\'sha224\': \'CryptoJS.algo.SHA224\',\n\t\'sha256\': \'CryptoJS.algo.SHA256\',\n\t\'sha384\': \'CryptoJS.algo.SHA384\',\n\t\'sha512\': \'CryptoJS.algo.SHA512\',\n\t\'ripemd160\': \'CryptoJS.algo.RIPEMD160\'\n    };\n\n    /**\n     * set hash algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} alg hash algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * // for SHA1\n     * md.setAlgAndProvider(\'sha1\', \'cryptojs\');\n     * // for RIPEMD160\n     * md.setAlgAndProvider(\'ripemd160\', \'cryptojs\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(alg) != -1 &&\n\t    prov == \'cryptojs\') {\n\t    try {\n\t\tthis.md = eval(_CryptoJSMdName[alg]).create();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.md.update(wHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n\tif (\':sha256:\'.indexOf(alg) != -1 &&\n\t    prov == \'sjcl\') {\n\t    try {\n\t\tthis.md = new sjcl.hash.sha256();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\tthis.md.update(baHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn sjcl.codec.hex.fromBits(hash);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString(\'New York\');\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex(\'0afe36\');\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name digest\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.digest = function() {\n\tthrow "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name digestString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString(\'aaa\')\n     */\n    this.digestString = function(str) {\n\tthrow "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, then completes the digest computation\n     * @name digestHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex(\'0f2abd\')\n     */\n    this.digestHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t}\n    }\n};\n\n\n/**\n * Signature class which is very similar to java.security.Signature class\n * @name KJUR.crypto.Signature\n * @class Signature class which is very similar to java.security.Signature class\n * @param {Array} params parameters for constructor\n * @property {String} state Current state of this signature object whether \'SIGN\', \'VERIFY\' or null\n * @description\n * <br/>\n * As for params of constructor\'s argument, it can be specify following attributes:\n * <ul>\n * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>\n * <li>provider - currently \'cryptojs/jsrsa\' only</li>\n * <li>prvkeypem - PEM string of signer\'s private key. If this specified, no need to call initSign(prvKey).</li>\n * </ul>\n * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}\n * withRSA algorithm in \'cryptojs/jsrsa\' provider.\n * <h4>EXAMPLES</h4>\n * @example\n * // signature generation\n * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig.initSign(prvKey);\n * sig.updateString(\'aaa\');\n * var hSigVal = sig.sign();\n *\n * // signature validation\n * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig2.initVerifyByCertificatePEM(cert)\n * sig.updateString(\'aaa\');\n * var isValid = sig2.verify(hSigVal);\n */\nKJUR.crypto.Signature = function(params) {\n    var prvKey = null; // RSAKey for signing\n    var pubKey = null; // RSAKey for verifying\n\n    var md = null; // KJUR.crypto.MessageDigest object\n    var sig = null;\n    var algName = null;\n    var provName = null;\n    var algProvName = null;\n    var mdAlgName = null;\n    var pubkeyAlgName = null;\n    var state = null;\n\n    var sHashHex = null; // hex hash value for hex\n    var hDigestInfo = null;\n    var hPaddedDigestInfo = null;\n    var hSign = null;\n\n    this._setAlgNames = function() {\n\tif (this.algName.match(/^(.+)with(.+)$/)) {\n\t    this.mdAlgName = RegExp.$1.toLowerCase();\n\t    this.pubkeyAlgName = RegExp.$2.toLowerCase();\n\t}\n    };\n\n    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\tvar s = "";\n\tvar nZero = bitLength / 4 - hex.length;\n\tfor (var i = 0; i < nZero; i++) {\n\t    s = s + "0";\n\t}\n\treturn s + hex;\n    };\n\n    /**\n     * set signature algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} alg signature algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * md.setAlgAndProvider(\'SHA1withRSA\', \'cryptojs/jsrsa\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tthis._setAlgNames();\n\tif (prov != \'cryptojs/jsrsa\')\n\t    throw "provider not supported: " + prov;\n\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(this.mdAlgName) != -1) {\n\t    try {\n\t\tthis.md = new KJUR.crypto.MessageDigest({\'alg\':this.mdAlgName,\'prov\':\'cryptojs\'});\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;\n\t    }\n\n\t    this.initSign = function(prvKey) {\n\t\tthis.prvKey = prvKey;\n\t\tthis.state = "SIGN";\n\t    };\n\n\t    this.initVerifyByPublicKey = function(rsaPubKey) {\n\t\tthis.pubKey = rsaPubKey;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tvar x509 = new X509();\n\t\tx509.readCertPEM(certPEM);\n\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.updateString = function(str) {\n\t\tthis.md.updateString(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tthis.md.updateHex(hex);\n\t    };\n\t    this.sign = function() {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.prvKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\t\tthis.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);\n\t\tthis.hPaddedDigestInfo = \n                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);\n\n\t\tvar biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);\n\t\tthis.hoge = biPaddedDigestInfo.toString(16);\n\n\t\tvar biSign = this.prvKey.doPrivate(biPaddedDigestInfo);\n\t\tthis.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);\n\t\treturn this.hSign;\n\t    };\n\t    this.signString = function(str) {\n\t\tthis.updateString(str);\n\t\tthis.sign();\n\t    };\n\t    this.signHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\tthis.sign();\n\t    };\n\t    this.verify = function(hSigVal) {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.pubKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\n\t\tvar biSigVal = parseBigInt(hSigVal, 16);\n\t\tvar biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);\n\t\tthis.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);\n                var s = this.hPaddedDigestInfo;\n                s = s.replace(/^1ff+00/, \'\');\n\n\t\tvar hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];\n                if (s.indexOf(hDIHEAD) != 0) {\n\t\t    return false;\n\t\t}\n\t\tvar hHashFromDI = s.substr(hDIHEAD.length);\n\t\t//alert(hHashFromDI + "\\n" + this.sHashHex);\n\t\treturn (hHashFromDI == this.sHashHex);\n\t    };\n\t}\n    };\n\n    /**\n     * Initialize this object for verifying with a public key\n     * @name initVerifyByPublicKey\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} rsaPubKey RSAKey object of public key\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByPublicKey(prvKey)\n     */\n    this.initVerifyByPublicKey = function(rsaPubKey) {\n\tthrow "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a certficate\n     * @name initVerifyByCertificatePEM\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} certPEM PEM formatted string of certificate\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByCertificatePEM(certPEM)\n     */\n    this.initVerifyByCertificatePEM = function(certPEM) {\n\tthrow "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for signing\n     * @name initSign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} prvKey RSAKey object of private key\n     * @description\n     * @example\n     * sig.initSign(prvKey)\n     */\n    this.initSign = function(prvKey) {\n\tthrow "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a string\n     * @name updateString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to use for the update\n     * @description\n     * @example\n     * sig.updateString(\'aaa\')\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to use for the update\n     * @description\n     * @example\n     * sig.updateHex(\'1f2f3f\')\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Returns the signature bytes of all data updates as a hexadecimal string\n     * @name sign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @return the signature bytes as a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.sign()\n     */\n    this.sign = function() {\n\tthrow "sign() not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signString(\'aaa\')\n     */\n    this.signString = function(str) {\n\tthrow "digestString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signHex(\'1fdc33\')\n     */\n    this.signHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * verifies the passed-in signature.\n     * @name verify\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return {Boolean} true if the signature was verified, otherwise false\n     * @description\n     * @example\n     * var isValid = sig.verify(\'1fbcefdca4823a7(snip)\')\n     */\n    this.verify = function(hSigVal) {\n\tthrow "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.algProvName = params[\'alg\'] + ":" + params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t    this._setAlgNames();\n\t}\n\tif (typeof params[\'prvkeypem\'] != "undefined") {\n\t    if (typeof params[\'prvkeypas\'] != "undefined") {\n\t\tthrow "both prvkeypem and prvkeypas parameters not supported";\n\t    } else {\n\t\ttry {\n\t\t    var prvKey = new RSAKey();\n\t\t    prvKey.readPrivateKeyFromPEMString(params[\'prvkeypem\']);\n\t\t    this.initSign(prvKey);\n\t\t} catch (ex) {\n\t\t    throw "fatal error to load pem private key: " + ex;\n\t\t}\n\t    }\n\t}\n    }\n};\nmodule.exports = KJUR\n\n},{"./sha256.js":167,"jsbn":171}],145:[function(require,module,exports){\n/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-sign.js - adding signing functions to RSAKey class.\n//\n//\n// version: 1.2.2 (13 May 2013)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be \n// included in all copies or substantial portions of the Software.\n\n//\n// Depends on:\n//   function sha1.hex(s) of sha1.js\n//   jsbn.js\n//   jsbn2.js\n//   rsa.js\n//   rsa2.js\n//\nvar BigInteger = require(\'jsbn\')\nvar RSAKey= require(\'./rsapem-1.1.js\')\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// keysize / pmstrlen\n//  512 /  128\n// 1024 /  256\n// 2048 /  512\n// 4096 / 1024\n\n/**\n * @fileOverview\n * @name rsasign-1.2.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * @property {Dictionary} _RSASIGN_DIHEAD\n * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.\n * You can add any DigestInfo hash algorith for signing.\n * See PKCS#1 v2.1 spec (p38).\n */\nvar _RSASIGN_DIHEAD = [];\n_RSASIGN_DIHEAD[\'sha1\'] =      "3021300906052b0e03021a05000414";\n_RSASIGN_DIHEAD[\'sha256\'] =    "3031300d060960864801650304020105000420";\n_RSASIGN_DIHEAD[\'sha384\'] =    "3041300d060960864801650304020205000430";\n_RSASIGN_DIHEAD[\'sha512\'] =    "3051300d060960864801650304020305000440";\n_RSASIGN_DIHEAD[\'md2\'] =       "3020300c06082a864886f70d020205000410";\n_RSASIGN_DIHEAD[\'md5\'] =       "3020300c06082a864886f70d020505000410";\n_RSASIGN_DIHEAD[\'ripemd160\'] = "3021300906052b2403020105000414";\n\n/**\n * @property {Dictionary} _RSASIGN_HASHHEXFUNC\n * @description Array of functions which calculate hash and returns it as hexadecimal.\n * You can add any hash algorithm implementations.\n */\nvar _RSASIGN_HASHHEXFUNC = [];\n_RSASIGN_HASHHEXFUNC[\'sha1\'] =      function(s){return KJUR.crypto.Util.sha1(s);};\n_RSASIGN_HASHHEXFUNC[\'sha256\'] =    function(s){return KJUR.crypto.Util.sha256(s);}\n_RSASIGN_HASHHEXFUNC[\'sha512\'] =    function(s){return KJUR.crypto.Util.sha512(s);}\n_RSASIGN_HASHHEXFUNC[\'md5\'] =       function(s){return KJUR.crypto.Util.md5(s);};\n_RSASIGN_HASHHEXFUNC[\'ripemd160\'] = function(s){return KJUR.crypto.Util.ripemd160(s);};\n\n//_RSASIGN_HASHHEXFUNC[\'sha1\'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n//_RSASIGN_HASHHEXFUNC[\'sha256\'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n\nvar _RE_HEXDECONLY = new RegExp("");\n_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");\n\n// ========================================================================\n// Signature Generation\n// ========================================================================\n\nfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n    var pmStrLen = keySize / 4;\n    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];\n    var sHashHex = hashFunc(s);\n\n    var sHead = "0001";\n    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;\n    var sMid = "";\n    var fLen = pmStrLen - sHead.length - sTail.length;\n    for (var i = 0; i < fLen; i += 2) {\n\tsMid += "ff";\n    }\n    sPaddedMessageHex = sHead + sMid + sTail;\n    return sPaddedMessageHex;\n}\n\nfunction _zeroPaddingOfSignature(hex, bitLength) {\n    var s = "";\n    var nZero = bitLength / 4 - hex.length;\n    for (var i = 0; i < nZero; i++) {\n\ts = s + "0";\n    }\n    return s + hex;\n}\n\n/**\n * sign for a message string with RSA private key.<br/>\n * @name signString\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signString(s, hashAlg) {\n    //alert("this.n.bitLength() = " + this.n.bitLength());\n    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);\n    var biPaddedMessage = parseBigInt(hPM, 16);\n    var biSign = this.doPrivate(biPaddedMessage);\n    var hexSign = biSign.toString(16);\n    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n}\n\nfunction _rsasign_signStringWithSHA1(s) {\n    return _rsasign_signString.call(this, s, \'sha1\');\n}\n\nfunction _rsasign_signStringWithSHA256(s) {\n    return _rsasign_signString.call(this, s, \'sha256\');\n}\n\n// PKCS#1 (PSS) mask generation function\nfunction pss_mgf1_str(seed, len, hash) {\n    var mask = \'\', i = 0;\n\n    while (mask.length < len) {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(s);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var salt = \'\';\n\n    if (sLen > 0) {\n        salt = new Array(sLen);\n        new SecureRandom().nextBytes(salt);\n        salt = String.fromCharCode.apply(String, salt);\n    }\n\n    var H = hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash + salt);\n    var PS = [];\n\n    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n        PS[i] = 0x00;\n    }\n\n    var DB = String.fromCharCode.apply(String, PS) + \'\\x01\' + salt;\n    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n    maskedDB[0] &= ~mask;\n\n    for (i = 0; i < hLen; i++) {\n        maskedDB.push(H.charCodeAt(i));\n    }\n\n    maskedDB.push(0xbc);\n\n    return _zeroPaddingOfSignature(\n            this.doPrivate(new BigInteger(maskedDB)).toString(16),\n            this.n.bitLength());\n}\n\n// ========================================================================\n// Signature Verification\n// ========================================================================\n\nfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n    var rsa = new RSAKey();\n    rsa.setPublic(hN, hE);\n    var biDecryptedSig = rsa.doPublic(biSig);\n    return biDecryptedSig;\n}\n\nfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    return hDigestInfo;\n}\n\nfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n    for (var algName in _RSASIGN_DIHEAD) {\n\tvar head = _RSASIGN_DIHEAD[algName];\n\tvar len = head.length;\n\tif (hDigestInfo.substring(0, len) == head) {\n\t    var a = [algName, hDigestInfo.substring(len)];\n\t    return a;\n\t}\n    }\n    return [];\n}\n\nfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\nfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n    var biSig = parseBigInt(hSig, 16);\n    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t  this.e.toString(16));\n    return result;\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyString\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyString(sMsg, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, \'\');\n    if (hSig.length != this.n.bitLength() / 4) return 0;\n    hSig = hSig.replace(/[ \\n]+/g, "");\n    var biSig = parseBigInt(hSig, 16);\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n  \n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n    if (hSig.length !== this.n.bitLength() / 4) {\n        return false;\n    }\n\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(sMsg);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();\n\n    for (i = 0; i < em.length; i += 1) {\n        em[i] &= 0xff;\n    }\n\n    while (em.length < emLen) {\n        em.unshift(0);\n    }\n\n    if (em[emLen -1] !== 0xbc) {\n        throw "encoded message does not end in 0xbc";\n    }\n\n    em = String.fromCharCode.apply(String, em);\n\n    var maskedDB = em.substr(0, emLen - hLen - 1);\n    var H = em.substr(maskedDB.length, hLen);\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n        throw "bits beyond keysize not zero";\n    }\n\n    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1) {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB[0] &= ~mask;\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i += 1) {\n        if (DB[i] !== 0x00) {\n            throw "leftmost octets not zero";\n        }\n    }\n\n    if (DB[checkLen] !== 0x01) {\n        throw "0x01 marker not found";\n    }\n\n    return H === hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash +\n                          String.fromCharCode.apply(String, DB.slice(-sLen)));\n}\n\nRSAKey.prototype.signString = _rsasign_signString;\nRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.sign = _rsasign_signString;\nRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\nRSAKey.prototype.signPSS = _rsasign_signStringPSS;\nRSAKey.SALT_LEN_HLEN = -1;\nRSAKey.SALT_LEN_MAX = -2;\n\nRSAKey.prototype.verifyString = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verify = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\nRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\nRSAKey.SALT_LEN_RECOVER = -2;\n\n/**\n * @name RSAKey\n * @class key of RSA public key algorithm\n * @description Tom Wu\'s RSA Key class and extension\n */\n\nmodule.exports = RSAKey\n\n},{"./rsapem-1.1.js":169,"jsbn":171}],171:[function(require,module,exports){\n(function(){\n    \n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary&0xffffff)==0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a,b,c) {\n      if(a != null)\n        if("number" == typeof a) this.fromNumber(a,b,c);\n        else if(b == null && "string" != typeof a) this.fromString(a,256);\n        else this.fromString(a,b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i,x,w,j,c,n) {\n      while(--n >= 0) {\n        var v = x*this[i++]+w[j]+c;\n        c = Math.floor(v/0x4000000);\n        w[j++] = v&0x3ffffff;\n      }\n      return c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i,x,w,j,c,n) {\n      var xl = x&0x7fff, xh = x>>15;\n      while(--n >= 0) {\n        var l = this[i]&0x7fff;\n        var h = this[i++]>>15;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n        w[j++] = l&0x3fffffff;\n      }\n      return c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i,x,w,j,c,n) {\n      var xl = x&0x3fff, xh = x>>14;\n      while(--n >= 0) {\n        var l = this[i]&0x3fff;\n        var h = this[i++]>>14;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n        c = (l>>28)+(m>>14)+xh*h;\n        w[j++] = l&0xfffffff;\n      }\n      return c;\n    }\n    var inBrowser = typeof navigator !== "undefined";\n    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\n      BigInteger.prototype.am = am2;\n      dbits = 30;\n    }\n    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {\n      BigInteger.prototype.am = am1;\n      dbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1<<dbits)-1);\n    BigInteger.prototype.DV = (1<<dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n    BigInteger.prototype.F1 = BI_FP-dbits;\n    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n    // Digit conversions\n    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\n    var BI_RC = new Array();\n    var rr,vv;\n    rr = "0".charCodeAt(0);\n    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = "a".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = "A".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s,i) {\n      var c = BI_RC[s.charCodeAt(i)];\n      return (c==null)?-1:c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n      r.t = this.t;\n      r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n      this.t = 1;\n      this.s = (x<0)?-1:0;\n      if(x > 0) this[0] = x;\n      else if(x < -1) this[0] = x+DV;\n      else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n    function bnpFromString(s,b) {\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 256) k = 8; // byte array\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else { this.fromRadix(s,b); return; }\n      this.t = 0;\n      this.s = 0;\n      var i = s.length, mi = false, sh = 0;\n      while(--i >= 0) {\n        var x = (k==8)?s[i]&0xff:intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-") mi = true;\n          continue;\n        }\n        mi = false;\n        if(sh == 0)\n          this[this.t++] = x;\n        else if(sh+k > this.DB) {\n          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n          this[this.t++] = (x>>(this.DB-sh));\n        }\n        else\n          this[this.t-1] |= x<<sh;\n        sh += k;\n        if(sh >= this.DB) sh -= this.DB;\n      }\n      if(k == 8 && (s[0]&0x80) != 0) {\n        this.s = -1;\n        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n      }\n      this.clamp();\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n      var c = this.s&this.DM;\n      while(this.t > 0 && this[this.t-1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n      if(this.s < 0) return "-"+this.negate().toString(b);\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else return this.toRadix(b);\n      var km = (1<<k)-1, d, m = false, r = "", i = this.t;\n      var p = this.DB-(i*this.DB)%k;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n        while(i >= 0) {\n          if(p < k) {\n            d = (this[i]&((1<<p)-1))<<(k-p);\n            d |= this[--i]>>(p+=this.DB-k);\n          }\n          else {\n            d = (this[i]>>(p-=k))&km;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if(d > 0) m = true;\n          if(m) r += int2char(d);\n        }\n      }\n      return m?r:"0";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s<0)?this.negate():this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n      var r = this.s-a.s;\n      if(r != 0) return r;\n      var i = this.t;\n      r = i-a.t;\n      if(r != 0) return (this.s<0)?-r:r;\n      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n      return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n      var r = 1, t;\n      if((t=x>>>16) != 0) { x = t; r += 16; }\n      if((t=x>>8) != 0) { x = t; r += 8; }\n      if((t=x>>4) != 0) { x = t; r += 4; }\n      if((t=x>>2) != 0) { x = t; r += 2; }\n      if((t=x>>1) != 0) { x = t; r += 1; }\n      return r;\n    }\n\n    // (public) return the number of bits in "this"\n    function bnBitLength() {\n      if(this.t <= 0) return 0;\n      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n,r) {\n      var i;\n      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n      for(i = n-1; i >= 0; --i) r[i] = 0;\n      r.t = this.t+n;\n      r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n,r) {\n      for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n      r.t = Math.max(this.t-n,0);\n      r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n,r) {\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<cbs)-1;\n      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n      for(i = this.t-1; i >= 0; --i) {\n        r[i+ds+1] = (this[i]>>cbs)|c;\n        c = (this[i]&bm)<<bs;\n      }\n      for(i = ds-1; i >= 0; --i) r[i] = 0;\n      r[ds] = c;\n      r.t = this.t+ds+1;\n      r.s = this.s;\n      r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n,r) {\n      r.s = this.s;\n      var ds = Math.floor(n/this.DB);\n      if(ds >= this.t) { r.t = 0; return; }\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<bs)-1;\n      r[0] = this[ds]>>bs;\n      for(var i = ds+1; i < this.t; ++i) {\n        r[i-ds-1] |= (this[i]&bm)<<cbs;\n        r[i-ds] = this[i]>>bs;\n      }\n      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n      r.t = this.t-ds;\n      r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]-a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c -= a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c -= a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c -= a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c < -1) r[i++] = this.DV+c;\n      else if(c > 0) r[i++] = c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyTo(a,r) {\n      var x = this.abs(), y = a.abs();\n      var i = x.t;\n      r.t = i+y.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n      r.s = 0;\n      r.clamp();\n      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n      var x = this.abs();\n      var i = r.t = 2*x.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < x.t-1; ++i) {\n        var c = x.am(i,x[i],r,2*i,0,1);\n        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n          r[i+x.t] -= x.DV;\n          r[i+x.t+1] = 1;\n        }\n      }\n      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n      r.s = 0;\n      r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m,q,r) {\n      var pm = m.abs();\n      if(pm.t <= 0) return;\n      var pt = this.abs();\n      if(pt.t < pm.t) {\n        if(q != null) q.fromInt(0);\n        if(r != null) this.copyTo(r);\n        return;\n      }\n      if(r == null) r = nbi();\n      var y = nbi(), ts = this.s, ms = m.s;\n      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n      else { pm.copyTo(y); pt.copyTo(r); }\n      var ys = y.t;\n      var y0 = y[ys-1];\n      if(y0 == 0) return;\n      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n      var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n      y.dlShiftTo(j,t);\n      if(r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t,r);\n      }\n      BigInteger.ONE.dlShiftTo(ys,t);\n      t.subTo(y,y);  // "negative" y so we can replace sub with am later\n      while(y.t < ys) y[y.t++] = 0;\n      while(--j >= 0) {\n        // Estimate quotient digit\n        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n          y.dlShiftTo(j,t);\n          r.subTo(t,r);\n          while(r[i] < --qd) r.subTo(t,r);\n        }\n      }\n      if(q != null) {\n        r.drShiftTo(ys,q);\n        if(ts != ms) BigInteger.ZERO.subTo(q,q);\n      }\n      r.t = ys;\n      r.clamp();\n      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n      if(ts < 0) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n      var r = nbi();\n      this.abs().divRemTo(a,null,r);\n      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n      return r;\n    }\n\n    // Modular reduction using "classic" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n      else return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m,null,x); }\n    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply "overflows" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n      if(this.t < 1) return 0;\n      var x = this[0];\n      if((x&1) == 0) return 0;\n      var y = x&3;       // y == 1/x mod 2^2\n      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n      // last step - calculate inverse mod DV directly;\n      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n      // we really want the negative inverse, and -DV < y < DV\n      return (y>0)?this.DV-y:-y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n      this.m = m;\n      this.mp = m.invDigit();\n      this.mpl = this.mp&0x7fff;\n      this.mph = this.mp>>15;\n      this.um = (1<<(m.DB-15))-1;\n      this.mt2 = 2*m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n      var r = nbi();\n      x.abs().dlShiftTo(this.m.t,r);\n      r.divRemTo(this.m,null,r);\n      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n      return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n      while(x.t <= this.mt2) // pad x so am has enough room later\n        x[x.t++] = 0;\n      for(var i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        var j = x[i]&0x7fff;\n        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i+this.m.t;\n        x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n        // propagate carry\n        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n      }\n      x.clamp();\n      x.drShiftTo(this.m.t,x);\n      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = "x^2/R mod m"; x != r\n    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = "xy/R mod m"; x,y != r\n    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)\n    function bnpExp(e,z) {\n      if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n      g.copyTo(r);\n      while(--i >= 0) {\n        z.sqrTo(r,r2);\n        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n        else { var t = r; r = r2; r2 = t; }\n      }\n      return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e,m) {\n      var z;\n      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n      return this.exp(e,z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // "constants"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See "LICENSE" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger("0", 10) returns "proper" zero\n    // Version 1.2: square() API, isProbablePrime fix\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n      if(this.s < 0) {\n        if(this.t == 1) return this[0]-this.DV;\n        else if(this.t == 0) return -1;\n      }\n      else if(this.t == 1) return this[0];\n      else if(this.t == 0) return 0;\n      // assumes 16 < DB < 32\n      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n      if(this.s < 0) return -1;\n      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n      else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n      if(b == null) b = 10;\n      if(this.signum() == 0 || b < 2 || b > 36) return "0";\n      var cs = this.chunkSize(b);\n      var a = Math.pow(b,cs);\n      var d = nbv(a), y = nbi(), z = nbi(), r = "";\n      this.divRemTo(d,y,z);\n      while(y.signum() > 0) {\n        r = (a+z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d,y,z);\n      }\n      return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s,b) {\n      this.fromInt(0);\n      if(b == null) b = 10;\n      var cs = this.chunkSize(b);\n      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n      for(var i = 0; i < s.length; ++i) {\n        var x = intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;\n          continue;\n        }\n        w = b*w+x;\n        if(++j >= cs) {\n          this.dMultiply(d);\n          this.dAddOffset(w,0);\n          j = 0;\n          w = 0;\n        }\n      }\n      if(j > 0) {\n        this.dMultiply(Math.pow(b,j));\n        this.dAddOffset(w,0);\n      }\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a,b,c) {\n      if("number" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if(a < 2) this.fromInt(1);\n        else {\n          this.fromNumber(a,c);\n          if(!this.testBit(a-1))\t// force MSB set\n            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n          if(this.isEven()) this.dAddOffset(1,0); // force odd\n          while(!this.isProbablePrime(b)) {\n            this.dAddOffset(2,0);\n            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n          }\n        }\n      }\n      else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a&7;\n        x.length = (a>>3)+1;\n        b.nextBytes(x);\n        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n        this.fromString(x,256);\n      }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n      var i = this.t, r = new Array();\n      r[0] = this.s;\n      var p = this.DB-(i*this.DB)%8, d, k = 0;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n          r[k++] = d|(this.s<<(this.DB-p));\n        while(i >= 0) {\n          if(p < 8) {\n            d = (this[i]&((1<<p)-1))<<(8-p);\n            d |= this[--i]>>(p+=this.DB-8);\n          }\n          else {\n            d = (this[i]>>(p-=8))&0xff;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if((d&0x80) != 0) d |= -256;\n          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n          if(k > 0 || d != this.s) r[k++] = d;\n        }\n      }\n      return r;\n    }\n\n    function bnEquals(a) { return(this.compareTo(a)==0); }\n    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a,op,r) {\n      var i, f, m = Math.min(a.t,this.t);\n      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n      if(a.t < this.t) {\n        f = a.s&this.DM;\n        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n        r.t = this.t;\n      }\n      else {\n        f = this.s&this.DM;\n        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n        r.t = a.t;\n      }\n      r.s = op(this.s,a.s);\n      r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x,y) { return x&y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n    // (public) this | a\n    function op_or(x,y) { return x|y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x,y) { return x^y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x,y) { return x&~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n      var r = nbi();\n      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n      r.t = this.t;\n      r.s = ~this.s;\n      return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n      var r = nbi();\n      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n      return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n      var r = nbi();\n      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n      return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n      if(x == 0) return -1;\n      var r = 0;\n      if((x&0xffff) == 0) { x >>= 16; r += 16; }\n      if((x&0xff) == 0) { x >>= 8; r += 8; }\n      if((x&0xf) == 0) { x >>= 4; r += 4; }\n      if((x&3) == 0) { x >>= 2; r += 2; }\n      if((x&1) == 0) ++r;\n      return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n      for(var i = 0; i < this.t; ++i)\n        if(this[i] != 0) return i*this.DB+lbit(this[i]);\n      if(this.s < 0) return this.t*this.DB;\n      return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n      var r = 0;\n      while(x != 0) { x &= x-1; ++r; }\n      return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n      var r = 0, x = this.s&this.DM;\n      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n      return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n      var j = Math.floor(n/this.DB);\n      if(j >= this.t) return(this.s!=0);\n      return((this[j]&(1<<(n%this.DB)))!=0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n,op) {\n      var r = BigInteger.ONE.shiftLeft(n);\n      this.bitwiseTo(r,op,r);\n      return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]+a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c += a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c += a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c > 0) r[i++] = c;\n      else if(c < -1) r[i++] = this.DV+c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n    // (public) this^2\n    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n      var q = nbi(), r = nbi();\n      this.divRemTo(a,q,r);\n      return new Array(q,r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n      this[this.t] = this.am(0,n-1,this,0,0,this.t);\n      ++this.t;\n      this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n,w) {\n      if(n == 0) return;\n      while(this.t <= w) this[this.t++] = 0;\n      this[w] += n;\n      while(this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if(++w >= this.t) this[this.t++] = 0;\n        ++this[w];\n      }\n    }\n\n    // A "null" reducer\n    function NullExp() {}\n    function nNop(x) { return x; }\n    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n    function nSqrTo(x,r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.exp(e,new NullExp()); }\n\n    // (protected) r = lower n words of "this * a", a.t <= n\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a,n,r) {\n      var i = Math.min(this.t+a.t,n);\n      r.s = 0; // assumes a,this >= 0\n      r.t = i;\n      while(i > 0) r[--i] = 0;\n      var j;\n      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n      r.clamp();\n    }\n\n    // (protected) r = "this * a" without lower n words, n > 0\n    // "this" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a,n,r) {\n      --n;\n      var i = r.t = this.t+a.t-n;\n      r.s = 0; // assumes a,this >= 0\n      while(--i >= 0) r[i] = 0;\n      for(i = Math.max(n-this.t,0); i < a.t; ++i)\n        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n      r.clamp();\n      r.drShiftTo(1,r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n      // setup Barrett\n      this.r2 = nbi();\n      this.q3 = nbi();\n      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n      this.mu = this.r2.divide(m);\n      this.m = m;\n    }\n\n    function barrettConvert(x) {\n      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n      else if(x.compareTo(this.m) < 0) return x;\n      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n      x.drShiftTo(this.m.t-1,this.r2);\n      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n      x.subTo(this.r2,x);\n      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e,m) {\n      var i = e.bitLength(), k, r = nbv(1), z;\n      if(i <= 0) return r;\n      else if(i < 18) k = 1;\n      else if(i < 48) k = 3;\n      else if(i < 144) k = 4;\n      else if(i < 768) k = 5;\n      else k = 6;\n      if(i < 8)\n        z = new Classic(m);\n      else if(m.isEven())\n        z = new Barrett(m);\n      else\n        z = new Montgomery(m);\n\n      // precomputation\n      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n      g[1] = z.convert(this);\n      if(k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1],g2);\n        while(n <= km) {\n          g[n] = nbi();\n          z.mulTo(g2,g[n-2],g[n]);\n          n += 2;\n        }\n      }\n\n      var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n      i = nbits(e[j])-1;\n      while(j >= 0) {\n        if(i >= k1) w = (e[j]>>(i-k1))&km;\n        else {\n          w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n        }\n\n        n = k;\n        while((w&1) == 0) { w >>= 1; --n; }\n        if((i -= n) < 0) { i += this.DB; --j; }\n        if(is1) {\t// ret == 1, don\'t bother squaring or multiplying it\n          g[w].copyTo(r);\n          is1 = false;\n        }\n        else {\n          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n          z.mulTo(r2,g[w],r);\n        }\n\n        while(j >= 0 && (e[j]&(1<<i)) == 0) {\n          z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n          if(--i < 0) { i = this.DB-1; --j; }\n        }\n      }\n      return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n      var x = (this.s<0)?this.negate():this.clone();\n      var y = (a.s<0)?a.negate():a.clone();\n      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n      if(g < 0) return x;\n      if(i < g) g = i;\n      if(g > 0) {\n        x.rShiftTo(g,x);\n        y.rShiftTo(g,y);\n      }\n      while(x.signum() > 0) {\n        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n        if(x.compareTo(y) >= 0) {\n          x.subTo(y,x);\n          x.rShiftTo(1,x);\n        }\n        else {\n          y.subTo(x,y);\n          y.rShiftTo(1,y);\n        }\n      }\n      if(g > 0) y.lShiftTo(g,y);\n      return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n      if(n <= 0) return 0;\n      var d = this.DV%n, r = (this.s<0)?n-1:0;\n      if(this.t > 0)\n        if(d == 0) r = this[0]%n;\n        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n      return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n      var ac = m.isEven();\n      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n      var u = m.clone(), v = this.clone();\n      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n      while(u.signum() != 0) {\n        while(u.isEven()) {\n          u.rShiftTo(1,u);\n          if(ac) {\n            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n            a.rShiftTo(1,a);\n          }\n          else if(!b.isEven()) b.subTo(m,b);\n          b.rShiftTo(1,b);\n        }\n        while(v.isEven()) {\n          v.rShiftTo(1,v);\n          if(ac) {\n            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n            c.rShiftTo(1,c);\n          }\n          else if(!d.isEven()) d.subTo(m,d);\n          d.rShiftTo(1,d);\n        }\n        if(u.compareTo(v) >= 0) {\n          u.subTo(v,u);\n          if(ac) a.subTo(c,a);\n          b.subTo(d,b);\n        }\n        else {\n          v.subTo(u,v);\n          if(ac) c.subTo(a,c);\n          d.subTo(b,d);\n        }\n      }\n      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n      if(d.compareTo(m) >= 0) return d.subtract(m);\n      if(d.signum() < 0) d.addTo(m,d); else return d;\n      if(d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n      var i, x = this.abs();\n      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n        for(i = 0; i < lowprimes.length; ++i)\n          if(x[0] == lowprimes[i]) return true;\n        return false;\n      }\n      if(x.isEven()) return false;\n      i = 1;\n      while(i < lowprimes.length) {\n        var m = lowprimes[i], j = i+1;\n        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j) if(m%lowprimes[i++] == 0) return false;\n      }\n      return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n      var n1 = this.subtract(BigInteger.ONE);\n      var k = n1.getLowestSetBit();\n      if(k <= 0) return false;\n      var r = n1.shiftRight(k);\n      t = (t+1)>>1;\n      if(t > lowprimes.length) t = lowprimes.length;\n      var a = nbi();\n      for(var i = 0; i < t; ++i) {\n        //Pick bases at random, instead of starting at 2\n        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n        var y = a.modPow(r,this);\n        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n          var j = 1;\n          while(j++ < k && y.compareTo(n1) != 0) {\n            y = y.modPowInt(2,this);\n            if(y.compareTo(BigInteger.ONE) == 0) return false;\n          }\n          if(y.compareTo(n1) != 0) return false;\n        }\n      }\n      return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // JSBN-specific extension\n    BigInteger.prototype.square = bnSquare;\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n    if (typeof exports !== \'undefined\') {\n        exports = module.exports = BigInteger;\n    } else {\n        this.BigInteger = BigInteger;\n    }\n    \n}).call(this);\n},{}],157:[function(require,module,exports){\n// Depends on rsa.js and jsbn2.js\nvar BigInteger = require(\'jsbn\')\nvar RSAKey = require(\'./rsa.js\')\n// Version 1.1: support utf-8 decoding in pkcs1unpad2\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\nfunction pkcs1unpad2(d,n) {\n  var b = d.toByteArray();\n  var i = 0;\n  while(i < b.length && b[i] == 0) ++i;\n  if(b.length-i != n-1 || b[i] != 2)\n    return null;\n  ++i;\n  while(b[i] != 0)\n    if(++i >= b.length) return null;\n  var ret = "";\n  while(++i < b.length) {\n    var c = b[i] & 255;\n    if(c < 128) { // utf-8 decode\n      ret += String.fromCharCode(c);\n    }\n    else if((c > 191) && (c < 224)) {\n      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));\n      ++i;\n    }\n    else {\n      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));\n      i += 2;\n    }\n  }\n  return ret;\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_str(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext\nfunction oaep_unpad(d, n, hash)\n{\n    d = d.toByteArray();\n\n    var i;\n\n    for (i = 0; i < d.length; i += 1)\n    {\n        d[i] &= 0xff;\n    }\n\n    while (d.length < n)\n    {\n        d.unshift(0);\n    }\n\n    d = String.fromCharCode.apply(String, d);\n\n    if (d.length < 2 * SHA1_SIZE + 2)\n    {\n        throw "Cipher too short";\n    }\n\n    var maskedSeed = d.substr(1, SHA1_SIZE)\n    var maskedDB = d.substr(SHA1_SIZE + 1);\n\n    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);\n    var seed = [], i;\n\n    for (i = 0; i < maskedSeed.length; i += 1)\n    {\n        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);\n    }\n\n    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),\n                           d.length - SHA1_SIZE, rstr_sha1);\n\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1)\n    {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB = String.fromCharCode.apply(String, DB);\n\n    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(\'\'))\n    {\n        throw "Hash mismatch";\n    }\n\n    DB = DB.substr(SHA1_SIZE);\n\n    var first_one = DB.indexOf(\'\\x01\');\n    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf(\'\\x00\') : -1;\n\n    if (last_zero + 1 != first_one)\n    {\n        throw "Malformed data";\n    }\n\n    return DB.substr(first_one + 1);\n}\n\n// Set the private key fields N, e, and d from hex strings\nfunction RSASetPrivate(N,E,D) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n    this.d = D;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n  }\n  else\n    alert("Invalid RSA private key");\n}\n\n// Set the private key fields N, e, d and CRT params from hex strings\nfunction RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {\n  //alert("RSASetPrivateEx called");\n  if (N == null) throw "RSASetPrivateEx N == null";\n  if (E == null) throw "RSASetPrivateEx E == null";\n  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";\n  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";\n\n  if (N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n    this.p = parseBigInt(P,16);\n    this.q = parseBigInt(Q,16);\n    this.dmp1 = parseBigInt(DP,16);\n    this.dmq1 = parseBigInt(DQ,16);\n    this.coeff = parseBigInt(C,16);\n  } else {\n    alert("Invalid RSA private key in RSASetPrivateEx");\n  }\n}\n\n// Generate a new random private key B bits long, using public expt E\nfunction RSAGenerate(B,E) {\n  var rng = new SecureRandom();\n  var qs = B>>1;\n  this.e = parseInt(E,16);\n  var ee = new BigInteger(E,16);\n  for(;;) {\n    for(;;) {\n      this.p = new BigInteger(B-qs,1,rng);\n      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;\n    }\n    for(;;) {\n      this.q = new BigInteger(qs,1,rng);\n      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;\n    }\n    if(this.p.compareTo(this.q) <= 0) {\n      var t = this.p;\n      this.p = this.q;\n      this.q = t;\n    }\n    var p1 = this.p.subtract(BigInteger.ONE);\t// p1 = p - 1\n    var q1 = this.q.subtract(BigInteger.ONE);\t// q1 = q - 1\n    var phi = p1.multiply(q1);\n    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n      this.n = this.p.multiply(this.q);\t// this.n = p * q\n      this.d = ee.modInverse(phi);\t// this.d = \n      this.dmp1 = this.d.mod(p1);\t// this.dmp1 = d mod (p - 1)\n      this.dmq1 = this.d.mod(q1);\t// this.dmq1 = d mod (q - 1)\n      this.coeff = this.q.modInverse(this.p);\t// this.coeff = (q ^ -1) mod p\n      break;\n    }\n  }\n}\n\n// Perform raw private operation on "x": return x^d (mod n)\nfunction RSADoPrivate(x) {\n  if(this.p == null || this.q == null)\n    return x.modPow(this.d, this.n);\n\n  // TODO: re-calculate any missing CRT params\n  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?\n  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?\n\n  while(xp.compareTo(xq) < 0)\n    xp = xp.add(this.p);\n  // NOTE:\n  // xp.subtract(xq) => cp -cq\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M\n  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecrypt(ctext) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);\n}\n\n// Return the PKCS#1 OAEP RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecryptOAEP(ctext, hash) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is a Base64-encoded string and the output is a plain string.\n//function RSAB64Decrypt(ctext) {\n//  var h = b64tohex(ctext);\n//  if(h) return this.decrypt(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPrivate = RSADoPrivate;\n\n// public\nRSAKey.prototype.setPrivate = RSASetPrivate;\nRSAKey.prototype.setPrivateEx = RSASetPrivateEx;\nRSAKey.prototype.generate = RSAGenerate;\nRSAKey.prototype.decrypt = RSADecrypt;\nRSAKey.prototype.decryptOAEP = RSADecryptOAEP;\n//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;\n\nmodule.exports = RSAKey\n\n},{"./rsa.js":172,"jsbn":160}],164:[function(require,module,exports){\n// Depends on rsa.js and jsbn2.js\nvar BigInteger = require(\'jsbn\')\nvar RSAKey = require(\'./rsa.js\')\n// Version 1.1: support utf-8 decoding in pkcs1unpad2\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\nfunction pkcs1unpad2(d,n) {\n  var b = d.toByteArray();\n  var i = 0;\n  while(i < b.length && b[i] == 0) ++i;\n  if(b.length-i != n-1 || b[i] != 2)\n    return null;\n  ++i;\n  while(b[i] != 0)\n    if(++i >= b.length) return null;\n  var ret = "";\n  while(++i < b.length) {\n    var c = b[i] & 255;\n    if(c < 128) { // utf-8 decode\n      ret += String.fromCharCode(c);\n    }\n    else if((c > 191) && (c < 224)) {\n      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));\n      ++i;\n    }\n    else {\n      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));\n      i += 2;\n    }\n  }\n  return ret;\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_str(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext\nfunction oaep_unpad(d, n, hash)\n{\n    d = d.toByteArray();\n\n    var i;\n\n    for (i = 0; i < d.length; i += 1)\n    {\n        d[i] &= 0xff;\n    }\n\n    while (d.length < n)\n    {\n        d.unshift(0);\n    }\n\n    d = String.fromCharCode.apply(String, d);\n\n    if (d.length < 2 * SHA1_SIZE + 2)\n    {\n        throw "Cipher too short";\n    }\n\n    var maskedSeed = d.substr(1, SHA1_SIZE)\n    var maskedDB = d.substr(SHA1_SIZE + 1);\n\n    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);\n    var seed = [], i;\n\n    for (i = 0; i < maskedSeed.length; i += 1)\n    {\n        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);\n    }\n\n    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),\n                           d.length - SHA1_SIZE, rstr_sha1);\n\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1)\n    {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB = String.fromCharCode.apply(String, DB);\n\n    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(\'\'))\n    {\n        throw "Hash mismatch";\n    }\n\n    DB = DB.substr(SHA1_SIZE);\n\n    var first_one = DB.indexOf(\'\\x01\');\n    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf(\'\\x00\') : -1;\n\n    if (last_zero + 1 != first_one)\n    {\n        throw "Malformed data";\n    }\n\n    return DB.substr(first_one + 1);\n}\n\n// Set the private key fields N, e, and d from hex strings\nfunction RSASetPrivate(N,E,D) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n    this.d = D;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n  }\n  else\n    alert("Invalid RSA private key");\n}\n\n// Set the private key fields N, e, d and CRT params from hex strings\nfunction RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {\n  //alert("RSASetPrivateEx called");\n  if (N == null) throw "RSASetPrivateEx N == null";\n  if (E == null) throw "RSASetPrivateEx E == null";\n  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";\n  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";\n\n  if (N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n    this.p = parseBigInt(P,16);\n    this.q = parseBigInt(Q,16);\n    this.dmp1 = parseBigInt(DP,16);\n    this.dmq1 = parseBigInt(DQ,16);\n    this.coeff = parseBigInt(C,16);\n  } else {\n    alert("Invalid RSA private key in RSASetPrivateEx");\n  }\n}\n\n// Generate a new random private key B bits long, using public expt E\nfunction RSAGenerate(B,E) {\n  var rng = new SecureRandom();\n  var qs = B>>1;\n  this.e = parseInt(E,16);\n  var ee = new BigInteger(E,16);\n  for(;;) {\n    for(;;) {\n      this.p = new BigInteger(B-qs,1,rng);\n      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;\n    }\n    for(;;) {\n      this.q = new BigInteger(qs,1,rng);\n      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;\n    }\n    if(this.p.compareTo(this.q) <= 0) {\n      var t = this.p;\n      this.p = this.q;\n      this.q = t;\n    }\n    var p1 = this.p.subtract(BigInteger.ONE);\t// p1 = p - 1\n    var q1 = this.q.subtract(BigInteger.ONE);\t// q1 = q - 1\n    var phi = p1.multiply(q1);\n    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n      this.n = this.p.multiply(this.q);\t// this.n = p * q\n      this.d = ee.modInverse(phi);\t// this.d = \n      this.dmp1 = this.d.mod(p1);\t// this.dmp1 = d mod (p - 1)\n      this.dmq1 = this.d.mod(q1);\t// this.dmq1 = d mod (q - 1)\n      this.coeff = this.q.modInverse(this.p);\t// this.coeff = (q ^ -1) mod p\n      break;\n    }\n  }\n}\n\n// Perform raw private operation on "x": return x^d (mod n)\nfunction RSADoPrivate(x) {\n  if(this.p == null || this.q == null)\n    return x.modPow(this.d, this.n);\n\n  // TODO: re-calculate any missing CRT params\n  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?\n  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?\n\n  while(xp.compareTo(xq) < 0)\n    xp = xp.add(this.p);\n  // NOTE:\n  // xp.subtract(xq) => cp -cq\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M\n  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecrypt(ctext) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);\n}\n\n// Return the PKCS#1 OAEP RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecryptOAEP(ctext, hash) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is a Base64-encoded string and the output is a plain string.\n//function RSAB64Decrypt(ctext) {\n//  var h = b64tohex(ctext);\n//  if(h) return this.decrypt(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPrivate = RSADoPrivate;\n\n// public\nRSAKey.prototype.setPrivate = RSASetPrivate;\nRSAKey.prototype.setPrivateEx = RSASetPrivateEx;\nRSAKey.prototype.generate = RSAGenerate;\nRSAKey.prototype.decrypt = RSADecrypt;\nRSAKey.prototype.decryptOAEP = RSADecryptOAEP;\n//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;\n\nmodule.exports = RSAKey\n\n},{"./rsa.js":173,"jsbn":166}],172:[function(require,module,exports){\n// Depends on jsbn.js and rng.js\nvar BigInteger = require(\'jsbn\')\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n\n// convert a (hex) string to a bignum object\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\nfunction linebrk(s,n) {\n  var ret = "";\n  var i = 0;\n  while(i + n < s.length) {\n    ret += s.substring(i,i+n) + "\\n";\n    i += n;\n  }\n  return ret + s.substring(i,s.length);\n}\n\nfunction byte2Hex(b) {\n  if(b < 0x10)\n    return "0" + b.toString(16);\n  else\n    return b.toString(16);\n}\n\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s,n) {\n  if(n < s.length + 11) { // TODO: fix for utf-8\n    alert("Message too long for RSA");\n    return null;\n  }\n  var ba = new Array();\n  var i = s.length - 1;\n  while(i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n    if(c < 128) { // encode using utf-8\n      ba[--n] = c;\n    }\n    else if((c > 127) && (c < 2048)) {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = (c >> 6) | 192;\n    }\n    else {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = ((c >> 6) & 63) | 128;\n      ba[--n] = (c >> 12) | 224;\n    }\n  }\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = new Array();\n  while(n > 2) { // random non-zero pad\n    x[0] = 0;\n    while(x[0] == 0) rng.nextBytes(x);\n    ba[--n] = x[0];\n  }\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\nfunction oaep_pad(s, n, hash)\n{\n    if (s.length + 2 * SHA1_SIZE + 2 > n)\n    {\n        throw "Message too long for RSA";\n    }\n\n    var PS = \'\', i;\n\n    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)\n    {\n        PS += \'\\x00\';\n    }\n\n    var DB = rstr_sha1(\'\') + PS + \'\\x01\' + s;\n    var seed = new Array(SHA1_SIZE);\n    new SecureRandom().nextBytes(seed);\n    \n    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1)\n    {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);\n    var maskedSeed = [0];\n\n    for (i = 0; i < seed.length; i += 1)\n    {\n        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n    }\n\n    return new BigInteger(maskedSeed.concat(maskedDB));\n}\n\n// "empty" RSA key constructor\nfunction RSAKey() {\n  this.n = null;\n  this.e = 0;\n  this.d = null;\n  this.p = null;\n  this.q = null;\n  this.dmp1 = null;\n  this.dmq1 = null;\n  this.coeff = null;\n}\n\n// Set the public key fields N and e from hex strings\nfunction RSASetPublic(N,E) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n  }\n  else\n    alert("Invalid RSA public key");\n}\n\n// Perform raw public operation on "x": return x^e (mod n)\nfunction RSADoPublic(x) {\n  return x.modPowInt(this.e, this.n);\n}\n\n// Return the PKCS#1 RSA encryption of "text" as an even-length hex string\nfunction RSAEncrypt(text) {\n  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string\nfunction RSAEncryptOAEP(text, hash) {\n  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string\n//function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPublic = RSADoPublic;\n\n// public\nRSAKey.prototype.setPublic = RSASetPublic;\nRSAKey.prototype.encrypt = RSAEncrypt;\nRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n\n\nmodule.exports = RSAKey\n//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n\n},{"jsbn":160}],170:[function(require,module,exports){\n// Depends on rsa.js and jsbn2.js\nvar BigInteger = require(\'jsbn\')\nvar RSAKey = require(\'./rsa.js\')\n// Version 1.1: support utf-8 decoding in pkcs1unpad2\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\nfunction pkcs1unpad2(d,n) {\n  var b = d.toByteArray();\n  var i = 0;\n  while(i < b.length && b[i] == 0) ++i;\n  if(b.length-i != n-1 || b[i] != 2)\n    return null;\n  ++i;\n  while(b[i] != 0)\n    if(++i >= b.length) return null;\n  var ret = "";\n  while(++i < b.length) {\n    var c = b[i] & 255;\n    if(c < 128) { // utf-8 decode\n      ret += String.fromCharCode(c);\n    }\n    else if((c > 191) && (c < 224)) {\n      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));\n      ++i;\n    }\n    else {\n      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));\n      i += 2;\n    }\n  }\n  return ret;\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_str(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext\nfunction oaep_unpad(d, n, hash)\n{\n    d = d.toByteArray();\n\n    var i;\n\n    for (i = 0; i < d.length; i += 1)\n    {\n        d[i] &= 0xff;\n    }\n\n    while (d.length < n)\n    {\n        d.unshift(0);\n    }\n\n    d = String.fromCharCode.apply(String, d);\n\n    if (d.length < 2 * SHA1_SIZE + 2)\n    {\n        throw "Cipher too short";\n    }\n\n    var maskedSeed = d.substr(1, SHA1_SIZE)\n    var maskedDB = d.substr(SHA1_SIZE + 1);\n\n    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);\n    var seed = [], i;\n\n    for (i = 0; i < maskedSeed.length; i += 1)\n    {\n        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);\n    }\n\n    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),\n                           d.length - SHA1_SIZE, rstr_sha1);\n\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1)\n    {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB = String.fromCharCode.apply(String, DB);\n\n    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(\'\'))\n    {\n        throw "Hash mismatch";\n    }\n\n    DB = DB.substr(SHA1_SIZE);\n\n    var first_one = DB.indexOf(\'\\x01\');\n    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf(\'\\x00\') : -1;\n\n    if (last_zero + 1 != first_one)\n    {\n        throw "Malformed data";\n    }\n\n    return DB.substr(first_one + 1);\n}\n\n// Set the private key fields N, e, and d from hex strings\nfunction RSASetPrivate(N,E,D) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n    this.d = D;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n  }\n  else\n    alert("Invalid RSA private key");\n}\n\n// Set the private key fields N, e, d and CRT params from hex strings\nfunction RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {\n  //alert("RSASetPrivateEx called");\n  if (N == null) throw "RSASetPrivateEx N == null";\n  if (E == null) throw "RSASetPrivateEx E == null";\n  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";\n  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";\n\n  if (N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n    this.p = parseBigInt(P,16);\n    this.q = parseBigInt(Q,16);\n    this.dmp1 = parseBigInt(DP,16);\n    this.dmq1 = parseBigInt(DQ,16);\n    this.coeff = parseBigInt(C,16);\n  } else {\n    alert("Invalid RSA private key in RSASetPrivateEx");\n  }\n}\n\n// Generate a new random private key B bits long, using public expt E\nfunction RSAGenerate(B,E) {\n  var rng = new SecureRandom();\n  var qs = B>>1;\n  this.e = parseInt(E,16);\n  var ee = new BigInteger(E,16);\n  for(;;) {\n    for(;;) {\n      this.p = new BigInteger(B-qs,1,rng);\n      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;\n    }\n    for(;;) {\n      this.q = new BigInteger(qs,1,rng);\n      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;\n    }\n    if(this.p.compareTo(this.q) <= 0) {\n      var t = this.p;\n      this.p = this.q;\n      this.q = t;\n    }\n    var p1 = this.p.subtract(BigInteger.ONE);\t// p1 = p - 1\n    var q1 = this.q.subtract(BigInteger.ONE);\t// q1 = q - 1\n    var phi = p1.multiply(q1);\n    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n      this.n = this.p.multiply(this.q);\t// this.n = p * q\n      this.d = ee.modInverse(phi);\t// this.d = \n      this.dmp1 = this.d.mod(p1);\t// this.dmp1 = d mod (p - 1)\n      this.dmq1 = this.d.mod(q1);\t// this.dmq1 = d mod (q - 1)\n      this.coeff = this.q.modInverse(this.p);\t// this.coeff = (q ^ -1) mod p\n      break;\n    }\n  }\n}\n\n// Perform raw private operation on "x": return x^d (mod n)\nfunction RSADoPrivate(x) {\n  if(this.p == null || this.q == null)\n    return x.modPow(this.d, this.n);\n\n  // TODO: re-calculate any missing CRT params\n  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?\n  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?\n\n  while(xp.compareTo(xq) < 0)\n    xp = xp.add(this.p);\n  // NOTE:\n  // xp.subtract(xq) => cp -cq\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M\n  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecrypt(ctext) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);\n}\n\n// Return the PKCS#1 OAEP RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecryptOAEP(ctext, hash) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is a Base64-encoded string and the output is a plain string.\n//function RSAB64Decrypt(ctext) {\n//  var h = b64tohex(ctext);\n//  if(h) return this.decrypt(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPrivate = RSADoPrivate;\n\n// public\nRSAKey.prototype.setPrivate = RSASetPrivate;\nRSAKey.prototype.setPrivateEx = RSASetPrivateEx;\nRSAKey.prototype.generate = RSAGenerate;\nRSAKey.prototype.decrypt = RSADecrypt;\nRSAKey.prototype.decryptOAEP = RSADecryptOAEP;\n//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;\n\nmodule.exports = RSAKey\n\n},{"./rsa.js":174,"jsbn":171}],173:[function(require,module,exports){\n// Depends on jsbn.js and rng.js\nvar BigInteger = require(\'jsbn\')\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n\n// convert a (hex) string to a bignum object\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\nfunction linebrk(s,n) {\n  var ret = "";\n  var i = 0;\n  while(i + n < s.length) {\n    ret += s.substring(i,i+n) + "\\n";\n    i += n;\n  }\n  return ret + s.substring(i,s.length);\n}\n\nfunction byte2Hex(b) {\n  if(b < 0x10)\n    return "0" + b.toString(16);\n  else\n    return b.toString(16);\n}\n\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s,n) {\n  if(n < s.length + 11) { // TODO: fix for utf-8\n    alert("Message too long for RSA");\n    return null;\n  }\n  var ba = new Array();\n  var i = s.length - 1;\n  while(i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n    if(c < 128) { // encode using utf-8\n      ba[--n] = c;\n    }\n    else if((c > 127) && (c < 2048)) {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = (c >> 6) | 192;\n    }\n    else {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = ((c >> 6) & 63) | 128;\n      ba[--n] = (c >> 12) | 224;\n    }\n  }\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = new Array();\n  while(n > 2) { // random non-zero pad\n    x[0] = 0;\n    while(x[0] == 0) rng.nextBytes(x);\n    ba[--n] = x[0];\n  }\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\nfunction oaep_pad(s, n, hash)\n{\n    if (s.length + 2 * SHA1_SIZE + 2 > n)\n    {\n        throw "Message too long for RSA";\n    }\n\n    var PS = \'\', i;\n\n    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)\n    {\n        PS += \'\\x00\';\n    }\n\n    var DB = rstr_sha1(\'\') + PS + \'\\x01\' + s;\n    var seed = new Array(SHA1_SIZE);\n    new SecureRandom().nextBytes(seed);\n    \n    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1)\n    {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);\n    var maskedSeed = [0];\n\n    for (i = 0; i < seed.length; i += 1)\n    {\n        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n    }\n\n    return new BigInteger(maskedSeed.concat(maskedDB));\n}\n\n// "empty" RSA key constructor\nfunction RSAKey() {\n  this.n = null;\n  this.e = 0;\n  this.d = null;\n  this.p = null;\n  this.q = null;\n  this.dmp1 = null;\n  this.dmq1 = null;\n  this.coeff = null;\n}\n\n// Set the public key fields N and e from hex strings\nfunction RSASetPublic(N,E) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n  }\n  else\n    alert("Invalid RSA public key");\n}\n\n// Perform raw public operation on "x": return x^e (mod n)\nfunction RSADoPublic(x) {\n  return x.modPowInt(this.e, this.n);\n}\n\n// Return the PKCS#1 RSA encryption of "text" as an even-length hex string\nfunction RSAEncrypt(text) {\n  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string\nfunction RSAEncryptOAEP(text, hash) {\n  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string\n//function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPublic = RSADoPublic;\n\n// public\nRSAKey.prototype.setPublic = RSASetPublic;\nRSAKey.prototype.encrypt = RSAEncrypt;\nRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n\n\nmodule.exports = RSAKey\n//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n\n},{"jsbn":166}],174:[function(require,module,exports){\n// Depends on jsbn.js and rng.js\nvar BigInteger = require(\'jsbn\')\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n\n// convert a (hex) string to a bignum object\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\nfunction linebrk(s,n) {\n  var ret = "";\n  var i = 0;\n  while(i + n < s.length) {\n    ret += s.substring(i,i+n) + "\\n";\n    i += n;\n  }\n  return ret + s.substring(i,s.length);\n}\n\nfunction byte2Hex(b) {\n  if(b < 0x10)\n    return "0" + b.toString(16);\n  else\n    return b.toString(16);\n}\n\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s,n) {\n  if(n < s.length + 11) { // TODO: fix for utf-8\n    alert("Message too long for RSA");\n    return null;\n  }\n  var ba = new Array();\n  var i = s.length - 1;\n  while(i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n    if(c < 128) { // encode using utf-8\n      ba[--n] = c;\n    }\n    else if((c > 127) && (c < 2048)) {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = (c >> 6) | 192;\n    }\n    else {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = ((c >> 6) & 63) | 128;\n      ba[--n] = (c >> 12) | 224;\n    }\n  }\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = new Array();\n  while(n > 2) { // random non-zero pad\n    x[0] = 0;\n    while(x[0] == 0) rng.nextBytes(x);\n    ba[--n] = x[0];\n  }\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\nfunction oaep_pad(s, n, hash)\n{\n    if (s.length + 2 * SHA1_SIZE + 2 > n)\n    {\n        throw "Message too long for RSA";\n    }\n\n    var PS = \'\', i;\n\n    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)\n    {\n        PS += \'\\x00\';\n    }\n\n    var DB = rstr_sha1(\'\') + PS + \'\\x01\' + s;\n    var seed = new Array(SHA1_SIZE);\n    new SecureRandom().nextBytes(seed);\n    \n    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1)\n    {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);\n    var maskedSeed = [0];\n\n    for (i = 0; i < seed.length; i += 1)\n    {\n        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n    }\n\n    return new BigInteger(maskedSeed.concat(maskedDB));\n}\n\n// "empty" RSA key constructor\nfunction RSAKey() {\n  this.n = null;\n  this.e = 0;\n  this.d = null;\n  this.p = null;\n  this.q = null;\n  this.dmp1 = null;\n  this.dmq1 = null;\n  this.coeff = null;\n}\n\n// Set the public key fields N and e from hex strings\nfunction RSASetPublic(N,E) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n  }\n  else\n    alert("Invalid RSA public key");\n}\n\n// Perform raw public operation on "x": return x^e (mod n)\nfunction RSADoPublic(x) {\n  return x.modPowInt(this.e, this.n);\n}\n\n// Return the PKCS#1 RSA encryption of "text" as an even-length hex string\nfunction RSAEncrypt(text) {\n  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string\nfunction RSAEncryptOAEP(text, hash) {\n  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string\n//function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPublic = RSADoPublic;\n\n// public\nRSAKey.prototype.setPublic = RSASetPublic;\nRSAKey.prototype.encrypt = RSAEncrypt;\nRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n\n\nmodule.exports = RSAKey\n//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n\n},{"jsbn":171}]},{},[1])\n;'],{type:"text/javascript"})));


io.outstandingFetches = [];
io.outstandingMakes = []
io.executeTangleCallback;
io.executeHashNameCallback;

io.localTangle = function(port, cb){
  io.worker.postMessage({command: "tangle", transport: "local"}, [port]);
  io.executeTangleCallback = cb
}

io.remoteTangle = function(opts, cb){
  console.log("remote tangle host: ", opts.host, " port: ", opts.port)
  io.worker.postMessage({command: "tangle", transport: "websocket", host: opts.host || location.host.split(":")[0], port: opts.port || 6565})
  io.executeTangleCallback = cb
}

io.telehashTangle = function(opts, cb){
  var ms = new MessageChannel()
  telehashTransport.start('wiki', function(hn, dos){
    console.log(hn, dos)
    hn.start(opts.hashname, "ndn", {js: 'incoming'}, function(err, packet, chan, cb){
      cb(true)
      if (packet.js == 'ndn'){
        console.log("packet type == ndn ", packet.body, typeof packet.body)
        var data = packet.body.toArrayBuffer()
        console.log(data)
        var buf = new Buffer(packet.body)
        console.log(buf)
        ms.port1.postMessage(buf.buffer)
      } else {

        console.log("got chan to server", chan.hashname, packet.body)
        ms.port1.onmessage = function(e){
          console.log(e)
          chan.send({js: "ndn", body: new Buffer(e.data)})
        }

      }

    })

    io.localTangle(ms.port2, cb)
  })
}

io.importPKI = function(cert, priPem, pubPem) {
  io.worker.postMessage({cert: cert, priPem: priPem, pubPem: pubPem})
}

io.getHashName = function(callback){
  executeHashNameCallback = callback
  io.worker.postMessage({command: "getHashName"})
}

io.fetch = function(req, whenGotten, whenNotGotten) {
  io.worker.postMessage({
    "command": "fetch",
    "uri": req.uri,
    "type": req.type,
    "version": req.version,
    "selectors": req.selectors
  });
  console.log(req.uri)
  io.outstandingFetches.push({uri: req.uri, whenGotten: whenGotten, whenNotGotten: whenNotGotten});
}

io.publish = function(opts){
  console.log('sending publish command')
  io.worker.postMessage({
    "command": "publish",
    "uri": opts.uri,
    "type": opts.type,
    "thing": opts.thing,
    "version": opts.version
  })
}

io.mirror = function(uri){
  io.worker.postMessage({
    "command": "mirror",
    "uri": uri
  })
}

io.makeEncodedData = function(uri, bytes, callback){
  io.outstandingMakes.push({id: bytes.toString(), callback: callback})
  io.worker.postMessage({command: "makeEncoded", uri: uri, bytes: bytes, id: bytes.toString()})
}

io.worker.onmessage = function (e) {
  if (e.data.responseTo == "fetch") {
    io.executeFetchCallback(e.data);
  } else if (e.data.responseTo == "publish") {
    io.executePublishCallback(e.data);
  } else if (e.data.responseTo == "makeEncoded") {
    io.executeEncodedDataCallback(e.data)
  } else if (e.data.responseTo == "getHashName") {
    io.executeHashNameCallback(e.data.hashName)
  } else if (e.data.responseTo == "tangle") {
    io.executeTangleCallback()
  }
}

io.executeEncodedDataCallback = function(data) {
  for (var i = 0; i < io.outstandingMakes.length; i++) {
    if (io.outstandingMakes[i].id == data.id){
      io.outstandingMakes[i].callback(data.encoded)
    }
  }

}

io.executeFetchCallback = function(response) {
  var mtch;
  console.log(response, io.outstandingFetches)
  for (var i = 0; i < io.outstandingFetches.length; i++){
    if (io.outstandingFetches[i].uri == response.uri) {
      console.log('matched outstanding fetch')
      mtch = io.outstandingFetches.splice(i,1)[0]
    }
  }
  console.log(mtch)
  if (response.success == true){
    mtch.whenGotten(mtch.uri, response.thing, response.firstCo);
  } else {
    mtch.whenNotGotten(mtch.uri);
  }

}

module.exports = io;

}).call(this,require("buffer").Buffer)
},{"buffer":1,"ndn-telehashTransport":139}],33:[function(require,module,exports){
var io = require('../../browser.js')
var ndn = require('ndn-lib')
var utils = require('ndn-utils')
var chanTrans = require('ndn-messageChannelTransport').transport
  , RegisteredPrefix = function RegisteredPrefix(prefix, closure) {  this.prefix = new ndn.Name(prefix);    this.closure = closure}
  , ms = new MessageChannel()
  , transport = new chanTrans(ms.port2)
  , face = new ndn.Face({host:1,port:1, getTransport: function(){return transport}})

face.transport.connect(face, function(){console.log('connected')})

function onInterest (prefix,interest,transport){
  console.log("got interest", prefix)
  var d = new ndn.Data(new ndn.Name(interest.name.toUri()), new ndn.SignedInfo(), "success")
  d.signedInfo.setFinalBlockID(new ndn.Name.Component([0x14]))
  d.signedInfo.setFields()
  var encoded = d.wireEncode()
  console.log("sending encoded", encoded)
  transport.send(encoded.buffer)
}

closure = new ndn.Face.CallbackClosure(null, null, onInterest, 'test', face.transport)
ndn.Face.registeredPrefixTable.push(new RegisteredPrefix('test', closure))


describe('Setup', function(){
  describe('should tangle', function(){
    it('with websocket', function(done) {
      function cb (){done()}
      io.remoteTangle({host: "rosewiki.org", port:9696}, cb)

    })
    
    it('with messageChannel', function(done){
      this.timeout(10000)
      function cb (){ done()}
      io.localTangle(ms.port1, cb)
    })
  })
})

describe('fetch', function(){
  it('should pipeline fetch 20 segments', function(done){
    function onData(data, transport, thing){
      console.log(data, transport, thing)
      done()
    }
    function onTimeout(){
      console.log('fail')
    }
    io.fetch({uri: "test/text/text/name", type: 'blob'}, onData, onTimeout)
  })
})


},{"../../browser.js":32,"ndn-lib":43,"ndn-messageChannelTransport":86,"ndn-utils":272}],34:[function(require,module,exports){
/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// asn1hex.js - Hexadecimal represented ASN.1 string library
//
// version: 1.1 (09-May-2012)
//
// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license/
//
// The above copyright and license notice shall be 
// included in all copies or substantial portions of the Software.
//
// Depends on:
//
var BigInteger = require('jsbn')
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}
// MEMO:
//   f('3082025b02...', 2) ... 82025b ... 3bytes
//   f('020100', 2) ... 01 ... 1byte
//   f('0203001...', 2) ... 03 ... 1byte
//   f('02818003...', 2) ... 8180 ... 2bytes
//   f('3080....0000', 2) ... 80 ... -1
//
//   Requirements:
//   - ASN.1 type octet length MUST be 1. 
//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)
//   - 

/**
 * @fileOverview
 * @name asn1hex-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.1
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * get byte length for ASN.1 L(length) bytes
 * @name getByteLengthOfL_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return byte length for ASN.1 L(length) bytes
 */
function _asnhex_getByteLengthOfL_AtObj(s, pos) {
  if (s.substring(pos + 2, pos + 3) != '8') return 1;
  var i = parseInt(s.substring(pos + 3, pos + 4));
  if (i == 0) return -1; 		// length octet '80' indefinite length
  if (0 < i && i < 10) return i + 1;	// including '8?' octet;
  return -2;				// malformed format
}


/**
 * get hexadecimal string for ASN.1 L(length) bytes
 * @name getHexOfL_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return {String} hexadecimal string for ASN.1 L(length) bytes
 */
function _asnhex_getHexOfL_AtObj(s, pos) {
  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);
  if (len < 1) return '';
  return s.substring(pos + 2, pos + 2 + len * 2);
}

//
//   getting ASN.1 length value at the position 'idx' of
//   hexa decimal string 's'.
//
//   f('3082025b02...', 0) ... 82025b ... ???
//   f('020100', 0) ... 01 ... 1
//   f('0203001...', 0) ... 03 ... 3
//   f('02818003...', 0) ... 8180 ... 128
/**
 * get integer value of ASN.1 length for ASN.1 data
 * @name getIntOfL_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return ASN.1 L(length) integer value
 */
function _asnhex_getIntOfL_AtObj(s, pos) {
  var hLength = _asnhex_getHexOfL_AtObj(s, pos);
  if (hLength == '') return -1;
  var bi;
  if (parseInt(hLength.substring(0, 1)) < 8) {
     bi = parseBigInt(hLength, 16);
  } else {
     bi = parseBigInt(hLength.substring(2), 16);
  }
  return bi.intValue();
}

/**
 * get ASN.1 value starting string position for ASN.1 object refered by index 'idx'.
 * @name getStartPosOfV_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 */
function _asnhex_getStartPosOfV_AtObj(s, pos) {
  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);
  if (l_len < 0) return l_len;
  return pos + (l_len + 1) * 2;
}

/**
 * get hexadecimal string of ASN.1 V(value)
 * @name getHexOfV_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return {String} hexadecimal string of ASN.1 value.
 */
function _asnhex_getHexOfV_AtObj(s, pos) {
  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);
  var len = _asnhex_getIntOfL_AtObj(s, pos);
  return s.substring(pos1, pos1 + len * 2);
}

/**
 * get hexadecimal string of ASN.1 TLV at
 * @name getHexOfTLV_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return {String} hexadecimal string of ASN.1 TLV.
 * @since 1.1
 */
function _asnhex_getHexOfTLV_AtObj(s, pos) {
  var hT = s.substr(pos, 2);
  var hL = _asnhex_getHexOfL_AtObj(s, pos);
  var hV = _asnhex_getHexOfV_AtObj(s, pos);
  return hT + hL + hV;
}

/**
 * get next sibling starting index for ASN.1 object string
 * @name getPosOfNextSibling_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return next sibling starting index for ASN.1 object string
 */
function _asnhex_getPosOfNextSibling_AtObj(s, pos) {
  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);
  var len = _asnhex_getIntOfL_AtObj(s, pos);
  return pos1 + len * 2;
}

/**
 * get array of indexes of child ASN.1 objects
 * @name getPosArrayOfChildren_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} start string index of ASN.1 object
 * @return {Array of Number} array of indexes for childen of ASN.1 objects
 */
function _asnhex_getPosArrayOfChildren_AtObj(h, pos) {
  var a = new Array();
  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);
  a.push(p0);

  var len = _asnhex_getIntOfL_AtObj(h, pos);
  var p = p0;
  var k = 0;
  while (1) {
    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);
    if (pNext == null || (pNext - p0  >= (len * 2))) break;
    if (k >= 200) break;

    a.push(pNext);
    p = pNext;

    k++;
  }

  return a;
}

/**
 * get string index of nth child object of ASN.1 object refered by h, idx
 * @name getNthChildIndex_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx start string index of ASN.1 object
 * @param {Number} nth for child
 * @return {Number} string index of nth child.
 * @since 1.1
 */
function _asnhex_getNthChildIndex_AtObj(h, idx, nth) {
  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);
  return a[nth];
}

// ========== decendant methods ==============================

/**
 * get string index of nth child object of ASN.1 object refered by h, idx
 * @name getDecendantIndexByNthList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @return {Number} string index refered by nthList
 * @since 1.1
 */
function _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {
  if (nthList.length == 0) {
    return currentIndex;
  }
  var firstNth = nthList.shift();
  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);
  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);
}

/**
 * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.
 * @name getDecendantHexTLVByNthList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList
 * @since 1.1
 */
function _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {
  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);
  return _asnhex_getHexOfTLV_AtObj(h, idx);
}

/**
 * get hexadecimal string of ASN.1 V refered by current index and nth index list.
 * @name getDecendantHexVByNthList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @return {Number} hexadecimal string of ASN.1 V refered by nthList
 * @since 1.1
 */
function _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {
  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);
  return _asnhex_getHexOfV_AtObj(h, idx);
}

// ========== class definition ==============================

/**
 * ASN.1 DER encoded hexadecimal string utility class
 * @class ASN.1 DER encoded hexadecimal string utility class
 * @author Kenji Urushima
 * @version 1.1 (09 May 2012)
 * @see <a href="http://kjur.github.com/jsrsasigns/">'jwrsasign'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>
 * @since 1.1
 */
function ASN1HEX() {
  return ASN1HEX;
}

ASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;
ASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;
ASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;
ASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;
ASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;
ASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;
ASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;
ASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;
ASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;
ASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;
ASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;
ASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;

module.exports = ASN1HEX;

},{"jsbn":85}],35:[function(require,module,exports){
var b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad="=";
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"
function int2char(n) { return BI_RM.charAt(n); }
function hex2b64(h) {
  var i;
  var c;
  var ret = "";
  for(i = 0; i+3 <= h.length; i+=3) {
    c = parseInt(h.substring(i,i+3),16);
    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
  }
  if(i+1 == h.length) {
    c = parseInt(h.substring(i,i+1),16);
    ret += b64map.charAt(c << 2);
  }
  else if(i+2 == h.length) {
    c = parseInt(h.substring(i,i+2),16);
    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
  }
  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;
  return ret;
}

// convert a base64 string to hex
function b64tohex(s) {
  var ret = ""
  var i;
  var k = 0; // b64 state, 0-3
  var slop;
  for(i = 0; i < s.length; ++i) {
    if(s.charAt(i) == b64pad) break;
    v = b64map.indexOf(s.charAt(i));
    if(v < 0) continue;
    if(k == 0) {
      ret += int2char(v >> 2);
      slop = v & 3;
      k = 1;
    }
    else if(k == 1) {
      ret += int2char((slop << 2) | (v >> 4));
      slop = v & 0xf;
      k = 2;
    }
    else if(k == 2) {
      ret += int2char(slop);
      ret += int2char(v >> 2);
      slop = v & 3;
      k = 3;
    }
    else {
      ret += int2char((slop << 2) | (v >> 4));
      ret += int2char(v & 0xf);
      k = 0;
    }
  }
  if(k == 1)
    ret += int2char(slop << 2);
  return ret;
}

// convert a base64 string to a byte/number array
function b64toBA(s) {
  //piggyback on b64tohex for now, optimize later
  var h = b64tohex(s);
  var i;
  var a = new Array();
  for(i = 0; 2*i < h.length; ++i) {
    a[i] = parseInt(h.substring(2*i,2*i+2),16);
  }
  return a;
}

module.exports = {b64tohex: b64tohex, b64toBA: b64toBA, hex2b64: hex2b64};

},{}],36:[function(require,module,exports){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

module.exports = CryptoJS

},{}],37:[function(require,module,exports){
/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
/*
 * crypto.js - Cryptographic Algorithm Provider class
 *
 * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * http://kjur.github.com/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name crypto-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.0.4 (2013-Mar-28)
 * @since 2.2
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */
var CryptoJS = require('./sha256.js')
var BigInteger = require('jsbn')
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

/** 
 * kjur's class library name space
 * @name KJUR
 * @namespace kjur's class library name space
 */
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
/**
 * kjur's cryptographic algorithm provider library name space
 * <p>
 * This namespace privides following crytpgrahic classes.
 * <ul>
 * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>
 * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>
 * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>
 * </ul>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * </p>
 * @name KJUR.crypto
 * @namespace
 */
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};

/**
 * static object for cryptographic function utilities
 * @name KJUR.crypto.Util
 * @class static object for cryptographic function utilities
 * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms
 * @description
 */
KJUR.crypto.Util = new function() {
    this.DIGESTINFOHEAD = {
	'sha1':      "3021300906052b0e03021a05000414",
        'sha224':    "302d300d06096086480165030402040500041c",
	'sha256':    "3031300d060960864801650304020105000420",
	'sha384':    "3041300d060960864801650304020205000430",
	'sha512':    "3051300d060960864801650304020305000440",
	'md2':       "3020300c06082a864886f70d020205000410",
	'md5':       "3020300c06082a864886f70d020505000410",
	'ripemd160': "3021300906052b2403020105000414"
    };

    /**
     * get hexadecimal DigestInfo
     * @name getDigestInfoHex
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} hHash hexadecimal hash value
     * @param {String} alg hash algorithm name (ex. 'sha1')
     * @return {String} hexadecimal string DigestInfo ASN.1 structure
     */
    this.getDigestInfoHex = function(hHash, alg) {
	if (typeof this.DIGESTINFOHEAD[alg] == "undefined")
	    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;
	return this.DIGESTINFOHEAD[alg] + hHash;
    };

    /**
     * get PKCS#1 padded hexadecimal DigestInfo
     * @name getPaddedDigestInfoHex
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} hHash hexadecimal hash value
     * @param {String} alg hash algorithm name (ex. 'sha1')
     * @param {Integer} keySize key bit length (ex. 1024)
     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo
     */
    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {
	var hDigestInfo = this.getDigestInfoHex(hHash, alg);
	var pmStrLen = keySize / 4; // minimum PM length

	if (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22
	    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;

	var hHead = "0001";
	var hTail = "00" + hDigestInfo;
	var hMid = "";
	var fLen = pmStrLen - hHead.length - hTail.length;
	for (var i = 0; i < fLen; i += 2) {
	    hMid += "ff";
	}
	var hPaddedMessage = hHead + hMid + hTail;
	return hPaddedMessage;
    };

    /**
     * get hexadecimal SHA1 hash of string
     * @name sha1
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha1 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'sha1', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal SHA256 hash of string
     * @name sha256
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha256 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'sha256', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal SHA512 hash of string
     * @name sha512
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha512 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'sha512', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal MD5 hash of string
     * @name md5
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.md5 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'md5', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal RIPEMD160 hash of string
     * @name ripemd160
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.ripemd160 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'ripemd160', 'prov':'cryptojs'});
        return md.digestString(s);
    };
};

/**
 * MessageDigest class which is very similar to java.security.MessageDigest class
 * @name KJUR.crypto.MessageDigest
 * @class MessageDigest class which is very similar to java.security.MessageDigest class
 * @param {Array} params parameters for constructor
 * @description
 * <br/>
 * Currently this supports following algorithm and providers combination:
 * <ul>
 * <li>md5 - cryptojs</li>
 * <li>sha1 - cryptojs</li>
 * <li>sha224 - cryptojs</li>
 * <li>sha256 - cryptojs</li>
 * <li>sha384 - cryptojs</li>
 * <li>sha512 - cryptojs</li>
 * <li>ripemd160 - cryptojs</li>
 * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>
 * </ul>
 * @example
 * // CryptoJS provider sample
 * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;
 * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;
 * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;
 * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});
 * md.updateString('aaa')
 * var mdHex = md.digest()
 *
 * // SJCL(Stanford JavaScript Crypto Library) provider sample
 * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;
 * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;
 * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only
 * md.updateString('aaa')
 * var mdHex = md.digest()
 */
KJUR.crypto.MessageDigest = function(params) {
    var md = null;
    var algName = null;
    var provName = null;
    var _CryptoJSMdName = {
	'md5': 'CryptoJS.algo.MD5',
	'sha1': 'CryptoJS.algo.SHA1',
	'sha224': 'CryptoJS.algo.SHA224',
	'sha256': 'CryptoJS.algo.SHA256',
	'sha384': 'CryptoJS.algo.SHA384',
	'sha512': 'CryptoJS.algo.SHA512',
	'ripemd160': 'CryptoJS.algo.RIPEMD160'
    };

    /**
     * set hash algorithm and provider
     * @name setAlgAndProvider
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} alg hash algorithm name
     * @param {String} prov provider name
     * @description
     * @example
     * // for SHA1
     * md.setAlgAndProvider('sha1', 'cryptojs');
     * // for RIPEMD160
     * md.setAlgAndProvider('ripemd160', 'cryptojs');
     */
    this.setAlgAndProvider = function(alg, prov) {
	if (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(alg) != -1 &&
	    prov == 'cryptojs') {
	    try {
		this.md = eval(_CryptoJSMdName[alg]).create();
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;
	    }
	    this.updateString = function(str) {
		this.md.update(str);
	    };
	    this.updateHex = function(hex) {
		var wHex = CryptoJS.enc.Hex.parse(hex);
		this.md.update(wHex);
	    };
	    this.digest = function() {
		var hash = this.md.finalize();
		return hash.toString(CryptoJS.enc.Hex);
	    };
	    this.digestString = function(str) {
		this.updateString(str);
		return this.digest();
	    };
	    this.digestHex = function(hex) {
		this.updateHex(hex);
		return this.digest();
	    };
	}
	if (':sha256:'.indexOf(alg) != -1 &&
	    prov == 'sjcl') {
	    try {
		this.md = new sjcl.hash.sha256();
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;
	    }
	    this.updateString = function(str) {
		this.md.update(str);
	    };
	    this.updateHex = function(hex) {
		var baHex = sjcl.codec.hex.toBits(hex);
		this.md.update(baHex);
	    };
	    this.digest = function() {
		var hash = this.md.finalize();
		return sjcl.codec.hex.fromBits(hash);
	    };
	    this.digestString = function(str) {
		this.updateString(str);
		return this.digest();
	    };
	    this.digestHex = function(hex) {
		this.updateHex(hex);
		return this.digest();
	    };
	}
    };

    /**
     * update digest by specified string
     * @name updateString
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} str string to update
     * @description
     * @example
     * md.updateString('New York');
     */
    this.updateString = function(str) {
	throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * update digest by specified hexadecimal string
     * @name updateHex
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} hex hexadecimal string to update
     * @description
     * @example
     * md.updateHex('0afe36');
     */
    this.updateHex = function(hex) {
	throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * completes hash calculation and returns hash result
     * @name digest
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @description
     * @example
     * md.digest()
     */
    this.digest = function() {
	throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * performs final update on the digest using string, then completes the digest computation
     * @name digestString
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} str string to final update
     * @description
     * @example
     * md.digestString('aaa')
     */
    this.digestString = function(str) {
	throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * performs final update on the digest using hexadecimal string, then completes the digest computation
     * @name digestHex
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} hex hexadecimal string to final update
     * @description
     * @example
     * md.digestHex('0f2abd')
     */
    this.digestHex = function(hex) {
	throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    if (typeof params != "undefined") {
	if (typeof params['alg'] != "undefined") {
	    this.algName = params['alg'];
	    this.provName = params['prov'];
	    this.setAlgAndProvider(params['alg'], params['prov']);
	}
    }
};


/**
 * Signature class which is very similar to java.security.Signature class
 * @name KJUR.crypto.Signature
 * @class Signature class which is very similar to java.security.Signature class
 * @param {Array} params parameters for constructor
 * @property {String} state Current state of this signature object whether 'SIGN', 'VERIFY' or null
 * @description
 * <br/>
 * As for params of constructor's argument, it can be specify following attributes:
 * <ul>
 * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>
 * <li>provider - currently 'cryptojs/jsrsa' only</li>
 * <li>prvkeypem - PEM string of signer's private key. If this specified, no need to call initSign(prvKey).</li>
 * </ul>
 * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>
 * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}
 * withRSA algorithm in 'cryptojs/jsrsa' provider.
 * <h4>EXAMPLES</h4>
 * @example
 * // signature generation
 * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});
 * sig.initSign(prvKey);
 * sig.updateString('aaa');
 * var hSigVal = sig.sign();
 *
 * // signature validation
 * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});
 * sig2.initVerifyByCertificatePEM(cert)
 * sig.updateString('aaa');
 * var isValid = sig2.verify(hSigVal);
 */
KJUR.crypto.Signature = function(params) {
    var prvKey = null; // RSAKey for signing
    var pubKey = null; // RSAKey for verifying

    var md = null; // KJUR.crypto.MessageDigest object
    var sig = null;
    var algName = null;
    var provName = null;
    var algProvName = null;
    var mdAlgName = null;
    var pubkeyAlgName = null;
    var state = null;

    var sHashHex = null; // hex hash value for hex
    var hDigestInfo = null;
    var hPaddedDigestInfo = null;
    var hSign = null;

    this._setAlgNames = function() {
	if (this.algName.match(/^(.+)with(.+)$/)) {
	    this.mdAlgName = RegExp.$1.toLowerCase();
	    this.pubkeyAlgName = RegExp.$2.toLowerCase();
	}
    };

    this._zeroPaddingOfSignature = function(hex, bitLength) {
	var s = "";
	var nZero = bitLength / 4 - hex.length;
	for (var i = 0; i < nZero; i++) {
	    s = s + "0";
	}
	return s + hex;
    };

    /**
     * set signature algorithm and provider
     * @name setAlgAndProvider
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} alg signature algorithm name
     * @param {String} prov provider name
     * @description
     * @example
     * md.setAlgAndProvider('SHA1withRSA', 'cryptojs/jsrsa');
     */
    this.setAlgAndProvider = function(alg, prov) {
	this._setAlgNames();
	if (prov != 'cryptojs/jsrsa')
	    throw "provider not supported: " + prov;

	if (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(this.mdAlgName) != -1) {
	    try {
		this.md = new KJUR.crypto.MessageDigest({'alg':this.mdAlgName,'prov':'cryptojs'});
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;
	    }

	    this.initSign = function(prvKey) {
		this.prvKey = prvKey;
		this.state = "SIGN";
	    };

	    this.initVerifyByPublicKey = function(rsaPubKey) {
		this.pubKey = rsaPubKey;
		this.state = "VERIFY";
	    };

	    this.initVerifyByCertificatePEM = function(certPEM) {
		var x509 = new X509();
		x509.readCertPEM(certPEM);
		this.pubKey = x509.subjectPublicKeyRSA;
		this.state = "VERIFY";
	    };

	    this.updateString = function(str) {
		this.md.updateString(str);
	    };
	    this.updateHex = function(hex) {
		this.md.updateHex(hex);
	    };
	    this.sign = function() {
                var util = KJUR.crypto.Util;
		var keyLen = this.prvKey.n.bitLength();
		this.sHashHex = this.md.digest();
		this.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);
		this.hPaddedDigestInfo = 
                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);

		var biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);
		this.hoge = biPaddedDigestInfo.toString(16);

		var biSign = this.prvKey.doPrivate(biPaddedDigestInfo);
		this.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);
		return this.hSign;
	    };
	    this.signString = function(str) {
		this.updateString(str);
		this.sign();
	    };
	    this.signHex = function(hex) {
		this.updateHex(hex);
		this.sign();
	    };
	    this.verify = function(hSigVal) {
                var util = KJUR.crypto.Util;
		var keyLen = this.pubKey.n.bitLength();
		this.sHashHex = this.md.digest();

		var biSigVal = parseBigInt(hSigVal, 16);
		var biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);
		this.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);
                var s = this.hPaddedDigestInfo;
                s = s.replace(/^1ff+00/, '');

		var hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];
                if (s.indexOf(hDIHEAD) != 0) {
		    return false;
		}
		var hHashFromDI = s.substr(hDIHEAD.length);
		//alert(hHashFromDI + "\n" + this.sHashHex);
		return (hHashFromDI == this.sHashHex);
	    };
	}
    };

    /**
     * Initialize this object for verifying with a public key
     * @name initVerifyByPublicKey
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {RSAKey} rsaPubKey RSAKey object of public key
     * @since 1.0.2
     * @description
     * @example
     * sig.initVerifyByPublicKey(prvKey)
     */
    this.initVerifyByPublicKey = function(rsaPubKey) {
	throw "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Initialize this object for verifying with a certficate
     * @name initVerifyByCertificatePEM
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} certPEM PEM formatted string of certificate
     * @since 1.0.2
     * @description
     * @example
     * sig.initVerifyByCertificatePEM(certPEM)
     */
    this.initVerifyByCertificatePEM = function(certPEM) {
	throw "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Initialize this object for signing
     * @name initSign
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {RSAKey} prvKey RSAKey object of private key
     * @description
     * @example
     * sig.initSign(prvKey)
     */
    this.initSign = function(prvKey) {
	throw "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Updates the data to be signed or verified by a string
     * @name updateString
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} str string to use for the update
     * @description
     * @example
     * sig.updateString('aaa')
     */
    this.updateString = function(str) {
	throw "updateString(str) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Updates the data to be signed or verified by a hexadecimal string
     * @name updateHex
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} hex hexadecimal string to use for the update
     * @description
     * @example
     * sig.updateHex('1f2f3f')
     */
    this.updateHex = function(hex) {
	throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Returns the signature bytes of all data updates as a hexadecimal string
     * @name sign
     * @memberOf KJUR.crypto.Signature
     * @function
     * @return the signature bytes as a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.sign()
     */
    this.sign = function() {
	throw "sign() not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string
     * @name signString
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} str string to final update
     * @return the signature bytes of a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.signString('aaa')
     */
    this.signString = function(str) {
	throw "digestString(str) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string
     * @name signHex
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} hex hexadecimal string to final update
     * @return the signature bytes of a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.signHex('1fdc33')
     */
    this.signHex = function(hex) {
	throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * verifies the passed-in signature.
     * @name verify
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} str string to final update
     * @return {Boolean} true if the signature was verified, otherwise false
     * @description
     * @example
     * var isValid = sig.verify('1fbcefdca4823a7(snip)')
     */
    this.verify = function(hSigVal) {
	throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;
    };

    if (typeof params != "undefined") {
	if (typeof params['alg'] != "undefined") {
	    this.algName = params['alg'];
	    this.provName = params['prov'];
	    this.algProvName = params['alg'] + ":" + params['prov'];
	    this.setAlgAndProvider(params['alg'], params['prov']);
	    this._setAlgNames();
	}
	if (typeof params['prvkeypem'] != "undefined") {
	    if (typeof params['prvkeypas'] != "undefined") {
		throw "both prvkeypem and prvkeypas parameters not supported";
	    } else {
		try {
		    var prvKey = new RSAKey();
		    prvKey.readPrivateKeyFromPEMString(params['prvkeypem']);
		    this.initSign(prvKey);
		} catch (ex) {
		    throw "fatal error to load pem private key: " + ex;
		}
	    }
	}
    }
};
module.exports = KJUR

},{"./sha256.js":42,"jsbn":85}],38:[function(require,module,exports){
// Depends on jsbn.js and rng.js
var BigInteger = require('jsbn')
// Version 1.1: support utf-8 encoding in pkcs1pad2

// convert a (hex) string to a bignum object
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

function linebrk(s,n) {
  var ret = "";
  var i = 0;
  while(i + n < s.length) {
    ret += s.substring(i,i+n) + "\n";
    i += n;
  }
  return ret + s.substring(i,s.length);
}

function byte2Hex(b) {
  if(b < 0x10)
    return "0" + b.toString(16);
  else
    return b.toString(16);
}

// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s,n) {
  if(n < s.length + 11) { // TODO: fix for utf-8
    alert("Message too long for RSA");
    return null;
  }
  var ba = new Array();
  var i = s.length - 1;
  while(i >= 0 && n > 0) {
    var c = s.charCodeAt(i--);
    if(c < 128) { // encode using utf-8
      ba[--n] = c;
    }
    else if((c > 127) && (c < 2048)) {
      ba[--n] = (c & 63) | 128;
      ba[--n] = (c >> 6) | 192;
    }
    else {
      ba[--n] = (c & 63) | 128;
      ba[--n] = ((c >> 6) & 63) | 128;
      ba[--n] = (c >> 12) | 224;
    }
  }
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n > 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}

// PKCS#1 (OAEP) mask generation function
function oaep_mgf1_arr(seed, len, hash)
{
    var mask = '', i = 0;

    while (mask.length < len)
    {
        mask += hash(String.fromCharCode.apply(String, seed.concat([
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff])));
        i += 1;
    }

    return mask;
}

var SHA1_SIZE = 20;

// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint
function oaep_pad(s, n, hash)
{
    if (s.length + 2 * SHA1_SIZE + 2 > n)
    {
        throw "Message too long for RSA";
    }

    var PS = '', i;

    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)
    {
        PS += '\x00';
    }

    var DB = rstr_sha1('') + PS + '\x01' + s;
    var seed = new Array(SHA1_SIZE);
    new SecureRandom().nextBytes(seed);
    
    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);
    var maskedDB = [];

    for (i = 0; i < DB.length; i += 1)
    {
        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);
    var maskedSeed = [0];

    for (i = 0; i < seed.length; i += 1)
    {
        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);
    }

    return new BigInteger(maskedSeed.concat(maskedDB));
}

// "empty" RSA key constructor
function RSAKey() {
  this.n = null;
  this.e = 0;
  this.d = null;
  this.p = null;
  this.q = null;
  this.dmp1 = null;
  this.dmq1 = null;
  this.coeff = null;
}

// Set the public key fields N and e from hex strings
function RSASetPublic(N,E) {
  if (typeof N !== "string")
  {
    this.n = N;
    this.e = E;
  }
  else if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
  }
  else
    alert("Invalid RSA public key");
}

// Perform raw public operation on "x": return x^e (mod n)
function RSADoPublic(x) {
  return x.modPowInt(this.e, this.n);
}

// Return the PKCS#1 RSA encryption of "text" as an even-length hex string
function RSAEncrypt(text) {
  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string
function RSAEncryptOAEP(text, hash) {
  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
//function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
//}

// protected
RSAKey.prototype.doPublic = RSADoPublic;

// public
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
RSAKey.prototype.encryptOAEP = RSAEncryptOAEP;


module.exports = RSAKey
//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

},{"jsbn":85}],39:[function(require,module,exports){
// Depends on rsa.js and jsbn2.js
var BigInteger = require('jsbn')
var RSAKey = require('./rsa.js')
// Version 1.1: support utf-8 decoding in pkcs1unpad2
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d,n) {
  var b = d.toByteArray();
  var i = 0;
  while(i < b.length && b[i] == 0) ++i;
  if(b.length-i != n-1 || b[i] != 2)
    return null;
  ++i;
  while(b[i] != 0)
    if(++i >= b.length) return null;
  var ret = "";
  while(++i < b.length) {
    var c = b[i] & 255;
    if(c < 128) { // utf-8 decode
      ret += String.fromCharCode(c);
    }
    else if((c > 191) && (c < 224)) {
      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));
      ++i;
    }
    else {
      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));
      i += 2;
    }
  }
  return ret;
}

// PKCS#1 (OAEP) mask generation function
function oaep_mgf1_str(seed, len, hash)
{
    var mask = '', i = 0;

    while (mask.length < len)
    {
        mask += hash(seed + String.fromCharCode.apply(String, [
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff]));
        i += 1;
    }

    return mask;
}

var SHA1_SIZE = 20;

// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext
function oaep_unpad(d, n, hash)
{
    d = d.toByteArray();

    var i;

    for (i = 0; i < d.length; i += 1)
    {
        d[i] &= 0xff;
    }

    while (d.length < n)
    {
        d.unshift(0);
    }

    d = String.fromCharCode.apply(String, d);

    if (d.length < 2 * SHA1_SIZE + 2)
    {
        throw "Cipher too short";
    }

    var maskedSeed = d.substr(1, SHA1_SIZE)
    var maskedDB = d.substr(SHA1_SIZE + 1);

    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);
    var seed = [], i;

    for (i = 0; i < maskedSeed.length; i += 1)
    {
        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);
    }

    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),
                           d.length - SHA1_SIZE, rstr_sha1);

    var DB = [];

    for (i = 0; i < maskedDB.length; i += 1)
    {
        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    DB = String.fromCharCode.apply(String, DB);

    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(''))
    {
        throw "Hash mismatch";
    }

    DB = DB.substr(SHA1_SIZE);

    var first_one = DB.indexOf('\x01');
    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf('\x00') : -1;

    if (last_zero + 1 != first_one)
    {
        throw "Malformed data";
    }

    return DB.substr(first_one + 1);
}

// Set the private key fields N, e, and d from hex strings
function RSASetPrivate(N,E,D) {
  if (typeof N !== "string")
  {
    this.n = N;
    this.e = E;
    this.d = D;
  }
  else if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
  }
  else
    alert("Invalid RSA private key");
}

// Set the private key fields N, e, d and CRT params from hex strings
function RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {
  //alert("RSASetPrivateEx called");
  if (N == null) throw "RSASetPrivateEx N == null";
  if (E == null) throw "RSASetPrivateEx E == null";
  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";
  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";

  if (N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
    this.p = parseBigInt(P,16);
    this.q = parseBigInt(Q,16);
    this.dmp1 = parseBigInt(DP,16);
    this.dmq1 = parseBigInt(DQ,16);
    this.coeff = parseBigInt(C,16);
  } else {
    alert("Invalid RSA private key in RSASetPrivateEx");
  }
}

// Generate a new random private key B bits long, using public expt E
function RSAGenerate(B,E) {
  var rng = new SecureRandom();
  var qs = B>>1;
  this.e = parseInt(E,16);
  var ee = new BigInteger(E,16);
  for(;;) {
    for(;;) {
      this.p = new BigInteger(B-qs,1,rng);
      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;
    }
    for(;;) {
      this.q = new BigInteger(qs,1,rng);
      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;
    }
    if(this.p.compareTo(this.q) <= 0) {
      var t = this.p;
      this.p = this.q;
      this.q = t;
    }
    var p1 = this.p.subtract(BigInteger.ONE);	// p1 = p - 1
    var q1 = this.q.subtract(BigInteger.ONE);	// q1 = q - 1
    var phi = p1.multiply(q1);
    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
      this.n = this.p.multiply(this.q);	// this.n = p * q
      this.d = ee.modInverse(phi);	// this.d = 
      this.dmp1 = this.d.mod(p1);	// this.dmp1 = d mod (p - 1)
      this.dmq1 = this.d.mod(q1);	// this.dmq1 = d mod (q - 1)
      this.coeff = this.q.modInverse(this.p);	// this.coeff = (q ^ -1) mod p
      break;
    }
  }
}

// Perform raw private operation on "x": return x^d (mod n)
function RSADoPrivate(x) {
  if(this.p == null || this.q == null)
    return x.modPow(this.d, this.n);

  // TODO: re-calculate any missing CRT params
  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?
  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?

  while(xp.compareTo(xq) < 0)
    xp = xp.add(this.p);
  // NOTE:
  // xp.subtract(xq) => cp -cq
  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h
  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M
  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecrypt(ctext) {
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);
}

// Return the PKCS#1 OAEP RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecryptOAEP(ctext, hash) {
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is a Base64-encoded string and the output is a plain string.
//function RSAB64Decrypt(ctext) {
//  var h = b64tohex(ctext);
//  if(h) return this.decrypt(h); else return null;
//}

// protected
RSAKey.prototype.doPrivate = RSADoPrivate;

// public
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;
RSAKey.prototype.decryptOAEP = RSADecryptOAEP;
//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;

module.exports = RSAKey

},{"./rsa.js":38,"jsbn":85}],40:[function(require,module,exports){
/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key
//              to RSAKey class.
//
// version: 1.1.1 (2013-Apr-12)
//
// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license/
//
// The above copyright and license notice shall be 
// included in all copies or substantial portions of the Software.
// 
//
// Depends on:
//
//
//
// _RSApem_pemToBase64(sPEM)
//
//   removing PEM header, PEM footer and space characters including
//   new lines from PEM formatted RSA private key string.
//
var ASN1HEX = require('./asn1hex-1.1.js')
var b64tohex = require('./base64.js').b64tohex
var RSAKey = require('./rsa2.js')
/**
 * @fileOverview
 * @name rsapem-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.1
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */
function _rsapem_pemToBase64(sPEMPrivateKey) {
  var s = sPEMPrivateKey;
  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");
  s = s.replace("-----END RSA PRIVATE KEY-----", "");
  s = s.replace(/[ \n]+/g, "");
  return s;
}

function _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {
  var a = new Array();
  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);
  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);
  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);
  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);
  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);
  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);
  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);
  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);
  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);
  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);
  return a;
}

function _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {
  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);
  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);
  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);
  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);
  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);
  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);
  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);
  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);
  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);
  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);
  var a = new Array();
  a.push(v, n, e, d, p, q, dp, dq, co);
  return a;
}

/**
 * read RSA private key from a ASN.1 hexadecimal string
 * @name readPrivateKeyFromASN1HexString
 * @memberOf RSAKey#
 * @function
 * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.
 * @since 1.1.1
 */
function _rsapem_readPrivateKeyFromASN1HexString(keyHex) {
  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);
  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
}

/**
 * read PKCS#1 private key from a string
 * @name readPrivateKeyFromPEMString
 * @memberOf RSAKey#
 * @function
 * @param {String} keyPEM string of PKCS#1 private key.
 */
function _rsapem_readPrivateKeyFromPEMString(keyPEM) {
  var keyB64 = _rsapem_pemToBase64(keyPEM);
  var keyHex = b64tohex(keyB64) // depends base64.js
  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);
  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
}

RSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;
RSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;

module.exports = RSAKey

},{"./asn1hex-1.1.js":34,"./base64.js":35,"./rsa2.js":39}],41:[function(require,module,exports){
/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// rsa-sign.js - adding signing functions to RSAKey class.
//
//
// version: 1.2.2 (13 May 2013)
//
// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license/
//
// The above copyright and license notice shall be 
// included in all copies or substantial portions of the Software.

//
// Depends on:
//   function sha1.hex(s) of sha1.js
//   jsbn.js
//   jsbn2.js
//   rsa.js
//   rsa2.js
//
var BigInteger = require('jsbn')
var RSAKey= require('./rsapem-1.1.js')
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

// keysize / pmstrlen
//  512 /  128
// 1024 /  256
// 2048 /  512
// 4096 / 1024

/**
 * @fileOverview
 * @name rsasign-1.2.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.2.2
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * @property {Dictionary} _RSASIGN_DIHEAD
 * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.
 * You can add any DigestInfo hash algorith for signing.
 * See PKCS#1 v2.1 spec (p38).
 */
var _RSASIGN_DIHEAD = [];
_RSASIGN_DIHEAD['sha1'] =      "3021300906052b0e03021a05000414";
_RSASIGN_DIHEAD['sha256'] =    "3031300d060960864801650304020105000420";
_RSASIGN_DIHEAD['sha384'] =    "3041300d060960864801650304020205000430";
_RSASIGN_DIHEAD['sha512'] =    "3051300d060960864801650304020305000440";
_RSASIGN_DIHEAD['md2'] =       "3020300c06082a864886f70d020205000410";
_RSASIGN_DIHEAD['md5'] =       "3020300c06082a864886f70d020505000410";
_RSASIGN_DIHEAD['ripemd160'] = "3021300906052b2403020105000414";

/**
 * @property {Dictionary} _RSASIGN_HASHHEXFUNC
 * @description Array of functions which calculate hash and returns it as hexadecimal.
 * You can add any hash algorithm implementations.
 */
var _RSASIGN_HASHHEXFUNC = [];
_RSASIGN_HASHHEXFUNC['sha1'] =      function(s){return KJUR.crypto.Util.sha1(s);};
_RSASIGN_HASHHEXFUNC['sha256'] =    function(s){return KJUR.crypto.Util.sha256(s);}
_RSASIGN_HASHHEXFUNC['sha512'] =    function(s){return KJUR.crypto.Util.sha512(s);}
_RSASIGN_HASHHEXFUNC['md5'] =       function(s){return KJUR.crypto.Util.md5(s);};
_RSASIGN_HASHHEXFUNC['ripemd160'] = function(s){return KJUR.crypto.Util.ripemd160(s);};

//_RSASIGN_HASHHEXFUNC['sha1'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html
//_RSASIGN_HASHHEXFUNC['sha256'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html

var _RE_HEXDECONLY = new RegExp("");
_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");

// ========================================================================
// Signature Generation
// ========================================================================

function _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {
    var pmStrLen = keySize / 4;
    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];
    var sHashHex = hashFunc(s);

    var sHead = "0001";
    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;
    var sMid = "";
    var fLen = pmStrLen - sHead.length - sTail.length;
    for (var i = 0; i < fLen; i += 2) {
	sMid += "ff";
    }
    sPaddedMessageHex = sHead + sMid + sTail;
    return sPaddedMessageHex;
}

function _zeroPaddingOfSignature(hex, bitLength) {
    var s = "";
    var nZero = bitLength / 4 - hex.length;
    for (var i = 0; i < nZero; i++) {
	s = s + "0";
    }
    return s + hex;
}

/**
 * sign for a message string with RSA private key.<br/>
 * @name signString
 * @memberOf RSAKey#
 * @function
 * @param {String} s message string to be signed.
 * @param {String} hashAlg hash algorithm name for signing.<br/>
 * @return returns hexadecimal string of signature value.
 */
function _rsasign_signString(s, hashAlg) {
    //alert("this.n.bitLength() = " + this.n.bitLength());
    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);
    var biPaddedMessage = parseBigInt(hPM, 16);
    var biSign = this.doPrivate(biPaddedMessage);
    var hexSign = biSign.toString(16);
    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());
}

function _rsasign_signStringWithSHA1(s) {
    return _rsasign_signString.call(this, s, 'sha1');
}

function _rsasign_signStringWithSHA256(s) {
    return _rsasign_signString.call(this, s, 'sha256');
}

// PKCS#1 (PSS) mask generation function
function pss_mgf1_str(seed, len, hash) {
    var mask = '', i = 0;

    while (mask.length < len) {
        mask += hash(seed + String.fromCharCode.apply(String, [
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff]));
        i += 1;
    }

    return mask;
}

/**
 * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>
 * @name signStringPSS
 * @memberOf RSAKey#
 * @function
 * @param {String} s message string to be signed.
 * @param {String} hashAlg hash algorithm name for signing.<br/>
 * @return returns hexadecimal string of signature value.
 */
function _rsasign_signStringPSS(s, hashAlg, sLen) {
    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];
    var mHash = hashFunc(s);
    var hLen = mHash.length;
    var emBits = this.n.bitLength() - 1;
    var emLen = Math.ceil(emBits / 8);
    var i;

    if (sLen === -1) {
        sLen = hLen; // same has hash length
    } else if ((sLen === -2) || (sLen === undefined)) {
        sLen = emLen - hLen - 2; // maximum
    } else if (sLen < -2) {
        throw "invalid salt length";
    }

    if (emLen < (hLen + sLen + 2)) {
        throw "data too long";
    }

    var salt = '';

    if (sLen > 0) {
        salt = new Array(sLen);
        new SecureRandom().nextBytes(salt);
        salt = String.fromCharCode.apply(String, salt);
    }

    var H = hashFunc('\x00\x00\x00\x00\x00\x00\x00\x00' + mHash + salt);
    var PS = [];

    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {
        PS[i] = 0x00;
    }

    var DB = String.fromCharCode.apply(String, PS) + '\x01' + salt;
    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);
    var maskedDB = [];

    for (i = 0; i < DB.length; i += 1) {
        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;
    maskedDB[0] &= ~mask;

    for (i = 0; i < hLen; i++) {
        maskedDB.push(H.charCodeAt(i));
    }

    maskedDB.push(0xbc);

    return _zeroPaddingOfSignature(
            this.doPrivate(new BigInteger(maskedDB)).toString(16),
            this.n.bitLength());
}

// ========================================================================
// Signature Verification
// ========================================================================

function _rsasign_getDecryptSignatureBI(biSig, hN, hE) {
    var rsa = new RSAKey();
    rsa.setPublic(hN, hE);
    var biDecryptedSig = rsa.doPublic(biSig);
    return biDecryptedSig;
}

function _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {
    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);
    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');
    return hDigestInfo;
}

function _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {
    for (var algName in _RSASIGN_DIHEAD) {
	var head = _RSASIGN_DIHEAD[algName];
	var len = head.length;
	if (hDigestInfo.substring(0, len) == head) {
	    var a = [algName, hDigestInfo.substring(len)];
	    return a;
	}
    }
    return [];
}

function _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {
    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);
    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);
    if (digestInfoAry.length == 0) return false;
    var algName = digestInfoAry[0];
    var diHashValue = digestInfoAry[1];
    var ff = _RSASIGN_HASHHEXFUNC[algName];
    var msgHashValue = ff(sMsg);
    return (diHashValue == msgHashValue);
}

function _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {
    var biSig = parseBigInt(hSig, 16);
    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,
						  this.n.toString(16),
						  this.e.toString(16));
    return result;
}

/**
 * verifies a sigature for a message string with RSA public key.<br/>
 * @name verifyString
 * @memberOf RSAKey#
 * @function
 * @param {String} sMsg message string to be verified.
 * @param {String} hSig hexadecimal string of siganture.<br/>
 *                 non-hexadecimal charactors including new lines will be ignored.
 * @return returns 1 if valid, otherwise 0
 */
function _rsasign_verifyString(sMsg, hSig) {
    hSig = hSig.replace(_RE_HEXDECONLY, '');
    if (hSig.length != this.n.bitLength() / 4) return 0;
    hSig = hSig.replace(/[ \n]+/g, "");
    var biSig = parseBigInt(hSig, 16);
    var biDecryptedSig = this.doPublic(biSig);
    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');
    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);
  
    if (digestInfoAry.length == 0) return false;
    var algName = digestInfoAry[0];
    var diHashValue = digestInfoAry[1];
    var ff = _RSASIGN_HASHHEXFUNC[algName];
    var msgHashValue = ff(sMsg);
    return (diHashValue == msgHashValue);
}

/**
 * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>
 * @name verifyStringPSS
 * @memberOf RSAKey#
 * @function
 * @param {String} sMsg message string to be verified.
 * @param {String} hSig hexadecimal string of siganture.<br/>
 *                 non-hexadecimal charactors including new lines will be ignored.
 * @return returns 1 if valid, otherwise 0
 */
function _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {
    if (hSig.length !== this.n.bitLength() / 4) {
        return false;
    }

    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];
    var mHash = hashFunc(sMsg);
    var hLen = mHash.length;
    var emBits = this.n.bitLength() - 1;
    var emLen = Math.ceil(emBits / 8);
    var i;

    if (sLen === -1) {
        sLen = hLen; // same has hash length
    } else if ((sLen === -2) || (sLen === undefined)) {
        sLen = emLen - hLen - 2; // maximum
    } else if (sLen < -2) {
        throw "invalid salt length";
    }

    if (emLen < (hLen + sLen + 2)) {
        throw "data too long";
    }

    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();

    for (i = 0; i < em.length; i += 1) {
        em[i] &= 0xff;
    }

    while (em.length < emLen) {
        em.unshift(0);
    }

    if (em[emLen -1] !== 0xbc) {
        throw "encoded message does not end in 0xbc";
    }

    em = String.fromCharCode.apply(String, em);

    var maskedDB = em.substr(0, emLen - hLen - 1);
    var H = em.substr(maskedDB.length, hLen);

    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;

    if ((maskedDB.charCodeAt(0) & mask) !== 0) {
        throw "bits beyond keysize not zero";
    }

    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);
    var DB = [];

    for (i = 0; i < maskedDB.length; i += 1) {
        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    DB[0] &= ~mask;

    var checkLen = emLen - hLen - sLen - 2;

    for (i = 0; i < checkLen; i += 1) {
        if (DB[i] !== 0x00) {
            throw "leftmost octets not zero";
        }
    }

    if (DB[checkLen] !== 0x01) {
        throw "0x01 marker not found";
    }

    return H === hashFunc('\x00\x00\x00\x00\x00\x00\x00\x00' + mHash +
                          String.fromCharCode.apply(String, DB.slice(-sLen)));
}

RSAKey.prototype.signString = _rsasign_signString;
RSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;
RSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;
RSAKey.prototype.sign = _rsasign_signString;
RSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;
RSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;
RSAKey.prototype.signStringPSS = _rsasign_signStringPSS;
RSAKey.prototype.signPSS = _rsasign_signStringPSS;
RSAKey.SALT_LEN_HLEN = -1;
RSAKey.SALT_LEN_MAX = -2;

RSAKey.prototype.verifyString = _rsasign_verifyString;
RSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;
RSAKey.prototype.verify = _rsasign_verifyString;
RSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;
RSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;
RSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;
RSAKey.SALT_LEN_RECOVER = -2;

/**
 * @name RSAKey
 * @class key of RSA public key algorithm
 * @description Tom Wu's RSA Key class and extension
 */

module.exports = RSAKey

},{"./rsapem-1.1.js":40,"jsbn":85}],42:[function(require,module,exports){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
    // Shortcuts
    var C = require('./core.js');
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Initialization and round constants tables
    var H = [];
    var K = [];

    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }

            return true;
        }

        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }

        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                nPrime++;
            }

            n++;
        }
    }());

    // Reusable object
    var W = [];

    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = C_algo.SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];

            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var gamma0x = W[i - 15];
                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                   (gamma0x >>> 3);

                    var gamma1x = W[i - 2];
                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                   (gamma1x >>> 10);

                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }

                var ch  = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);

                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;

                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA256(message, key);
     */
    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);

module.exports = C

},{"./core.js":36}],43:[function(require,module,exports){
exports.Face = require('./js/face.js').Face;
exports.NDN = require('./js/face.js').NDN; // deprecated
exports.Closure = require('./js/closure.js').Closure;
exports.Name = require('./js/name.js').Name;
exports.ForwardingFlags = require('./js/forwarding-flags.js').ForwardingFlags;
exports.Interest = require('./js/interest.js').Interest;
exports.Exclude = require('./js/exclude.js').Exclude;
exports.Data = require('./js/data.js').Data;
exports.ContentObject = require('./js/data.js').ContentObject; // deprecated
exports.ContentType = require('./js/meta-info.js').ContentType;
exports.MetaInfo = require('./js/meta-info.js').MetaInfo;
exports.SignedInfo = require('./js/meta-info.js').SignedInfo; // deprecated
exports.Key = require('./js/key.js').Key;
exports.KeyLocator = require('./js/key-locator.js').KeyLocator;
exports.KeyName = require('./js/key-locator.js').KeyName;
exports.KeyLocatorType = require('./js/key-locator.js').KeyLocatorType;
exports.PublisherPublicKeyDigest = require('./js/publisher-public-key-digest.js').PublisherPublicKeyDigest;
exports.WireFormat = require('./js/encoding/wire-format.js').WireFormat;
exports.BinaryXmlWireFormat = require('./js/encoding/binary-xml-wire-format.js').BinaryXmlWireFormat;
exports.TlvWireFormat = require('./js/encoding/tlv-wire-format.js').TlvWireFormat;
exports.TlvDecoder = require('./js/encoding/tlv/tlv-decoder.js').TlvDecoder;
exports.Tlv = require('./js/encoding/tlv/tlv.js').Tlv
exports.DataUtils = require('./js/encoding/data-utils.js').DataUtils;
exports.EncodingUtils = require('./js/encoding/encoding-utils.js').EncodingUtils;
exports.Blob = require('./js/util/blob.js').Blob;
exports.NameEnumeration = require('./js/util/name-enumeration.js').NameEnumeration;
exports.NDNTime = require('./js/util/ndn-time.js').NDNTime;
exports.globalKeyManager = require('./js/security/key-manager.js').globalKeyManager;
exports.ElementReader = require('./js/encoding/element-reader.js').ElementReader;
exports.customBuffer = require('./js/browserify.js').Buffer

},{"./js/browserify.js":45,"./js/closure.js":46,"./js/data.js":47,"./js/encoding/binary-xml-wire-format.js":51,"./js/encoding/data-utils.js":52,"./js/encoding/element-reader.js":54,"./js/encoding/encoding-utils.js":55,"./js/encoding/tlv-wire-format.js":57,"./js/encoding/tlv/tlv-decoder.js":58,"./js/encoding/tlv/tlv.js":61,"./js/encoding/wire-format.js":62,"./js/exclude.js":63,"./js/face.js":65,"./js/forwarding-flags.js":67,"./js/interest.js":68,"./js/key-locator.js":69,"./js/key.js":70,"./js/meta-info.js":72,"./js/name.js":73,"./js/publisher-public-key-digest.js":75,"./js/security/key-manager.js":76,"./js/util/blob.js":79,"./js/util/name-enumeration.js":81,"./js/util/ndn-time.js":83}],44:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.
exports.TcpTransport = require('./transport/web-socket-transport.js').WebSocketTransport;

},{"./transport/web-socket-transport.js":78}],45:[function(require,module,exports){
/** 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Wentao Shang
 * See COPYING for copyright and distribution information.
 */

// Library namespace
var ndn = ndn || {};

var exports = ndn;

var ASN1HEX = require('../contrib/securityLib/asn1hex-1.1.js')
var KJUR = require('../contrib/securityLib/crypto-1.0.js')
var RSAKey = require('../contrib/securityLib/rsasign-1.2.js')
var b64tohex = require('../contrib/securityLib/base64.js').b64tohex
// Factory method to create node.js compatible buffer objects
var customBuf = function customBuf(data, format) 
{
  var obj;

  if (typeof data == 'number')
    obj = new Uint8Array(data);
  else if (typeof data == 'string') {
    if (format == null || format == 'utf8') {
      var utf8 = customBuf.str2rstr_utf8(data);
      obj = new Uint8Array(utf8.length);
      for (var i = 0; i < utf8.length; i++)
        obj[i] = utf8.charCodeAt(i);
    } 
    else if (format == 'binary') {
      obj = new Uint8Array(data.length);
      for (var i = 0; i < data.length; i++)
        obj[i] = data.charCodeAt(i);
    } 
    else if (format == 'hex') {
      obj = new Uint8Array(Math.floor(data.length / 2));
      var i = 0;
      data.replace(/(..)/g, function(ss) {
        obj[i++] = parseInt(ss, 16);
      });
    } 
    else if (format == 'base64') {
      var hex = b64tohex(data);
      obj = new Uint8Array(Math.floor(hex.length / 2));
      var i = 0;
      hex.replace(/(..)/g, function(ss) {
        obj[i++] = parseInt(ss, 16);
      });
    } 
    else 
      throw new Error('Buffer: unknown encoding format ' + format);
  } 
  else if (typeof data == 'object' && (data instanceof Uint8Array || data instanceof customBuf)) {
    // The second argument is a boolean for "copy", default true.
    if (format == false)
      obj = data.subarray(0);
    else
      obj = new Uint8Array(data);
  }
  else if (typeof data == 'object' && data instanceof ArrayBuffer)
    // Copy.
    obj = new Uint8Array(data);
  else if (typeof data == 'object')
    // Assume component is a byte array.  We can't check instanceof Array because
    //   this doesn't work in JavaScript if the array comes from a different module.
    obj = new Uint8Array(data);
  else
    throw new Error('Buffer: unknown data type.');

  try {
    obj.__proto__ = customBuf.prototype;
  } catch(ex) {
    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);
  }

  obj.__proto__.toString = function(encoding) {
    if (encoding == null || encoding == 'binary') {
      var ret = "";
      for (var i = 0; i < this.length; i++)
        ret += String.fromCharCode(this[i]);
      return ret;
    }

    var ret = "";
    for (var i = 0; i < this.length; i++)
      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);

    if (encoding == 'hex')
      return ret;
    else if (encoding == 'base64')
      return hex2b64(ret);
    else
      throw new Error('Buffer.toString: unknown encoding format ' + encoding);
  };

  obj.__proto__.slice = function(begin, end) {
    if (end !== undefined)
      return new customBuf(this.subarray(begin, end), false);
    else
      return new customBuf(this.subarray(begin), false);
  };

  obj.__proto__.copy = function(target, targetStart) {
    if (targetStart !== undefined)
      target.set(this, targetStart);
    else
      target.set(this);
  };

  return obj;
};

customBuf.prototype = Uint8Array.prototype;

customBuf.concat = function(arrays) 
{
  var totalLength = 0;
  for (var i = 0; i < arrays.length; ++i)
    totalLength += arrays[i].length;
    
  var result = new customBuf(totalLength);
  var offset = 0;
  for (var i = 0; i < arrays.length; ++i) {
    result.set(arrays[i], offset);
    offset += arrays[i].length;
  }
  return result;
};

customBuf.str2rstr_utf8 = function(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while (++i < input.length)
  {
    // Decode utf-16 surrogate pairs
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    // Encode output as utf-8
    if (x <= 0x7F)
      output += String.fromCharCode(x);
    else if (x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if (x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if (x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
};

// Factory method to create hasher objects
exports.createHash = function(alg) 
{
  if (alg != 'sha256')
    throw new Error('createHash: unsupported algorithm.');

  var obj = {};

  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});

  obj.update = function(buf) {
    this.md.updateHex(buf.toString('hex'));
  };

  obj.digest = function() {
    return new customBuf(this.md.digest(), 'hex');
  };

  return obj;
};

// Factory method to create RSA signer objects
exports.createSign = function(alg) 
{
  if (alg != 'RSA-SHA256')
    throw new Error('createSign: unsupported algorithm.');

  var obj = {};

  obj.arr = [];

  obj.update = function(buf) {
    this.arr.push(buf);
  };

  obj.sign = function(keypem) {
    var rsa = new RSAKey();
    rsa.readPrivateKeyFromPEMString(keypem);
    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});
    signer.initSign(rsa);
    for (var i = 0; i < this.arr.length; ++i)
      signer.updateHex(this.arr[i].toString('hex'));

    return new customBuf(signer.sign(), 'hex');
  };

  return obj;
};

// Factory method to create RSA verifier objects
exports.createVerify = function(alg) 
{
  if (alg != 'RSA-SHA256')
    throw new Error('createSign: unsupported algorithm.');

  var obj = {};
    
  obj.arr = [];

  obj.update = function(buf) {
    this.arr.push(buf);
  };

  var getSubjectPublicKeyPosFromHex = function(hPub) {  
    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0); 
    if (a.length != 2) 
      return -1;
    var pBitString = a[1];
    if (hPub.substring(pBitString, pBitString + 2) != '03') 
      return -1;
    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);
    if (hPub.substring(pBitStringV, pBitStringV + 2) != '00') 
      return -1;
    return pBitStringV + 2;
  };

  var readPublicDER = function(pub_der) {
    var hex = pub_der.toString('hex'); 
    var p = getSubjectPublicKeyPosFromHex(hex);
    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);
    if (a.length != 2) 
      return null;
    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);
    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);
    var rsaKey = new RSAKey();
    rsaKey.setPublic(hN, hE);
    return rsaKey;
  };

  obj.verify = function(keypem, sig) {
    var key = new ndn.Key();
    key.fromPemString(keypem);

    var rsa = readPublicDER(key.publicToDER());
    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});
    signer.initVerifyByPublicKey(rsa);
    for (var i = 0; i < this.arr.length; i++)
      signer.updateHex(this.arr[i].toString('hex'));
    var hSig = sig.toString('hex'); 
    return signer.verify(hSig);
  };

  return obj;
};

exports.randomBytes = function(size)
{
  // TODO: Use a cryptographic random number generator.
  var result = new customBuf(size);
  for (var i = 0; i < size; ++i)
    result[i] = Math.floor(Math.random() * 256);
  return result;
};

exports.Buffer = customBuf;

module.exports = exports;

},{"../contrib/securityLib/asn1hex-1.1.js":34,"../contrib/securityLib/base64.js":35,"../contrib/securityLib/crypto-1.0.js":37,"../contrib/securityLib/rsasign-1.2.js":41}],46:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * Provide the callback closure for the async communication methods in the Face class.
 * This is a port of Closure.py from PyNDN, written by: 
 * Derek Kulinski <takeda@takeda.tk>
 * Jeff Burke <jburke@ucla.edu>
 */

/**
 * A subclass of Closure is passed to expressInterest and registerPrefix.
 * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.
 * @constructor
 */
var Closure = function Closure() 
{
  // I don't think storing Face's closure is needed
  // and it creates a reference loop, as of now both
  // of those variables are never set -- Derek
  //
  // Use instance variables to return data to callback
  this.ndn_data = null;  // this holds the ndn_closure
  this.ndn_data_dirty = false; 
};

exports.Closure = Closure;

// Upcall result
Closure.RESULT_ERR               = -1; // upcall detected an error
Closure.RESULT_OK                =  0; // normal upcall return
Closure.RESULT_REEXPRESS         =  1; // reexpress the same interest again
Closure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest
Closure.RESULT_VERIFY            =  3; // force an unverified result to be verified
Closure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest
                                       //   with the key available in the local storage

// Upcall kind
Closure.UPCALL_FINAL              = 0; // handler is about to be deregistered
Closure.UPCALL_INTEREST           = 1; // incoming interest
Closure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered
Closure.UPCALL_CONTENT            = 3; // incoming verified content
Closure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out
Closure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified
Closure.UPCALL_CONTENT_BAD        = 6; // verification failed

/**
 * Override this in your subclass.
 * If you're getting strange errors in upcall()
 * check your code whether you're returning a value.
 */
Closure.prototype.upcall = function(kind, upcallInfo) 
{
  //dump('upcall ' + this + " " + kind + " " + upcallInfo + "\n");
  return Closure.RESULT_OK;
};

/**
 * An UpcallInfo is passed to Closure.upcall.
 * @constructor
 */
var UpcallInfo = function UpcallInfo(face, interest, matchedComps, data) 
{
  this.face = face;  // Face object (not used)
  this.ndn = face;   // deprecated
  this.interest = interest;  // Interest object
  this.matchedComps = matchedComps;  // int
  this.data = data;  // Data
  this.contentObject = data; // deprecated.  Include for backward compatibility.
};

UpcallInfo.prototype.toString = function() 
{
  var ret = "face = " + this.face;
  ret += "\nInterest = " + this.interest;
  ret += "\nmatchedComps = " + this.matchedComps;
  ret += "\nData: " + this.data;
  return ret;
};

exports.UpcallInfo = UpcallInfo;

},{}],47:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an NDN Data object.
 */

var Blob = require('./util/blob.js').Blob;
var SignedBlob = require('./util/signed-blob.js').SignedBlob;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var DataUtils = require('./encoding/data-utils.js').DataUtils;
var Name = require('./name.js').Name;
var Signature = require('./signature.js').Signature;
var MetaInfo = require('./meta-info.js').MetaInfo;
var KeyLocator = require('./key-locator.js').KeyLocator;
var globalKeyManager = require('./security/key-manager.js').globalKeyManager;
var WireFormat = require('./encoding/wire-format.js').WireFormat;
var customBuf = require('./buffer.js').Buffer
/**
 * Create a new Data with the optional values.  There are 2 forms of constructor:
 * new Data([name] [, content]);
 * new Data(name, metaInfo [, content]);
 *
 * @constructor
 * @param {Name} name
 * @param {MetaInfo} metaInfo
 * @param {Buffer} content
 */
var Data = function Data(name, metaInfoOrContent, arg3)
{
  if (typeof name === 'string')
    this.name = new Name(name);
  else
    this.name = typeof name === 'object' && name instanceof Name ?
       new Name(name) : new Name();

  var metaInfo;
  var content;
  if (typeof metaInfoOrContent === 'object' &&
      metaInfoOrContent instanceof MetaInfo) {
    metaInfo = metaInfoOrContent;
    content = arg3;
  }
  else {
    metaInfo = null;
    content = metaInfoOrContent;
  }

  // Use signedInfo instead of metaInfo for backward compatibility.
  this.signedInfo = typeof metaInfo === 'object' && metaInfo instanceof MetaInfo ?
       new MetaInfo(metaInfo) : new MetaInfo();

  if (typeof content === 'string')
    this.content = DataUtils.toNumbersFromString(content);
  else if (typeof content === 'object' && content instanceof Blob)
    this.content = content.buf();
  else
    this.content = content;

  this.signature = new Signature();

  this.wireEncoding = SignedBlob();
};

exports.Data = Data;

/**
 * Get the data packet's name.
 * @returns {Name} The name.
 */
Data.prototype.getName = function()
{
  return this.name;
};

/**
 * Get the data packet's meta info.
 * @returns {MetaInfo} The meta info.
 */
Data.prototype.getMetaInfo = function()
{
  return this.signedInfo;
};

/**
 * Get the data packet's signature object.
 * @returns {Signature} The signature object.
 */
Data.prototype.getSignature = function()
{
  return this.signature;
};

/**
 * Get the data packet's content.
 * @returns {Buffer} The content as a customBuf, which is null if unspecified.
 */
Data.prototype.getContent = function()
{
  return this.content;
};

/**
 * Set name to a copy of the given Name.
 * @param {Name} name The Name which is copied.
 * @returns {Data} This Data so that you can chain calls to update values.
 */
Data.prototype.setName = function(name)
{
  this.name = typeof name === 'object' && name instanceof Name ?
    new Name(name) : new Name();

  // The object has changed, so the wireEncoding is invalid.
  this.wireEncoding = SignedBlob();
  return this;
};

/**
 * Set metaInfo to a copy of the given MetaInfo.
 * @param {MetaInfo} metaInfo The MetaInfo which is copied.
 * @returns {Data} This Data so that you can chain calls to update values.
 */
Data.prototype.setMetaInfo = function(metaInfo)
{
  this.signedInfo = typeof metaInfo === 'object' && metaInfo instanceof MetaInfo ?
    new MetaInfo(metaInfo) : new MetaInfo();

  // The object has changed, so the wireEncoding is invalid.
  this.wireEncoding = SignedBlob();
  return this;
};

/**
 * Set the signature to a copy of the given signature.
 * @param {Signature} signature The signature object which is cloned.
 * @returns {Data} This Data so that you can chain calls to update values.
 */
Data.prototype.setSignature = function(signature)
{
  this.signature = typeof signature === 'object' && signature instanceof Signature ?
    signature.clone() : new Signature();

  // The object has changed, so the wireEncoding is invalid.
  this.wireEncoding = SignedBlob();
  return this;
};

/**
 * Set the content to the given value.
 * @param {type} content The array this is copied.
 * @returns {Data} This Data so that you can chain calls to update values.
 */
Data.prototype.setContent = function(content)
{
  if (typeof content === 'string')
    this.content = DataUtils.toNumbersFromString(content);
  else if (typeof content === 'object' && content instanceof Blob)
    this.content = content.buf();
  else
    this.content = new customBuf(content);

  // The object has changed, so the wireEncoding is invalid.
  this.wireEncoding = SignedBlob();
  return this;
};

Data.prototype.sign = function(wireFormat)
{
  var rs = require('buffer')
  var ss = require('./crypto.js')
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());

  if (this.getSignatureOrMetaInfoKeyLocator() == null ||
      this.getSignatureOrMetaInfoKeyLocator().getType() == null)
    this.getMetaInfo().setFields();

  if (this.wireEncoding == null || this.wireEncoding.isNull()) {
    // Need to encode to set wireEncoding.
    // Set an initial empty signature so that we can encode.
    this.getSignature().setSignature(new customBuf(128));
    this.wireEncode(wireFormat);
  }

  var rsa = require("./crypto.js").createSign('RSA-SHA256');
  rsa.update(this.wireEncoding.signedBuf());

  var sig = new customBuf
    (DataUtils.toNumbersIfString(rsa.sign(globalKeyManager.privateKey)));
  this.signature.signature = sig;
};

// The first time verify is called, it sets this to determine if a signature
//   buffer needs to be converted to a string for the crypto verifier.
Data.verifyUsesString = null;
Data.prototype.verify = function(/*Key*/ key)
{
  if (key == null || key.publicKeyPem == null)
    throw new Error('Cannot verify Data without a public key.');

  if (Data.verifyUsesString == null) {
    var hashResult = require("crypto").createHash('sha256').digest();
    // If the has result is a string, we assume that this is a version of
    //   crypto where verify also uses a string signature.
    Data.verifyUsesString = (typeof hashResult === 'string');
  }

  if (this.wireEncoding == null || this.wireEncoding.isNull())
    // Need to encode to set wireEncoding.
    this.wireEncode();
  var verifier = require('./crypto.js').createVerify('RSA-SHA256');
  verifier.update(this.wireEncoding.signedBuf());
  var signatureBytes = Data.verifyUsesString ?
    DataUtils.toString(this.signature.signature) : this.signature.signature;
  return verifier.verify(key.publicKeyPem, signatureBytes);
};

Data.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };

/**
 * Encode this Data for a particular wire format.
 * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object
 * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().
 * @returns {SignedBlob} The encoded buffer in a SignedBlob object.
 */
Data.prototype.wireEncode = function(wireFormat)
{
  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  var result = wireFormat.encodeData(this);
  // TODO: Implement setDefaultWireEncoding with getChangeCount support.
  this.wireEncoding = new SignedBlob
    (result.encoding, result.signedPortionBeginOffset,
     result.signedPortionEndOffset);
  return this.wireEncoding;
};

/**
 * Decode the input using a particular wire format and update this Data.
 * @param {Blob|Buffer} input The buffer with the bytes to decode.
 * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object
 * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().
 */
Data.prototype.wireDecode = function(input, wireFormat)
{
  var wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  // If input is a blob, get its buf().
  var decodeBuffer = typeof input === 'object' && input instanceof Blob ?
                     input.buf() : input;
  var result = wireFormat.decodeData(this, decodeBuffer);
  // TODO: Implement setDefaultWireEncoding with getChangeCount support.
  // In the Blob constructor, set copy true, but if input is already a Blob, it
  //   won't copy.
  this.wireEncoding = new SignedBlob
    (new Blob(input, true), result.signedPortionBeginOffset,
     result.signedPortionEndOffset);
};

/**
 * If getSignature() has a key locator, return it.  Otherwise, use
 * the key locator from getMetaInfo() for backward compatibility and print
 * a warning to console.log that the key locator has moved to the Signature
 * object.  If neither has a key locator, return an empty key locator.
 * When we stop supporting the key locator in MetaInfo, this function is not
 * necessary and we will just use the key locator in the Signature.
 * @returns {KeyLocator} The key locator to use.
 */
Data.prototype.getSignatureOrMetaInfoKeyLocator = function()
{
  if (this.signature != null && this.signature.getKeyLocator() != null &&
      this.signature.getKeyLocator().getType() != null &&
      this.signature.getKeyLocator().getType() >= 0)
    // The application is using the key locator in the correct object.
    return this.signature.getKeyLocator();

  if (this.signedInfo != null && this.signedInfo.locator != null &&
      this.signedInfo.locator.type != null &&
      this.signedInfo.locator.type >= 0) {
    //console.log("WARNING: Temporarily using the key locator found in the MetaInfo - expected it in the Signature object.");
    //console.log("WARNING: In the future, the key locator in the Signature object will not be supported.");
    return this.signedInfo.locator;
  }

  // Return the empty key locator from the Signature object if possible.
  if (this.signature != null && this.signature.getKeyLocator() != null)
    return this.signature.getKeyLocator();
  else
    return new KeyLocator();
}

// Since binary-xml-wire-format.js includes this file, put these at the bottom to avoid problems with cycles of require.
var BinaryXmlWireFormat = require('./encoding/binary-xml-wire-format.js').BinaryXmlWireFormat;

/**
 * @deprecated Use BinaryXmlWireFormat.decodeData.
 */
Data.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)
{
  BinaryXmlWireFormat.decodeData(this, decoder);
};

/**
 * @deprecated Use BinaryXmlWireFormat.encodeData.
 */
Data.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)
{
  BinaryXmlWireFormat.encodeData(this, encoder);
};

/**
 * @deprecated Use wireEncode.  If you need binary XML, use
 * wireEncode(BinaryXmlWireFormat.get()).
 */
Data.prototype.encode = function(wireFormat)
{
  wireFormat = (wireFormat || BinaryXmlWireFormat.get());
  return wireFormat.encodeData(this).buf();
};

/**
 * @deprecated Use wireDecode.  If you need binary XML, use
 * wireDecode(input, BinaryXmlWireFormat.get()).
 */
Data.prototype.decode = function(input, wireFormat)
{
  wireFormat = (wireFormat || BinaryXmlWireFormat.get());
  wireFormat.decodeData(this, input);
};

/**
 * @deprecated Use new Data.
 */
var ContentObject = function ContentObject(name, signedInfo, content)
{
  // Call the base constructor.
  Data.call(this, name, signedInfo, content);
}

ContentObject.prototype = new Data();

exports.ContentObject = ContentObject;

},{"./buffer.js":45,"./crypto.js":45,"./encoding/binary-xml-encoder.js":49,"./encoding/binary-xml-wire-format.js":51,"./encoding/data-utils.js":52,"./encoding/wire-format.js":62,"./key-locator.js":69,"./meta-info.js":72,"./name.js":73,"./security/key-manager.js":76,"./signature.js":77,"./util/blob.js":79,"./util/ndn-protoco-id-tags.js":82,"./util/signed-blob.js":84,"buffer":1,"crypto":5}],48:[function(require,module,exports){
/**
 * This class is used to decode ndnb binary elements (blob, type/value pairs).
 * 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer
var NDNProtocolDTags = require('../util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var NDNTime = require('../util/ndn-time.js').NDNTime;
var DataUtils = require('./data-utils.js').DataUtils;
var DecodingException = require('./decoding-exception.js').DecodingException;
var LOG = require('../log.js').Log.LOG;

var XML_EXT = 0x00; 
  
var XML_TAG = 0x01; 
  
var XML_DTAG = 0x02; 
  
var XML_ATTR = 0x03; 
 
var XML_DATTR = 0x04; 
  
var XML_BLOB = 0x05; 
  
var XML_UDATA = 0x06; 
  
var XML_CLOSE = 0x0;

var XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; 
  

var XML_TT_BITS = 3;
var XML_TT_MASK = ((1 << XML_TT_BITS) - 1);
var XML_TT_VAL_BITS = XML_TT_BITS + 1;
var XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);
var XML_REG_VAL_BITS = 7;
var XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);
var XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80
var BYTE_MASK = 0xFF;
var LONG_BYTES = 8;
var LONG_BITS = 64;
  
var bits_11 = 0x0000007FF;
var bits_18 = 0x00003FFFF;
var bits_32 = 0x0FFFFFFFF;



//returns a string
tagToString = function(/*long*/ tagVal) 
{
  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {
    return NDNProtocolDTagsStrings[tagVal];
  } 
  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {
    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;
  }
  
  return null;
};

//returns a Long
stringToTag =  function(/*String*/ tagName) 
{
  // the slow way, but right now we don't care.... want a static lookup for the forward direction
  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {
    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)
      return i;
  }
  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {
    return NDNProtocolDTags.NDNProtocolDataUnit;
  }
  
  return null;
};

/**
 * @constructor
 */
var BinaryXMLDecoder = function BinaryXMLDecoder(input) 
{
  var MARK_LEN=512;
  var DEBUG_MAX_LEN =  32768;
  
  this.input = input;
  this.offset = 0;
  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.
  this.previouslyPeekedDTagStartOffset = -1;
};

exports.BinaryXMLDecoder = BinaryXMLDecoder;

/**
 * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.
   * Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 */
BinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)
{
  if (this.offset == this.previouslyPeekedDTagStartOffset) {
    // peekDTag already decoded this DTag.
    if (this.previouslyPeekedDTag != expectedTag)
      throw new DecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));

    // Fast forward past the header.
    this.offset = this.previouslyPeekedDTagEndOffset;
  }
  else {
    var typeAndValue = this.decodeTypeAndVal();
    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)
      throw new DecodingException(new Error("Header type is not a DTAG"));

    if (typeAndValue.val() != expectedTag)
      throw new DecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));
  }  
};

/**
 * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readStartElement = function(
    //String 
    startTag,
    //TreeMap<String, String> 
    attributes)
{
  //TypeAndVal 
  var tv = this.decodeTypeAndVal();
      
  if (null == tv)
    throw new DecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));
      
  //String 
  var decodedTag = null;
      
  if (tv.type() == XML_TAG) {
    // Tag value represents length-1 as tags can never be empty.
    var valval;
        
    if (typeof tv.val() == 'string')
      valval = (parseInt(tv.val())) + 1;
    else
      valval = (tv.val())+ 1;
        
    decodedTag = this.decodeUString(valval);
  } 
  else if (tv.type() == XML_DTAG)
    decodedTag = tv.val();
      
  if (null ==  decodedTag || decodedTag != startTag) {
    console.log('expecting '+ startTag + ' but got '+ decodedTag);
    throw new DecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));
  }
      
  // DKS: does not read attributes out of stream if caller doesn't
  // ask for them. Should possibly peek and skip over them regardless.
  // TODO: fix this
  if (null != attributes)
    readAttributes(attributes); 
};
  
/**
 * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readAttributes = function(
  // array of [attributeName, attributeValue] 
  attributes) 
{
  if (null == attributes)
    return;

  try {
    // Now need to get attributes.
    //TypeAndVal 
    var nextTV = this.peekTypeAndVal();

    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {
      // Decode this attribute. First, really read the type and value.
      //this.TypeAndVal 
      var thisTV = this.decodeTypeAndVal();

      //String 
      var attributeName = null;
      if (XML_ATTR == thisTV.type()) {
        // Tag value represents length-1 as attribute names cannot be empty.
        var valval ;
        if (typeof thisTV.val() == 'string')
          valval = (parseInt(thisTV.val())) + 1;
        else
          valval = (thisTV.val())+ 1;
        
        attributeName = this.decodeUString(valval);
      } 
      else if (XML_DATTR == thisTV.type()) {
        // DKS TODO are attributes same or different dictionary?
        attributeName = tagToString(thisTV.val());
        if (null == attributeName)
          throw new DecodingException(new Error("Unknown DATTR value" + thisTV.val()));
      }
      
      // Attribute values are always UDATA
      //String
      var attributeValue = this.decodeUString();

      attributes.push([attributeName, attributeValue]);
      nextTV = this.peekTypeAndVal();
    }
  } 
  catch (e) {
    throw new DecodingException(new Error("readStartElement", e));
  }
};

/**
 * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.peekStartElementAsString = function() 
{
  //String 
  var decodedTag = null;
  var previousOffset = this.offset;
  try {
    // Have to distinguish genuine errors from wrong tags. Could either use
    // a special exception subtype, or redo the work here.
    //this.TypeAndVal 
    var tv = this.decodeTypeAndVal();

    if (null != tv) {
      if (tv.type() == XML_TAG) {
        // Tag value represents length-1 as tags can never be empty.
        var valval ;
        if (typeof tv.val() == 'string')
          valval = (parseInt(tv.val())) + 1;
        else
          valval = (tv.val())+ 1;
        
        decodedTag = this.decodeUString(valval);
      }
      else if (tv.type() == XML_DTAG)
        decodedTag = tagToString(tv.val());          
    } // else, not a type and val, probably an end element. rewind and return false.
  } 
  catch (e) {
  } 
  finally {
    try {
      this.offset = previousOffset;
    } 
    catch (e) {
      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);
      throw new DecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));
    }
  }
  
  return decodedTag;
};

/**
 * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,
 * then set return true.  Do not update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {boolean} True if the tag is the expected tag, otherwise false.
 */
BinaryXMLDecoder.prototype.peekDTag = function(expectedTag)
{
  if (this.offset == this.previouslyPeekedDTagStartOffset)
    // We already decoded this DTag.
    return this.previouslyPeekedDTag == expectedTag;
  else {
    // First check if it is an element close (which cannot be the expected tag).  
    if (this.input[this.offset] == XML_CLOSE)
      return false;

    var saveOffset = this.offset;
    var typeAndValue = this.decodeTypeAndVal();
    // readElementStartDTag will use this to fast forward.
    this.previouslyPeekedDTagEndOffset = this.offset;
    // Restore the position.
    this.offset = saveOffset;

    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {
      this.previouslyPeekedDTagStartOffset = saveOffset;
      this.previouslyPeekedDTag = typeAndValue.val();

      return typeAndValue.val() == expectedTag;
    }
    else
      return false;
  }  
};

/**
 * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.peekStartElement = function(
    //String 
    startTag) 
{
  //String 
  if (typeof startTag == 'string') {
    var decodedTag = this.peekStartElementAsString();
    
    if (null !=  decodedTag && decodedTag == startTag)
      return true;

    return false;
  }
  else if (typeof startTag == 'number') {
    var decodedTag = this.peekStartElementAsLong();
    if (null !=  decodedTag && decodedTag == startTag)
      return true;

    return false;
  }
  else
    throw new DecodingException(new Error("SHOULD BE STRING OR NUMBER"));
};

/**
 * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.peekStartElementAsLong = function() 
{
  //Long
  var decodedTag = null;    
  var previousOffset = this.offset;
  
  try {
    // Have to distinguish genuine errors from wrong tags. Could either use
    // a special exception subtype, or redo the work here.
    //this.TypeAndVal
    var tv = this.decodeTypeAndVal();

    if (null != tv) {
      if (tv.type() == XML_TAG) {
        if (tv.val() + 1 > DEBUG_MAX_LEN)
          throw new DecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));

        var valval;
        if (typeof tv.val() == 'string')
          valval = (parseInt(tv.val())) + 1;
        else
          valval = (tv.val())+ 1;
        
        // Tag value represents length-1 as tags can never be empty.
        //String 
        var strTag = this.decodeUString(valval);
        
        decodedTag = stringToTag(strTag);
      } 
      else if (tv.type() == XML_DTAG)
        decodedTag = tv.val();          
    } // else, not a type and val, probably an end element. rewind and return false.

  } 
  catch (e) {  
  } 
  finally {
    try {
      //this.input.reset();
      this.offset = previousOffset;
    } catch (e) {
      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);
      throw new Error("Cannot reset stream! " + e.getMessage(), e);
    }
  }
  
  return decodedTag;
};

/**
 * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.
 * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a 
 * customBuf. However, if allowNull is true, then the item may be absent.
 * Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @param {boolean} allowNull True if the binary item may be missing.
 * @returns {Buffer} A customBuf which is a slice on the data inside the input buffer. However, 
 * if allowNull is true and the binary data item is absent, then return null.
 */
BinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)
{
  this.readElementStartDTag(expectedTag);
  return this.readBlob(allowNull);  
};

/**
 * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readBinaryElement = function(
    //long 
    startTag,
    //TreeMap<String, String> 
    attributes,
    //boolean
    allowNull) 
{
  this.readStartElement(startTag, attributes);
  return this.readBlob(allowNull);  
};

/**
 * Read one byte from the input starting at its offset, expecting it to be the element close.
 * Update the input's offset.
 */
BinaryXMLDecoder.prototype.readElementClose = function() 
{
  var next = this.input[this.offset++];     
  if (next != XML_CLOSE)
    throw new DecodingException(new Error("Expected end element, got: " + next));
};

/**
 * @deprecated Use readElementClose.
 */
BinaryXMLDecoder.prototype.readEndElement = function() 
{
  if (LOG > 4) console.log('this.offset is '+this.offset);
  
  var next = this.input[this.offset]; 
  
  this.offset++;
  
  if (LOG > 4) console.log('XML_CLOSE IS '+XML_CLOSE);
  if (LOG > 4) console.log('next is '+next);
  
  if (next != XML_CLOSE) {
    console.log("Expected end element, got: " + next);
    throw new DecodingException(new Error("Expected end element, got: " + next));
  }
};

//String  
BinaryXMLDecoder.prototype.readUString = function() 
{
  //String 
  var ustring = this.decodeUString();  
  this.readElementClose();
  return ustring;
};
  
/**
 * Read a blob as well as the end element. Returns a customBuf (or null for missing blob).
 * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,
 *   just read the end element and return null.
 */
BinaryXMLDecoder.prototype.readBlob = function(allowNull) 
{
  if (this.input[this.offset] == XML_CLOSE && allowNull) {
    this.readElementClose();
    return null;
  }
    
  var blob = this.decodeBlob();  
  this.readElementClose();
  return blob;
};

/**
 * Decode the header from the input starting at its offset, expecting the type to be 
 * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned 
 * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.
 * Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {NDNTime} The dateTime value.
 */
BinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)  
{
  var byteTimestamp = this.readBinaryDTagElement(expectedTag);
  byteTimestamp = DataUtils.toHex(byteTimestamp);
  byteTimestamp = parseInt(byteTimestamp, 16);
  
  var lontimestamp = (byteTimestamp/ 4096) * 1000;

  var timestamp = new NDNTime(lontimestamp);  
  if (null == timestamp)
    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));

  return timestamp;
};

/**
 * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readDateTime = function(
  //long 
  startTag)  
{
  var byteTimestamp = this.readBinaryElement(startTag);
  byteTimestamp = DataUtils.toHex(byteTimestamp);
  byteTimestamp = parseInt(byteTimestamp, 16);
  
  var lontimestamp = (byteTimestamp/ 4096) * 1000;

  if (LOG > 4) console.log('DECODED DATE WITH VALUE');
  if (LOG > 4) console.log(lontimestamp);
  
  //NDNTime 
  var timestamp = new NDNTime(lontimestamp);  
  if (null == timestamp)
    throw new DecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));

  return timestamp;
};

BinaryXMLDecoder.prototype.decodeTypeAndVal = function() 
{
  
  /*int*/ var type = -1;
  /*long*/ var val = 0;
  /*boolean*/ var more = true;

  do {
    var next = this.input[this.offset ];
    if (next == null)
      // Quit the loop.
      return null; 
    
    if (next < 0)
      return null; 

    if (0 == next && 0 == val)
      return null;
    
    more = (0 == (next & XML_TT_NO_MORE));
    
    if  (more) {
      val = val << XML_REG_VAL_BITS;
      val |= (next & XML_REG_VAL_MASK);
    } 
    else {
      type = next & XML_TT_MASK;
      val = val << XML_TT_VAL_BITS;
      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);
    }
    
    this.offset++;
  } while (more);
  
  if (LOG > 4) console.log('TYPE is '+ type + ' VAL is '+ val);

  return new TypeAndVal(type, val);
};

//TypeAndVal
BinaryXMLDecoder.prototype.peekTypeAndVal = function() 
{
  //TypeAndVal 
  var tv = null;
  var previousOffset = this.offset;
  
  try {
    tv = this.decodeTypeAndVal();
  } 
  finally {
    this.offset = previousOffset;
  }
  
  return tv;
};

//Buffer
BinaryXMLDecoder.prototype.decodeBlob = function(
    //int 
    blobLength) 
{  
  if (null == blobLength) {
    //TypeAndVal
    var tv = this.decodeTypeAndVal();

    var valval ;
    if (typeof tv.val() == 'string')
      valval = (parseInt(tv.val()));
    else
      valval = (tv.val());
    
    return this.decodeBlob(valval);
  }
  
  //Buffer
  var bytes = new customBuf(this.input.slice(this.offset, this.offset+ blobLength));
  this.offset += blobLength;
  
  return bytes;
};

//String
BinaryXMLDecoder.prototype.decodeUString = function(
    //int 
    byteLength) 
{
  if (null == byteLength) {
    var tempStreamPosition = this.offset;
      
    //TypeAndVal 
    var tv = this.decodeTypeAndVal();
    
    if (LOG > 4) console.log('TV is '+tv);
    if (LOG > 4) console.log(tv);
    
    if (LOG > 4) console.log('Type of TV is '+typeof tv);
  
    // if we just have closers left, will get back null
    if (null == tv || XML_UDATA != tv.type()) {
      this.offset = tempStreamPosition;      
      return "";
    }
      
    return this.decodeUString(tv.val());
  }
  else {
    //Buffer 
    var stringBytes = this.decodeBlob(byteLength);
    
    // TODO: Should this parse as UTF8?
    return DataUtils.toString(stringBytes);    
  }
};

//OBject containg a pair of type and value
var TypeAndVal = function TypeAndVal(_type,_val) 
{
  this.t = _type;
  this.v = _val;
};

TypeAndVal.prototype.type = function() 
{
  return this.t;
};

TypeAndVal.prototype.val = function() 
{
  return this.v;
};

/**
 * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.
 * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {number} The parsed integer.
 */
BinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)
{
  return parseInt(this.readUTF8DTagElement(expectedTag));
};

/**
 * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readIntegerElement = function(
  //String 
  startTag) 
{
  //String 
  if (LOG > 4) console.log('READING INTEGER '+ startTag);
  if (LOG > 4) console.log('TYPE OF '+ typeof startTag);
  
  var strVal = this.readUTF8Element(startTag);
  
  return parseInt(strVal);
};

/**
 * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.
 * Then read one UDATA item and return a string. Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {string} The UDATA string.
 */
BinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)
{
  this.readElementStartDTag(expectedTag);
  return this.readUString();;
};

/**
 * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readUTF8Element = function(
    //String 
    startTag,
    //TreeMap<String, String> 
    attributes) 
{
  //throws Error where name == "DecodingException" 

  // can't use getElementText, can't get attributes
  this.readStartElement(startTag, attributes);
  //String 
  var strElementText = this.readUString();
  return strElementText;
};

/**
 * Set the offset into the input, used for the next read.
 * @param {number} offset The new offset.
 */
BinaryXMLDecoder.prototype.seek = function(offset) 
{
  this.offset = offset;
};

},{"../buffer.js":45,"../log.js":71,"../util/ndn-protoco-id-tags.js":82,"../util/ndn-time.js":83,"./data-utils.js":52,"./decoding-exception.js":53}],49:[function(require,module,exports){
/**
 * This class is used to encode ndnb binary elements (blob, type/value pairs).
 * 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */

var LOG = require('../log.js').Log.LOG;

var customBuf = require('../buffer.js').Buffer
var NDNProtocolDTags = require('../util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var DynamicBuffer = require('../util/dynamic-buffer.js').DynamicBuffer;
var DataUtils = require('./data-utils.js').DataUtils;
var LOG = require('../log.js').Log.LOG;

var XML_EXT = 0x00; 
  
var XML_TAG = 0x01; 
  
var XML_DTAG = 0x02; 
  
var XML_ATTR = 0x03; 
 
var XML_DATTR = 0x04; 
  
var XML_BLOB = 0x05; 
  
var XML_UDATA = 0x06; 
  
var XML_CLOSE = 0x0;

var XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; 


var XML_TT_BITS = 3;
var XML_TT_MASK = ((1 << XML_TT_BITS) - 1);
var XML_TT_VAL_BITS = XML_TT_BITS + 1;
var XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);
var XML_REG_VAL_BITS = 7;
var XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);
var XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80
var BYTE_MASK = 0xFF;
var LONG_BYTES = 8;
var LONG_BITS = 64;
  
var bits_11 = 0x0000007FF;
var bits_18 = 0x00003FFFF;
var bits_32 = 0x0FFFFFFFF;

/**
 * @constructor
 */
var BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength) 
{
  if (!initiaLength)
    initiaLength = 16;
  
  this.ostream = new DynamicBuffer(initiaLength);
  this.offset = 0;
  this.CODEC_NAME = "Binary";
};

exports.BinaryXMLEncoder = BinaryXMLEncoder;

/**
 * Encode utf8Content as utf8 and write to the output buffer as a UDATA.
 * @param {string} utf8Content The string to convert to utf8.
 */
BinaryXMLEncoder.prototype.writeUString = function(utf8Content) 
{
  this.encodeUString(utf8Content, XML_UDATA);
};

BinaryXMLEncoder.prototype.writeBlob = function(
    /*Buffer*/ binaryContent) 
{  
  if (LOG >3) console.log(binaryContent);
  
  this.encodeBlob(binaryContent, binaryContent.length);
};

/**
 * Write an element start header using DTAG with the tag to the output buffer.
 * @param {number} tag The DTAG tag.
 */
BinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)
{
  this.encodeTypeAndVal(XML_DTAG, tag);
};

/**
 * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLEncoder.prototype.writeStartElement = function(
  /*String*/ tag, 
  /*TreeMap<String,String>*/ attributes) 
{
  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);
  
  if (null == dictionaryVal)
    this.encodeUString(tag, XML_TAG);
  else
    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);
  
  if (null != attributes)
    this.writeAttributes(attributes); 
};

/**
 * Write an element close to the output buffer.
 */
BinaryXMLEncoder.prototype.writeElementClose = function() 
{
  this.ostream.ensureLength(this.offset + 1);
  this.ostream.array[this.offset] = XML_CLOSE;
  this.offset += 1;
};

/**
 * @deprecated Use writeElementClose.
 */
BinaryXMLEncoder.prototype.writeEndElement = function() 
{
  this.writeElementClose();
};

/**
 * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.
 */
BinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes) 
{
  if (null == attributes)
    return;

  // the keySet of a TreeMap is sorted.

  for (var i = 0; i< attributes.length;i++) {
    var strAttr = attributes[i].k;
    var strValue = attributes[i].v;

    var dictionaryAttr = stringToTag(strAttr);
    if (null == dictionaryAttr)
      // not in dictionary, encode as attr
      // compressed format wants length of tag represented as length-1
      // to save that extra bit, as tag cannot be 0 length.
      // encodeUString knows to do that.
      this.encodeUString(strAttr, XML_ATTR);
    else
      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);

    // Write value
    this.encodeUString(strValue);    
  }
};

//returns a string
stringToTag = function(/*long*/ tagVal) 
{
  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)
    return NDNProtocolDTagsStrings[tagVal];
  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)
    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;
  
  return null;
};

//returns a Long
tagToString =  function(/*String*/ tagName) 
{
  // the slow way, but right now we don't care.... want a static lookup for the forward direction
  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {
    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)
      return i;
  }
  
  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)
    return NDNProtocolDTags.NDNProtocolDataUnit;

  return null;
};

/**
 * Write an element start header using DTAG with the tag to the output buffer, then the content as explained below, 
 * then an element close.
 * @param {number} tag The DTAG tag.
 * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,
 * call writeUString.  Otherwise, call writeBlob.
 */
BinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)
{
  this.writeElementStartDTag(tag);
  
  if (typeof content === 'number')
    this.writeUString(content.toString());
  else if (typeof content === 'string')
    this.writeUString(content);
  else
    this.writeBlob(content);
  
  this.writeElementClose();
};

/**
 * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 * If Content is a string, then encode as utf8 and write UDATA.
 */
BinaryXMLEncoder.prototype.writeElement = function(
    //long 
    tag, 
    //byte[] 
    Content,
    //TreeMap<String, String> 
    attributes) 
{
  this.writeStartElement(tag, attributes);
  // Will omit if 0-length
  
  if (typeof Content === 'number') {
    if (LOG > 4) console.log('GOING TO WRITE THE NUMBER .charCodeAt(0) ' + Content.toString().charCodeAt(0));
    if (LOG > 4) console.log('GOING TO WRITE THE NUMBER ' + Content.toString());
    if (LOG > 4) console.log('type of number is ' + typeof Content.toString());
    
    this.writeUString(Content.toString());
  }
  else if (typeof Content === 'string') {
    if (LOG > 4) console.log('GOING TO WRITE THE STRING  ' + Content);
    if (LOG > 4) console.log('type of STRING is ' + typeof Content);
    
    this.writeUString(Content);
  }
  else {
    if (LOG > 4) console.log('GOING TO WRITE A BLOB  ' + Content);

    this.writeBlob(Content);
  }
  
  this.writeElementClose();
};

var TypeAndVal = function TypeAndVal(_type,_val) 
{
  this.type = _type;
  this.val = _val;  
};

BinaryXMLEncoder.prototype.encodeTypeAndVal = function(
    //int
    type, 
    //long 
    val) 
{  
  if (LOG > 4) console.log('Encoding type '+ type+ ' and value '+ val);
  
  if (LOG > 4) console.log('OFFSET IS ' + this.offset);
  
  if (type > XML_UDATA || type < 0 || val < 0)
    throw new Error("Tag and value must be positive, and tag valid.");
  
  // Encode backwards. Calculate how many bytes we need:
  var numEncodingBytes = this.numEncodingBytes(val);
  this.ostream.ensureLength(this.offset + numEncodingBytes);

  // Bottom 4 bits of val go in last byte with tag.
  this.ostream.array[this.offset + numEncodingBytes - 1] = 
    //(byte)
      (BYTE_MASK &
          (((XML_TT_MASK & type) | 
           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |
           XML_TT_NO_MORE); // set top bit for last byte
  val = val >>> XML_TT_VAL_BITS;
  
  // Rest of val goes into preceding bytes, 7 bits per byte, top bit
  // is "more" flag.
  var i = this.offset + numEncodingBytes - 2;
  while (0 != val && i >= this.offset) {
    this.ostream.array[i] = //(byte)
        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset
    val = val >>> XML_REG_VAL_BITS;
    --i;
  }
  
  if (val != 0)
    throw new Error("This should not happen: miscalculated encoding");

  this.offset+= numEncodingBytes;
  
  return numEncodingBytes;
};

/**
 * Encode ustring as utf8.
 */
BinaryXMLEncoder.prototype.encodeUString = function(
    //String 
    ustring, 
    //byte 
    type) 
{  
  if (null == ustring)
    return;
  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)
    return;
  
  if (LOG > 3) console.log("The string to write is ");
  if (LOG > 3) console.log(ustring);

  var strBytes = DataUtils.stringToUtf8Array(ustring);
  
  this.encodeTypeAndVal(type, 
            (((type == XML_TAG) || (type == XML_ATTR)) ?
                (strBytes.length-1) :
                strBytes.length));
  
  if (LOG > 3) console.log("THE string to write is ");
  
  if (LOG > 3) console.log(strBytes);
  
  this.writeString(strBytes);
  this.offset+= strBytes.length;
};


BinaryXMLEncoder.prototype.encodeBlob = function(
    //Buffer 
    blob, 
    //int 
    length) 
{
  if (null == blob)
    return;
  
  if (LOG > 4) console.log('LENGTH OF XML_BLOB IS '+length);
  
  this.encodeTypeAndVal(XML_BLOB, length);
  this.writeBlobArray(blob);
  this.offset += length;
};

var ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);
var ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);
var ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);

BinaryXMLEncoder.prototype.numEncodingBytes = function(
    //long
    x) 
{
  if (x <= ENCODING_LIMIT_1_BYTE) return (1);
  if (x <= ENCODING_LIMIT_2_BYTES) return (2);
  if (x <= ENCODING_LIMIT_3_BYTES) return (3);
  
  var numbytes = 1;
  
  // Last byte gives you XML_TT_VAL_BITS
  // Remainder each give you XML_REG_VAL_BITS
  x = x >>> XML_TT_VAL_BITS;
  while (x != 0) {
        numbytes++;
    x = x >>> XML_REG_VAL_BITS;
  }
  return (numbytes);
};

/**
 * Write an element start header using DTAG with the tag to the output buffer, then the dateTime
   * as a big endian BLOB converted to 4096 ticks per second, then an element close.
 * @param {number} tag The DTAG tag.
 * @param {NDNTime} dateTime
 */
BinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)
{  
  //parse to hex
  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;
  if (binarydate.length % 2 == 1)
    binarydate = '0' + binarydate;

  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));
};

/**
 * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and 
 * support is not maintained in the code base.
 */
BinaryXMLEncoder.prototype.writeDateTime = function(
    //String 
    tag, 
    //NDNTime 
    dateTime) 
{  
  //parse to hex
  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;
  if (binarydate.length % 2 == 1)
    binarydate = '0' + binarydate;

  this.writeElement(tag, DataUtils.toNumbers(binarydate));
};

// This does not update this.offset.
BinaryXMLEncoder.prototype.writeString = function(input) 
{
  if (typeof input === 'string') {
    if (LOG > 4) console.log('GOING TO WRITE A STRING');
    if (LOG > 4) console.log(input);
        
    this.ostream.ensureLength(this.offset + input.length);
    for (var i = 0; i < input.length; i++) {
      if (LOG > 4) console.log('input.charCodeAt(i)=' + input.charCodeAt(i));
      this.ostream.array[this.offset + i] = (input.charCodeAt(i));
    }
  }
  else
  {
    if (LOG > 4) console.log('GOING TO WRITE A STRING IN BINARY FORM');
    if (LOG > 4) console.log(input);
    
    this.writeBlobArray(input);
  }
};

BinaryXMLEncoder.prototype.writeBlobArray = function(
    //Buffer 
    blob) 
{  
  if (LOG > 4) console.log('GOING TO WRITE A BLOB');
    
  this.ostream.copy(blob, this.offset);
};

BinaryXMLEncoder.prototype.getReducedOstream = function() 
{
  return this.ostream.slice(0, this.offset);
};

},{"../buffer.js":45,"../log.js":71,"../util/dynamic-buffer.js":80,"../util/ndn-protoco-id-tags.js":82,"./data-utils.js":52}],50:[function(require,module,exports){
/**
 * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to 
 * determine its end.
 * 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var BinaryXMLDecoder = require('./binary-xml-decoder.js').BinaryXMLDecoder;
var DynamicBuffer = require('../util/dynamic-buffer.js').DynamicBuffer;

var XML_EXT = 0x00; 
var XML_TAG = 0x01; 
var XML_DTAG = 0x02; 
var XML_ATTR = 0x03; 
var XML_DATTR = 0x04; 
var XML_BLOB = 0x05; 
var XML_UDATA = 0x06;   
var XML_CLOSE = 0x0;

var XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16; 

var XML_TT_BITS = 3;
var XML_TT_MASK = ((1 << XML_TT_BITS) - 1);
var XML_TT_VAL_BITS = XML_TT_BITS + 1;
var XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);
var XML_REG_VAL_BITS = 7;
var XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);
var XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80

/**
 * @constructor
 */
var BinaryXMLStructureDecoder = function BinaryXMLDecoder() 
{
  this.gotElementEnd = false;
  this.offset = 0;
  this.level = 0;
  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;
  this.headerLength = 0;
  this.useHeaderBuffer = false;
  this.headerBuffer = new DynamicBuffer(5);
  this.nBytesToRead = 0;
};

exports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;

BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;
BinaryXMLStructureDecoder.READ_BYTES = 1;

/**
 * Continue scanning input starting from this.offset.  If found the end of the element
 *   which started at offset 0 then return true, else false.
 * If this returns false, you should read more into input and call again.
 * You have to pass in input each time because the array could be reallocated.
 * This throws an exception for badly formed ndnb.
 */
BinaryXMLStructureDecoder.prototype.findElementEnd = function(
  // customBuf
  input)
{
  if (this.gotElementEnd)
    // Someone is calling when we already got the end.
    return true;

  var decoder = new BinaryXMLDecoder(input);
  
  while (true) {
    if (this.offset >= input.length)
      // All the cases assume we have some input.
      return false;
  
    switch (this.state) {
      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:               
        // First check for XML_CLOSE.
        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {
          ++this.offset;
          // Close the level.
          --this.level;
          if (this.level == 0) {
            // Finished.
            this.gotElementEnd = true;
            return true;
          }
          if (this.level < 0)
            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));
              
          // Get ready for the next header.
          this.startHeader();
          break;
        }
        
        var startingHeaderLength = this.headerLength;
        while (true) {
          if (this.offset >= input.length) {
            // We can't get all of the header bytes from this input. Save in headerBuffer.
            this.useHeaderBuffer = true;
            var nNewBytes = this.headerLength - startingHeaderLength;
            this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);
              
            return false;
          }
          var headerByte = input[this.offset++];
          ++this.headerLength;
          if (headerByte & XML_TT_NO_MORE)
            // Break and read the header.
            break;
        }
        
        var typeAndVal;
        if (this.useHeaderBuffer) {
          // Copy the remaining bytes into headerBuffer.
          nNewBytes = this.headerLength - startingHeaderLength;
          this.headerBuffer.copy(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);

          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();
        }
        else {
          // We didn't have to use the headerBuffer.
          decoder.seek(this.offset - this.headerLength);
          typeAndVal = decoder.decodeTypeAndVal();
        }
        
        if (typeAndVal == null)
          throw new Error("BinaryXMLStructureDecoder: Can't read header starting at offset " +
                          (this.offset - this.headerLength));
        
        // Set the next state based on the type.
        var type = typeAndVal.t;
        if (type == XML_DATTR)
          // We already consumed the item. READ_HEADER_OR_CLOSE again.
          // ndnb has rules about what must follow an attribute, but we are just scanning.
          this.startHeader();
        else if (type == XML_DTAG || type == XML_EXT) {
          // Start a new level and READ_HEADER_OR_CLOSE again.
          ++this.level;
          this.startHeader();
        }
        else if (type == XML_TAG || type == XML_ATTR) {
          if (type == XML_TAG)
            // Start a new level and read the tag.
            ++this.level;
          // Minimum tag or attribute length is 1.
          this.nBytesToRead = typeAndVal.v + 1;
          this.state = BinaryXMLStructureDecoder.READ_BYTES;
          // ndnb has rules about what must follow an attribute, but we are just scanning.
        }
        else if (type == XML_BLOB || type == XML_UDATA) {
          this.nBytesToRead = typeAndVal.v;
          this.state = BinaryXMLStructureDecoder.READ_BYTES;
        }
        else
          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);
        break;
    
      case BinaryXMLStructureDecoder.READ_BYTES:
        var nRemainingBytes = input.length - this.offset;
        if (nRemainingBytes < this.nBytesToRead) {
          // Need more.
          this.offset += nRemainingBytes;
          this.nBytesToRead -= nRemainingBytes;
          return false;
        }
        // Got the bytes.  Read a new header or close.
        this.offset += this.nBytesToRead;
        this.startHeader();
        break;
    
      default:
        // We don't expect this to happen.
        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);
    }
  }
};

/**
 * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header
 */
BinaryXMLStructureDecoder.prototype.startHeader = function() 
{
  this.headerLength = 0;
  this.useHeaderBuffer = false;
  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;    
};

/**
 *  Set the offset into the input, used for the next read.
 */
BinaryXMLStructureDecoder.prototype.seek = function(offset) 
{
  this.offset = offset;
};

},{"../util/dynamic-buffer.js":80,"./binary-xml-decoder.js":48}],51:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var Blob = require('../util/blob.js').Blob;
var NDNProtocolDTags = require('../util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var BinaryXMLEncoder = require('./binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./binary-xml-decoder.js').BinaryXMLDecoder;
var WireFormat = require('./wire-format.js').WireFormat;
var Name = require('../name.js').Name;
var Exclude = require('../exclude.js').Exclude;
var Signature = require('../signature.js').Signature;
var MetaInfo = require('../meta-info.js').MetaInfo;
var PublisherPublicKeyDigest = require('../publisher-public-key-digest.js').PublisherPublicKeyDigest;
var DataUtils = require('./data-utils.js').DataUtils;
var KeyLocatorType = require('../key-locator.js').KeyLocatorType;

/**
 * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.
 * @constructor
 */
var BinaryXmlWireFormat = function BinaryXmlWireFormat() 
{
  // Inherit from WireFormat.
  WireFormat.call(this);
};

exports.BinaryXmlWireFormat = BinaryXmlWireFormat;

// Default object.
BinaryXmlWireFormat.instance = null;

/**
 * Encode interest as Binary XML and return the encoding.
 * @param {Interest} interest The Interest to encode.
 * @returns {Blob} A Blob containing the encoding.
 */
BinaryXmlWireFormat.prototype.encodeInterest = function(interest) 
{
  var encoder = new BinaryXMLEncoder();
  BinaryXmlWireFormat.encodeInterest(interest, encoder);  
  return new Blob(encoder.getReducedOstream(), false);  
};

/**
 * Decode input as a Binary XML interest and set the fields of the interest object. 
 * @param {Interest} interest The Interest object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 */
BinaryXmlWireFormat.prototype.decodeInterest = function(interest, input) 
{
  var decoder = new BinaryXMLDecoder(input);
  BinaryXmlWireFormat.decodeInterest(interest, decoder);
};

/**
 * Encode data as Binary XML and return the encoding and signed offsets.
 * @param {Data} data The Data object to encode.
 * @returns {object with (Blob, int, int)} An associative array with fields
 * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding 
 * is a Blob containing the encoding, signedPortionBeginOffset is the offset in 
 * the encoding of the beginning of the signed portion, and 
 * signedPortionEndOffset is the offset in the encoding of the end of the 
 * signed portion.
 */
BinaryXmlWireFormat.prototype.encodeData = function(data) 
{
  var encoder = new BinaryXMLEncoder(1500);
  var result = BinaryXmlWireFormat.encodeData(data, encoder);
  result.encoding = new Blob(encoder.getReducedOstream(), false);
  return result;
};

/**
 * @deprecated Use encodeData(data).
 */
BinaryXmlWireFormat.prototype.encodeContentObject = function(data)
{
  return this.encodeData(data);
};

/**
 * Decode input as a Binary XML data packet, set the fields in the data object, and return 
 * the signed offsets. 
 * @param {Data} data The Data object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 */
BinaryXmlWireFormat.prototype.decodeData = function(data, input) 
{
  var decoder = new BinaryXMLDecoder(input);
  return BinaryXmlWireFormat.decodeData(data, decoder);
};

/**
 * @deprecated Use decodeData(data, input).
 */
BinaryXmlWireFormat.prototype.decodeContentObject = function(data, input) 
{
  this.decodeData(data, input);
};

/**
 * Get a singleton instance of a BinaryXmlWireFormat.  Assuming that the default 
 * wire format was set with 
 * WireFormat.setDefaultWireFormat(BinaryXmlWireFormat.get()), you can check if 
 * this is the default wire encoding with
 * if WireFormat.getDefaultWireFormat() == BinaryXmlWireFormat.get().
 * @returns {BinaryXmlWireFormat} The singleton instance.
 */
BinaryXmlWireFormat.get = function()
{
  if (BinaryXmlWireFormat.instance === null)
    BinaryXmlWireFormat.instance = new BinaryXmlWireFormat();
  return BinaryXmlWireFormat.instance;
};

/**
 * Encode the interest by calling the operations on the encoder.
 * @param {Interest} interest
 * @param {BinaryXMLEncoder} encoder
 */
BinaryXmlWireFormat.encodeInterest = function(interest, encoder) 
{
  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);
    
  interest.name.to_ndnb(encoder);
  
  if (null != interest.minSuffixComponents) 
    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);  

  if (null != interest.maxSuffixComponents) 
    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);

  if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && 
      interest.getKeyLocator().getKeyData() != null &&
      interest.getKeyLocator().getKeyData().length > 0)
    // There is a KEY_LOCATOR_DIGEST. Use this instead of the publisherPublicKeyDigest.
    encoder.writeDTagElement
      (NDNProtocolDTags.PublisherPublicKeyDigest, 
       interest.getKeyLocator().getKeyData());
  else {
    if (null != interest.publisherPublicKeyDigest)
      interest.publisherPublicKeyDigest.to_ndnb(encoder);
  }
    
  if (null != interest.exclude)
    interest.exclude.to_ndnb(encoder);
    
  if (null != interest.childSelector) 
    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);

  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null) 
    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);
    
  if (null != interest.scope) 
    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);
    
  if (null != interest.interestLifetime) 
    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime, 
                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));
    
  if (null != interest.nonce)
    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);
    
  encoder.writeElementClose();
};

/**
 * Use the decoder to place the result in interest.
 * @param {Interest} interest
 * @param {BinaryXMLDecoder} decoder
 */
BinaryXmlWireFormat.decodeInterest = function(interest, decoder) 
{
  decoder.readElementStartDTag(NDNProtocolDTags.Interest);

  interest.name = new Name();
  interest.name.from_ndnb(decoder);

  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))
    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);
  else
    interest.minSuffixComponents = null;

  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents)) 
    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);
  else
    interest.maxSuffixComponents = null;
      
  // Initially clear the keyLocator.
  interest.getKeyLocator().clear();
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();
    interest.publisherPublicKeyDigest.from_ndnb(decoder);
  }
  else
    interest.publisherPublicKeyDigest = null;
  if (interest.publisherPublicKeyDigest != null &&
      interest.publisherPublicKeyDigest.publisherPublicKeyDigest != null &&
      interest.publisherPublicKeyDigest.publisherPublicKeyDigest.length > 0) {
    // We keep the deprecated publisherPublicKeyDigest for backwards 
    //   compatibility.  Also set the key locator.
    interest.getKeyLocator().setType(KeyLocatorType.KEY_LOCATOR_DIGEST);
    interest.getKeyLocator().setKeyData
      (interest.publisherPublicKeyDigest.publisherPublicKeyDigest);
  }

  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {
    interest.exclude = new Exclude();
    interest.exclude.from_ndnb(decoder);
  }
  else
    interest.exclude = null;
    
  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))
    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);
  else
    interest.childSelector = null;
    
  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))
    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);
  else
    interest.answerOriginKind = null;
    
  if (decoder.peekDTag(NDNProtocolDTags.Scope))
    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);
  else
    interest.scope = null;

  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))
    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt
               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;
  else
    interest.interestLifetime = null;              
    
  if (decoder.peekDTag(NDNProtocolDTags.Nonce))
    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);
  else
    interest.nonce = null;
    
  decoder.readElementClose();
};

/**
 * Encode the data by calling the operations on the encoder.
 * @param {Data} data
 * @param {BinaryXMLEncoder} encoder
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 */
BinaryXmlWireFormat.encodeData = function(data, encoder)  
{
  //TODO verify name, MetaInfo and Signature is present
  encoder.writeElementStartDTag(data.getElementLabel());

  if (null != data.signature) 
    data.signature.to_ndnb(encoder);
    
  var signedPortionBeginOffset = encoder.offset;

  if (null != data.name) 
    data.name.to_ndnb(encoder);
  
  if (null != data.signedInfo) 
    // Use getSignatureOrMetaInfoKeyLocator for the transition of moving
    //   the key locator from the MetaInfo to the Signauture object.
    data.signedInfo.to_ndnb(encoder, data.getSignatureOrMetaInfoKeyLocator());

  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);
  
  var signedPortionEndOffset = encoder.offset;
  
  encoder.writeElementClose();
  
  return { signedPortionBeginOffset: signedPortionBeginOffset, 
           signedPortionEndOffset: signedPortionEndOffset };  
};

/**
 * Use the decoder to place the result in data.
 * @param {Data} data
 * @param {BinaryXMLDecoder} decoder
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 */
BinaryXmlWireFormat.decodeData = function(data, decoder) 
{
  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT
  decoder.readElementStartDTag(data.getElementLabel());

  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {
    data.signature = new Signature();
    data.signature.from_ndnb(decoder);
  }
  else
    data.signature = null;
    
  var signedPortionBeginOffset = decoder.offset;

  data.name = new Name();
  data.name.from_ndnb(decoder);
    
  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {
    data.signedInfo = new MetaInfo();
    data.signedInfo.from_ndnb(decoder);
    if (data.signedInfo.locator != null && data.getSignature() != null)
      // Copy the key locator pointer to the Signature object for the transition 
      //   of moving the key locator from the MetaInfo to the Signature object.
      data.getSignature().keyLocator = data.signedInfo.locator;
  }
  else
    data.signedInfo = null;

  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);
    
  var signedPortionEndOffset = decoder.offset;
    
  decoder.readElementClose();
    
  return { signedPortionBeginOffset: signedPortionBeginOffset, 
           signedPortionEndOffset: signedPortionEndOffset };  
};

},{"../exclude.js":63,"../key-locator.js":69,"../meta-info.js":72,"../name.js":73,"../publisher-public-key-digest.js":75,"../signature.js":77,"../util/blob.js":79,"../util/ndn-protoco-id-tags.js":82,"./binary-xml-decoder.js":48,"./binary-xml-encoder.js":49,"./data-utils.js":52,"./wire-format.js":62}],52:[function(require,module,exports){
/**
 * This class contains utilities to help parse the data
 *
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer

/**
 * A DataUtils has static methods for converting data.
 * @constructor
 */


var DataUtils = function()
{
};

exports.DataUtils = new DataUtils();

/*
 * NOTE THIS IS CURRENTLY NOT BEING USED
 *
 */

DataUtils.prototype.keyStr = "ABCDEFGHIJKLMNOP" +
                   "QRSTUVWXYZabcdef" +
                   "ghijklmnopqrstuv" +
                   "wxyz0123456789+/" +
                   "=";

/**
 * Raw String to Base 64
 */
DataUtils.prototype.stringtoBase64 = function stringtoBase64(input)
{
   //input = escape(input);
   var output = "";
   var chr1, chr2, chr3 = "";
   var enc1, enc2, enc3, enc4 = "";
   var i = 0;

   do {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);

    enc1 = chr1 >> 2;
    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
    enc4 = chr3 & 63;

    if (isNaN(chr2))
       enc3 = enc4 = 64;
    else if (isNaN(chr3))
       enc4 = 64;

    output = output +
       DataUtils.keyStr.charAt(enc1) +
       DataUtils.keyStr.charAt(enc2) +
       DataUtils.keyStr.charAt(enc3) +
       DataUtils.keyStr.charAt(enc4);
    chr1 = chr2 = chr3 = "";
    enc1 = enc2 = enc3 = enc4 = "";
   } while (i < input.length);

   return output;
};

/**
 * Base 64 to Raw String
 */
DataUtils.prototype.base64toString = function base64toString(input)
{
  var output = "";
  var chr1, chr2, chr3 = "";
  var enc1, enc2, enc3, enc4 = "";
  var i = 0;

  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  var base64test = /[^A-Za-z0-9\+\/\=]/g;
  /* Test for invalid characters. */
  if (base64test.exec(input)) {
    alert("There were invalid base64 characters in the input text.\n" +
          "Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\n" +
          "Expect errors in decoding.");
  }

  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

  do {
    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));
    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));
    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));
    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 != 64)
      output = output + String.fromCharCode(chr2);

    if (enc4 != 64)
      output = output + String.fromCharCode(chr3);

    chr1 = chr2 = chr3 = "";
    enc1 = enc2 = enc3 = enc4 = "";
  } while (i < input.length);

  return output;
};

/**
 * customBuf to Hex String
 */
DataUtils.prototype.toHex = function(buffer)
{
  return buffer.toString('hex');
};

/**
 * Raw string to hex string.
 */
DataUtils.prototype.stringToHex = function(args)
{
  var ret = "";
  for (var i = 0; i < args.length; ++i) {
    var value = args.charCodeAt(i);
    ret += (value < 16 ? "0" : "") + value.toString(16);
  }
  return ret;
};

/**
 * customBuf to raw string.
 */
DataUtils.prototype.toString = function(buffer)
{
  return buffer.toString('binary');
};

/**
 * Hex String to customBuf.
 */
DataUtils.prototype.toNumbers = function(str)
{
  return new customBuf(str, 'hex');
};

/**
 * Hex String to raw string.
 */
DataUtils.prototype.hexToRawString = function(str)
{
  if (typeof str =='string') {
  var ret = "";
  str.replace(/(..)/g, function(s) {
    ret += String.fromCharCode(parseInt(s, 16));
  });
  return ret;
  }
};

/**
 * Raw String to customBuf.
 */
DataUtils.prototype.toNumbersFromString = function(str)
{
  return new customBuf(str, 'binary');
};

/**
 * Encode str as utf8 and return as customBuf.
 * If value is a string, then interpret it as a raw string and convert to
 * a Buffer. Otherwise assume it is a Buffer or array type and just return it.
 * @param {string|any} value
 * @returns {Buffer}
 */
DataUtils.prototype.toNumbersIfString = function(value)
{
  if (typeof value === 'string')
    return new customBuf(value, 'binary');
  else
    return value;
};

/**
 * Encode str as utf8 and return as Buffer.
 */
DataUtils.prototype.stringToUtf8Array = function(str)
{
  return new customBuf(str, 'utf8');
};

/**
 * arrays is an array of customBuf. Return a new customBuf which is the concatenation of all.
 */
DataUtils.prototype.concatArrays = function(arrays)
{
  return customBuf.concat(arrays);
};

// TODO: Take customBuf and use TextDecoder when available.
DataUtils.prototype.decodeUtf8 = function(utftext)
{
  var string = "";
  var i = 0;
  var c = 0;
    var c1 = 0;
    var c2 = 0;

  while (i < utftext.length) {
    c = utftext.charCodeAt(i);

    if (c < 128) {
      string += String.fromCharCode(c);
      i++;
    }
    else if (c > 191 && c < 224) {
      c2 = utftext.charCodeAt(i + 1);
      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
      i += 2;
    }
    else {
      c2 = utftext.charCodeAt(i+1);
      var c3 = utftext.charCodeAt(i+2);
      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      i += 3;
    }
  }

  return string;
};

/**
 * Return true if a1 and a2 are the same length with equal elements.
 */
DataUtils.prototype.arraysEqual = function(a1, a2)
{
  // A simple sanity check that it is an array.
  if (!a1.slice)
    throw new Error("DataUtils.arraysEqual: a1 is not an array");
  if (!a2.slice)
    throw new Error("DataUtils.arraysEqual: a2 is not an array");

  if (a1.length != a2.length)
    return false;

  for (var i = 0; i < a1.length; ++i) {
    if (a1[i] != a2[i])
      return false;
  }

  return true;
};

/**
 * Convert the big endian customBuf to an unsigned int.
 * Don't check for overflow.
 */
DataUtils.prototype.bigEndianToUnsignedInt = function(bytes)
{
  var result = 0;
  for (var i = 0; i < bytes.length; ++i) {
    result <<= 8;
    result += bytes[i];
  }
  return result;
};

/**
 * Convert the int value to a new big endian customBuf and return.
 * If value is 0 or negative, return new customBuf(0).
 */
DataUtils.prototype.nonNegativeIntToBigEndian = function(value)
{
  value = Math.round(value);
  if (value <= 0)
    return new customBuf(0);

  // Assume value is not over 64 bits.
  var size = 8;
  var result = new customBuf(size);
  var i = 0;
  while (value != 0) {
    ++i;
    result[size - i] = value & 0xff;
    value >>= 8;
  }
  return result.slice(size - i, size);
};

/**
 * Modify array to randomly shuffle the elements.
 */
DataUtils.prototype.shuffle = function(array)
{
  for (var i = array.length - 1; i >= 1; --i) {
    // j is from 0 to i.
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
};

},{"../buffer.js":45}],53:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * Create a new DecodingException wrapping the given error object.
 * Call with: throw new DecodingException(new Error("message")).
 * @constructor
 * @param {string} error The exception created with new Error.
 */
function DecodingException(error) 
{
  this.message = error.message;
  // Copy lineNumber, etc. from where new Error was called.
  for (var prop in error)
      this[prop] = error[prop];
}
DecodingException.prototype = new Error();
DecodingException.prototype.name = "DecodingException";

exports.DecodingException = DecodingException;

},{}],54:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var customBuf = require('../buffer.js').Buffer
var DataUtils = require('./data-utils.js').DataUtils;
var BinaryXMLStructureDecoder = require('./binary-xml-structure-decoder.js').BinaryXMLStructureDecoder;
var Tlv = require('./tlv/tlv.js').Tlv;
var TlvStructureDecoder = require('./tlv/tlv-structure-decoder.js').TlvStructureDecoder;
var LOG = require('../log.js').Log.LOG;

/**
 * A ElementReader lets you call onReceivedData multiple times which uses a
 * BinaryXMLStructureDecoder or TlvStructureDecoder to detect the end of a
 * binary XML or TLV element and calls elementListener.onReceivedElement(element)
 * with the element.  This handles the case where a single call to
 * onReceivedData may contain multiple elements.
 * @constructor
 * @param {{onReceivedElement:function}} elementListener
 */
var ElementReader = function ElementReader(elementListener)
{
  this.elementListener = elementListener;
  this.dataParts = [];
  this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();
  this.tlvStructureDecoder = new TlvStructureDecoder();
  this.useTlv = null;
};

exports.ElementReader = ElementReader;

ElementReader.prototype.onReceivedData = function(/* customBuf */ data)
{
  // Process multiple objects in the data.
  while (true) {
    if (this.dataParts.length == 0) {
      // This is the beginning of an element.  Check whether it is binaryXML or TLV.
      if (data.length <= 0)
        // Wait for more data.
        return;

      // The type codes for TLV Interest and Data packets are chosen to not
      //   conflict with the first byte of a binary XML packet, so we can
      //   just look at the first byte.
      if (data[0] == Tlv.Interest || data[0] == Tlv.Data || data[0] == 0x80)
        this.useTlv = true;
      else
        // Binary XML.
        this.useTlv = false;
    }

    var gotElementEnd;
    var offset;
    if (this.useTlv) {
      // Scan the input to check if a whole TLV object has been read.
      this.tlvStructureDecoder.seek(0);
      gotElementEnd = this.tlvStructureDecoder.findElementEnd(data);
      offset = this.tlvStructureDecoder.getOffset();
    }
    else {
      // Scan the input to check if a whole Binary XML object has been read.
      this.binaryXmlStructureDecoder.seek(0);
      gotElementEnd = this.binaryXmlStructureDecoder.findElementEnd(data);
      offset = this.binaryXmlStructureDecoder.offset;
    }

    if (gotElementEnd) {
      // Got the remainder of an object.  Report to the caller.
      this.dataParts.push(data.slice(0, offset));
      var element = DataUtils.concatArrays(this.dataParts);
      this.dataParts = [];
      try {
        this.elementListener.onReceivedElement(element);
      } catch (ex) {
          console.log("ElementReader: ignoring exception from onReceivedElement: " , ex);
      }

      // Need to read a new object.
      data = data.slice(offset, data.length);
      this.binaryXmlStructureDecoder = new BinaryXMLStructureDecoder();
      this.tlvStructureDecoder = new TlvStructureDecoder();
      if (data.length == 0)
        // No more data in the packet.
        return;

      // else loop back to decode.
    }
    else {
      // Save for a later call to concatArrays so that we only copy data once.
      this.dataParts.push(data);
      if (LOG > 3) console.log('Incomplete packet received. Length ' + data.length + '. Wait for more input.');
        return;
    }
  }
};

},{"../buffer.js":45,"../log.js":71,"./binary-xml-structure-decoder.js":50,"./data-utils.js":52,"./tlv/tlv-structure-decoder.js":60,"./tlv/tlv.js":61}],55:[function(require,module,exports){
/**
 * This file contains utilities to help encode and decode NDN objects.
 * Copyright (C) 2013-2014 Regents of the University of California.
 * author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */

var DataUtils = require('./data-utils.js').DataUtils;
var BinaryXMLEncoder = require('./binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./binary-xml-decoder.js').BinaryXMLDecoder;
var Key = require('../key.js').Key;
var KeyLocatorType = require('../key-locator.js').KeyLocatorType;
var Interest = require('../interest.js').Interest;
var Data = require('../data.js').Data;
var FaceInstance = require('../face-instance.js').FaceInstance;
var ForwardingEntry = require('../forwarding-entry.js').ForwardingEntry;
var WireFormat = require('./wire-format.js').WireFormat;
var LOG = require('../log.js').Log.LOG;

/**
 * An EncodingUtils has static methods for encoding data.
 * @constructor
 */
var EncodingUtils = function EncodingUtils() 
{
};

exports.EncodingUtils = EncodingUtils;

EncodingUtils.encodeToHexInterest = function(interest, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  return DataUtils.toHex(interest.wireEncode(wireFormat).buf());
};

EncodingUtils.encodeToHexData = function(data, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  return DataUtils.toHex(data.wireEncode(wireFormat).buf());
};

/**
 * @deprecated Use EncodingUtils.encodeToHexData(data).
 */
EncodingUtils.encodeToHexContentObject = function(data, wireFormat) 
{
  return EncodingUtils.encodeToHexData(data, wireFormat);
}

EncodingUtils.encodeForwardingEntry = function(data) 
{
  var enc = new BinaryXMLEncoder();
  data.to_ndnb(enc);
  var bytes = enc.getReducedOstream();

  return bytes;
};

EncodingUtils.decodeHexFaceInstance = function(result) 
{  
  var numbers = DataUtils.toNumbers(result); 
  var decoder = new BinaryXMLDecoder(numbers);
  
  if (LOG > 3) console.log('DECODING HEX FACE INSTANCE  \n'+numbers);

  var faceInstance = new FaceInstance();
  faceInstance.from_ndnb(decoder);
  
  return faceInstance;
};

EncodingUtils.decodeHexInterest = function(input, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  var interest = new Interest();
  interest.wireDecode(DataUtils.toNumbers(input), wireFormat);
  return interest;
};

EncodingUtils.decodeHexData = function(input, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  var data = new Data();
  data.wireDecode(DataUtils.toNumbers(input), wireFormat);
  return data;
};

/**
 * @deprecated Use EncodingUtils.decodeHexData(input).
 */
EncodingUtils.decodeHexContentObject = function(input, wireFormat) 
{
  return EncodingUtils.decodeHexData(input, wireFormat);
}

EncodingUtils.decodeHexForwardingEntry = function(result) 
{
  var numbers = DataUtils.toNumbers(result);
  var decoder = new BinaryXMLDecoder(numbers);
  
  if (LOG > 3) console.log('DECODED HEX FORWARDING ENTRY \n'+numbers);
  
  var forwardingEntry = new ForwardingEntry();
  forwardingEntry.from_ndnb(decoder);
  return forwardingEntry;
};

/**
 * Decode the customBuf array which holds SubjectPublicKeyInfo and return an RSAKey.
 */
EncodingUtils.decodeSubjectPublicKeyInfo = function(array) 
{
  var hex = DataUtils.toHex(array).toLowerCase();
  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));
  var rsaKey = new RSAKey();
  rsaKey.setPublic(a[0], a[1]);
  return rsaKey;
}

/**
 * Return a user friendly HTML string with the contents of data.
 * This also outputs to console.log.
 */
EncodingUtils.dataToHtml = function(/* Data */ data) 
{
  var output ="";
      
  if (data == -1)
    output+= "NO CONTENT FOUND"
  else if (data == -2)
    output+= "CONTENT NAME IS EMPTY"
  else {
    if (data.name != null && data.name.components != null) {
      output+= "NAME: " + data.name.toUri();
        
      output+= "<br />";
      output+= "<br />";
    }
    if (data.content != null) {
      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.content != null) {
      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signature != null && data.signature.digestAlgorithm != null) {
      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signature != null && data.signature.witness != null) {
      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signature != null && data.signature.signature != null) {
      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {
      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);
      
      output+= "<br />";
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.timestamp != null) {
      var d = new Date();
      d.setTime(data.signedInfo.timestamp.msec);
      
      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];
      
      output += "TimeStamp: "+d;
      output+= "<br />";
      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;
      
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {
      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {
      output += "keyLocator: ";
      if (data.signedInfo.locator.type == KeyLocatorType.KEY)
        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";
      else if (data.signedInfo.locator.type == KeyLocatorType.KEY_LOCATOR_DIGEST)
        output += "KeyLocatorDigest: " + DataUtils.toHex(data.signedInfo.locator.getKeyData()).toLowerCase() + "<br />";
      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)
        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";
      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)
        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";
      else
        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";      
    }
  }

  return output;
};

/**
 * @deprecated Use return EncodingUtils.dataToHtml(data).
 */
EncodingUtils.contentObjectToHtml = function(data) 
{
  return EncodingUtils.dataToHtml(data);
}

//
// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.
//

var encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }
var encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }
var encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }
var decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }
var decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }
var decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }
var decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }
var decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }
var contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }

/**
 * @deprecated Use interest.wireEncode().
 */
function encodeToBinaryInterest(interest) { return interest.wireEncode().buf(); }
/**
 * @deprecated Use data.wireEncode().
 */
function encodeToBinaryContentObject(data) { return data.wireEncode().buf(); }

},{"../data.js":47,"../face-instance.js":64,"../forwarding-entry.js":66,"../interest.js":68,"../key-locator.js":69,"../key.js":70,"../log.js":71,"./binary-xml-decoder.js":48,"./binary-xml-encoder.js":49,"./data-utils.js":52,"./wire-format.js":62}],56:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var crypto = require('../crypto.js');
var Blob = require('../util/blob.js').Blob;
var Tlv = require('./tlv/tlv.js').Tlv;
var TlvEncoder = require('./tlv/tlv-encoder.js').TlvEncoder;
var TlvDecoder = require('./tlv/tlv-decoder.js').TlvDecoder;
var WireFormat = require('./wire-format.js').WireFormat;
var Exclude = require('../exclude.js').Exclude;
var ContentType = require('../meta-info.js').ContentType;
var KeyLocatorType = require('../key-locator.js').KeyLocatorType;
var Signature = require('../signature.js').Signature;
var DecodingException = require('./decoding-exception.js').DecodingException;

/**
 * A Tlv0_1a2WireFormat implements the WireFormat interface for encoding and 
 * decoding with the NDN-TLV wire format, version 0.1a2
 * @constructor
 */
var Tlv0_1a2WireFormat = function Tlv0_1a2WireFormat() 
{
  // Inherit from WireFormat.
  WireFormat.call(this);
};

Tlv0_1a2WireFormat.prototype = new WireFormat();
Tlv0_1a2WireFormat.prototype.name = "Tlv0_1a2WireFormat";

exports.Tlv0_1a2WireFormat = Tlv0_1a2WireFormat;

// Default object.
Tlv0_1a2WireFormat.instance = null;

/**
 * Encode the interest using NDN-TLV and return a customBuf.
 * @param {Interest} interest The Interest object to encode.
 * @returns {Blob} A Blob containing the encoding.
 */
Tlv0_1a2WireFormat.prototype.encodeInterest = function(interest) 
{
  var encoder = new TlvEncoder();
  var saveLength = encoder.getLength();
  
  // Encode backwards.
  encoder.writeOptionalNonNegativeIntegerTlv
    (Tlv.InterestLifetime, interest.getInterestLifetimeMilliseconds());
  encoder.writeOptionalNonNegativeIntegerTlv(Tlv.Scope, interest.getScope());
  
  // Encode the Nonce as 4 bytes.
  if (interest.getNonce() == null || interest.getNonce().length == 0)
    // This is the most common case. Generate a nonce.
    encoder.writeBlobTlv(Tlv.Nonce, require("../crypto.js").randomBytes(4));
  else if (interest.getNonce().length < 4) {
    var nonce = customBuf(4);
    // Copy existing nonce bytes.
    interest.getNonce().copy(nonce);

    // Generate random bytes for remaining bytes in the nonce.
    for (var i = interest.getNonce().length; i < 4; ++i)
      nonce[i] = require("crypto").randomBytes(1)[0];

    encoder.writeBlobTlv(Tlv.Nonce, nonce);
  }
  else if (interest.getNonce().length == 4)
    // Use the nonce as-is.
    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce());
  else
    // Truncate.
    encoder.writeBlobTlv(Tlv.Nonce, interest.getNonce().slice(0, 4));
  
  Tlv0_1a2WireFormat.encodeSelectors(interest, encoder);
  Tlv0_1a2WireFormat.encodeName(interest.getName(), encoder);
  
  encoder.writeTypeAndLength(Tlv.Interest, encoder.getLength() - saveLength);
      
  return new Blob(encoder.getOutput(), false);
};

/**
 * Decode input as an NDN-TLV interest and set the fields of the interest 
 * object.  
 * @param {Interest} interest The Interest object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 */
Tlv0_1a2WireFormat.prototype.decodeInterest = function(interest, input) 
{
  var decoder = new TlvDecoder(input);

  var endOffset = decoder.readNestedTlvsStart(Tlv.Interest);
  Tlv0_1a2WireFormat.decodeName(interest.getName(), decoder);
  if (decoder.peekType(Tlv.Selectors, endOffset))
    Tlv0_1a2WireFormat.decodeSelectors(interest, decoder);
  // Require a Nonce, but don't force it to be 4 bytes.
  var nonce = decoder.readBlobTlv(Tlv.Nonce);
  interest.setScope(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.Scope, endOffset));
  interest.setInterestLifetimeMilliseconds
    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.InterestLifetime, endOffset));

  // Set the nonce last because setting other interest fields clears it.
  interest.setNonce(nonce);

  decoder.finishNestedTlvs(endOffset);
};

/**
 * Encode data as NDN-TLV and return the encoding and signed offsets.
 * @param {Data} data The Data object to encode.
 * @returns {object with (Blob, int, int)} An associative array with fields
 * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding 
 * is a Blob containing the encoding, signedPortionBeginOffset is the offset in 
 * the encoding of the beginning of the signed portion, and 
 * signedPortionEndOffset is the offset in the encoding of the end of the 
 * signed portion.
 */
Tlv0_1a2WireFormat.prototype.encodeData = function(data) 
{
  var encoder = new TlvEncoder(1500);
  var saveLength = encoder.getLength();
  
  // Encode backwards.
  // TODO: The library needs to handle other signature types than 
  //   SignatureSha256WithRsa.
  encoder.writeBlobTlv(Tlv.SignatureValue, data.getSignature().getSignature());
  var signedPortionEndOffsetFromBack = encoder.getLength();

  // Use getSignatureOrMetaInfoKeyLocator for the transition of moving
  //   the key locator from the MetaInfo to the Signauture object.
  Tlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue
    (data.getSignature(), encoder, data.getSignatureOrMetaInfoKeyLocator());
  encoder.writeBlobTlv(Tlv.Content, data.getContent());
  Tlv0_1a2WireFormat.encodeMetaInfo(data.getMetaInfo(), encoder);
  Tlv0_1a2WireFormat.encodeName(data.getName(), encoder);
  var signedPortionBeginOffsetFromBack = encoder.getLength();

  encoder.writeTypeAndLength(Tlv.Data, encoder.getLength() - saveLength);
  var signedPortionBeginOffset = 
    encoder.getLength() - signedPortionBeginOffsetFromBack;
  var signedPortionEndOffset = encoder.getLength() - signedPortionEndOffsetFromBack;

  return { encoding: new Blob(encoder.getOutput(), false),
           signedPortionBeginOffset: signedPortionBeginOffset, 
           signedPortionEndOffset: signedPortionEndOffset };  
};

/**
 * Decode input as an NDN-TLV data packet, set the fields in the data object, 
 * and return the signed offsets. 
 * @param {Data} data The Data object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 */
Tlv0_1a2WireFormat.prototype.decodeData = function(data, input) 
{
  var decoder = new TlvDecoder(input);

  var endOffset = decoder.readNestedTlvsStart(Tlv.Data);
  var signedPortionBeginOffset = decoder.getOffset();

  Tlv0_1a2WireFormat.decodeName(data.getName(), decoder);
  Tlv0_1a2WireFormat.decodeMetaInfo(data.getMetaInfo(), decoder);
  data.setContent(decoder.readBlobTlv(Tlv.Content));
  Tlv0_1a2WireFormat.decodeSignatureInfo(data, decoder);
  if (data.getSignature() != null && 
      data.getSignature().getKeyLocator() != null && 
      data.getMetaInfo() != null)
    // Copy the key locator pointer to the MetaInfo object for the transition of 
    //   moving the key locator from the MetaInfo to the Signature object.
    data.getMetaInfo().locator = data.getSignature().getKeyLocator();

  var signedPortionEndOffset = decoder.getOffset();
  // TODO: The library needs to handle other signature types than 
  //   SignatureSha256WithRsa.
  data.getSignature().setSignature(decoder.readBlobTlv(Tlv.SignatureValue));

  decoder.finishNestedTlvs(endOffset);
  return { signedPortionBeginOffset: signedPortionBeginOffset, 
           signedPortionEndOffset: signedPortionEndOffset };  
};

/**
 * Get a singleton instance of a Tlv1_0a2WireFormat.  To always use the
 * preferred version NDN-TLV, you should use TlvWireFormat.get().
 * @returns {Tlv0_1a2WireFormat} The singleton instance.
 */
Tlv0_1a2WireFormat.get = function()
{
  if (Tlv0_1a2WireFormat.instance === null)
    Tlv0_1a2WireFormat.instance = new Tlv0_1a2WireFormat();
  return Tlv0_1a2WireFormat.instance;
};

Tlv0_1a2WireFormat.encodeName = function(name, encoder)
{
  var saveLength = encoder.getLength();

  // Encode the components backwards.
  for (var i = name.size() - 1; i >= 0; --i)
    encoder.writeBlobTlv(Tlv.NameComponent, name.get(i).getValue());

  encoder.writeTypeAndLength(Tlv.Name, encoder.getLength() - saveLength);
};
        
Tlv0_1a2WireFormat.decodeName = function(name, decoder)
{
  name.clear();
  
  var endOffset = decoder.readNestedTlvsStart(Tlv.Name);      
  while (decoder.getOffset() < endOffset)
      name.append(decoder.readBlobTlv(Tlv.NameComponent));

  decoder.finishNestedTlvs(endOffset);
};

/**
 * Encode the interest selectors.  If no selectors are written, do not output a 
 * Selectors TLV.
 */
Tlv0_1a2WireFormat.encodeSelectors = function(interest, encoder)
{
  var saveLength = encoder.getLength();

  // Encode backwards.
  if (interest.getMustBeFresh())
    encoder.writeTypeAndLength(Tlv.MustBeFresh, 0);
  encoder.writeOptionalNonNegativeIntegerTlv(
    Tlv.ChildSelector, interest.getChildSelector());
  if (interest.getExclude().size() > 0)
    Tlv0_1a2WireFormat.encodeExclude(interest.getExclude(), encoder);
  
  if (interest.getKeyLocator().getType() != null)
    Tlv0_1a2WireFormat.encodeKeyLocator(interest.getKeyLocator(), encoder);
  else {
    // There is no keyLocator. If there is a publisherPublicKeyDigest, then 
    //   encode as KEY_LOCATOR_DIGEST. (When we remove the deprecated 
    //   publisherPublicKeyDigest, we don't need this.)
    if (null != interest.publisherPublicKeyDigest) {
      var savePublisherPublicKeyDigestLength = encoder.getLength();
      encoder.writeBlobTlv
        (Tlv.KeyLocatorDigest, 
         interest.publisherPublicKeyDigest.publisherPublicKeyDigest);
      encoder.writeTypeAndLength
        (Tlv.KeyLocator, encoder.getLength() - savePublisherPublicKeyDigestLength);
    }
  }
  
  encoder.writeOptionalNonNegativeIntegerTlv(
    Tlv.MaxSuffixComponents, interest.getMaxSuffixComponents());
  encoder.writeOptionalNonNegativeIntegerTlv(
    Tlv.MinSuffixComponents, interest.getMinSuffixComponents());

  // Only output the type and length if values were written.
  if (encoder.getLength() != saveLength)
    encoder.writeTypeAndLength(Tlv.Selectors, encoder.getLength() - saveLength);
};

Tlv0_1a2WireFormat.decodeSelectors = function(interest, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.Selectors);

  interest.setMinSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.MinSuffixComponents, endOffset));
  interest.setMaxSuffixComponents(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.MaxSuffixComponents, endOffset));

  // Initially set publisherPublicKeyDigest to none.
  interest.publisherPublicKeyDigest = null;
  if (decoder.peekType(Tlv.KeyLocator, endOffset)) {
    Tlv0_1a2WireFormat.decodeKeyLocator(interest.getKeyLocator(), decoder);
    if (interest.getKeyLocator().getType() == KeyLocatorType.KEY_LOCATOR_DIGEST) {
      // For backwards compatibility, also set the publisherPublicKeyDigest.
      interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();
      interest.publisherPublicKeyDigest.publisherPublicKeyDigest =
        interest.getKeyLocator().getKeyData();
    }
  }
  else
    interest.getKeyLocator().clear();

  if (decoder.peekType(Tlv.Exclude, endOffset))
    Tlv0_1a2WireFormat.decodeExclude(interest.getExclude(), decoder);
  else
    interest.getExclude().clear();

  interest.setChildSelector(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.ChildSelector, endOffset));
  interest.setMustBeFresh(decoder.readBooleanTlv(Tlv.MustBeFresh, endOffset));

  decoder.finishNestedTlvs(endOffset);
};
  
Tlv0_1a2WireFormat.encodeExclude = function(exclude, encoder)
{
  var saveLength = encoder.getLength();

  // TODO: Do we want to order the components (except for ANY)?
  // Encode the entries backwards.
  for (var i = exclude.size() - 1; i >= 0; --i) {
    var entry = exclude.get(i);

    if (entry == Exclude.ANY)
      encoder.writeTypeAndLength(Tlv.Any, 0);
    else
      encoder.writeBlobTlv(Tlv.NameComponent, entry.getValue());
  }
  
  encoder.writeTypeAndLength(Tlv.Exclude, encoder.getLength() - saveLength);
};
  
Tlv0_1a2WireFormat.decodeExclude = function(exclude, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.Exclude);

  exclude.clear();
  while (true) {
    if (decoder.peekType(Tlv.NameComponent, endOffset))
      exclude.appendComponent(decoder.readBlobTlv(Tlv.NameComponent));
    else if (decoder.readBooleanTlv(Tlv.Any, endOffset))
      exclude.appendAny();
    else
      // Else no more entries.
      break;
  }
  
  decoder.finishNestedTlvs(endOffset);
};

Tlv0_1a2WireFormat.encodeKeyLocator = function(keyLocator, encoder)
{
  var saveLength = encoder.getLength();

  // Encode backwards.
  if (keyLocator.getType() != null) {
    if (keyLocator.getType() == KeyLocatorType.KEYNAME)
      Tlv0_1a2WireFormat.encodeName(keyLocator.getKeyName(), encoder);
    else if (keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST &&
             keyLocator.getKeyData().length > 0)
      encoder.writeBlobTlv(Tlv.KeyLocatorDigest, keyLocator.getKeyData());
    else
      throw new Error("Unrecognized KeyLocatorType " + keyLocator.getType());
  }
  
  encoder.writeTypeAndLength(Tlv.KeyLocator, encoder.getLength() - saveLength);
};

Tlv0_1a2WireFormat.decodeKeyLocator = function(keyLocator, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.KeyLocator);

  keyLocator.clear();

  if (decoder.getOffset() == endOffset)
    // The KeyLocator is omitted, so leave the fields as none.
    return;

  if (decoder.peekType(Tlv.Name, endOffset)) {
    // KeyLocator is a Name.
    keyLocator.setType(KeyLocatorType.KEYNAME);
    Tlv0_1a2WireFormat.decodeName(keyLocator.getKeyName(), decoder);
  }
  else if (decoder.peekType(Tlv.KeyLocatorDigest, endOffset)) {
    // KeyLocator is a KeyLocatorDigest.
    keyLocator.setType(KeyLocatorType.KEY_LOCATOR_DIGEST);
    keyLocator.setKeyData(decoder.readBlobTlv(Tlv.KeyLocatorDigest));
  }
  else
    throw new DecodingException
      ("decodeKeyLocator: Unrecognized key locator type");

  decoder.finishNestedTlvs(endOffset);
};

/**
 * Encode the signature object in TLV, using the given keyLocator instead of the
 * locator in this object.
 * @param {Signature} signature The Signature object to encode.
 * @param {TlvEncoder} encoder The encoder.
 * @param {KeyLocator} keyLocator The key locator to use (from 
 * Data.getSignatureOrMetaInfoKeyLocator).
 */
Tlv0_1a2WireFormat.encodeSignatureSha256WithRsaValue = function
  (signature, encoder, keyLocator)
{
  var saveLength = encoder.getLength();

  // Encode backwards.
  Tlv0_1a2WireFormat.encodeKeyLocator(keyLocator, encoder);
  encoder.writeNonNegativeIntegerTlv
    (Tlv.SignatureType, Tlv.SignatureType_SignatureSha256WithRsa);

  encoder.writeTypeAndLength(Tlv.SignatureInfo, encoder.getLength() - saveLength);
};

Tlv0_1a2WireFormat.decodeSignatureInfo = function(data, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.SignatureInfo);

  var signatureType = decoder.readNonNegativeIntegerTlv(Tlv.SignatureType);
  // TODO: The library needs to handle other signature types than 
  //     SignatureSha256WithRsa.
  if (signatureType == Tlv.SignatureType_SignatureSha256WithRsa) {
      var signature = {}
      signature.sig = Signature
      data.setSignature(signature.sig());
      // Modify data's signature object because if we create an object
      //   and set it, then data will have to copy all the fields.
      var signatureInfo = data.getSignature();
      Tlv0_1a2WireFormat.decodeKeyLocator
        (signatureInfo.getKeyLocator(), decoder);
  }
  else
      throw new DecodingException
       ("decodeSignatureInfo: unrecognized SignatureInfo type" + signatureType);

  decoder.finishNestedTlvs(endOffset);
};

Tlv0_1a2WireFormat.encodeMetaInfo = function(metaInfo, encoder)
{
  var saveLength = encoder.getLength();

  // Encode backwards.
  // TODO: finalBlockID should be a Name.Component, not customBuf.
  var finalBlockIdBuf = metaInfo.getFinalBlockID();
  if (finalBlockIdBuf != null && finalBlockIdBuf.length > 0) {
    // FinalBlockId has an inner NameComponent.
    var finalBlockIdSaveLength = encoder.getLength();
    encoder.writeBlobTlv(Tlv.NameComponent, finalBlockIdBuf);
    encoder.writeTypeAndLength
      (Tlv.FinalBlockId, encoder.getLength() - finalBlockIdSaveLength);
  }

  encoder.writeOptionalNonNegativeIntegerTlv
    (Tlv.FreshnessPeriod, metaInfo.getFreshnessPeriod());
  if (metaInfo.getType() != ContentType.BLOB) {
    // Not the default, so we need to encode the type.
    if (metaInfo.getType() == ContentType.LINK ||
        metaInfo.getType() == ContentType.KEY)
      // The ContentType enum is set up with the correct integer for 
      // each NDN-TLV ContentType.
      encoder.writeNonNegativeIntegerTlv(Tlv.ContentType, metaInfo.getType());
    else
      throw new Error("unrecognized TLV ContentType");
  }

  encoder.writeTypeAndLength(Tlv.MetaInfo, encoder.getLength() - saveLength);
};

Tlv0_1a2WireFormat.decodeMetaInfo = function(metaInfo, decoder)
{
  var endOffset = decoder.readNestedTlvsStart(Tlv.MetaInfo);  

  // The ContentType enum is set up with the correct integer for each 
  // NDN-TLV ContentType.  If readOptionalNonNegativeIntegerTlv returns
  // None, then setType will convert it to BLOB.
  metaInfo.setType(decoder.readOptionalNonNegativeIntegerTlv
    (Tlv.ContentType, endOffset));
  metaInfo.setFreshnessPeriod
    (decoder.readOptionalNonNegativeIntegerTlv(Tlv.FreshnessPeriod, endOffset));
  if (decoder.peekType(Tlv.FinalBlockId, endOffset)) {
    var finalBlockIdEndOffset = decoder.readNestedTlvsStart(Tlv.FinalBlockId);
    metaInfo.setFinalBlockID(decoder.readBlobTlv(Tlv.NameComponent));
    decoder.finishNestedTlvs(finalBlockIdEndOffset);
  }
  else
    metaInfo.setFinalBlockID(null);

  decoder.finishNestedTlvs(endOffset);
};

},{"../crypto.js":45,"../exclude.js":63,"../key-locator.js":69,"../meta-info.js":72,"../signature.js":77,"../util/blob.js":79,"./decoding-exception.js":53,"./tlv/tlv-decoder.js":58,"./tlv/tlv-encoder.js":59,"./tlv/tlv.js":61,"./wire-format.js":62,"crypto":5}],57:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var WireFormat = require('./wire-format.js').WireFormat;
var Tlv0_1a2WireFormat = require('./tlv-0_1a2-wire-format.js').Tlv0_1a2WireFormat;

/**
 * A TlvWireFormat extends Tlv0_1a2WireFormat to override its methods to 
 * implement encoding and decoding using the preferred implementation of NDN-TLV.
 * @constructor
 */
var TlvWireFormat = function TlvWireFormat() 
{
  // Inherit from Tlv0_1a2WireFormat.
  Tlv0_1a2WireFormat.call(this);
};

TlvWireFormat.prototype = new Tlv0_1a2WireFormat();
TlvWireFormat.prototype.name = "TlvWireFormat";

exports.TlvWireFormat = TlvWireFormat;

// Default object.
TlvWireFormat.instance = null;

/**
 * Get a singleton instance of a TlvWireFormat.  Assuming that the default 
 * wire format was set with WireFormat.setDefaultWireFormat(TlvWireFormat.get()), 
 * you can check if this is the default wire encoding with
 * if WireFormat.getDefaultWireFormat() == TlvWireFormat.get().
 * @returns {TlvWireFormat} The singleton instance.
 */
TlvWireFormat.get = function()
{
  if (TlvWireFormat.instance === null)
    TlvWireFormat.instance = new TlvWireFormat();
  return TlvWireFormat.instance;
};

// On loading this module, make this the default wire format.
// This module will be loaded because WireFormat loads it.
WireFormat.setDefaultWireFormat(TlvWireFormat.get());

},{"./tlv-0_1a2-wire-format.js":56,"./wire-format.js":62}],58:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../../buffer.js').Buffer
var DecodingException = require('../decoding-exception.js').DecodingException;

/**
 * Create a new TlvDecoder for decoding the input in the NDN-TLV wire format.
 * @constructor
 * @param {Buffer} input The buffer with the bytes to decode.
 */
var TlvDecoder = function TlvDecoder(input)
{
  this.input = input;
  this.offset = 0;
};

exports.TlvDecoder = TlvDecoder;

/**
 * Decode VAR-NUMBER in NDN-TLV and return it. Update offset.
 * @returns {number} The decoded VAR-NUMBER.
 */
TlvDecoder.prototype.readVarNumber = function() 
{
  // Assume array values are in the range 0 to 255.
  var firstOctet = this.input[this.offset];
  this.offset += 1;
  if (firstOctet < 253)
    return firstOctet;
  else
    return this.readExtendedVarNumber(firstOctet);
};

/**
 * A private function to do the work of readVarNumber, given the firstOctet
 * which is >= 253.
 * @param {number} firstOctet The first octet which is >= 253, used to decode 
 * the remaining bytes.
 * @returns {number} The decoded VAR-NUMBER.
 */
TlvDecoder.prototype.readExtendedVarNumber = function(firstOctet) 
{
  // This is a private function so we know firstOctet >= 253.
  if (firstOctet == 253) {
    result = ((this.input[this.offset] << 8) +
           this.input[this.offset + 1]);
    this.offset += 2;
  }
  else if (firstOctet == 254) {
    result = ((this.input[this.offset] << 24) +
          (this.input[this.offset + 1] << 16) +
          (this.input[this.offset + 2] << 8) +
           this.input[this.offset + 3]);
    this.offset += 4;
  }
  else {
    result = ((this.input[this.offset] << 56) +
          (this.input[this.offset + 1] << 48) +
          (this.input[this.offset + 2] << 40) +
          (this.input[this.offset + 3] << 32) +
          (this.input[this.offset + 4] << 24) +
          (this.input[this.offset + 5] << 16) +
          (this.input[this.offset + 6] << 8) +
           this.input[this.offset + 7]);
    this.offset += 8;
  }
  
  return result;
};

/**
 * Decode the type and length from this's input starting at offset, expecting 
 * the type to be expectedType and return the length. Update offset.  Also make 
 * sure the decoded length does not exceed the number of bytes remaining in the 
 * input.
 * @param {number} expectedType The expected type.
 * @returns {number} The length of the TLV.
 * @throws DecodingException if (did not get the expected TLV type or the TLV length 
 * exceeds the buffer length.
 */
TlvDecoder.prototype.readTypeAndLength = function(expectedType) 
{
  var type = this.readVarNumber();
  if (type != expectedType)
    throw new DecodingException("Did not get the expected TLV type");

  var length = this.readVarNumber();
  if (this.offset + length > this.input.length)
    throw new DecodingException("TLV length exceeds the buffer length");

  return length;
};

/**
 * Decode the type and length from the input starting at offset, expecting the 
 * type to be expectedType.  Update offset.  Also make sure the decoded length 
 * does not exceed the number of bytes remaining in the input. Return the offset 
 * of the end of this parent TLV, which is used in decoding optional nested 
 * TLVs. After reading all nested TLVs, call finishNestedTlvs.
 * @param {number} expectedType The expected type.
 * @returns {number} The offset of the end of the parent TLV.
 * @throws DecodingException if did not get the expected TLV type or the TLV 
 * length exceeds the buffer length.
 */
TlvDecoder.prototype.readNestedTlvsStart = function(expectedType) 
{
  return this.readTypeAndLength(expectedType) + this.offset;
};

/**
 * Call this after reading all nested TLVs to skip any remaining unrecognized 
 * TLVs and to check if the offset after the final nested TLV matches the 
 * endOffset returned by readNestedTlvsStart.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @throws DecodingException if the TLV length does not equal the total length 
 * of the nested TLVs.
 */
TlvDecoder.prototype.finishNestedTlvs = function(endOffset) 
{
  // We expect offset to be endOffset, so check this first.
  if (this.offset == endOffset)
    return;

  // Skip remaining TLVs.
  while (this.offset < endOffset) {
    // Skip the type VAR-NUMBER.
    this.readVarNumber();
    // Read the length and update offset.
    var length = this.readVarNumber();
    this.offset += length;

    if (this.offset > this.input.length)
      throw new DecodingException("TLV length exceeds the buffer length");
  }
  
  if (this.offset != endOffset)
    throw new DecodingException
      ("TLV length does not equal the total length of the nested TLVs");
};

/**
 * Decode the type from this's input starting at offset, and if it is the 
 * expectedType, then return true, else false.  However, if this's offset is 
 * greater than or equal to endOffset, then return false and don't try to read 
 * the type. Do not update offset.
 * @param {number} expectedType The expected type.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @returns {boolean} true if the type of the next TLV is the expectedType, 
 *  otherwise false.
 */
TlvDecoder.prototype.peekType = function(expectedType, endOffset) 
{
  if (this.offset >= endOffset)
    // No more sub TLVs to look at.
    return false;
  else {
    var saveOffset = this.offset;
    var type = this.readVarNumber();
    // Restore offset.
    this.offset = saveOffset;

    return type == expectedType;
  }
};

/**
 * Decode a non-negative integer in NDN-TLV and return it. Update offset by 
 * length.
 * @param {number} length The number of bytes in the encoded integer.
 * @returns {number} The integer.
 * @throws DecodingException if length is an invalid length for a TLV 
 * non-negative integer.
 */
TlvDecoder.prototype.readNonNegativeInteger = function(length) 
{
  var result;
  if (length == 1)
    result = this.input[this.offset];
  else if (length == 2)
    result = ((this.input[this.offset] << 8) +
           this.input[this.offset + 1]);
  else if (length == 4)
    result = ((this.input[this.offset] << 24) +
          (this.input[this.offset + 1] << 16) +
          (this.input[this.offset + 2] << 8) +
           this.input[this.offset + 3]);
  else if (length == 8)
    result = ((this.input[this.offset] << 56) +
          (this.input[this.offset + 1] << 48) +
          (this.input[this.offset + 2] << 40) +
          (this.input[this.offset + 3] << 32) +
          (this.input[this.offset + 4] << 24) +
          (this.input[this.offset + 5] << 16) +
          (this.input[this.offset + 6] << 8) +
           this.input[this.offset + 7]);
  else
    throw new DecodingException("Invalid length for a TLV nonNegativeInteger");

  this.offset += length;
  return result;
};

/**
 * Decode the type and length from this's input starting at offset, expecting 
 * the type to be expectedType. Then decode a non-negative integer in NDN-TLV 
 * and return it.  Update offset.
 * @param {number} expectedType The expected type.
 * @returns {number} The integer.
 * @throws DecodingException if did not get the expected TLV type or can't 
 * decode the value.
 */
TlvDecoder.prototype.readNonNegativeIntegerTlv = function(expectedType) 
{
  var length = this.readTypeAndLength(expectedType);
  return this.readNonNegativeInteger(length);
};

/**
 * Peek at the next TLV, and if it has the expectedType then call 
 * readNonNegativeIntegerTlv and return the integer.  Otherwise, return null.  
 * However, if this's offset is greater than or equal to endOffset, then return 
 * null and don't try to read the type.
 * @param {number} expectedType The expected type.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @returns {number} The integer or null if the next TLV doesn't have the 
 * expected type.
 */
TlvDecoder.prototype.readOptionalNonNegativeIntegerTlv = function
  (expectedType, endOffset) 
{
  if (this.peekType(expectedType, endOffset))
    return this.readNonNegativeIntegerTlv(expectedType);
  else
    return null;
};

/**
 * Decode the type and length from this's input starting at offset, expecting 
 * the type to be expectedType. Then return an array of the bytes in the value.
 * Update offset.
 * @param {number} expectedType The expected type.
 * @returns {Buffer} The bytes in the value as a slice on the buffer.  This is
 * not a copy of the bytes in the input buffer.  If you need a copy, then you 
 * must make a copy of the return value.
 * @throws DecodingException if did not get the expected TLV type.
 */
TlvDecoder.prototype.readBlobTlv = function(expectedType) 
{
  var length = this.readTypeAndLength(expectedType);
  var result = this.input.slice(this.offset, this.offset + length);

  // readTypeAndLength already checked if length exceeds the input buffer.
  this.offset += length;
  return result;
};

/**
 * Peek at the next TLV, and if it has the expectedType then call readBlobTlv 
 * and return the value.  Otherwise, return null. However, if this's offset is 
 * greater than or equal to endOffset, then return null and don't try to read 
 * the type.
 * @param {number} expectedType The expected type.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @returns {Buffer} The bytes in the value as a slice on the buffer or null if 
 * the next TLV doesn't have the expected type.  This is not a copy of the bytes 
 * in the input buffer.  If you need a copy, then you must make a copy of the 
 * return value.
 */
TlvDecoder.prototype.readOptionalBlobTlv = function(expectedType, endOffset) 
{
  if (this.peekType(expectedType, endOffset))
    return this.readBlobTlv(expectedType);
  else
    return null;
};

/**
 * Peek at the next TLV, and if it has the expectedType then read a type and 
 * value, ignoring the value, and return true. Otherwise, return false.
 * However, if this's offset is greater than or equal to endOffset, then return 
 * false and don't try to read the type.
 * @param {number} expectedType The expected type.
 * @param {number} endOffset The offset of the end of the parent TLV, returned 
 * by readNestedTlvsStart.
 * @returns {boolean} true, or else false if the next TLV doesn't have the 
 * expected type.
 */
TlvDecoder.prototype.readBooleanTlv = function(expectedType, endOffset) 
{
  if (this.peekType(expectedType, endOffset)) {
    var length = this.readTypeAndLength(expectedType);
    // We expect the length to be 0, but update offset anyway.
    this.offset += length;
    return true;
  }
  else
    return false;
};

/**
 * Get the offset into the input, used for the next read.
 * @returns {number} The offset.
 */
TlvDecoder.prototype.getOffset = function() 
{
  return this.offset;
};

/**
 * Set the offset into the input, used for the next read.
 * @param {number} offset The new offset.
 */
TlvDecoder.prototype.seek = function(offset) 
{
  this.offset = offset;
};  

},{"../../buffer.js":45,"../decoding-exception.js":53}],59:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../../buffer.js').Buffer
var DynamicBuffer = require('../../util/dynamic-buffer.js').DynamicBuffer;

/**
 * Create a new TlvEncoder with an initialCapacity for the encoding buffer.
 * @constructor
 * @param {number} initialCapacity (optional) The initial capacity of the 
 * encoding buffer. If omitted, use a default value.
 */
var TlvEncoder = function TlvEncoder(initialCapacity)
{
  initialCapacity = initialCapacity || 16;
  this.output = new DynamicBuffer(initialCapacity);
  // length is the number of bytes that have been written to the back of 
  //  this.output.array.
  this.length = 0;
};

exports.TlvEncoder = TlvEncoder;

/**
 * Get the number of bytes that have been written to the output.  You can
 * save this number, write sub TLVs, then subtract the new length from this
 * to get the total length of the sub TLVs.
 * @returns {number} The number of bytes that have been written to the output.
 */
TlvEncoder.prototype.getLength = function()
{
  return this.length;
};

/**
 * Encode varNumber as a VAR-NUMBER in NDN-TLV and write it to this.output just 
 * before this.length from the back.  Advance this.length.
 * @param {number} varNumber The non-negative number to encode.
 */
TlvEncoder.prototype.writeVarNumber = function(varNumber)
{
  if (varNumber < 253) {
    this.length += 1;
    this.output.ensureLengthFromBack(this.length);
    this.output.array[this.output.array.length - this.length] = varNumber & 0xff;
  }
  else if (varNumber <= 0xffff) {
    this.length += 3;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset] = 253;
    this.output.array[offset + 1] = (varNumber >> 8) & 0xff;
    this.output.array[offset + 2] = varNumber & 0xff;
  }
  else if (varNumber <= 0xffffffff) {
    this.length += 5;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset] = 254;
    this.output.array[offset + 1] = (varNumber >> 24) & 0xff;
    this.output.array[offset + 2] = (varNumber >> 16) & 0xff;
    this.output.array[offset + 3] = (varNumber >> 8) & 0xff;
    this.output.array[offset + 4] = varNumber & 0xff;
  }
  else {
    this.length += 9;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset] = 255;
    this.output.array[offset + 1] = (varNumber >> 56) & 0xff;
    this.output.array[offset + 2] = (varNumber >> 48) & 0xff;
    this.output.array[offset + 3] = (varNumber >> 40) & 0xff;
    this.output.array[offset + 4] = (varNumber >> 32) & 0xff;
    this.output.array[offset + 5] = (varNumber >> 24) & 0xff;
    this.output.array[offset + 6] = (varNumber >> 16) & 0xff;
    this.output.array[offset + 7] = (varNumber >> 8) & 0xff;
    this.output.array[offset + 8] = varNumber & 0xff;
  }
};

/**
 * Encode the type and length as VAR-NUMBER and write to this.output just before 
 * this.length from the back.  Advance this.length.
 * @param {number} type The type of the TLV.
 * @param {number} length The non-negative length of the TLV.
 */
TlvEncoder.prototype.writeTypeAndLength = function(type, length)
{
  // Write backwards.
  this.writeVarNumber(length);
  this.writeVarNumber(type);
};

/**
 * Write the type, then the length of the encoded value then encode value as a 
 * non-negative integer and write it to this.output just before this.length from 
 * the back. Advance this.length.
 * @param {number} type The type of the TLV.
 * @param {number} value The non-negative integer to encode.
 */
TlvEncoder.prototype.writeNonNegativeIntegerTlv = function(type, value)
{
  if (value < 0)
    throw new Error("TLV integer value may not be negative");

  // JavaScript doesn't distinguish int from float, so round.
  value = Math.round(value)

  // Write backwards.
  var saveNBytes = this.length;
  if (value < 253) {
    this.length += 1;
    this.output.ensureLengthFromBack(this.length);
    this.output.array[this.output.array.length - this.length] = value & 0xff;
  }
  else if (value <= 0xffff) {
    this.length += 2;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset]     = (value >> 8) & 0xff;
    this.output.array[offset + 1] = value & 0xff;
  }
  else if (value <= 0xffffffff) {
    this.length += 4;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset]     = (value >> 24) & 0xff;
    this.output.array[offset + 1] = (value >> 16) & 0xff;
    this.output.array[offset + 2] = (value >> 8) & 0xff;
    this.output.array[offset + 3] = value & 0xff;
  }
  else {
    this.length += 8;
    this.output.ensureLengthFromBack(this.length);
    var offset = this.output.array.length - this.length;
    this.output.array[offset]     = (value >> 56) & 0xff;
    this.output.array[offset + 1] = (value >> 48) & 0xff;
    this.output.array[offset + 2] = (value >> 40) & 0xff;
    this.output.array[offset + 3] = (value >> 32) & 0xff;
    this.output.array[offset + 4] = (value >> 24) & 0xff;
    this.output.array[offset + 5] = (value >> 16) & 0xff;
    this.output.array[offset + 6] = (value >> 8) & 0xff;
    this.output.array[offset + 7] = value & 0xff;
  }

  this.writeTypeAndLength(type, this.length - saveNBytes);
};

/**
 * If value is negative or null then do nothing, otherwise call 
 * writeNonNegativeIntegerTlv.
 * @param {number} type The type of the TLV.
 * @param {number} value If negative or None do nothing, otherwise the integer 
 *   to encode.
 */
TlvEncoder.prototype.writeOptionalNonNegativeIntegerTlv = function(type, value)
{
  if (value != null && value >= 0)
    this.writeNonNegativeIntegerTlv(type, value);
};

/**
 * Write the type, then the length of the buffer then the buffer value to 
 * this.output just before this.length from the back. Advance this.length.
 * @param {number} type The type of the TLV.
 * @param {Buffer} value The byte array with the bytes of the blob.  If value is
    null, then just write the type and length 0.
 */
TlvEncoder.prototype.writeBlobTlv = function(type, value)
{
  if (value == null) {
    this.writeTypeAndLength(type, 0);
    return;
  }

  // Write backwards, starting with the blob array.    
  this.length += value.length;
  this.output.copyFromBack(value, this.length);

  this.writeTypeAndLength(type, value.length);
};

/**
 * If the byte array is null or zero length then do nothing, otherwise call 
 * writeBlobTlv.
 * @param {number} type The type of the TLV.
 * @param {Buffer} value If null or zero length do nothing, otherwise the byte 
 * array with the bytes of the blob.
 */
TlvEncoder.prototype.writeOptionalBlobTlv = function(type, value)
{
  if (value != null && value.length > 0)
    this.writeBlobTlv(type, value);
};

/**
 * Get a slice of the encoded bytes.
 * @returns {Buffer} A slice backed by the encoding customBuf.
 */
TlvEncoder.prototype.getOutput = function()
{
  return this.output.array.slice(this.output.array.length - this.length);
};

},{"../../buffer.js":45,"../../util/dynamic-buffer.js":80}],60:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var TlvDecoder = require('./tlv-decoder.js').TlvDecoder;
var customBuf = require('../../buffer.js').Buffer
/**
 * Create and initialize a TlvStructureDecoder.
 */
var TlvStructureDecoder = function TlvStructureDecoder()
{
  this.gotElementEnd = false;
  this.offset = 0;
  this.state = TlvStructureDecoder.READ_TYPE;
  this.headerLength = 0;
  this.useHeaderBuffer = false;
  // 8 bytes is enough to hold the extended bytes in the length encoding 
  // where it is an 8-byte number.
  this.headerBuffer = new customBuf(8);
  this.nBytesToRead = 0;
};

exports.TlvStructureDecoder = TlvStructureDecoder;

TlvStructureDecoder.READ_TYPE =         0;
TlvStructureDecoder.READ_TYPE_BYTES =   1;
TlvStructureDecoder.READ_LENGTH =       2;
TlvStructureDecoder.READ_LENGTH_BYTES = 3;
TlvStructureDecoder.READ_VALUE_BYTES =  4;

/**
 * Continue scanning input starting from this.offset to find the element end.  
 * If the end of the element which started at offset 0 is found, this returns 
 * true and getOffset() is the length of the element.  Otherwise, this returns 
 * false which means you should read more into input and call again.
 * @param {Buffer} input The input buffer. You have to pass in input each time
 * because the buffer could be reallocated.
 * @returns {boolean} true if found the element end, false if not.
 */
TlvStructureDecoder.prototype.findElementEnd = function(input)
{
  if (this.gotElementEnd)
    // Someone is calling when we already got the end.
    return true;

  var decoder = new TlvDecoder(input);

  while (true) {
    if (this.offset >= input.length)
      // All the cases assume we have some input. Return and wait for more.
      return false;

    if (this.state == TlvStructureDecoder.READ_TYPE) {
      var firstOctet = input[this.offset];
      this.offset += 1;
      if (firstOctet < 253)
        // The value is simple, so we can skip straight to reading the length.
        this.state = TlvStructureDecoder.READ_LENGTH;
      else {
        // Set up to skip the type bytes.
        if (firstOctet == 253)
          this.nBytesToRead = 2;
        else if (firstOctet == 254)
          this.nBytesToRead = 4;
        else
          // value == 255.
          this.nBytesToRead = 8;

        this.state = TlvStructureDecoder.READ_TYPE_BYTES;
      }
    }
    else if (this.state == TlvStructureDecoder.READ_TYPE_BYTES) {
      var nRemainingBytes = input.length - this.offset;
      if (nRemainingBytes < this.nBytesToRead) {
        // Need more.
        this.offset += nRemainingBytes;
        this.nBytesToRead -= nRemainingBytes;
        return false;
      }

      // Got the type bytes. Move on to read the length.
      this.offset += this.nBytesToRead;
      this.state = TlvStructureDecoder.READ_LENGTH;
    }
    else if (this.state == TlvStructureDecoder.READ_LENGTH) {
      var firstOctet = input[this.offset];
      this.offset += 1;
      if (firstOctet < 253) {
        // The value is simple, so we can skip straight to reading 
        //  the value bytes.
        this.nBytesToRead = firstOctet;
        if (this.nBytesToRead == 0) {
          // No value bytes to read. We're finished.
          this.gotElementEnd = true;
          return true;
        }

        this.state = TlvStructureDecoder.READ_VALUE_BYTES;
      }
      else {
        // We need to read the bytes in the extended encoding of 
        //  the length.
        if (firstOctet == 253)
          this.nBytesToRead = 2;
        else if (firstOctet == 254)
          this.nBytesToRead = 4;
        else
          // value == 255.
          this.nBytesToRead = 8;

        // We need to use firstOctet in the next state.
        this.firstOctet = firstOctet;
        this.state = TlvStructureDecoder.READ_LENGTH_BYTES;
      }
    }
    else if (this.state == TlvStructureDecoder.READ_LENGTH_BYTES) {
      var nRemainingBytes = input.length - this.offset;
      if (!this.useHeaderBuffer && nRemainingBytes >= this.nBytesToRead) {
        // We don't have to use the headerBuffer. Set nBytesToRead.
        decoder.seek(this.offset);

        this.nBytesToRead = decoder.readExtendedVarNumber(this.firstOctet);
        // Update this.offset to the decoder's offset after reading.
        this.offset = decoder.getOffset();
      }
      else {
        this.useHeaderBuffer = true;

        var nNeededBytes = this.nBytesToRead - this.headerLength;
        if (nNeededBytes > nRemainingBytes) {
          // We can't get all of the header bytes from this input. 
          // Save in headerBuffer.
          if (this.headerLength + nRemainingBytes > this.headerBuffer.length)
            // We don't expect this to happen.
            throw new Error
              ("Cannot store more header bytes than the size of headerBuffer");
          input.slice(this.offset, this.offset + nRemainingBytes).copy
            (this.headerBuffer, this.headerLength);
          this.offset += nRemainingBytes;
          this.headerLength += nRemainingBytes;

          return false;
        }

        // Copy the remaining bytes into headerBuffer, read the 
        //   length and set nBytesToRead.
        if (this.headerLength + nNeededBytes > this.headerBuffer.length)
          // We don't expect this to happen.
          throw new Error
            ("Cannot store more header bytes than the size of headerBuffer");
        input.slice(this.offset, this.offset + nNeededBytes).copy
          (this.headerBuffer, this.headerLength);
        this.offset += nNeededBytes;

        // Use a local decoder just for the headerBuffer.
        var bufferDecoder = new TlvDecoder(this.headerBuffer);
        // Replace nBytesToRead with the length of the value.
        this.nBytesToRead = bufferDecoder.readExtendedVarNumber(this.firstOctet);
      }
      
      if (this.nBytesToRead == 0) {
        // No value bytes to read. We're finished.
        this.gotElementEnd = true;
        return true;
      }

      // Get ready to read the value bytes.
      this.state = TlvStructureDecoder.READ_VALUE_BYTES;
    }
    else if (this.state == TlvStructureDecoder.READ_VALUE_BYTES) {
      nRemainingBytes = input.length - this.offset;
      if (nRemainingBytes < this.nBytesToRead) {
        // Need more.
        this.offset += nRemainingBytes;
        this.nBytesToRead -= nRemainingBytes;
        return false;
      }

      // Got the bytes. We're finished.
      this.offset += this.nBytesToRead;
      this.gotElementEnd = true;
      return true;
    }
    else
      // We don't expect this to happen.
      throw new Error("findElementEnd: unrecognized state");
  }
};

/**
 * Get the current offset into the input buffer.
 * @returns {number} The offset.
 */
TlvStructureDecoder.prototype.getOffset = function()
{
  return this.offset;
};

/**
 * Set the offset into the input, used for the next read.
 * @param {number} offset The new offset.
 */
TlvStructureDecoder.prototype.seek = function(offset)
{
  this.offset = offset;
};

},{"../../buffer.js":45,"./tlv-decoder.js":58}],61:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * The Tlv class has static type codes for the NDN-TLV wire format.
 * @constructor
 */
var Tlv = function Tlv()
{
}

exports.Tlv = Tlv;

Tlv.Interest =         5;
Tlv.Data =             6;
Tlv.Name =             7;
Tlv.NameComponent =    8;
Tlv.Selectors =        9;
Tlv.Nonce =            10;
Tlv.Scope =            11;
Tlv.InterestLifetime = 12;
Tlv.MinSuffixComponents = 13;
Tlv.MaxSuffixComponents = 14;
Tlv.PublisherPublicKeyLocator = 15;
Tlv.Exclude =          16;
Tlv.ChildSelector =    17;
Tlv.MustBeFresh =      18;
Tlv.Any =              19;
Tlv.MetaInfo =         20;
Tlv.Content =          21;
Tlv.SignatureInfo =    22;
Tlv.SignatureValue =   23;
Tlv.ContentType =      24;
Tlv.FreshnessPeriod =  25;
Tlv.FinalBlockId =     26;
Tlv.SignatureType =    27;
Tlv.KeyLocator =       28;
Tlv.KeyLocatorDigest = 29;
Tlv.FaceInstance =     128;
Tlv.ForwardingEntry =  129;
Tlv.StatusResponse =   130;
Tlv.Action =           131;
Tlv.FaceID =           132;
Tlv.IPProto =          133;
Tlv.Host =             134;
Tlv.Port =             135;
Tlv.MulticastInterface = 136;
Tlv.MulticastTTL =     137;
Tlv.ForwardingFlags =  138;
Tlv.StatusCode =       139;
Tlv.StatusText =       140;

Tlv.SignatureType_DigestSha256 = 0;
Tlv.SignatureType_SignatureSha256WithRsa = 1;

},{}],62:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents Interest Objects
 */
var customBuf = require('../buffer.js').Buffer
/**
 * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like TlvWireFormat.
 * @constructor
 */
var WireFormat = function WireFormat() {
};

exports.WireFormat = WireFormat;

/**
 * Encode interest and return the encoding.  Your derived class should override.
 * @param {Interest} interest The Interest to encode.
 * @returns {Blob} A Blob containing the encoding.
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.encodeInterest = function(interest) 
{
  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * Decode input as an interest and set the fields of the interest object. 
 * Your derived class should override.
 * @param {Interest} interest The Interest object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.decodeInterest = function(interest, input) 
{
  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * Encode data and return the encoding and signed offsets. Your derived class 
 * should override.
 * @param {Data} data The Data object to encode.
 * @returns {object with (Blob, int, int)} An associative array with fields
 * (encoding, signedPortionBeginOffset, signedPortionEndOffset) where encoding 
 * is a Blob containing the encoding, signedPortionBeginOffset is the offset in 
 * the encoding of the beginning of the signed portion, and 
 * signedPortionEndOffset is the offset in the encoding of the end of the 
 * signed portion.
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.encodeData = function(data) 
{
  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * Decode input as a data packet, set the fields in the data object, and return 
 * the signed offsets.  Your derived class should override.
 * @param {Data} data The Data object whose fields are updated.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @returns {object with (int, int)} An associative array with fields
 * (signedPortionBeginOffset, signedPortionEndOffset) where 
 * signedPortionBeginOffset is the offset in the encoding of the beginning of 
 * the signed portion, and signedPortionEndOffset is the offset in the encoding 
 * of the end of the signed portion.
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.decodeData = function(data, input) 
{
  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * Set the static default WireFormat used by default encoding and decoding 
 * methods.
 * @param wireFormat {a subclass of WireFormat} An object of a subclass of 
 * WireFormat.
 */
WireFormat.setDefaultWireFormat = function(wireFormat)
{
  WireFormat.defaultWireFormat = wireFormat;
};

/**
 * Return the default WireFormat used by default encoding and decoding methods 
 * which was set with setDefaultWireFormat.
 * @returns {a subclass of WireFormat} The WireFormat object.
 */
WireFormat.getDefaultWireFormat = function()
{
  return WireFormat.defaultWireFormat;
};

// Invoke TlvWireFormat to set the default format.
// Since tlv-wire-format.js includes this file, put this at the bottom 
// to avoid problems with cycles of require.
var TlvWireFormat = require('./tlv-wire-format.js').TlvWireFormat;

},{"../buffer.js":45,"./tlv-wire-format.js":57}],63:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an Interest Exclude.
 */

var customBuf = require('./buffer.js').Buffer
var Name = require('./name.js').Name;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var DataUtils = require('./encoding/data-utils.js').DataUtils;

/**
 * Create a new Exclude.
 * @constructor
 * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, customBuf component or Exclude.ANY.
 */
var Exclude = function Exclude(values) 
{ 
  this.values = [];
  
  if (typeof values === 'object' && values instanceof Exclude)
    // Copy the exclude.
    this.values = values.values.slice(0);
  else if (values) {
    for (var i = 0; i < values.length; ++i) {
      if (values[i] == Exclude.ANY)
        this.appendAny();
      else
        this.appendComponent(values[i]);
    }
  }
};

exports.Exclude = Exclude;

Exclude.ANY = "*";

/**
 * Get the number of entries.
 * @returns {number} The number of entries.
 */
Exclude.prototype.size = function() { return this.values.length; };

/**
 * Get the entry at the given index.
 * @param {number} i The index of the entry, starting from 0.
 * @returns {Exclude.ANY|Name.Component} Exclude.ANY or a Name.Component.
 */
Exclude.prototype.get = function(i) { return this.values[i]; };

/**
 * Append an Exclude.ANY element.
 * @returns This Exclude so that you can chain calls to append.
 */
Exclude.prototype.appendAny = function() 
{
  this.values.push(Exclude.ANY);
  return this;
};

/**
 * Append a component entry, copying from component.
 * @param {Name.Component|Buffer} component
 * @returns This Exclude so that you can chain calls to append.
 */
Exclude.prototype.appendComponent = function(component) 
{
  this.values.push(new Name.Component(component));
  return this;
};

/**
 * Clear all the entries.
 */
Exclude.prototype.clear = function() 
{
  this.values = [];
};

Exclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) 
{
  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);

  while (true) {
    if (decoder.peekDTag(NDNProtocolDTags.Component))
      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));
    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {
      decoder.readElementStartDTag(NDNProtocolDTags.Any);
      decoder.readElementClose();
      this.appendAny();
    }
    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {
      // Skip the Bloom and treat it as Any.
      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);
      this.appendAny();
    }
    else
      break;
  }
    
  decoder.readElementClose();
};

Exclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  
{
  if (this.values == null || this.values.length == 0)
    return;

  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);
    
  // TODO: Do we want to order the components (except for ANY)?
  for (var i = 0; i < this.values.length; ++i) {
    if (this.values[i] == Exclude.ANY) {
      encoder.writeElementStartDTag(NDNProtocolDTags.Any);
      encoder.writeElementClose();
    }
    else
      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());
  }

  encoder.writeElementClose();
};

/**
 * Return a string with elements separated by "," and Exclude.ANY shown as "*". 
 */
Exclude.prototype.toUri = function() 
{
  if (this.values == null || this.values.length == 0)
    return "";

  var result = "";
  for (var i = 0; i < this.values.length; ++i) {
    if (i > 0)
      result += ",";
        
    if (this.values[i] == Exclude.ANY)
      result += "*";
    else
      result += Name.toEscapedString(this.values[i].getValue());
  }
  return result;
};

/**
 * Return true if the component matches any of the exclude criteria.
 */
Exclude.prototype.matches = function(/*Buffer*/ component) 
{
  if (typeof component == 'object' && component instanceof Name.Component)
    component = component.getValue();

  for (var i = 0; i < this.values.length; ++i) {
    if (this.values[i] == Exclude.ANY) {
      var lowerBound = null;
      if (i > 0)
        lowerBound = this.values[i - 1];
      
      // Find the upper bound, possibly skipping over multiple ANY in a row.
      var iUpperBound;
      var upperBound = null;
      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {
        if (this.values[iUpperBound] != Exclude.ANY) {
          upperBound = this.values[iUpperBound];
          break;
        }
      }
      
      // If lowerBound != null, we already checked component equals lowerBound on the last pass.
      // If upperBound != null, we will check component equals upperBound on the next pass.
      if (upperBound != null) {
        if (lowerBound != null) {
          if (Exclude.compareComponents(component, lowerBound) > 0 &&
              Exclude.compareComponents(component, upperBound) < 0)
            return true;
        }
        else {
          if (Exclude.compareComponents(component, upperBound) < 0)
            return true;
        }
          
        // Make i equal iUpperBound on the next pass.
        i = iUpperBound - 1;
      }
      else {
        if (lowerBound != null) {
            if (Exclude.compareComponents(component, lowerBound) > 0)
              return true;
        }
        else
          // this.values has only ANY.
          return true;
      }
    }
    else {
      if (DataUtils.arraysEqual(component, this.values[i].getValue()))
        return true;
    }
  }
  
  return false;
};

/**
 * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.
 * A component is less if it is shorter, otherwise if equal length do a byte comparison.
 */
Exclude.compareComponents = function(component1, component2) 
{
  if (typeof component1 == 'object' && component1 instanceof Name.Component)
    component1 = component1.getValue();
  if (typeof component2 == 'object' && component2 instanceof Name.Component)
    component2 = component2.getValue();

  if (component1.length < component2.length)
    return -1;
  if (component1.length > component2.length)
    return 1;
  
  for (var i = 0; i < component1.length; ++i) {
    if (component1[i] < component2[i])
      return -1;
    if (component1[i] > component2[i])
      return 1;
  }

  return 0;
};

},{"./buffer.js":45,"./encoding/binary-xml-decoder.js":48,"./encoding/binary-xml-encoder.js":49,"./encoding/data-utils.js":52,"./name.js":73,"./util/ndn-protoco-id-tags.js":82}],64:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Face Instances
 */

var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var PublisherPublicKeyDigest = require('./publisher-public-key-digest.js').PublisherPublicKeyDigest;

/**
 * @constructor
 */
var FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,
    multicastTTL, freshnessSeconds) 
{
  this.action = action;
  this.publisherPublicKeyDigest = publisherPublicKeyDigest;
  this.faceID = faceID;
  this.ipProto = ipProto;
  this.host = host;
  this.Port = port;
  this.multicastInterface =multicastInterface;
  this.multicastTTL =multicastTTL;
  this.freshnessSeconds = freshnessSeconds;
};

exports.FaceInstance = FaceInstance;

FaceInstance.NetworkProtocol = { TCP:6, UDP:17};

/**
 * Used by NetworkObject to decode the object from a network stream.
 */
FaceInstance.prototype.from_ndnb = function(
  //XMLDecoder 
  decoder) 
{
  decoder.readElementStartDTag(this.getElementLabel());
  
  if (decoder.peekDTag(NDNProtocolDTags.Action))   
    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();
    this.publisherPublicKeyDigest.from_ndnb(decoder);
  }
  if (decoder.peekDTag(NDNProtocolDTags.FaceID))
    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);
  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {
    //int
    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);
    
    this.ipProto = null;
    
    if (FaceInstance.NetworkProtocol.TCP == pI)
      this.ipProto = FaceInstance.NetworkProtocol.TCP;
    else if (FaceInstance.NetworkProtocol.UDP == pI)
      this.ipProto = FaceInstance.NetworkProtocol.UDP;
    else
      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);
  }
  
  if (decoder.peekDTag(NDNProtocolDTags.Host))
    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);
  if (decoder.peekDTag(NDNProtocolDTags.Port))
    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port); 
  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))
    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface); 
  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))
    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL); 
  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))
    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); 

  decoder.readElementClose();
};

/**
 * Used by NetworkObject to encode the object to a network stream.
 */
FaceInstance.prototype.to_ndnb = function(
  //XMLEncoder
  encoder) 
{
  encoder.writeElementStartDTag(this.getElementLabel());
  
  if (null != this.action && this.action.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  
  if (null != this.publisherPublicKeyDigest)
    this.publisherPublicKeyDigest.to_ndnb(encoder);
  if (null != this.faceID)
    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);
  if (null != this.ipProto)
    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);
  if (null != this.host && this.host.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);  
  if (null != this.Port)
    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);
  if (null != this.multicastInterface && this.multicastInterface.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);
  if (null !=  this.multicastTTL)
    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);
  if (null != this.freshnessSeconds)
    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);

  encoder.writeElementClose();         
};

FaceInstance.prototype.getElementLabel = function() 
{
  return NDNProtocolDTags.FaceInstance;
};


},{"./publisher-public-key-digest.js":75,"./util/ndn-protoco-id-tags.js":82}],65:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang
 * See COPYING for copyright and distribution information.
 * This class represents the top-level object for communicating with an NDN host.
 */

var customBuf = require('./buffer.js').Buffer
var crypto = require('./crypto.js');
var DataUtils = require('./encoding/data-utils.js').DataUtils;
var Name = require('./name.js').Name;
var Interest = require('./interest.js').Interest;
var Data = require('./data.js').Data;
var MetaInfo = require('./meta-info.js').MetaInfo;
var ForwardingEntry = require('./forwarding-entry.js').ForwardingEntry;
var TlvWireFormat = require('./encoding/tlv-wire-format.js').TlvWireFormat;
var BinaryXmlWireFormat = require('./encoding/binary-xml-wire-format.js').BinaryXmlWireFormat;
var Tlv = require('./encoding/tlv/tlv.js').Tlv;
var TlvDecoder = require('./encoding/tlv/tlv-decoder.js').TlvDecoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var Key = require('./key.js').Key;
var KeyLocatorType = require('./key-locator.js').KeyLocatorType;
var ForwardingFlags = require('./forwarding-flags.js').ForwardingFlags;
var Closure = require('./closure.js').Closure;
var UpcallInfo = require('./closure.js').UpcallInfo;
var TcpTransport = require('./transport/tcp-transport.js').TcpTransport;
var LOG = require('./log.js').Log.LOG;

/**
 * Create a new Face with the given settings.
 * This throws an exception if Face.supported is false.
 * @constructor
 * @param {Object} settings if not null, an associative array with the following defaults:
 * {
 *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.
 *              OR function() { return new TcpTransport(); },       // If in Node.js.
 *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.
 *   host: null, // If null, use getHostAndPort when connecting.
 *   port: 9696, // If in the browser.
 *      OR 6363, // If in Node.js.
 *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },
 *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },
 *   verify: false // If false, don't verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.
 * }
 */
var Face = function Face(settings)
{
  if (!Face.supported)
    throw new Error("The necessary JavaScript support is not available on this platform.");

  settings = (settings || {});
  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.
  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });
  this.transport = getTransport();
  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);
  this.host = (settings.host !== undefined ? settings.host : null);
  this.port = (settings.port || (typeof WebSocketTransport != 'undefined' ? 9696 : 6363));
  this.readyStatus = Face.UNOPEN;
  this.verify = (settings.verify !== undefined ? settings.verify : false);
  // Event handler
  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });
  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });
  this.ndndid = null;
};

exports.Face = Face;

Face.UNOPEN = 0;  // created but not opened yet
Face.OPENED = 1;  // connection to ndnd opened
Face.CLOSED = 2;  // connection to ndnd closed

/**
 * Return true if necessary JavaScript support is available, else log an error and return false.
 */
Face.getSupported = function()
{
  try {
    var dummy = new customBuf(1).slice(0, 1);
  }
  catch (ex) {
    console.log("NDN not available: customBuf not supported. " + ex);
    return false;
  }

  return true;
};

Face.supported = Face.getSupported();

Face.ndndIdFetcher = new Name('/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY');

Face.prototype.createRoute = function(host, port)
{
  this.host=host;
  this.port=port;
};

Face.KeyStore = new Array();

var KeyStoreEntry = function KeyStoreEntry(name, rsa, time)
{
  this.keyName = name;  // KeyName
  this.rsaKey = rsa;    // RSA key
  this.timeStamp = time;  // Time Stamp
};

Face.addKeyEntry = function(/* KeyStoreEntry */ keyEntry)
{
  var result = Face.getKeyByName(keyEntry.keyName);
  if (result == null)
    Face.KeyStore.push(keyEntry);
  else
    result = keyEntry;
};

Face.getKeyByName = function(/* KeyName */ name)
{
  var result = null;

  for (var i = 0; i < Face.KeyStore.length; i++) {
    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {
      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)
        result = Face.KeyStore[i];
    }
  }

  return result;
};

Face.prototype.close = function()
{
  if (this.readyStatus != Face.OPENED)
    throw new Error('Cannot close because Face connection is not opened.');

  this.readyStatus = Face.CLOSED;
  this.transport.close();
};

// For fetching data
Face.PITTable = new Array();

/**
 * @constructor
 */
var PITEntry = function PITEntry(interest, closure)
{
  this.interest = interest;  // Interest
  this.closure = closure;    // Closure
  this.timerID = -1;  // Timer ID
};

/**
 * Return the entry from Face.PITTable where the name conforms to the interest selectors, and
 * the interest name is the longest that matches name.
 */

/**
 * Find all entries from Face.PITTable where the name conforms to the entry's
 * interest selectors, remove the entries from the table, cancel their timeout
 * timers and return them.
 * @param {Name} name The name to find the interest for (from the incoming data
 * packet).
 * @returns {Array<PITEntry>} The matching entries from Face.PITTable, or [] if
 * none are found.
 */
Face.extractEntriesForExpressedInterest = function(name)
{
  var result = [];

  // Go backwards through the list so we can erase entries.
  for (var i = Face.PITTable.length - 1; i >= 0; --i) {
    var entry = Face.PITTable[i];
    if (entry.interest.matchesName(name)) {
      // Cancel the timeout timer.
      clearTimeout(entry.timerID);

      result.push(entry);
      Face.PITTable.splice(i, 1);
    }
  }

  return result;
};

// For publishing data
Face.registeredPrefixTable = new Array();

/**
 * @constructor
 */
var RegisteredPrefix = function RegisteredPrefix(prefix, closure)
{
  this.prefix = prefix;        // String
  this.closure = closure;  // Closure
};

/**
 * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.
 * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).
 * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.
 */
function getEntryForRegisteredPrefix(name)
{
  var iResult = -1;

  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {
    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " , Face.registeredPrefixTable[i].prefix , " matches " , name);
    if (Face.registeredPrefixTable[i].prefix.match(name)) {
      if (iResult < 0 ||
          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())
        // Update to the longer match.
        iResult = i;
    }
  }

  if (iResult >= 0)
    return Face.registeredPrefixTable[iResult];
  else
    return null;
}

/**
 * Return a function that selects a host at random from hostList and returns { host: host, port: port }.
 * If no more hosts remain, return null.
 */
Face.makeShuffledGetHostAndPort = function(hostList, port)
{
  // Make a copy.
  hostList = hostList.slice(0, hostList.length);
  DataUtils.shuffle(hostList);

  return function() {
    if (hostList.length == 0)
      return null;

    return { host: hostList.splice(0, 1)[0], port: port };
  };
};

/**
 * Send the interest through the transport, read the entire response and call onData.
 * If the interest times out according to interest lifetime, call onTimeout (if not omitted).
 * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):
 * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from
 * a name and optional interest template:
 * expressInterest(name [, template], onData [, onTimeout]).
 * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.
 * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.
 * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:
 *   interest is the interest given to expressInterest,
 *   data is the received Data object.
 * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime,
 *   this calls onTimeout(interest) where:
 *   interest is the interest given to expressInterest.
 * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).
 * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest.
 * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).
 */
Face.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4)
{
  // There are several overloaded versions of expressInterest, each shown inline below.

  // expressInterest(Name name, Closure closure);                      // deprecated
  // expressInterest(Name name, Closure closure,   Interest template); // deprecated
  if (arg2 && arg2.upcall && typeof arg2.upcall == 'function') {
    // Assume arg2 is the deprecated use with Closure.
    // The first argument is a name. Make the interest from the name and possible template.
    interest = new Interest(interestOrName);
    if (arg3) {
      var template = arg3;
      interest.minSuffixComponents = template.minSuffixComponents;
      interest.maxSuffixComponents = template.maxSuffixComponents;
      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;
      interest.exclude = template.exclude;
      interest.childSelector = template.childSelector;
      interest.answerOriginKind = template.answerOriginKind;
      interest.scope = template.scope;
      interest.interestLifetime = template.interestLifetime;
    }
    else
      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.

    this.expressInterestWithClosure(interest, arg2);
    return;
  }

  var interest;
  var onData;
  var onTimeout;
  // expressInterest(Interest interest, function onData);
  // expressInterest(Interest interest, function onData, function onTimeout);
  if (typeof interestOrName == 'object' && interestOrName instanceof Interest) {
    // Just use a copy of the interest.
    interest = new Interest(interestOrName);
    onData = arg2;
    onTimeout = (arg3 ? arg3 : function() {});
  }
  else {
    // The first argument is a name. Make the interest from the name and possible template.
    interest = new Interest(interestOrName);
    // expressInterest(Name name, Interest template, function onData);
    // expressInterest(Name name, Interest template, function onData, function onTimeout);
    if (arg2 && typeof arg2 == 'object' && arg2 instanceof Interest) {
      var template = arg2;
      interest.minSuffixComponents = template.minSuffixComponents;
      interest.maxSuffixComponents = template.maxSuffixComponents;
      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;
      interest.exclude = template.exclude;
      interest.childSelector = template.childSelector;
      interest.answerOriginKind = template.answerOriginKind;
      interest.scope = template.scope;
      interest.interestLifetime = template.interestLifetime;

      onData = arg3;
      onTimeout = (arg4 ? arg4 : function() {});
    }
    // expressInterest(Name name, function onData);
    // expressInterest(Name name, function onData,   function onTimeout);
    else {
      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.
      onData = arg2;
      onTimeout = (arg3 ? arg3 : function() {});
    }
  }

  // Make a Closure from the callbacks so we can use expressInterestWithClosure.
  // TODO: Convert the PIT to use callbacks, not a closure.
  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout), interest);
}

Face.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {
  // Inherit from Closure.
  Closure.call(this);

  this.onData = onData;
  this.onTimeout = onTimeout;
  this.onInterest = onInterest;
  this.prefix = prefix;
  this.transport = transport;
};

Face.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {
  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)
    this.onData(upcallInfo.interest, upcallInfo.data);
  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)
    this.onTimeout(upcallInfo.interest);
  else if (kind == Closure.UPCALL_INTEREST)
    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.
    this.onInterest(this.prefix, upcallInfo.interest, this.transport)

  return Closure.RESULT_OK;
};

/**
 * A private method to send the the interest to host:port, read the entire response and call
 * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),
 *                 new UpcallInfo(this, interest, 0, data)).
 * @deprecated Use expressInterest with callback functions, not Closure.
 * @param {Interest} the interest, already processed with a template (if supplied).
 * @param {Closure} closure
 */
Face.prototype.expressInterestWithClosure = function(interest, closure)
{
  if (this.host == null || this.port == null) {
    if (this.getHostAndPort == null)
      console.log('ERROR: host OR port NOT SET');
    else {
      var thisNDN = this;
      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });
    }
  }
  else
    this.reconnectAndExpressInterest(interest, closure);
};

/**
 * If the host and port are different than the ones in this.transport, then call
 *   this.transport.connect to change the connection (or connect for the first time).
 * Then call expressInterestHelper.
 */
Face.prototype.reconnectAndExpressInterest = function(interest, closure)
{
  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {
    var thisNDN = this;
    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });
    this.readyStatus = Face.OPENED;
  }
  else
    this.expressInterestHelper(interest, closure);
};

/**
 * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call
 *   this.transport.send to send the interest.
 */
Face.prototype.expressInterestHelper = function(interest, closure)
{
  var binaryInterest = interest.wireEncode();
  var thisNDN = this;
  //TODO: check local content store first
  if (closure != null) {
    var pitEntry = new PITEntry(interest, closure);
    // TODO: This needs to be a single thread-safe transaction on a global object.
    Face.PITTable.push(pitEntry);
    closure.pitEntry = pitEntry;

    // Set interest timer.
    var timeoutMilliseconds = (interest.interestLifetime || 4000);
    var timeoutCallback = function() {
      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());

      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express
      //   the interest because we don't want to match it in the mean time.
      // TODO: Make this a thread-safe operation on the global PITTable.
      var index = Face.PITTable.indexOf(pitEntry);
      if (index >= 0)
        Face.PITTable.splice(index, 1);

      // Raise closure callback
      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {
        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());
        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);
        Face.PITTable.push(pitEntry);
        thisNDN.transport.send(binaryInterest.buf());
      }
    };

    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);
  }

  this.transport.send(binaryInterest.buf());
};

/**
 * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.
 * This uses the form:
 * registerPrefix(name, onInterest, onRegisterFailed [, flags]).
 * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.
 * @param {Name} prefix The Name prefix.
 * @param {function} onInterest When an interest is received which matches the name prefix, this calls
 * onInterest(prefix, interest, transport) where:
 *   prefix is the prefix given to registerPrefix.
 *   interest is the received interest.
 *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().
 * @param {function} onRegisterFailed If failed to retrieve the connected hub's ID or failed to register the prefix,
 * this calls onRegisterFailed(prefix) where:
 *   prefix is the prefix given to registerPrefix.
 * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.
 * If omitted, use the default flags defined by the default ForwardingFlags constructor.
 */
Face.prototype.registerPrefix = function(prefix, arg2, arg3, arg4)
{
  // There are several overloaded versions of registerPrefix, each shown inline below.

  // registerPrefix(Name prefix, Closure closure);            // deprecated
  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated
  if (arg2 && arg2.upcall && typeof arg2.upcall == 'function') {
    // Assume arg2 is the deprecated use with Closure.
    if (arg3)
      this.registerPrefixWithClosure(prefix, arg2, arg3);
    else
      this.registerPrefixWithClosure(prefix, arg2);
    return;
  }

  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);
  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);
  var onInterest = arg2;
  var onRegisterFailed = (arg3 ? arg3 : function() {});
  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());
  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport),
                                 intFlags, onRegisterFailed);
}

/**
 * A private method to register the prefix with the host, receive the data and call
 * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)).
 * @deprecated Use registerPrefix with callback functions, not Closure.
 * @param {Name} prefix
 * @param {Closure} closure
 * @param {number} intFlags
 * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix)
 * if registration fails.
 */
Face.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed)
{
  intFlags = intFlags | 3;
  var thisNDN = this;
  var onConnected = function() {
    if (thisNDN.ndndid == null) {
      // Fetch ndndid first, then register.
      var interest = new Interest(Face.ndndIdFetcher);
      interest.interestLifetime = 4000; // milliseconds
      if (LOG > 3) console.log('Expressing interest for ndndid from ndnd.');
      thisNDN.reconnectAndExpressInterest
        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));
    }
    else
      thisNDN.registerPrefixHelper(prefix, closure, flags, onRegisterFailed);
  };

  if (this.host == null || this.port == null) {
    if (this.getHostAndPort == null)
      console.log('ERROR: host OR port NOT SET');
    else
      this.connectAndExecute(onConnected);
  }
  else
    onConnected();
};

/**
 * This is a closure to receive the Data for Face.ndndIdFetcher and call
 *   registerPrefixHelper(prefix, callerClosure, flags).
 */
Face.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed)
{
  // Inherit from Closure.
  Closure.call(this);

  this.face = face;
  this.prefix = prefix;
  this.callerClosure = callerClosure;
  this.flags = flags;
  this.onRegisterFailed = onRegisterFailed;
};

Face.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo)
{
  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");
    if (this.onRegisterFailed)
      this.onRegisterFailed(this.prefix);
    return Closure.RESULT_OK;
  }
  if (!(kind == Closure.UPCALL_CONTENT ||
        kind == Closure.UPCALL_CONTENT_UNVERIFIED))
    // The upcall is not for us.  Don't expect this to happen.
    return Closure.RESULT_ERR;

  if (LOG > 3) console.log('Got ndndid from ndnd.');
  // Get the digest of the public key in the data packet content.
  var hash = require("./crypto.js").createHash('sha256');
  hash.update(upcallInfo.data.getContent());
  this.face.ndndid = new customBuf(DataUtils.toNumbersIfString(hash.digest()));
  if (LOG > 3) console.log(this.face.ndndid);

  this.face.registerPrefixHelper
    (this.prefix, this.callerClosure, this.flags, this.onRegisterFailed);

  return Closure.RESULT_OK;
};
/**
 * This is a closure to receive the response Data packet from the register
 * prefix interest sent to the connected NDN hub. If this gets a bad response
 * or a timeout, call onRegisterFailed.
 */
Face.RegisterResponseClosure = function RegisterResponseClosure
  (prefix, onRegisterFailed)
{
  // Inherit from Closure.
  Closure.call(this);

  this.prefix = prefix;
  this.onRegisterFailed = onRegisterFailed;
};

Face.RegisterResponseClosure.prototype.upcall = function(kind, upcallInfo)
{
  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
    if (this.onRegisterFailed)
      this.onRegisterFailed(this.prefix);
    return Closure.RESULT_OK;
  }
  if (!(kind == Closure.UPCALL_CONTENT ||
        kind == Closure.UPCALL_CONTENT_UNVERIFIED))
    // The upcall is not for us.  Don't expect this to happen.
    return Closure.RESULT_ERR;

  var expectedName = new Name("/ndnx/.../selfreg");
  // Got a response. Do a quick check of expected name components.
  if (upcallInfo.data.getName().size() < 4 ||
      !upcallInfo.data.getName().get(0).equals(expectedName.get(0)) ||
      !upcallInfo.data.getName().get(2).equals(expectedName.get(2))) {
    this.onRegisterFailed(this.prefix);
    return;
  }

  // Otherwise, silently succeed.
  return Closure.RESULT_OK;
};

/**
 * Do the work of registerPrefix once we know we are connected with a ndndid.
 */
Face.prototype.registerPrefixHelper = function
  (prefix, closure, flags, onRegisterFailed)
{
  var fe = new ForwardingEntry('selfreg', prefix, null, null, flags, null);

  // Always encode as BinaryXml until we support TLV for ForwardingEntry.
  var encoder = new BinaryXMLEncoder();
  fe.to_ndnb(encoder);
  var bytes = encoder.getReducedOstream();

  var si = new MetaInfo();
  si.setFields();

  // Set the name to a random value so that each request is unique.
  var data = new Data(new Name().append(require("crypto").randomBytes(4)), si, bytes);
  // Always encode as BinaryXml until we support TLV for ForwardingEntry.
  data.sign(BinaryXmlWireFormat.get());
  var coBinary = data.wireEncode(BinaryXmlWireFormat.get());;

  var nodename = this.ndndid;
  var interestName = new Name(['ndnx', nodename, 'selfreg', coBinary]);

  var interest = new Interest(interestName);
  interest.setInterestLifetimeMilliseconds(4000.0);
  interest.setScope(1);
  if (LOG > 3) console.log('Send Interest registration packet.');

  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));

  this.reconnectAndExpressInterest
    (interest, new Face.RegisterResponseClosure(prefix, onRegisterFailed));
};

/**
 * This is called when an entire binary XML element is received, such as a Data or Interest.
 * Look up in the PITTable and call the closure callback.
 */
Face.prototype.onReceivedElement = function(element)
{
  if (LOG > 3) console.log('Complete element received. Length ' + element.length + '. Start decoding.');
  // First, decode as Interest or Data.
  var interest = null;
  var data = null;
  // The type codes for TLV Interest and Data packets are chosen to not
  //   conflict with the first byte of a binary XML packet, so we can
  //   just look at the first byte.
  if (element[0] == Tlv.Interest || element[0] == Tlv.Data) {
    if (LOG > 3) console.log('Detected Tlv element', element, TlvWireFormat.get())
    var decoder = new TlvDecoder(element);
    if (decoder.peekType(Tlv.Interest, element.length)) {
      interest = new Interest();
      interest.wireDecode(element, TlvWireFormat.get());
    }
    else if (decoder.peekType(Tlv.Data, element.length)) {
      data = new Data();
      data.wireDecode(element, TlvWireFormat.get());
    }
  }
  else {
    if (LOG > 3) console.log('assumed BinaryXML')
    // Binary XML.
    var decoder = new BinaryXMLDecoder(element);
    if (decoder.peekDTag(NDNProtocolDTags.Interest)) {
      interest = new Interest();
      interest.wireDecode(element, BinaryXmlWireFormat.get());
    }
    else if (decoder.peekDTag(NDNProtocolDTags.Data)) {
      data = new Data();
      data.wireDecode(element, BinaryXmlWireFormat.get());
    }
  }

  // Now process as Interest or Data.
  if (interest !== null) {
    if (LOG > 3) console.log('Interest packet received.');
    var entry = getEntryForRegisteredPrefix(interest.name);
    if (entry != null) {
      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());
      var info = new UpcallInfo(this, interest, 0, null);
      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);
      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null)
        this.transport.send(info.data.wireEncode().buf());
    }
  }
  else if (data !== null) {
    if (LOG > 3) console.log('Data packet received.');

    var pendingInterests = Face.extractEntriesForExpressedInterest(data.name);
    // Process each matching PIT entry (if any).
    for (var i = 0; i < pendingInterests.length; ++i) {
      var pitEntry = pendingInterests[i];
      var currentClosure = pitEntry.closure;

      if (this.verify == false) {
        // Pass content up without verifying the signature
        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));
        continue;
      }

      // Key verification

      // Recursive key fetching & verification closure
      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {
        this.data = content;  // unverified data packet object
        this.closure = closure;  // closure corresponding to the data
        this.keyName = key;  // name of current key to be fetched

        Closure.call(this);
      };

      var thisNDN = this;
      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {
        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
          console.log("In KeyFetchClosure.upcall: interest time out.");
          console.log(this.keyName.contentName.toUri());
        }
        else if (kind == Closure.UPCALL_CONTENT) {
          var rsakey = new Key();
          rsakey.readDerPublicKey(upcallInfo.data.content);
          var verified = data.verify(rsakey);

          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;
          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));

          // Store key in cache
          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());
          Face.addKeyEntry(keyEntry);
        }
        else if (kind == Closure.UPCALL_CONTENT_BAD)
          console.log("In KeyFetchClosure.upcall: signature verification failed");
      };

      if (data.signedInfo && data.signedInfo.locator && data.signature) {
        if (LOG > 3) console.log("Key verification...");
        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();

        var wit = null;
        if (data.signature.witness != null)
            //SWT: deprecate support for Witness decoding and Merkle hash tree verification
            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));

        var keylocator = data.signedInfo.locator;
        if (keylocator.type == KeyLocatorType.KEYNAME) {
          if (LOG > 3) console.log("KeyLocator contains KEYNAME");

          if (keylocator.keyName.contentName.match(data.name)) {
            if (LOG > 3) console.log("Content is key itself");

            var rsakey = new Key();
            rsakey.readDerPublicKey(data.content);
            var verified = data.verify(rsakey);
            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;

            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));

            // SWT: We don't need to store key here since the same key will be stored again in the closure.
          }
          else {
            // Check local key store
            var keyEntry = Face.getKeyByName(keylocator.keyName);
            if (keyEntry) {
              // Key found, verify now
              if (LOG > 3) console.log("Local key cache hit");
              var rsakey = keyEntry.rsaKey;
              var verified = data.verify(rsakey);
              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;

              // Raise callback
              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));
            }
            else {
              // Not found, fetch now
              if (LOG > 3) console.log("Fetch key according to keylocator");
              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);
              // TODO: Use expressInterest with callbacks, not Closure.
              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);
            }
          }
        }
        else if (keylocator.type == KeyLocatorType.KEY) {
          if (LOG > 3) console.log("Keylocator contains KEY");

          var rsakey = new Key();
          rsakey.readDerPublicKey(keylocator.publicKey);
          var verified = data.verify(rsakey);

          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;
          // Raise callback
          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));

          // Since KeyLocator does not contain key name for this key,
          // we have no way to store it as a key entry in KeyStore.
        }
        else {
          var cert = keylocator.certificate;
          console.log("KeyLocator contains CERT");
          console.log(cert);
          // TODO: verify certificate
        }
      }
    }
  }
};

/**
 * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host
 *   is not alive.  Get a host and port, connect, then execute onConnected().
 */
Face.prototype.connectAndExecute = function(onConnected)
{
  var hostAndPort = this.getHostAndPort();
  if (hostAndPort == null) {
    console.log('ERROR: No more hosts from getHostAndPort');
    this.host = null;
    return;
  }

  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {
    console.log('ERROR: The host returned by getHostAndPort is not alive: ' + this.host + ":" + this.port);
    return;
  }

  this.host = hostAndPort.host;
  this.port = hostAndPort.port;
  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);

  // Fetch any content.
  var interest = new Interest(new Name("/"));
  interest.interestLifetime = 4000; // milliseconds

  var thisNDN = this;
  var timerID = setTimeout(function() {
    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);
      // Try again.
      thisNDN.connectAndExecute(onConnected);
  }, 3000);

  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));
};

/**
 * This is called by the Transport when the connection is closed by the remote host.
 */
Face.prototype.closeByTransport = function()
{
  this.readyStatus = Face.CLOSED;
  this.onclose();
};

Face.ConnectClosure = function ConnectClosure(face, onConnected, timerID)
{
  // Inherit from Closure.
  Closure.call(this);

  this.face = face;
  this.onConnected = onConnected;
  this.timerID = timerID;
};

Face.ConnectClosure.prototype.upcall = function(kind, upcallInfo)
{
  if (!(kind == Closure.UPCALL_CONTENT ||
        kind == Closure.UPCALL_CONTENT_UNVERIFIED))
    // The upcall is not for us.
    return Closure.RESULT_ERR;

  // The host is alive, so cancel the timeout and continue with onConnected().
  clearTimeout(this.timerID);

    // Call Face.onopen after success
  this.face.readyStatus = Face.OPENED;
  this.face.onopen();

  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);
  this.onConnected();

  return Closure.RESULT_OK;
};

/**
 * @deprecated Use new Face.
 */
var NDN = function NDN(settings)
{
  // Call the base constructor.
  Face.call(this, settings);
}

// Use dummy functions so that the Face constructor will not try to set its own defaults.
NDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });

exports.NDN = NDN;

NDN.supported = Face.supported;
NDN.UNOPEN = Face.UNOPEN;
NDN.OPENED = Face.OPENED;
NDN.CLOSED = Face.CLOSED;

},{"./buffer.js":45,"./closure.js":46,"./crypto.js":45,"./data.js":47,"./encoding/binary-xml-decoder.js":48,"./encoding/binary-xml-encoder.js":49,"./encoding/binary-xml-wire-format.js":51,"./encoding/data-utils.js":52,"./encoding/tlv-wire-format.js":57,"./encoding/tlv/tlv-decoder.js":58,"./encoding/tlv/tlv.js":61,"./forwarding-entry.js":66,"./forwarding-flags.js":67,"./interest.js":68,"./key-locator.js":69,"./key.js":70,"./log.js":71,"./meta-info.js":72,"./name.js":73,"./transport/tcp-transport.js":44,"./util/ndn-protoco-id-tags.js":82,"crypto":5}],66:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Forwarding Entries
 */

var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var PublisherPublicKeyDigest = require('./publisher-public-key-digest.js').PublisherPublicKeyDigest;
var Name = require('./name.js').Name;

/**
 * Create a new ForwardingEntry with the optional arguments.
 * @constructor
 * @param {String} action
 * @param {Name} prefixName
 * @param {PublisherPublicKeyDigest} ndndId
 * @param {number} faceID
 * @param {number} flags
 * @param {number} lifetime in seconds
 */
var ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime) 
{
  this.action = action;
  this.prefixName = prefixName;
  this.ndndID = ndndId;
  this.faceID = faceID;
  this.flags = flags;
  this.lifetime = lifetime;
};

exports.ForwardingEntry = ForwardingEntry;

ForwardingEntry.ACTIVE         = 1;
ForwardingEntry.CHILD_INHERIT  = 2;
ForwardingEntry.ADVERTISE      = 4;
ForwardingEntry.LAST           = 8;
ForwardingEntry.CAPTURE       = 16;
ForwardingEntry.LOCAL         = 32;
ForwardingEntry.TAP           = 64;
ForwardingEntry.CAPTURE_OK   = 128;

ForwardingEntry.prototype.from_ndnb = function(
  //XMLDecoder 
  decoder) 
  //throws DecodingException
{
  decoder.readElementStartDTag(this.getElementLabel());
  if (decoder.peekDTag(NDNProtocolDTags.Action))
    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action); 
  if (decoder.peekDTag(NDNProtocolDTags.Name)) {
    this.prefixName = new Name();
    this.prefixName.from_ndnb(decoder) ;
  }
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    this.NdndId = new PublisherPublicKeyDigest();
    this.NdndId.from_ndnb(decoder);
  }
  if (decoder.peekDTag(NDNProtocolDTags.FaceID))
    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID); 
  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))
    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags); 
  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))
    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds); 

  decoder.readElementClose();
};

ForwardingEntry.prototype.to_ndnb = function(
  //XMLEncoder 
  encoder) 
{
  encoder.writeElementStartDTag(this.getElementLabel());
  if (null != this.action && this.action.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);  
  if (null != this.prefixName)
    this.prefixName.to_ndnb(encoder);
  if (null != this.NdndId)
    this.NdndId.to_ndnb(encoder);
  if (null != this.faceID)
    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);
  if (null != this.flags)
    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);
  if (null != this.lifetime)
    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);

  encoder.writeElementClose();         
};

ForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }

},{"./name.js":73,"./publisher-public-key-digest.js":75,"./util/ndn-protoco-id-tags.js":82}],67:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

var ForwardingEntry = require('./forwarding-entry.js').ForwardingEntry;

/**
 * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for
 * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding
 * bits are changed, amended or deprecated.
 * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.
 */
var ForwardingFlags = function ForwardingFlags() 
{
  this.active = true;
  this.childInherit = true;
  this.advertise = false;
  this.last = false;
  this.capture = false;
  this.local = false;
  this.tap = false;
  this.captureOk = false;
}

exports.ForwardingFlags = ForwardingFlags;

/**
 * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.
 * @returns {number} An integer with the bits set.
 */
ForwardingFlags.prototype.getForwardingEntryFlags = function()
{
  var result = 0;
  
  if (this.active)
    result |= ForwardingEntry.ACTIVE;
  if (this.childInherit)
    result |= ForwardingEntry.CHILD_INHERIT;
  if (this.advertise)
    result |= ForwardingEntry.ADVERTISE;
  if (this.last)
    result |= ForwardingEntry.LAST;
  if (this.capture)
    result |= ForwardingEntry.CAPTURE;
  if (this.local)
    result |= ForwardingEntry.LOCAL;
  if (this.tap)
    result |= ForwardingEntry.TAP;
  if (this.captureOk)
    result |= ForwardingEntry.CAPTURE_OK;
  
  return result;
};

/**
 * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.
 * @param {number} forwardingEntryFlags An integer with the bits set.
 */
ForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)
{
  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);
  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);
  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);
  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);
  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);
  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);
  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);
  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);
};

/**
 * Get the value of the "active" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getActive = function() { return this.active; };

/**
 * Get the value of the "childInherit" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };

/**
 * Get the value of the "advertise" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };

/**
 * Get the value of the "last" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getLast = function() { return this.last; };

/**
 * Get the value of the "capture" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getCapture = function() { return this.capture; };

/**
 * Get the value of the "local" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getLocal = function() { return this.local; };

/**
 * Get the value of the "tap" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getTap = function() { return this.tap; };

/**
 * Get the value of the "captureOk" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };

/**
 * Set the value of the "active" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setActive = function(value) { this.active = value; };

/**
 * Set the value of the "childInherit" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };

/**
 * Set the value of the "advertise" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };

/**
 * Set the value of the "last" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setLast = function(value) { this.last = value; };

/**
 * Set the value of the "capture" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };

/**
 * Set the value of the "local" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setLocal = function(value) { this.local = value; };

/**
 * Set the value of the "tap" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setTap = function(value) { this.tap = value; };

/**
 * Set the value of the "captureOk" flag
 * @param {number} value true to set the flag, false to clear it.
 */  
ForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };

},{"./forwarding-entry.js":66}],68:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents Interest Objects
 */

var Blob = require('./util/blob.js').Blob;
var Name = require('./name.js').Name;
var Exclude = require('./exclude.js').Exclude;
var PublisherPublicKeyDigest = require('./publisher-public-key-digest.js').PublisherPublicKeyDigest;
var KeyLocator = require('./key-locator.js').KeyLocator;
var WireFormat = require('./encoding/wire-format.js').WireFormat;
var customBuf = require('./buffer.js').Buffer
var LOG = require('./log.js').LOG
/**
 * Create a new Interest with the optional values.
 * 
 * @constructor
 * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the
 * other arguments.  Otherwise this is the optional name for the new Interest.
 * @param {number} minSuffixComponents
 * @param {number} maxSuffixComponents
 * @param {Buffer} publisherPublicKeyDigest
 * @param {Exclude} exclude
 * @param {number} childSelector
 * @param {number} answerOriginKind
 * @param {number} scope
 * @param {number} interestLifetimeMilliseconds in milliseconds
 * @param {Buffer} nonce
 */
var Interest = function Interest
   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude, 
    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce) 
{
  if (typeof nameOrInterest === 'object' && nameOrInterest instanceof Interest) {
    // Special case: this is a copy constructor.  Ignore all but the first argument.
    var interest = nameOrInterest;
    if (interest.name)
      // Copy the name.
      this.name = new Name(interest.name);
    this.maxSuffixComponents = interest.maxSuffixComponents;
    this.minSuffixComponents = interest.minSuffixComponents;

    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;
    this.keyLocator = new KeyLocator(interest.keyLocator);
    this.exclude = new Exclude(interest.exclude);
    this.childSelector = interest.childSelector;
    this.answerOriginKind = interest.answerOriginKind;
    this.scope = interest.scope;
    this.interestLifetime = interest.interestLifetime;
    if (interest.nonce)
      // Copy.
      this.nonce = new customBuf(interest.nonce);    
  }  
  else {
    this.name = typeof nameOrInterest === 'object' && nameOrInterest instanceof Name ?
                new Name(nameOrInterest) : new Name();
    this.maxSuffixComponents = maxSuffixComponents;
    this.minSuffixComponents = minSuffixComponents;

    this.publisherPublicKeyDigest = publisherPublicKeyDigest;
    this.keyLocator = new KeyLocator();
    this.exclude = typeof exclude === 'object' && exclude instanceof Exclude ?
                   new Exclude(exclude) : new Exclude();
    this.childSelector = childSelector;
    this.answerOriginKind = answerOriginKind;
    this.scope = scope;
    this.interestLifetime = interestLifetimeMilliseconds;
    if (nonce)
      // Copy and make sure it is a customBuf.
      this.nonce = new customBuf(nonce);
  }
};

exports.Interest = Interest;

Interest.RECURSIVE_POSTFIX = "*";

Interest.CHILD_SELECTOR_LEFT = 0;
Interest.CHILD_SELECTOR_RIGHT = 1;

Interest.ANSWER_NO_CONTENT_STORE = 0;
Interest.ANSWER_CONTENT_STORE = 1;
Interest.ANSWER_GENERATED = 2;
Interest.ANSWER_STALE = 4;    // Stale answer OK
Interest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"

Interest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;

/**
 * Return true if this.name.match(name) and the name conforms to the interest selectors.
 * @param {Name} name
 * @returns {boolean}
 */
Interest.prototype.matchesName = function(/*Name*/ name) 
{
  if (!this.name.match(name))
    return false;
    
  if (this.minSuffixComponents != null &&
      // Add 1 for the implicit digest.
      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))
    return false;
  if (this.maxSuffixComponents != null &&
      // Add 1 for the implicit digest.
      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))
    return false;
  if (this.exclude != null && name.size() > this.name.size() &&
      this.exclude.matches(name.components[this.name.size()]))
    return false;
    
  return true;
};

/**
 * @deprecated Use matchesName.
 */
Interest.prototype.matches_name = function(/*Name*/ name) 
{
  return this.matchesName(name);
};

/**
 * Return a new Interest with the same fields as this Interest.  
 */
Interest.prototype.clone = function() 
{
  return new Interest
     (this.name, this.minSuffixComponents, this.maxSuffixComponents, 
      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind, 
      this.scope, this.interestLifetime, this.nonce);
};

/**
 * Get the interest Name.
 * @returns {Name} The name.  The name size() may be 0 if not specified.
 */
Interest.prototype.getName = function() { return this.name; };

/**
 * Get the min suffix components.
 * @returns number} The min suffix components, or null if not specified.
 */
Interest.prototype.getMinSuffixComponents = function() 
{ 
  return this.minSuffixComponents; 
};

/**
 * Get the max suffix components.
 * @returns {number} The max suffix components, or null if not specified.
 */
Interest.prototype.getMaxSuffixComponents = function() 
{ 
  return this.maxSuffixComponents; 
};

/**
 * Get the interest key locator.
 * @returns {KeyLocator} The key locator. If its getType() is null, 
 * then the key locator is not specified.
 */
Interest.prototype.getKeyLocator = function() 
{ 
  return this.keyLocator; 
};

/**
 * Get the exclude object.
 * @returns {Exclude} The exclude object. If the exclude size() is zero, then
 * the exclude is not specified.
 */
Interest.prototype.getExclude = function() { return this.exclude; };

/**
 * Get the child selector.
 * @returns {number} The child selector, or null if not specified.
 */
Interest.prototype.getChildSelector = function() 
{ 
  return this.childSelector; 
};

/**
 * @deprecated Use getMustBeFresh.
 */
Interest.prototype.getAnswerOriginKind = function() 
{ 
  return this.answerOriginKind; 
};
  
  /**
   * Return true if the content must be fresh.
   * @return true if must be fresh, otherwise false.
   */
  
/**
 * Get the must be fresh flag. If not specified, the default is true.
 * @returns {boolean} The must be fresh flag.
 */
Interest.prototype.getMustBeFresh = function() 
{
  if (this.answerOriginKind == null || this.answerOriginKind < 0)
    return true;
  else
    return (this.answerOriginKind & Interest.ANSWER_STALE) == 0;
};

/**
 * Return the nonce value from the incoming interest.  If you change any of the 
 * fields in this Interest object, then the nonce value is cleared.
 * @returns {Buffer} The nonce, or null if not specified.
 */
Interest.prototype.getNonce = function() { return this.nonce; };

/**
 * Get the interest scope.
 * @returns {number} The scope, or null if not specified.
 */
Interest.prototype.getScope = function() { return this.scope; };

/**
 * Get the interest lifetime.
 * @returns {number} The interest lifetime in milliseconds, or null if not 
 * specified.
 */
Interest.prototype.getInterestLifetimeMilliseconds = function() 
{ 
  return this.interestLifetime; 
};

Interest.prototype.setName = function(name)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.name = typeof name === 'object' && name instanceof Interest ?
              new Name(name) : new Name();
};
                
Interest.prototype.setMinSuffixComponents = function(minSuffixComponents)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.minSuffixComponents = minSuffixComponents;
};

Interest.prototype.setMaxSuffixComponents = function(maxSuffixComponents)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.maxSuffixComponents = maxSuffixComponents;
};

/**
 * Set this interest to use a copy of the given exclude object. Note: You can 
 * also change this interest's exclude object modifying the object from 
 * getExclude().
 * @param {Exclude} exclude The exlcude object that is copied.
 */
Interest.prototype.setExclude = function(exclude)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.exclude = typeof exclude === 'object' && exclude instanceof Exclude ?
                 new Exclude(exclude) : new Exclude();
};

Interest.prototype.setChildSelector = function(childSelector)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.childSelector = childSelector;
};

/**
 * @deprecated Use setMustBeFresh.
 */
Interest.prototype.setAnswerOriginKind = function(answerOriginKind)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.answerOriginKind = answerOriginKind;
};

/**
 * Set the MustBeFresh flag.
 * @param {boolean} mustBeFresh True if the content must be fresh, otherwise false.
 */
Interest.prototype.setMustBeFresh = function(mustBeFresh)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  if (this.answerOriginKind == null || this.answerOriginKind < 0) {
    // It is is already the default where MustBeFresh is true. 
    if (!mustBeFresh)
      // Set answerOriginKind_ so that getMustBeFresh returns false.
      this.answerOriginKind = Interest.ANSWER_STALE; 
  }
  else {
    if (mustBeFresh)
      // Clear the stale bit.
      this.answerOriginKind &= ~Interest.ANSWER_STALE;
    else
      // Set the stale bit.
      this.answerOriginKind |= Interest.ANSWER_STALE;
  }
};

Interest.prototype.setScope = function(scope)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.scope = scope;
};

Interest.prototype.setInterestLifetimeMilliseconds = function(interestLifetimeMilliseconds)
{
  // The object has changed, so the nonce is invalid.
  this.nonce = null;
  
  this.interestLifetime = interestLifetimeMilliseconds;
};

/**
 * @deprecated You should let the wire encoder generate a random nonce 
 * internally before sending the interest.
 */
Interest.prototype.setNonce = function(nonce)
{
  if (nonce)
    // Copy and make sure it is a customBuf.
    this.nonce = new customBuf(nonce);
  else
    this.nonce = null;
};

/**
 * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and
 * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".
 * @returns {string} The URI string.
 * @note This is an experimental feature.  See the API docs for more detail at
 * http://named-data.net/doc/ndn-ccl-api/interest.html#interest-touri-method .
 */
Interest.prototype.toUri = function() 
{  
  var selectors = "";
  
  if (this.minSuffixComponents != null)
    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;
  if (this.maxSuffixComponents != null)
    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;
  if (this.childSelector != null)
    selectors += "&ndn.ChildSelector=" + this.childSelector;
  if (this.answerOriginKind != null)
    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;
  if (this.scope != null)
    selectors += "&ndn.Scope=" + this.scope;
  if (this.interestLifetime != null)
    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;
  if (this.publisherPublicKeyDigest != null)
    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);
  if (this.nonce != null)
    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);
  if (this.exclude != null && this.exclude.size() > 0)
    selectors += "&ndn.Exclude=" + this.exclude.toUri();

  var result = this.name.toUri();
  if (selectors != "")
    // Replace the first & with ?.
    result += "?" + selectors.substr(1);
  
  return result;
};

/**
 * Encode this Interest for a particular wire format.
 * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object 
 * used to encode this object. If omitted, use WireFormat.getDefaultWireFormat().
 * @returns {Blob} The encoded buffer in a Blob object.
 */
Interest.prototype.wireEncode = function(wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  return wireFormat.encodeInterest(this);
};

/**
 * Decode the input using a particular wire format and update this Interest.
 * @param {Buffer} input The buffer with the bytes to decode.
 * @param {a subclass of WireFormat} wireFormat (optional) A WireFormat object 
 * used to decode this object. If omitted, use WireFormat.getDefaultWireFormat().
 */
Interest.prototype.wireDecode = function(input, wireFormat) 
{
  wireFormat = (wireFormat || WireFormat.getDefaultWireFormat());
  // If input is a blob, get its buf().
  if (LOG > 3 ) console.log('decoding input to interes', input)
  var decodeBuffer = typeof input === 'object' && input instanceof Blob ? 
                     input.buf() : input;
  wireFormat.decodeInterest(this, decodeBuffer);
};

// Since binary-xml-wire-format.js includes this file, put these at the bottom 
// to avoid problems with cycles of require.
var BinaryXmlWireFormat = require('./encoding/binary-xml-wire-format.js').BinaryXmlWireFormat;

/**
 * @deprecated Use wireDecode(input, BinaryXmlWireFormat.get()).
 */
Interest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder) 
{
  BinaryXmlWireFormat.decodeInterest(this, decoder);
};

/**
 * @deprecated Use wireEncode(BinaryXmlWireFormat.get()).
 */
Interest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder) 
{
  BinaryXmlWireFormat.encodeInterest(this, encoder);
};

/**
 * @deprecated Use wireEncode.  If you need binary XML, use
 * wireEncode(BinaryXmlWireFormat.get()).
 */
Interest.prototype.encode = function(wireFormat) 
{
  return this.wireEncode(BinaryXmlWireFormat.get()).buf();
};

/**
 * @deprecated Use wireDecode.  If you need binary XML, use
 * wireDecode(input, BinaryXmlWireFormat.get()).
 */
Interest.prototype.decode = function(input, wireFormat) 
{
  this.wireDecode(input, BinaryXmlWireFormat.get())
};

},{"./buffer.js":45,"./encoding/binary-xml-wire-format.js":51,"./encoding/wire-format.js":62,"./exclude.js":63,"./key-locator.js":69,"./log.js":71,"./name.js":73,"./publisher-public-key-digest.js":75,"./util/blob.js":79}],69:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an NDN KeyLocator object.
 */

var Name = require('./name.js').Name;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var PublisherID = require('./publisher-id.js').PublisherID;
var customBuf = require('./buffer.js').Buffer
var LOG = require('./log.js').Log.LOG;

/**
 * KeyLocator
 */
var KeyLocatorType = {
  KEYNAME: 1,
  KEY_LOCATOR_DIGEST: 2,
  KEY: 3,
  CERTIFICATE: 4
};

exports.KeyLocatorType = KeyLocatorType;

/**
 * @constructor
 */
var KeyLocator = function KeyLocator(input,type) 
{ 
  if (typeof input === 'object' && input instanceof KeyLocator) {
    // Copy from the input KeyLocator.
    this.type = input.type;
    this.keyName = new KeyName();
    if (input.keyName != null) {
      this.keyName.contentName = input.keyName.contentName == null ? 
        null : new Name(input.keyName.contentName);
      this.keyName.publisherID = input.keyName.publisherID;
    }
    this.keyData = input.keyData == null ? null : new customBuf(input.keyData);
    this.publicKey = input.publicKey == null ? null : new customBuf(input.publicKey);
    this.certificate = input.certificate == null ? null : new customBuf(input.certificate);
  }
  else {
    this.type = type;
    this.keyName = new KeyName();

    if (type == KeyLocatorType.KEYNAME)
      this.keyName = input;
    else if (type == KeyLocatorType.KEY_LOCATOR_DIGEST)
      this.keyData = new customBuf(input);
    else if (type == KeyLocatorType.KEY) {
      this.keyData = new customBuf(input);
      // Set for backwards compatibility.
      this.publicKey = this.keyData;
    }
    else if (type == KeyLocatorType.CERTIFICATE) {
      this.keyData = new customBuf(input);
      // Set for backwards compatibility.
      this.certificate = this.keyData;
    }
  }
};

exports.KeyLocator = KeyLocator;

/**
 * Get the key locator type. If KeyLocatorType.KEYNAME, you may also
 * getKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you may also
 * getKeyData() to get the digest.
 * @returns {number} The key locator type, or null if not specified.
 */
KeyLocator.prototype.getType = function() { return this.type; };

/**
 * Get the key name.  This is meaningful if getType() is KeyLocatorType.KEYNAME.
 * @returns {Name} The key name. If not specified, the Name is empty.
 */
KeyLocator.prototype.getKeyName = function() 
{ 
  if (this.keyName == null)
    this.keyName = new KeyName();
  if (this.keyName.contentName == null)
    this.keyName.contentName = new Name();
  
  return this.keyName.contentName;
};

/**
 * Get the key data. If getType() is KeyLocatorType.KEY_LOCATOR_DIGEST, this is 
 * the digest bytes. If getType() is KeyLocatorType.KEY, this is the DER 
 * encoded public key. If getType() is KeyLocatorType.CERTIFICATE, this is the 
 * DER encoded certificate. 
 * @returns {Buffer} The key data, or null if not specified.
 */
KeyLocator.prototype.getKeyData = function() 
{ 
  if (this.type == KeyLocatorType.KEY)
    return this.publicKey;
  else if (this.type == KeyLocatorType.CERTIFICATE)
    return this.certificate;
  else
    return this.keyData;
};

/**
 * Set the key locator type.  If KeyLocatorType.KEYNAME, you must also
 * setKeyName().  If KeyLocatorType.KEY_LOCATOR_DIGEST, you must also
 * setKeyData() to the digest.
 * @param {number} type The key locator type.  If null, the type is unspecified.
 */
KeyLocator.prototype.setType = function(type) { this.type = type; }; 

/**
 * Set key name to a copy of the given Name.  This is the name if getType() 
 * is KeyLocatorType.KEYNAME.
 * @param {Name} name The key name which is copied.
 */
KeyLocator.prototype.setKeyName = function(name) 
{ 
  if (this.keyName == null)
    this.keyName = new KeyName();
  
  this.keyName.contentName = typeof name === 'object' && name instanceof Name ?
                             new Name(name) : new Name(); 
}; 

/**
 * Set the key data to the given value. This is the digest bytes if getType() is 
 * KeyLocatorType.KEY_LOCATOR_DIGEST.
 * @param {Buffer} keyData The array with the key data bytes.
 */
KeyLocator.prototype.setKeyData = function(keyData)
{
  var value = keyData;
  if (value != null)
    // Make a copy.
    value = new customBuf(value);
  
  this.keyData = value;
  // Set for backwards compatibility.
  this.publicKey = value;
  this.certificate = value;
};

/**
 * Clear the keyData and set the type to none.
 */
KeyLocator.prototype.clear = function() 
{
  this.type = null;
  this.keyName = null;
  this.keyData = null;
  this.publicKey = null;
  this.certificate = null;
};

KeyLocator.prototype.from_ndnb = function(decoder) {

  decoder.readElementStartDTag(this.getElementLabel());

  if (decoder.peekDTag(NDNProtocolDTags.Key)) 
  {
    try {
      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);
      // This is a DER-encoded SubjectPublicKeyInfo.
      
      //TODO FIX THIS, This should create a Key Object instead of keeping bytes

      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);
      this.type = KeyLocatorType.KEY;    

      if (LOG > 4) console.log('PUBLIC KEY FOUND: '+ this.publicKey);
    } 
    catch (e) {
      throw new Error("Cannot parse key: ", e);
    } 

    if (null == this.publicKey)
      throw new Error("Cannot parse key: ");
  } 
  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {
    try {
      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);
      
      /*
       * Certificates not yet working
       */
      
      this.certificate = encodedCert;
      this.type = KeyLocatorType.CERTIFICATE;

      if (LOG > 4) console.log('CERTIFICATE FOUND: '+ this.certificate);      
    } 
    catch (e) {
      throw new Error("Cannot decode certificate: " +  e);
    }
    if (null == this.certificate)
      throw new Error("Cannot parse certificate! ");
  } else  {
    this.type = KeyLocatorType.KEYNAME;
    
    this.keyName = new KeyName();
    this.keyName.from_ndnb(decoder);
  }
  decoder.readElementClose();
};  

KeyLocator.prototype.to_ndnb = function(encoder) 
{
  if (LOG > 4) console.log('type is is ' + this.type);

  if (this.type == KeyLocatorType.KEY_LOCATOR_DIGEST)
    // encodeSignedInfo already encoded this as the publisherPublicKeyDigest,
    //   so do nothing here.
    return;

  encoder.writeElementStartDTag(this.getElementLabel());
  
  if (this.type == KeyLocatorType.KEY) {
    if (LOG > 5) console.log('About to encode a public key' +this.publicKey);
    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);  
  } 
  else if (this.type == KeyLocatorType.CERTIFICATE) {  
    try {
      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);
    } 
    catch (e) {
      throw new Error("CertificateEncodingException attempting to write key locator: " + e);
    }    
  } 
  else if (this.type == KeyLocatorType.KEYNAME)
    this.keyName.to_ndnb(encoder);

  encoder.writeElementClose();
};

KeyLocator.prototype.getElementLabel = function() 
{
  return NDNProtocolDTags.KeyLocator; 
};

/**
 * KeyName is only used by KeyLocator.
 * @constructor
 */
var KeyName = function KeyName() 
{
  this.contentName = new Name();  //contentName
  this.publisherID = this.publisherID;  //publisherID
};

exports.KeyName = KeyName;

KeyName.prototype.from_ndnb = function(decoder) 
{
  decoder.readElementStartDTag(this.getElementLabel());

  this.contentName = new Name();
  this.contentName.from_ndnb(decoder);
  
  if (LOG > 4) console.log('KEY NAME FOUND: ');
  
  if (PublisherID.peek(decoder)) {
    this.publisherID = new PublisherID();
    this.publisherID.from_ndnb(decoder);
  }
  
  decoder.readElementClose();
};

KeyName.prototype.to_ndnb = function(encoder)
{
  encoder.writeElementStartDTag(this.getElementLabel());
  
  this.contentName.to_ndnb(encoder);
  if (null != this.publisherID)
    this.publisherID.to_ndnb(encoder);

  encoder.writeElementClose();       
};
  
KeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };


},{"./buffer.js":45,"./log.js":71,"./name.js":73,"./publisher-id.js":74,"./util/ndn-protoco-id-tags.js":82}],70:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Key Objects
 */

var customBuf = require('./buffer.js').Buffer
var DataUtils = require('./encoding/data-utils.js').DataUtils;
var LOG = require('./log.js').Log.LOG;

/**
 * @constructor
 */
/**
 * Key
 */
var Key = function Key()
{
  this.publicKeyDer = null;     // customBuf
  this.publicKeyDigest = null;  // customBuf
  this.publicKeyPem = null;     // String
  this.privateKeyPem = null;    // String
};

exports.Key = Key;

/**
 * Helper functions to read Key fields
 * TODO: generateRSA()
 */

Key.prototype.publicToDER = function()
{
  return this.publicKeyDer;  // customBuf
};

Key.prototype.privateToDER = function()
{
  // Remove the '-----XXX-----' from the beginning and the end of the key
  // and also remove any \n in the key string
  var lines = this.privateKeyPem.split('\n');
  priKey = "";
  for (var i = 1; i < lines.length - 1; i++)
    priKey += lines[i];

  return new customBuf(priKey, 'base64');
};

Key.prototype.publicToPEM = function()
{
  return this.publicKeyPem;
};

Key.prototype.privateToPEM = function()
{
  return this.privateKeyPem;
};

Key.prototype.getKeyID = function()
{
  return this.publicKeyDigest;
};

exports.Key = Key;

Key.prototype.readDerPublicKey = function(/*Buffer*/pub_der)
{
  if (LOG > 4) console.log("Encode DER public key:\n" + pub_der.toString('hex'));

  this.publicKeyDer = pub_der;

  var hash = require("./crypto.js").createHash('sha256');
  hash.update(this.publicKeyDer);
  this.publicKeyDigest = new customBuf(DataUtils.toNumbersIfString(hash.digest()));
  var keyStr = pub_der.toString('base64');
  var keyPem = "-----BEGIN PUBLIC KEY-----\n";
  for (var i = 0; i < keyStr.length; i += 64)
  keyPem += (keyStr.substr(i, 64) + "\n");
  keyPem += "-----END PUBLIC KEY-----";
  this.publicKeyPem = keyPem;

  if (LOG > 4) console.log("Convert public key to PEM format:\n" + this.publicKeyPem);
};

/**
 * Load RSA key pair from PEM-encoded strings.
 * Will throw an Error if both 'pub' and 'pri' are null.
 */
Key.prototype.fromPemString = function(pub, pri)
{
  if (pub == null && pri == null)
    throw new Error('Cannot create Key object if both public and private PEM string is empty.');

  // Read public key
  if (pub != null) {
    this.publicKeyPem = pub;
    if (LOG > 4) console.log("Key.publicKeyPem: \n" + this.publicKeyPem);

    // Remove the '-----XXX-----' from the beginning and the end of the public key
    // and also remove any \n in the public key string
    var lines = pub.split('\n');
    pub = "";
    for (var i = 1; i < lines.length - 1; i++)
      pub += lines[i];
    this.publicKeyDer = new customBuf(pub, 'base64');
    if (LOG > 4) console.log("Key.publicKeyDer: \n" + this.publicKeyDer.toString('hex'));

    var hash = require("./crypto.js").createHash('sha256');
    hash.update(this.publicKeyDer);
    this.publicKeyDigest = new customBuf(DataUtils.toNumbersIfString(hash.digest()));
    if (LOG > 4) console.log("Key.publicKeyDigest: \n" + this.publicKeyDigest.toString('hex'));
  }

  // Read private key
  if (pri != null) {
    this.privateKeyPem = pri;
    if (LOG > 4) console.log("Key.privateKeyPem: \n" + this.privateKeyPem);
  }
};

Key.prototype.fromPem = Key.prototype.fromPemString;

/**
 * Static method that create a Key object.
 * Parameter 'obj' is a JSON object that has two properties:
 *   pub: the PEM string for the public key
 *   pri: the PEM string for the private key
 * Will throw an Error if both obj.pub and obj.pri are null.
 */
Key.createFromPEM = function(obj)
{
    var key = new Key();
    key.fromPemString(obj.pub, obj.pri);
    return key;
};

},{"./buffer.js":45,"./crypto.js":45,"./encoding/data-utils.js":52,"./log.js":71}],71:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * The Log class holds the global static variable LOG.
 */
var Log = function Log()
{
}

exports.Log = Log;

/**
 * LOG is the level for logging debugging statements.  0 means no log messages.
 * @type Number
 */
Log.LOG = 0;

},{}],72:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an NDN Data MetaInfo object.
 */

var customBuf = require('./buffer.js').Buffer
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var Blob = require('./util/blob.js').Blob;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var KeyLocator = require('./key-locator.js').KeyLocator;
var KeyLocatorType = require('./key-locator.js').KeyLocatorType;
var Name = require('./name.js').Name;
var PublisherPublicKeyDigest = require('./publisher-public-key-digest.js').PublisherPublicKeyDigest;
var NDNTime = require('./util/ndn-time.js').NDNTime;
var globalKeyManager = require('./security/key-manager.js').globalKeyManager;
var LOG = require('./log.js').Log.LOG;

var ContentType = {
  BLOB:0,
  // ContentType DATA is deprecated.  Use ContentType.BLOB .
  DATA:0, 
  LINK:1, 
  KEY: 2, 
  // ContentType ENCR, GONE and NACK are not supported in NDN-TLV encoding and are deprecated.
  ENCR:3, 
  GONE:4, 
  NACK:5
};

exports.ContentType = ContentType;

/**
 * Create a new MetaInfo with the optional values.
 * @constructor
 */
var MetaInfo = function MetaInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID, skipSetFields) 
{
  if (typeof publisherOrMetaInfo === 'object' && 
      publisherOrMetaInfo instanceof MetaInfo) {
    // Copy values.
    var metaInfo = publisherOrMetaInfo;
    this.publisher = metaInfo.publisher;
    this.timestamp = metaInfo.timestamp;
    this.type = metaInfo.type;
    this.locator = metaInfo.locator == null ? 
      new KeyLocator() : new KeyLocator(metaInfo.locator);
    this.freshnessSeconds = metaInfo.freshnessSeconds;
    this.finalBlockID = metaInfo.finalBlockID;
  }
  else {
    this.publisher = publisherOrMetaInfo; //publisherPublicKeyDigest
    this.timestamp = timestamp; // NDN Time
    this.type = type; // ContentType
    this.locator = locator == null ? new KeyLocator() : new KeyLocator(locator);
    this.freshnessSeconds = freshnessSeconds; // Integer
    this.finalBlockID = finalBlockID; //byte array

    if (!skipSetFields)
      this.setFields();
  }
};

exports.MetaInfo = MetaInfo;

/**
 * Get the content type.
 * @returns {an int from ContentType} The content type.
 */
MetaInfo.prototype.getType = function()
{
  return this.type;
};

/**
 * Get the freshness period.
 * @returns {number} The freshness period in milliseconds, or null if not 
 * specified.
 */
MetaInfo.prototype.getFreshnessPeriod = function()
{
  // Use attribute freshnessSeconds for backwards compatibility.
  if (this.freshnessSeconds == null || this.freshnessSeconds < 0)
    return null;
  else
    // Convert to milliseconds.
    return this.freshnessSeconds * 1000.0;
};

/**
 * Get the final block ID.
 * @returns {Buffer} The final block ID or null if not specified.
 */
MetaInfo.prototype.getFinalBlockID = function()
{
  // TODO: finalBlockID should be a Name.Component, not customBuf.
  return this.finalBlockID;
};

/**
 * Set the content type.
 * @param {an int from ContentType} type The content type.  If null, this 
 * uses ContentType.BLOB.
 */
MetaInfo.prototype.setType = function(type)
{
  this.type = type == null || type < 0 ? ContentType.BLOB : type;
};

/**
 * Set the freshness period.
 * @param {type} freshnessPeriod The freshness period in milliseconds, or null
 * for not specified.
 */
MetaInfo.prototype.setFreshnessPeriod = function(freshnessPeriod)
{
  // Use attribute freshnessSeconds for backwards compatibility.
  if (freshnessPeriod == null || freshnessPeriod < 0)
    this.freshnessSeconds = null;
  else
    // Convert from milliseconds.
    this.freshnessSeconds = freshnessPeriod / 1000.0;
};

MetaInfo.prototype.setFinalBlockID = function(finalBlockID)
{
  // TODO: finalBlockID should be a Name.Component, not customBuf.
  if (finalBlockID == null)
    this.finalBlockID = null;
  else if (typeof finalBlockID === 'object' && finalBlockID instanceof Blob)
    this.finalBlockID = finalBlockID.buf();
  else if (typeof finalBlockID === 'object' && finalBlockID instanceof Name.Component)
    this.finalBlockID = finalBlockID.getValue();
  else 
    this.finalBlockID = new customBuf(finalBlockID);
};

MetaInfo.prototype.setFields = function() 
{
  var key = globalKeyManager.getKey();
  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());

  var d = new Date();
    
  var time = d.getTime();  

  this.timestamp = new NDNTime(time);
    
  if (LOG > 4) console.log('TIME msec is');

  if (LOG > 4) console.log(this.timestamp.msec);

  //DATA
  this.type = ContentType.BLOB;
  
  if (LOG > 4) console.log('PUBLIC KEY TO WRITE TO DATA PACKET IS ');
  if (LOG > 4) console.log(key.publicToDER().toString('hex'));

  this.locator = new KeyLocator(key.getKeyID(), KeyLocatorType.KEY_LOCATOR_DIGEST);
};

MetaInfo.prototype.from_ndnb = function(decoder) 
{
  decoder.readElementStartDTag(this.getElementLabel());
  
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    if (LOG > 4) console.log('DECODING PUBLISHER KEY');
    this.publisher = new PublisherPublicKeyDigest();
    this.publisher.from_ndnb(decoder);
  }

  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {
    if (LOG > 4) console.log('DECODING TIMESTAMP');
    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);
  }

  if (decoder.peekDTag(NDNProtocolDTags.Type)) {
    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);
    
    if (LOG > 4) console.log('Binary Type of of Signed Info is '+binType);

    this.type = binType;
    
    //TODO Implement type of Key Reading
    if (null == this.type)
      throw new Error("Cannot parse signedInfo type: bytes.");
  } 
  else
    this.type = ContentType.DATA; // default
  
  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {
    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);
    if (LOG > 4) console.log('FRESHNESS IN SECONDS IS '+ this.freshnessSeconds);
  }
  
  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {
    if (LOG > 4) console.log('DECODING FINAL BLOCKID');
    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);
  }
  
  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {
    if (LOG > 4) console.log('DECODING KEY LOCATOR');
    this.locator = new KeyLocator();
    this.locator.from_ndnb(decoder);
  }
      
  decoder.readElementClose();
};

/**
 * Encode this MetaInfo in ndnb, using the given keyLocator instead of the
 * locator in this object.
 * @param {BinaryXMLEncoder} encoder The encoder.
 * @param {KeyLocator} keyLocator The key locator to use (from 
 * Data.getSignatureOrMetaInfoKeyLocator).
 */
MetaInfo.prototype.to_ndnb = function(encoder, keyLocator)  {
  if (!this.validate())
    throw new Error("Cannot encode : field values missing.");

  encoder.writeElementStartDTag(this.getElementLabel());
  
  if (null != this.publisher) {
    // We have a publisherPublicKeyDigest, so use it.
    if (LOG > 3) console.log('ENCODING PUBLISHER KEY' + this.publisher.publisherPublicKeyDigest);
    this.publisher.to_ndnb(encoder);
  }
  else {
    if (null != keyLocator &&
        keyLocator.getType() == KeyLocatorType.KEY_LOCATOR_DIGEST && 
        keyLocator.getKeyData() != null &&
        keyLocator.getKeyData().length > 0)
      // We have a TLV-style KEY_LOCATOR_DIGEST, so encode as the
      //   publisherPublicKeyDigest.
      encoder.writeDTagElement
        (NDNProtocolDTags.PublisherPublicKeyDigest, keyLocator.getKeyData());
  }

  if (null != this.timestamp)
    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);
  
  if (null != this.type && this.type != 0)
    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);
  
  if (null != this.freshnessSeconds)
    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);

  if (null != this.finalBlockID)
    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);

  if (null != keyLocator)
    keyLocator.to_ndnb(encoder);

  encoder.writeElementClose();       
};
  
MetaInfo.prototype.valueToType = function() 
{
  return null;  
};

MetaInfo.prototype.getElementLabel = function() { 
  return NDNProtocolDTags.SignedInfo;
};

MetaInfo.prototype.validate = function() 
{
  // We don't do partial matches any more, even though encoder/decoder
  // is still pretty generous.
  if (null == this.timestamp)
    return false;
  return true;
};

/**
 * @deprecated Use new MetaInfo.
 */
var SignedInfo = function SignedInfo(publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID) 
{
  // Call the base constructor.
  MetaInfo.call(this, publisherOrMetaInfo, timestamp, type, locator, freshnessSeconds, finalBlockID); 
}

// Set skipSetFields true since we only need the prototype functions.
SignedInfo.prototype = new MetaInfo(null, null, null, null, null, null, true);

exports.SignedInfo = SignedInfo;

},{"./buffer.js":45,"./encoding/binary-xml-decoder.js":48,"./encoding/binary-xml-encoder.js":49,"./key-locator.js":69,"./log.js":71,"./name.js":73,"./publisher-public-key-digest.js":75,"./security/key-manager.js":76,"./util/blob.js":79,"./util/ndn-protoco-id-tags.js":82,"./util/ndn-time.js":83}],73:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents a Name as an array of components where each is a byte array.
 */
 
var Blob = require('./util/blob.js').Blob;
var DataUtils = require('./encoding/data-utils.js').DataUtils;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var customBuf = require('./buffer.js').Buffer
var LOG = require('./log.js').Log.LOG;

/**
 * Create a new Name from components.
 * 
 * @constructor
 * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.  
 * Otherwise it is an array of components which are appended according to Name.append, so
 * convert each and store it as an array of customBuf.  If a component is a string, encode as utf8.
 */
var Name = function Name(components) 
{
  if (typeof components == 'string') {    
    if (LOG > 3) console.log('Content Name String ' + components);
    this.components = Name.createNameArray(components);
  }
  else if (typeof components === 'object') {    
    this.components = [];
    if (components instanceof Name)
      this.append(components);
    else {
      for (var i = 0; i < components.length; ++i)
        this.append(components[i]);
    }
  }
  else if (components == null)
    this.components = [];
  else
    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");
};

exports.Name = Name;

/**
 * 
 * @constructor
 * Create a new Name.Component with a copy of the given value.
 * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don't unescape).
 */
Name.Component = function NameComponent(value) 
{
  if (typeof value === 'string')
    this.value = DataUtils.stringToUtf8Array(value);
  else if (typeof value === 'object' && value instanceof Name.Component)
    this.value = new customBuf(value.value);
  else if (typeof value === 'object' && value instanceof Blob)
    this.value = new customBuf(value.buf());
  else if (typeof value === 'object' && value instanceof customBuf)
    this.value = new customBuf(value);
  else if (typeof value === 'object' && typeof ArrayBuffer !== 'undefined' &&  value instanceof ArrayBuffer) {
    // Make a copy.  Don't use ArrayBuffer.slice since it isn't always supported.                                                      
    this.value = new customBuf(new ArrayBuffer(value.byteLength));
    this.value.set(new customBuf(value));
  }
  else if (typeof value === 'object')
    // Assume value is a byte array.  We can't check instanceof Array because
    //   this doesn't work in JavaScript if the array comes from a different module.
    this.value = new customBuf(value);
  else if (!value)
    this.value = new customBuf(0);
  else 
    throw new Error("Name.Component constructor: Invalid type");
}

/**
 * Get the component value.
 * @returns {Buffer} The component value.
 */
Name.Component.prototype.getValue = function() 
{
  return this.value;
}

/**
 * Convert this component value to a string by escaping characters according to the NDN URI Scheme.
 * This also adds "..." to a value with zero or more ".".
 * @returns {string} The escaped string.
 */
Name.Component.prototype.toEscapedString = function() 
{
  return Name.toEscapedString(this.value);
}

/**
 * Check if this is the same component as other.
 * @param {Name.Component} other The other Component to compare with.
 * @returns {Boolean} true if the components are equal, otherwise false.
 */
Name.Component.prototype.equals = function(other) 
{
  return DataUtils.arraysEqual(this.value, other.value);
}

/**
 * @deprecated Use toUri.
 */
Name.prototype.getName = function() 
{
  return this.toUri();
};

/** Parse uri as a URI and return an array of customBuf components.
 */
Name.createNameArray = function(uri) 
{
  uri = uri.trim();
  if (uri.length <= 0)
    return [];

  var iColon = uri.indexOf(':');
  if (iColon >= 0) {
    // Make sure the colon came before a '/'.
    var iFirstSlash = uri.indexOf('/');
    if (iFirstSlash < 0 || iColon < iFirstSlash)
      // Omit the leading protocol such as ndn:
      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();
  }
    
  if (uri[0] == '/') {
    if (uri.length >= 2 && uri[1] == '/') {
      // Strip the authority following "//".
      var iAfterAuthority = uri.indexOf('/', 2);
      if (iAfterAuthority < 0)
        // Unusual case: there was only an authority.
        return [];
      else
        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();
    }
    else
      uri = uri.substr(1, uri.length - 1).trim();
  }

  var array = uri.split('/');
    
  // Unescape the components.
  for (var i = 0; i < array.length; ++i) {
    var value = Name.fromEscapedString(array[i]);
        
    if (value == null) {
      // Ignore the illegal componenent.  This also gets rid of a trailing '/'.
      array.splice(i, 1);
      --i;  
      continue;
    }
    else
      array[i] = new Name.Component(value);
  }

  return array;
};

Name.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)  
{
  decoder.readElementStartDTag(this.getElementLabel());
    
  this.components = [];

  while (decoder.peekDTag(NDNProtocolDTags.Component))
    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));
    
  decoder.readElementClose();
};

Name.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)  
{    
  if (this.components == null) 
    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");

  encoder.writeElementStartDTag(this.getElementLabel());
  var count = this.size();
  for (var i=0; i < count; i++)
    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());
  
  encoder.writeElementClose();
};

Name.prototype.getElementLabel = function() 
{
  return NDNProtocolDTags.Name;
};

/**
 * Convert the component to a customBuf and append to this Name.
 * Return this Name object to allow chaining calls to add.
 * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don't unescape).
 * @returns {Name}
 */
Name.prototype.append = function(component) 
{
  if (typeof component == 'object' && component instanceof Name) {
    var components;
    if (component == this)
      // special case, when we need to create a copy
      components = this.components.slice(0, this.components.length);
    else
      components = component.components;
      
    for (var i = 0; i < components.length; ++i)
      this.components.push(new Name.Component(components[i]));
  }
  else
    // Just use the Name.Component constructor.
    this.components.push(new Name.Component(component));

  return this;
};

/**
 * @deprecated Use append.
 */
Name.prototype.add = function(component)
{
  return this.append(component);
};

/**
 * Clear all the components.
 */
Name.prototype.clear = function()
{
  this.components = [];  
};

/**
 * Return the escaped name string according to "NDNx URI Scheme".
 * @returns {String}
 */
Name.prototype.toUri = function() 
{  
  if (this.size() == 0)
    return "/";
    
  var result = "";
  
  for (var i = 0; i < this.size(); ++i)
    result += "/"+ Name.toEscapedString(this.components[i].getValue());
  
  return result;  
};

/**
 * @deprecated Use toUri.
 */
Name.prototype.to_uri = function() 
{
  return this.toUri();
};

/**
 * Append a component with the encoded segment number.
 * @param {number} segment The segment number.
 * @returns {Name} This name so that you can chain calls to append.
 */
Name.prototype.appendSegment = function(segment) 
{
  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(segment);
  // Put a 0 byte in front.
  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);
  segmentNumberComponent[0] = 0;
  segmentNumberBigEndian.copy(segmentNumberComponent, 1);

  this.components.push(new Name.Component(segmentNumberComponent));
  return this;
};

/**
 * Append a component with the encoded version number.
 * Note that this encodes the exact value of version without converting from a 
 * time representation.
 * @param {number} version The version number.
 * @returns {Name} This name so that you can chain calls to append.
 */
Name.prototype.appendVersion = function(version) 
{
  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(version);
  // Put a 0 byte in front.
  var segmentNumberComponent = new customBuf(segmentNumberBigEndian.length + 1);
  segmentNumberComponent[0] = 0xfD;
  segmentNumberBigEndian.copy(segmentNumberComponent, 1);

  this.components.push(new Name.Component(segmentNumberComponent));
  return this;
};

/**
 * @deprecated Use appendSegment.
 */
Name.prototype.addSegment = function(number) 
{
  return this.appendSegment(number);
};

/**
 * Get a new name, constructed as a subset of components.
 * @param {number} iStartComponent The index if the first component to get.
 * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,
 * return components starting at iStartComponent until the end of the name.
 * @returns {Name} A new name.
 */
Name.prototype.getSubName = function(iStartComponent, nComponents)
{
  if (nComponents == undefined)
    nComponents = this.components.length - iStartComponent;
  
  var result = new Name();

  var iEnd = iStartComponent + nComponents;
  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)
    result.components.push(this.components[i]);

  return result;  
};

/**
 * Return a new Name with the first nComponents components of this Name.
 * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up
 * to name.size() - N. For example getPrefix(-1) returns the name without the final component.
 * @returns {Name} A new name.
 */
Name.prototype.getPrefix = function(nComponents) 
{
  if (nComponents < 0)
    return this.getSubName(0, this.components.length + nComponents);
  else
    return this.getSubName(0, nComponents);
};

/**
 * @brief Get prefix of the name, containing less minusComponents right components
 * @param minusComponents number of components to cut from the back
 */
Name.prototype.cut = function(minusComponents) 
{
  return new Name(this.components.slice(0, this.components.length - minusComponents));
};

/**
 * Return the number of name components.
 * @returns {number}
 */
Name.prototype.size = function() 
{
  return this.components.length;
};

/**
 * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().
 * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component
 * at size() - (-i).
 * @returns {Name.Component}
 */
Name.prototype.get = function(i) 
{
  if (i >= 0) {
    if (i >= this.components.length)
      throw new Error("Name.get: Index is out of bounds");

    return new Name.Component(this.components[i]);
  }
  else {
    // Negative index.
    if (i < -this.components.length)
      throw new Error("Name.get: Index is out of bounds");

    return new Name.Component(this.components[this.components.length - (-i)]);
  }
};

/**
 * @deprecated Use size().
 */
Name.prototype.getComponentCount = function() 
{
  return this.components.length;
};

/**
 * @deprecated To get just the component value, use get(i).getValue().
 */
Name.prototype.getComponent = function(i) 
{
  return new customBuf(this.components[i].getValue());
};

/**
 * The "file name" in a name is the last component that isn't blank and doesn't start with one of the
 *   special marker octets (for version, etc.).  Return the index in this.components of
 *   the file name, or -1 if not found.
 */
Name.prototype.indexOfFileName = function() 
{
  for (var i = this.size() - 1; i >= 0; --i) {
    var component = this.components[i].getValue();
    if (component.length <= 0)
      continue;
        
    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 || 
        (component[0] >= 0xF5 && component[0] <= 0xFF))
      continue;
        
    return i;
  }
    
  return -1;
};

/**
 * Return true if this Name has the same components as name.
 */
Name.prototype.equals = function(name) 
{
  if (this.components.length != name.components.length)
    return false;
    
  // Start from the last component because they are more likely to differ.
  for (var i = this.components.length - 1; i >= 0; --i) {
    if (!this.components[i].equals(name.components[i]))
      return false;
  }
    
  return true;
};

/**
 * @deprecated Use equals.
 */
Name.prototype.equalsName = function(name)
{
  return this.equals(name);
};

/**
 * Find the last component in name that has a ContentDigest and return the digest value as customBuf, 
 *   or null if not found.  See Name.getComponentContentDigestValue.
 */
Name.prototype.getContentDigestValue = function() 
{
  for (var i = this.size() - 1; i >= 0; --i) {
    var digestValue = Name.getComponentContentDigestValue(this.components[i]);
    if (digestValue != null)
      return digestValue;
  }
    
  return null;
};

/**
 * If component is a ContentDigest, return the digest value as a customBuf slice (don't modify!).
 * If not a ContentDigest, return null.
 * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.
 */
Name.getComponentContentDigestValue = function(component) 
{
  if (typeof component == 'object' && component instanceof Name.Component)
    component = component.getValue();

  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length; 
  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.
  if (component.length == digestComponentLength &&
      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length), 
                            Name.ContentDigestPrefix) &&
      DataUtils.arraysEqual(component.slice
         (component.length - Name.ContentDigestSuffix.length, component.length),
                            Name.ContentDigestSuffix))
   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);
 else
   return null;
};

// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB. 
Name.ContentDigestPrefix = new customBuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);
Name.ContentDigestSuffix = new customBuf([0x00]);


/**
 * Return value as an escaped string according to "NDNx URI Scheme".
 * We can't use encodeURIComponent because that doesn't encode all the characters we want to.
 * @param {Buffer|Name.Component} component The value or Name.Component to escape.
 * @returns {string} The escaped string.
 */
Name.toEscapedString = function(value) 
{
  if (typeof value == 'object' && value instanceof Name.Component)
    value = value.getValue();
  
  var result = "";
  var gotNonDot = false;
  for (var i = 0; i < value.length; ++i) {
    if (value[i] != 0x2e) {
      gotNonDot = true;
      break;
    }
  }
  if (!gotNonDot) {
    // Special case for component of zero or more periods.  Add 3 periods.
    result = "...";
    for (var i = 0; i < value.length; ++i)
      result += ".";
  }
  else {
    for (var i = 0; i < value.length; ++i) {
      var x = value[i];
      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)
      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||
          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d || 
          x == 0x2e || x == 0x5f)
        result += String.fromCharCode(x);
      else
        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();
    }
  }
  return result;
};

/**
 * Return a customBuf byte array by decoding the escapedString according to "NDNx URI Scheme".
 * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.
 * @param {string} escapedString The escaped string to decode.
 * @returns {Buffer} The byte array, or null which means to skip the component in the name.
 */
Name.fromEscapedString = function(escapedString) 
{
  var value = unescape(escapedString.trim());
        
  if (value.match(/[^.]/) == null) {
    // Special case for value of only periods.  
    if (value.length <= 2)
      // Zero, one or two periods is illegal.  Ignore this componenent to be
      //   consistent with the C implementation.
      return null;
    else
      // Remove 3 periods.
      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));
  }
  else
    return DataUtils.toNumbersFromString(value);
};

/**
 * Return true if the N components of this name are the same as the first N components of the given name.
 * @param {Name} name The name to check.
 * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.
 */
Name.prototype.match = function(name) 
{
  var i_name = this.components;
  var o_name = name.components;

  // This name is longer than the name we are checking it against.
  if (i_name.length > o_name.length)
    return false;

  // Check if at least one of given components doesn't match.
  for (var i = 0; i < i_name.length; ++i) {
    if (!i_name[i].equals(o_name[i]))
      return false;
  }

  return true;
};

},{"./buffer.js":45,"./encoding/binary-xml-decoder.js":48,"./encoding/binary-xml-encoder.js":49,"./encoding/data-utils.js":52,"./log.js":71,"./util/blob.js":79,"./util/ndn-protoco-id-tags.js":82}],74:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Publisher and PublisherType Objects
 */

var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var NDNProtocolDTagsStrings = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTagsStrings;
var DecodingException = require('./encoding/decoding-exception.js').DecodingException;

/**
 * @constructor
 */
var PublisherType = function PublisherType(tag) 
{
  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;
  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;
  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;
  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;

  this.Tag = tag;
}; 

/**
 * @constructor
 */
var PublisherID = function PublisherID() 
{
  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";
  this.PUBLISHER_ID_LEN = 256/8;
    
  //TODO, implement publisherID creation and key creation

  //TODO implement generatePublicKeyDigest
  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray
    
  //TODO implement generate key
  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);
  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type   
};

exports.PublisherID = PublisherID;

PublisherID.prototype.from_ndnb = function(decoder) 
{    
  // We have a choice here of one of 4 binary element types.
  var nextTag = PublisherID.peekAndGetNextDTag(decoder);
    
  this.publisherType = new PublisherType(nextTag); 
    
  if (nextTag < 0)
    throw new Error("Invalid publisher ID, got unexpected type");

  this.publisherID = decoder.readBinaryDTagElement(nextTag);
  if (null == this.publisherID)
    throw new DecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));
};

PublisherID.prototype.to_ndnb = function(encoder) 
{
  if (!this.validate())
    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");

  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);
};

/**
 * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.
 * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.
 * @returns {number} The PublisherID DTag or -1 if it is not one of them.
 */
PublisherID.peekAndGetNextDTag = function(decoder) 
{
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))
    return             NDNProtocolDTags.PublisherPublicKeyDigest;
  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))
    return             NDNProtocolDTags.PublisherCertificateDigest;
  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))
    return             NDNProtocolDTags.PublisherIssuerKeyDigest;
  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))
    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;
  
  return -1;
};
  
PublisherID.peek = function(/* XMLDecoder */ decoder) 
{
  return PublisherID.peekAndGetNextDTag(decoder) >= 0;
};

PublisherID.prototype.getElementLabel = function()
{ 
  return this.publisherType.Tag;
};

PublisherID.prototype.validate = function() 
{
  return null != id() && null != type();
};

},{"./encoding/decoding-exception.js":53,"./util/ndn-protoco-id-tags.js":82}],75:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents PublisherPublicKeyDigest Objects
 */

var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var LOG = require('./log.js').Log.LOG;

/**
 * @constructor
 */
var PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd) 
{ 
 this.PUBLISHER_ID_LEN = 512/8;
 this.publisherPublicKeyDigest = pkd;
};

exports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;

PublisherPublicKeyDigest.prototype.from_ndnb = function(decoder) 
{
  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());
    
  if (LOG > 4) console.log('Publisher public key digest is ' + this.publisherPublicKeyDigest);

  if (null == this.publisherPublicKeyDigest)
    throw new Error("Cannot parse publisher key digest.");
    
  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)

  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {
    if (LOG > 0)
      console.log('LENGTH OF PUBLISHER ID IS WRONG! Expected ' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);
      
    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;    
  }
};

PublisherPublicKeyDigest.prototype.to_ndnb= function(encoder) 
{
  //TODO Check that the ByteArray for the key is present
  if (!this.validate())
    throw new Error("Cannot encode : field values missing.");

  if (LOG > 3) console.log('PUBLISHER KEY DIGEST IS'+this.publisherPublicKeyDigest);
  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);
};
  
PublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };

PublisherPublicKeyDigest.prototype.validate = function() 
{
    return null != this.publisherPublicKeyDigest;
};

},{"./log.js":71,"./util/ndn-protoco-id-tags.js":82}],76:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */

var Key = require('../key.js').Key;

/**
 * @constructor
 */
var KeyManager = function KeyManager()
{
  this.certificate = 
  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +
  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +
  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +
  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +
  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +
  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +
  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +
  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +
  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";

  // Public Key
    this.publicKey = 
  "-----BEGIN PUBLIC KEY-----\n" +
  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\n" +
  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\n" +
  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\n" +
  "WFwYKClbU5XrShd3nwIDAQAB\n" +
  "-----END PUBLIC KEY-----";
  // Private Key
    this.privateKey = 
  "-----BEGIN RSA PRIVATE KEY-----\n" +
  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\n" +
  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\n" +
  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\n" +
  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\n" +
  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\n" +
  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\n" +
  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\n" +
  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\n" +
  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\n" +
  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\n" +
  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\n" +
  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\n" +
  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\n" +
  "-----END RSA PRIVATE KEY-----";
  
  this.key = null;
};

/**
 * Return a Key object for the keys in this KeyManager.  This creates the Key on the first
 * call and returns a cached copy after that.
 * @returns {Key}
 */
KeyManager.prototype.getKey = function()
{
  if (this.key === null) {
    this.key = new Key();
    this.key.fromPemString(this.publicKey, this.privateKey);
  }
  
  return this.key;
}

var globalKeyManager = globalKeyManager || new KeyManager();
exports.globalKeyManager = globalKeyManager;

},{"../key.js":70}],77:[function(require,module,exports){
/**
 * Copyright (C) 2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents an NDN Data Signature object.
 */

var Blob = require('./util/blob.js').Blob;
var BinaryXMLEncoder = require('./encoding/binary-xml-encoder.js').BinaryXMLEncoder;
var BinaryXMLDecoder = require('./encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var NDNProtocolDTags = require('./util/ndn-protoco-id-tags.js').NDNProtocolDTags;
var KeyLocator = require('./key-locator.js').KeyLocator;
var customBuf = require('./buffer.js').Buffer
var LOG = require('./log.js').Log.LOG;

/**
 * Create a new Signature with the optional values.
 * @constructor
 */
var Signature = function Signature(witnessOrSignatureObject, signature, digestAlgorithm) 
{
  if (typeof witnessOrSignatureObject === 'object' && 
      witnessOrSignatureObject instanceof Signature) {
    // Copy the values.
    this.keyLocator = new KeyLocator(witnessOrSignatureObject.keyLocator);
    this.signature = witnessOrSignatureObject.signature;
    // witness is deprecated.
    this.witness = witnessOrSignatureObject.witness;
    // digestAlgorithm is deprecated.
    this.digestAlgorithm = witnessOrSignatureObject.digestAlgorithm;
  }
  else {
    this.keyLocator = new KeyLocator();
    this.signature = signature;
    // witness is deprecated.
    this.witness = witnessOrSignatureObject;
    // digestAlgorithm is deprecated.
    this.digestAlgorithm = digestAlgorithm;
  }
};

exports.Signature = Signature;

/**
 * Create a new Signature which is a copy of this object.
 * @returns {Signature} A new object which is a copy of this object.
 */
Signature.prototype.clone = function()
{
  return new Signature(this);
};

/**
 * Get the key locator.
 * @returns {KeyLocator} The key locator.
 */
Signature.prototype.getKeyLocator = function()
{
  return this.keyLocator;
};

/**
 * Get the data packet's signature bytes.
 * @returns {Buffer} The signature bytes.
 */
Signature.prototype.getSignature = function()
{
  return this.signature;
};

/**
 * Set the key locator to a copy of the given keyLocator.
 * @param {KeyLocator} keyLocator The KeyLocator to copy.
 */
Signature.prototype.setKeyLocator = function(keyLocator)
{
  this.keyLocator = typeof keyLocator === 'object' && keyLocator instanceof KeyLocator ?
                    new KeyLocator(keyLocator) : new KeyLocator();
};
  
/**
 * Set the data packet's signature bytes.
 * @param {type} signature
 */
Signature.prototype.setSignature = function(signature)
{
  if (signature == null)
    this.signature = null;
  else if (typeof signature === 'object' && signature instanceof Blob)
    this.signature = new customBuf(signature.buf());
  else
    this.signature = new customBuf(signature);
};

Signature.prototype.from_ndnb = function(decoder) 
{
  decoder.readElementStartDTag(this.getElementLabel());
    
  if (LOG > 4) console.log('STARTED DECODING SIGNATURE');
    
  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {
    if (LOG > 4) console.log('DIGIEST ALGORITHM FOUND');
    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm); 
  }
  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {
    if (LOG > 4) console.log('WITNESS FOUND');
    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness); 
  }
    
  //FORCE TO READ A SIGNATURE

  if (LOG > 4) console.log('SIGNATURE FOUND');
  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);

  decoder.readElementClose();
};

Signature.prototype.to_ndnb = function(encoder) 
{      
  if (!this.validate())
    throw new Error("Cannot encode: field values missing.");
  
  encoder.writeElementStartDTag(this.getElementLabel());
  
  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))
    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));
  
  if (null != this.witness)
    // needs to handle null witness
    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);

  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);

  encoder.writeElementClose();       
};

Signature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };

Signature.prototype.validate = function() 
{
  return null != this.signature;
};

},{"./buffer.js":45,"./encoding/binary-xml-decoder.js":48,"./encoding/binary-xml-encoder.js":49,"./key-locator.js":69,"./log.js":71,"./util/blob.js":79,"./util/ndn-protoco-id-tags.js":82}],78:[function(require,module,exports){
/** 
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Wentao Shang
 * See COPYING for copyright and distribution information.
 */

var customBuf = require('../buffer.js').Buffer
var ElementReader = require('../encoding/element-reader.js').ElementReader;
var DataUtils = require('../encoding/data-utils.js').DataUtils;
var LOG = require('../log.js').Log.LOG;


function makeShuffledGetHostAndPort (hostList, port)
{
  // Make a copy.
  hostList = hostList.slice(0, hostList.length);
  DataUtils.shuffle(hostList);

  return function() {
    if (hostList.length == 0)
      return null;

    return { host: hostList.splice(0, 1)[0], port: port };
  };
};


/**
 * @constructor
 */
var WebSocketTransport = function WebSocketTransport() 
{    
  if (!WebSocket)
    throw new Error("WebSocket support is not available on this platform.");
    
  this.ws = null;
  this.connectedHost = null; // Read by Face.
  this.connectedPort = null; // Read by Face.
  this.elementReader = null;
  this.defaultGetHostAndPort = makeShuffledGetHostAndPort
    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu", 
      "E.ws.ndn.ucla.edu", "F.ws.ndn.ucla.edu", "G.ws.ndn.ucla.edu", "H.ws.ndn.ucla.edu", 
      "I.ws.ndn.ucla.edu", "J.ws.ndn.ucla.edu", "K.ws.ndn.ucla.edu", "L.ws.ndn.ucla.edu", 
      "M.ws.ndn.ucla.edu", "N.ws.ndn.ucla.edu"],
     9696);
};

exports.WebSocketTransport = WebSocketTransport;

/**
 * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost
 *   and connectedPort.  Once connected, call onopenCallback().
 * Listen on the port to read an entire binary XML encoded element and call
 *    face.onReceivedElement(element).
 */
WebSocketTransport.prototype.connect = function(face, onopenCallback) 
{
  this.close();
  
  this.ws = new WebSocket('ws:' + face.host + ':' + face.port);
  if (LOG > 0) console.log('ws connection created.');
    this.connectedHost = face.host;
    this.connectedPort = face.port;
  
  this.ws.binaryType = "arraybuffer";
  
  this.elementReader = new ElementReader(face);
  var self = this;
  this.ws.onmessage = function(ev) {
    var result = ev.data;
    //console.log('RecvHandle called.');
      
    if (result == null || result == undefined || result == "") {
      console.log('INVALID ANSWER');
    } 
    else if (result instanceof ArrayBuffer) {
      var bytearray = new customBuf(result);
          
      if (LOG > 3) console.log('BINARY RESPONSE IS ' + bytearray.toString('hex'));
      
      try {
        // Find the end of the binary XML element and call face.onReceivedElement.
        self.elementReader.onReceivedData(bytearray);
      } catch (ex) {
        console.log("NDN.ws.onmessage exception: " + ex);
        return;
      }
    }
  }
  
  this.ws.onopen = function(ev) {
    if (LOG > 3) console.log(ev);
    if (LOG > 3) console.log('ws.onopen: WebSocket connection opened.');
    if (LOG > 3) console.log('ws.onopen: ReadyState: ' + this.readyState);
    // Face.registerPrefix will fetch the ndndid when needed.

    onopenCallback();
  }
  
  this.ws.onerror = function(ev) {
    console.log('ws.onerror: ReadyState: ' + this.readyState);
    console.log(ev);
    console.log('ws.onerror: WebSocket error: ' + ev.data);
  }
  
  this.ws.onclose = function(ev) {
    console.log('ws.onclose: WebSocket connection closed.');
    self.ws = null;
    
    // Close Face when WebSocket is closed
    face.readyStatus = 2; //Face.CLOSED
    face.onclose();
    //console.log("NDN.onclose event fired.");
  }
};

/**
 * Send the Uint8Array data.
 */
WebSocketTransport.prototype.send = function(data) 
{
  if (this.ws != null) {
    // If we directly use data.buffer to feed ws.send(), 
    // WebSocket may end up sending a packet with 10000 bytes of data.
    // That is, WebSocket will flush the entire buffer
    // regardless of the offset of the Uint8Array. So we have to create
    // a new Uint8Array buffer with just the right size and copy the 
    // content from binaryInterest to the new buffer.
    //    ---Wentao
    var bytearray = new Uint8Array(data.length);
    bytearray.set(data);
    this.ws.send(bytearray.buffer);
    if (LOG > 3) console.log('ws.send() returned.');
  }
  else
    console.log('WebSocket connection is not established.');
};

/**
 * Close the connection.
 */
WebSocketTransport.prototype.close = function()
{
  if (this.ws != null)
    delete this.ws;
}


},{"../buffer.js":45,"../encoding/data-utils.js":52,"../encoding/element-reader.js":54,"../log.js":71}],79:[function(require,module,exports){
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer
/**
 * A Blob holds an immutable byte array implemented as a customBuf.  This should be 
 * treated like a string which is a pointer to an immutable string. (It is OK to 
 * pass a pointer to the string because the new owner cant change the bytes of 
 * the string.)  Blob does not inherit from customBuf. Instead you must call buf() 
 * to get the byte array which reminds you that you should not change the 
 * contents.  Also remember that buf() can return null.
 * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take 
 * another pointer to the customBuf without copying. If value is a customBuf or byte 
 * array, copy to create a new customBuf.  If omitted, buf() will return null.
 * @param {boolean} copy (optional) (optional) If true, copy the contents of 
 * value into a new customBuf.  If false, just use the existing value without 
 * copying. If omitted, then copy the contents (unless value is already a Blob).
 * IMPORTANT: If copy is false, if you keep a pointer to the value then you must
 * treat the value as immutable and promise not to change it.
 */
var Blob = function Blob(value, copy) 
{
  if (copy == null)
    copy = true;
  
  if (value == null)
    this.buffer = null;
  else if (typeof value === 'object' && value instanceof Blob)
    // Use the existing buffer.  Don't need to check for copy.
    this.buffer = value.buffer;
  else {
    if (typeof value === 'string')
      // Convert from a string to utf-8 byte encoding.
      this.buffer = new customBuf(value, 'utf8');
    else {
      if (copy)
        // We are copying, so just make another customBuf.
        this.buffer = new customBuf(value);
      else {
        if (typeof value === 'object' && value instanceof customBuf)
          // We can use as-is.
          this.buffer = value;
        else
          // We need a customBuf, so copy.
          this.buffer = new customBuf(value);
      }
    }
  }
};

exports.Blob = Blob;

/**
 * Return the length of the immutable byte array.
 * @returns {number} The length of the array.  If buf() is null, return 0.
 */
Blob.prototype.size = function()
{
  if (this.buffer != null)
    return this.buffer.length;
  else
    return 0;
};

/**
 * Return the immutable byte array.  DO NOT change the contents of the customBuf.  
 * If you need to change it, make a copy.
 * @returns {Buffer} The customBuf holding the immutable byte array, or null.
 */
Blob.prototype.buf = function()
{
  return this.buffer;
};

/**
 * Return true if the array is null, otherwise false.
 * @returns {boolean} True if the array is null.
 */
Blob.prototype.isNull = function()
{
  return this.buffer == null;
};

/**
 * Return the hex representation of the bytes in the byte array.
 * @returns {string} The hex string.
 */
Blob.prototype.toHex = function() 
{  
  if (this.buffer == null)
    return "";
  else
    return this.buffer.toString('hex');
};

},{"../buffer.js":45}],80:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * Encapsulate a customBuf and support dynamic reallocation.
 */
var customBuf = require('../buffer.js').Buffer
/**
 * Create a DynamicBuffer where this.array is a customBuf of size length.
 * To access the array, use this.array or call slice.
 * @constructor
 * @param {number} length the initial length of the array.  If null, use a default.
 */
var DynamicBuffer = function DynamicBuffer(length) 
{
  if (!length)
    length = 16;
    
  this.array = new customBuf(length);
};

exports.DynamicBuffer = DynamicBuffer;

/**
 * Ensure that this.array has the length, reallocate and copy if necessary.
 * Update the length of this.array which may be greater than length.
 * @param {number} length The minimum length for the array.
 */
DynamicBuffer.prototype.ensureLength = function(length) 
{
  if (this.array.length >= length)
    return;
    
  // See if double is enough.
  var newLength = this.array.length * 2;
  if (length > newLength)
    // The needed length is much greater, so use it.
    newLength = length;
    
  var newArray = new customBuf(newLength);
  this.array.copy(newArray);
  this.array = newArray;
};

/**
 * Copy the value to this.array at offset, reallocating if necessary. 
 * @param {Buffer} value The buffer to copy.
 * @param {number} offset The offset in the buffer to start copying into.
 */
DynamicBuffer.prototype.copy = function(value, offset) 
{
  this.ensureLength(value.length + offset);
    
  if (typeof value == 'object' && value instanceof customBuf)
    value.copy(this.array, offset);
  else
    // Need to make value a customBuf to copy.
    new customBuf(value).copy(this.array, offset);
};

/**
 * Ensure that this.array has the length. If necessary, reallocate the array
 *   and shift existing data to the back of the new array.
 * Update the length of this.array which may be greater than length.
 * @param {number} length The minimum length for the array.
 */
DynamicBuffer.prototype.ensureLengthFromBack = function(length) 
{
  if (this.array.length >= length)
    return;
    
  // See if double is enough.
  var newLength = this.array.length * 2;
  if (length > newLength)
    // The needed length is much greater, so use it.
    newLength = length;
    
  var newArray = new customBuf(newLength);
  // Copy to the back of newArray.
  this.array.copy(newArray, newArray.length - this.array.length);
  this.array = newArray;
};

/**
 * First call ensureLengthFromBack to make sure the bytearray has
 * offsetFromBack bytes, then copy value into the array starting
 * offsetFromBack bytes from the back of the array.
 * @param {Buffer} value The buffer to copy.
 * @param {offsetFromBack} offset The offset from the back of the array to start
 * copying.
 */
DynamicBuffer.prototype.copyFromBack = function(value, offsetFromBack) 
{
  this.ensureLengthFromBack(offsetFromBack);

  if (typeof value == 'object' && value instanceof customBuf)
    value.copy(this.array, this.array.length - offsetFromBack);
  else
    // Need to make value a customBuf to copy.
    new customBuf(value).copy(this.array, this.array.length - offsetFromBack);
};

/**
 * Return this.array.slice(begin, end);
 * @param {number} begin The begin index for the slice.
 * @param {number} end The end index for the slice.
 * @returns {Buffer} The buffer slice.
 */
DynamicBuffer.prototype.slice = function(begin, end) 
{
  return this.array.slice(begin, end);
};

},{"../buffer.js":45}],81:[function(require,module,exports){
(function (Buffer){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer
var DataUtils = require('../encoding/data-utils.js').DataUtils;
var BinaryXMLDecoder = require('../encoding/binary-xml-decoder.js').BinaryXMLDecoder;
var NDNProtocolDTags = require('./ndn-protoco-id-tags.js').NDNProtocolDTags;
var Name = require('../name.js').Name;

/**
 * Create a context for getting the response from the name enumeration command, as neede by getComponents.
 * (To do name enumeration, call the static method NameEnumeration.getComponents.)
 * @param {Face} face The Face object for using expressInterest.
 * @param {function} onComponents The onComponents callback given to getComponents.
 */
var NameEnumeration = function NameEnumeration(face, onComponents) 
{
  this.face = face;
  this.onComponents = onComponents;
  this.contentParts = [];
  
  var self = this;
  this.onData = function(interest, data) { self.processData(data); };
  this.onTimeout = function(interest) { self.processTimeout(); };
};

exports.NameEnumeration = NameEnumeration;

/**
 * Use the name enumeration protocol to get the child components of the name prefix.
 * @param {Face} face The Face object for using expressInterest.
 * @param {Name} name The name prefix for finding the child components.
 * @param {function} onComponents On getting the response, this calls onComponents(components) where
 * components is an array of customBuf name components.  If there is no response, this calls onComponents(null). 
 */
NameEnumeration.getComponents = function(face, prefix, onComponents)
{
  var command = new Name(prefix);
  // Add %C1.E.be
  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])
  
  var enumeration = new NameEnumeration(face, onComponents);
  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);
};

/**
 * Parse the response from the name enumeration command and call this.onComponents.
 * @param {Data} data
 */
NameEnumeration.prototype.processData = function(data) 
{
  try {
    if (!NameEnumeration.endsWithSegmentNumber(data.name))
      // We don't expect a name without a segment number.  Treat it as a bad packet.
      this.onComponents(null);
    else {
      var segmentNumber = DataUtils.bigEndianToUnsignedInt
          (data.name.get(data.name.size() - 1).getValue());

      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.
      var expectedSegmentNumber = this.contentParts.length;
      if (segmentNumber != expectedSegmentNumber)
        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.
        this.face.expressInterest
          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);
      else {
        // Save the content and check if we are finished.
        this.contentParts.push(data.content);

        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {
          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);
          if (segmentNumber == finalSegmentNumber) {
            // We are finished.  Parse and return the result.
            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));
            return;
          }
        }

        // Fetch the next segment.
        this.face.expressInterest
          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);
      }
    }
  } catch (ex) {
    console.log("NameEnumeration: ignoring exception: " + ex);
  }
};

/**
 * Just call onComponents(null).
 */
NameEnumeration.prototype.processTimeout = function()
{
  try {
    this.onComponents(null);
  } catch (ex) {
    console.log("NameEnumeration: ignoring exception: " + ex);
  }
};

/**
 * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.
 * @param {Uint8Array} content The content to parse.
 * @returns {Array<Buffer>} The array of components.
 */
NameEnumeration.parseComponents = function(content)
{
  var components = [];
  var decoder = new BinaryXMLDecoder(content);
  
  decoder.readElementStartDTag(NDNProtocolDTags.Collection);
 
  while (decoder.peekDTag(NDNProtocolDTags.Link)) {
    decoder.readElementStartDTag(NDNProtocolDTags.Link);    
    decoder.readElementStartDTag(NDNProtocolDTags.Name);
    
    components.push(new customBuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));
    
    decoder.readElementClose();  
    decoder.readElementClose();  
  }

  decoder.readElementClose();
  return components;
};

/**
 * Check if the last component in the name is a segment number.
 * TODO: Move to Name class.
 * @param {Name} name
 * @returns {Boolean} True if the name ends with a segment number, otherwise false.
 */
NameEnumeration.endsWithSegmentNumber = function(name) {
  return name.components != null && name.size() >= 1 &&
         name.get(name.size() - 1).getValue().length >= 1 &&
         name.get(name.size() - 1).getValue()[0] == 0;
};

}).call(this,require("buffer").Buffer)
},{"../buffer.js":45,"../encoding/binary-xml-decoder.js":48,"../encoding/data-utils.js":52,"../name.js":73,"./ndn-protoco-id-tags.js":82,"buffer":1}],82:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class contains all NDNx tags
 */


var NDNProtocolDTags = {

  /**
   * Note if you add one of these, add it to the reverse string map as well.
   * Emphasize getting the work done at compile time over trying to make something
   * flexible and developer error-proof.
   */

   Any : 13,
   Name : 14,
   Component : 15,
   Certificate : 16,
   Collection : 17,
   CompleteName : 18,
   Content : 19,
   SignedInfo : 20,
   ContentDigest : 21,
   ContentHash : 22,
   Count : 24,
   Header : 25,
   Interest : 26,  /* 20090915 */
   Key : 27,
   KeyLocator : 28,
   KeyName : 29,
   Length : 30,
   Link : 31,
   LinkAuthenticator : 32,
   NameComponentCount : 33,  /* DeprecatedInInterest */
   RootDigest : 36,
   Signature : 37,
   Start : 38,
   Timestamp : 39,
   Type : 40,
   Nonce : 41,
   Scope : 42,
   Exclude : 43,
   Bloom : 44,
   BloomSeed : 45,
   AnswerOriginKind : 47,
   InterestLifetime : 48,
   Witness : 53,
   SignatureBits : 54,
   DigestAlgorithm : 55,
   BlockSize : 56,
   FreshnessSeconds : 58,
   FinalBlockID : 59,
   PublisherPublicKeyDigest : 60,
   PublisherCertificateDigest : 61,
   PublisherIssuerKeyDigest : 62,
   PublisherIssuerCertificateDigest : 63,
   Data : 64,  /* 20090915 */
   WrappedKey : 65,
   WrappingKeyIdentifier : 66,
   WrapAlgorithm : 67,
   KeyAlgorithm : 68,
   Label : 69,
   EncryptedKey : 70,
   EncryptedNonceKey : 71,
   WrappingKeyName : 72,
   Action : 73,
   FaceID : 74,
   IPProto : 75,
   Host : 76,
   Port : 77,
   MulticastInterface : 78,
   ForwardingFlags : 79,
   FaceInstance : 80,
   ForwardingEntry : 81,
   MulticastTTL : 82,
   MinSuffixComponents : 83,
   MaxSuffixComponents : 84,
   ChildSelector : 85,
   RepositoryInfo : 86,
   Version : 87,
   RepositoryVersion : 88,
   GlobalPrefix : 89,
   LocalName : 90,
   Policy : 91,
   Namespace : 92,
   GlobalPrefixName : 93,
   PolicyVersion : 94,
   KeyValueSet : 95,
   KeyValuePair : 96,
   IntegerValue : 97,
   DecimalValue : 98,
   StringValue : 99,
   BinaryValue : 100,
   NameValue : 101,
   Entry : 102,
   ACL : 103,
   ParameterizedName : 104,
   Prefix : 105,
   Suffix : 106,
   Root : 107,
   ProfileName : 108,
   Parameters : 109,
   InfoString : 110,
  // 111 unallocated
   StatusResponse : 112,
   StatusCode : 113,
   StatusText : 114,

  // Sync protocol
   SyncNode : 115,
   SyncNodeKind : 116,
   SyncNodeElement : 117,
   SyncVersion : 118,
   SyncNodeElements : 119,
   SyncContentHash : 120,
   SyncLeafCount : 121,
   SyncTreeDepth : 122,
   SyncByteCount : 123,
   ConfigSlice : 124,
   ConfigSliceList : 125,
   ConfigSliceOp : 126,

  // Remember to keep in sync with schema/tagnames.csvsdict
   NDNProtocolDataUnit : 17702112,
   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"
};

exports.NDNProtocolDTags = NDNProtocolDTags;

var NDNProtocolDTagsStrings = [
  null, null, null, null, null, null, null, null, null, null, null,
  null, null,
  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",
  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",
  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",
  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",
  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",
  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",
  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",
  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",
  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",
  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",
  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",
  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",
  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",
  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",
  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",
  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",
  "InfoString", null,
    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",
    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",
    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];

exports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;

},{}],83:[function(require,module,exports){
/**
 * Copyright (C) 2013-2014 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents NDNTime Objects
 */

var LOG = require('../log.js').Log.LOG;

/**
 * @constructor
 */
var NDNTime = function NDNTime(input) 
{
  this.NANOS_MAX = 999877929;
  
  if (typeof input =='number')
    this.msec = input;
  else {
    if (LOG > 1) console.log('UNRECOGNIZED TYPE FOR TIME');
  }
};

exports.NDNTime = NDNTime;

NDNTime.prototype.getJavascriptDate = function() 
{
  var d = new Date();
  d.setTime(this.msec);
  return d
};  

},{"../log.js":71}],84:[function(require,module,exports){
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */
var customBuf = require('../buffer.js').Buffer
var Blob = require('./blob.js').Blob;

/**
 * A SignedBlob extends Blob to keep the offsets of a signed portion (e.g., the 
 * bytes of Data packet). This inherits from Blob, including Blob.size and Blob.buf.
 * @param {Blob|Buffer|Array<number>} value (optional) If value is a Blob, take 
 * another pointer to the customBuf without copying. If value is a customBuf or byte 
 * array, copy to create a new customBuf.  If omitted, buf() will return null.
 * @param {number} signedPortionBeginOffset (optional) The offset in the 
 * encoding of the beginning of the signed portion. If omitted, set to 0.
 * @param {number} signedPortionEndOffset (optional) The offset in the encoding 
 * of the end of the signed portion. If omitted, set to 0.
 */
var SignedBlob = function SignedBlob(value, signedPortionBeginOffset, signedPortionEndOffset) 
{
  // Call the base constructor.
  Blob.call(this, value);
  
  if (this.buffer == null) {
    this.signedPortionBeginOffset = 0;
    this.signedPortionEndOffset = 0;
  }
  else if (typeof value === 'object' && value instanceof SignedBlob) {
    // Copy the SignedBlob, allowing override for offsets.
    this.signedPortionBeginOffset = signedPortionBeginOffset == null ? 
      value.signedPortionBeginOffset : signedPortionBeginOffset;
    this.signedPortionEndOffset = signedPortionEndOffset == null ? 
      value.signedPortionEndOffset : signedPortionEndOffset;
  }
  else {
    this.signedPortionBeginOffset = signedPortionBeginOffset || 0;
    this.signedPortionEndOffset = signedPortionEndOffset || 0;
  }
  
  if (this.buffer == null)
    this.signedBuffer = null;
  else
    this.signedBuffer = this.buffer.slice
      (this.signedPortionBeginOffset, this.signedPortionEndOffset);
};

SignedBlob.prototype = new Blob();
SignedBlob.prototype.name = "SignedBlob";

exports.SignedBlob = SignedBlob;

/**
 * Return the length of the signed portion of the immutable byte array.
 * @returns {number} The length of the signed portion.  If signedBuf() is null, 
 * return 0.
 */
SignedBlob.prototype.signedSize = function()
{
  if (this.signedBuffer != null)
    return this.signedBuffer.length;
  else
    return 0;
};

/**
 * Return a the signed portion of the immutable byte array.
 * @returns {Buffer} A slice into the customBuf which is the signed portion.  
 * If the pointer to the array is null, return null.
 */
SignedBlob.prototype.signedBuf = function()
{
  if (this.signedBuffer != null)
    return this.signedBuffer;
  else
    return null;
};

/**
 * Return the offset in the array of the beginning of the signed portion.
 * @returns {number} The offset in the array.
 */
SignedBlob.prototype.getSignedPortionBeginOffset = function()
{
  return this.signedPortionBeginOffset;
};

/**
 * Return the offset in the array of the end of the signed portion.
 * @returns {number} The offset in the array.
 */
SignedBlob.prototype.getSignedPortionEndOffset = function()
{
  return this.signedPortionEndOffset;
};

},{"../buffer.js":45,"./blob.js":79}],85:[function(require,module,exports){
(function(){
    
    // Copyright (c) 2005  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Basic JavaScript BN library - subset useful for RSA encryption.

    // Bits per digit
    var dbits;

    // JavaScript engine analysis
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary&0xffffff)==0xefcafe);

    // (public) Constructor
    function BigInteger(a,b,c) {
      if(a != null)
        if("number" == typeof a) this.fromNumber(a,b,c);
        else if(b == null && "string" != typeof a) this.fromString(a,256);
        else this.fromString(a,b);
    }

    // return new, unset BigInteger
    function nbi() { return new BigInteger(null); }

    // am: Compute w_j += (x*this_i), propagate carries,
    // c is initial carry, returns final carry.
    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
    // We need to select the fastest one that works in this environment.

    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    function am1(i,x,w,j,c,n) {
      while(--n >= 0) {
        var v = x*this[i++]+w[j]+c;
        c = Math.floor(v/0x4000000);
        w[j++] = v&0x3ffffff;
      }
      return c;
    }
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    function am2(i,x,w,j,c,n) {
      var xl = x&0x7fff, xh = x>>15;
      while(--n >= 0) {
        var l = this[i]&0x7fff;
        var h = this[i++]>>15;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
        w[j++] = l&0x3fffffff;
      }
      return c;
    }
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    function am3(i,x,w,j,c,n) {
      var xl = x&0x3fff, xh = x>>14;
      while(--n >= 0) {
        var l = this[i]&0x3fff;
        var h = this[i++]>>14;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
        c = (l>>28)+(m>>14)+xh*h;
        w[j++] = l&0xfffffff;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    }
    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
      BigInteger.prototype.am = am1;
      dbits = 26;
    }
    else { // Mozilla/Netscape seems to prefer am3
      BigInteger.prototype.am = am3;
      dbits = 28;
    }

    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1<<dbits)-1);
    BigInteger.prototype.DV = (1<<dbits);

    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2,BI_FP);
    BigInteger.prototype.F1 = BI_FP-dbits;
    BigInteger.prototype.F2 = 2*dbits-BI_FP;

    // Digit conversions
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr,vv;
    rr = "0".charCodeAt(0);
    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

    function int2char(n) { return BI_RM.charAt(n); }
    function intAt(s,i) {
      var c = BI_RC[s.charCodeAt(i)];
      return (c==null)?-1:c;
    }

    // (protected) copy this to r
    function bnpCopyTo(r) {
      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }

    // (protected) set from integer value x, -DV <= x < DV
    function bnpFromInt(x) {
      this.t = 1;
      this.s = (x<0)?-1:0;
      if(x > 0) this[0] = x;
      else if(x < -1) this[0] = x+DV;
      else this.t = 0;
    }

    // return bigint initialized to value
    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

    // (protected) set from string and radix
    function bnpFromString(s,b) {
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 256) k = 8; // byte array
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else { this.fromRadix(s,b); return; }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while(--i >= 0) {
        var x = (k==8)?s[i]&0xff:intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-") mi = true;
          continue;
        }
        mi = false;
        if(sh == 0)
          this[this.t++] = x;
        else if(sh+k > this.DB) {
          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
          this[this.t++] = (x>>(this.DB-sh));
        }
        else
          this[this.t-1] |= x<<sh;
        sh += k;
        if(sh >= this.DB) sh -= this.DB;
      }
      if(k == 8 && (s[0]&0x80) != 0) {
        this.s = -1;
        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
      }
      this.clamp();
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) clamp off excess high words
    function bnpClamp() {
      var c = this.s&this.DM;
      while(this.t > 0 && this[this.t-1] == c) --this.t;
    }

    // (public) return string representation in given radix
    function bnToString(b) {
      if(this.s < 0) return "-"+this.negate().toString(b);
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1<<k)-1, d, m = false, r = "", i = this.t;
      var p = this.DB-(i*this.DB)%k;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
        while(i >= 0) {
          if(p < k) {
            d = (this[i]&((1<<p)-1))<<(k-p);
            d |= this[--i]>>(p+=this.DB-k);
          }
          else {
            d = (this[i]>>(p-=k))&km;
            if(p <= 0) { p += this.DB; --i; }
          }
          if(d > 0) m = true;
          if(m) r += int2char(d);
        }
      }
      return m?r:"0";
    }

    // (public) -this
    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

    // (public) |this|
    function bnAbs() { return (this.s<0)?this.negate():this; }

    // (public) return + if this > a, - if this < a, 0 if equal
    function bnCompareTo(a) {
      var r = this.s-a.s;
      if(r != 0) return r;
      var i = this.t;
      r = i-a.t;
      if(r != 0) return (this.s<0)?-r:r;
      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
      return 0;
    }

    // returns bit length of the integer x
    function nbits(x) {
      var r = 1, t;
      if((t=x>>>16) != 0) { x = t; r += 16; }
      if((t=x>>8) != 0) { x = t; r += 8; }
      if((t=x>>4) != 0) { x = t; r += 4; }
      if((t=x>>2) != 0) { x = t; r += 2; }
      if((t=x>>1) != 0) { x = t; r += 1; }
      return r;
    }

    // (public) return the number of bits in "this"
    function bnBitLength() {
      if(this.t <= 0) return 0;
      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
    }

    // (protected) r = this << n*DB
    function bnpDLShiftTo(n,r) {
      var i;
      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
      for(i = n-1; i >= 0; --i) r[i] = 0;
      r.t = this.t+n;
      r.s = this.s;
    }

    // (protected) r = this >> n*DB
    function bnpDRShiftTo(n,r) {
      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
      r.t = Math.max(this.t-n,0);
      r.s = this.s;
    }

    // (protected) r = this << n
    function bnpLShiftTo(n,r) {
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<cbs)-1;
      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
      for(i = this.t-1; i >= 0; --i) {
        r[i+ds+1] = (this[i]>>cbs)|c;
        c = (this[i]&bm)<<bs;
      }
      for(i = ds-1; i >= 0; --i) r[i] = 0;
      r[ds] = c;
      r.t = this.t+ds+1;
      r.s = this.s;
      r.clamp();
    }

    // (protected) r = this >> n
    function bnpRShiftTo(n,r) {
      r.s = this.s;
      var ds = Math.floor(n/this.DB);
      if(ds >= this.t) { r.t = 0; return; }
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<bs)-1;
      r[0] = this[ds]>>bs;
      for(var i = ds+1; i < this.t; ++i) {
        r[i-ds-1] |= (this[i]&bm)<<cbs;
        r[i-ds] = this[i]>>bs;
      }
      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
      r.t = this.t-ds;
      r.clamp();
    }

    // (protected) r = this - a
    function bnpSubTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]-a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c -= a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c -= a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = (c<0)?-1:0;
      if(c < -1) r[i++] = this.DV+c;
      else if(c > 0) r[i++] = c;
      r.t = i;
      r.clamp();
    }

    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    function bnpMultiplyTo(a,r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i+y.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
      r.s = 0;
      r.clamp();
      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
    }

    // (protected) r = this^2, r != this (HAC 14.16)
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2*x.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < x.t-1; ++i) {
        var c = x.am(i,x[i],r,2*i,0,1);
        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
          r[i+x.t] -= x.DV;
          r[i+x.t+1] = 1;
        }
      }
      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
      r.s = 0;
      r.clamp();
    }

    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    function bnpDivRemTo(m,q,r) {
      var pm = m.abs();
      if(pm.t <= 0) return;
      var pt = this.abs();
      if(pt.t < pm.t) {
        if(q != null) q.fromInt(0);
        if(r != null) this.copyTo(r);
        return;
      }
      if(r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
      else { pm.copyTo(y); pt.copyTo(r); }
      var ys = y.t;
      var y0 = y[ys-1];
      if(y0 == 0) return;
      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
      y.dlShiftTo(j,t);
      if(r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t,r);
      }
      BigInteger.ONE.dlShiftTo(ys,t);
      t.subTo(y,y);  // "negative" y so we can replace sub with am later
      while(y.t < ys) y[y.t++] = 0;
      while(--j >= 0) {
        // Estimate quotient digit
        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
          y.dlShiftTo(j,t);
          r.subTo(t,r);
          while(r[i] < --qd) r.subTo(t,r);
        }
      }
      if(q != null) {
        r.drShiftTo(ys,q);
        if(ts != ms) BigInteger.ZERO.subTo(q,q);
      }
      r.t = ys;
      r.clamp();
      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
      if(ts < 0) BigInteger.ZERO.subTo(r,r);
    }

    // (public) this mod a
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a,null,r);
      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
      return r;
    }

    // Modular reduction using "classic" algorithm
    function Classic(m) { this.m = m; }
    function cConvert(x) {
      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) { return x; }
    function cReduce(x) { x.divRemTo(this.m,null,x); }
    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;

    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    function bnpInvDigit() {
      if(this.t < 1) return 0;
      var x = this[0];
      if((x&1) == 0) return 0;
      var y = x&3;       // y == 1/x mod 2^2
      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
      // last step - calculate inverse mod DV directly;
      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
      // we really want the negative inverse, and -DV < y < DV
      return (y>0)?this.DV-y:-y;
    }

    // Montgomery reduction
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp&0x7fff;
      this.mph = this.mp>>15;
      this.um = (1<<(m.DB-15))-1;
      this.mt2 = 2*m.t;
    }

    // xR mod m
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t,r);
      r.divRemTo(this.m,null,r);
      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
      return r;
    }

    // x/R mod m
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }

    // x = x/R mod m (HAC 14.32)
    function montReduce(x) {
      while(x.t <= this.mt2) // pad x so am has enough room later
        x[x.t++] = 0;
      for(var i = 0; i < this.m.t; ++i) {
        // faster way of calculating u0 = x[i]*mp mod DV
        var j = x[i]&0x7fff;
        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
        // use am to combine the multiply-shift-add into one call
        j = i+this.m.t;
        x[j] += this.m.am(0,u0,x,i,0,this.m.t);
        // propagate carry
        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
      }
      x.clamp();
      x.drShiftTo(this.m.t,x);
      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = "x^2/R mod m"; x != r
    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = "xy/R mod m"; x,y != r
    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;

    // (protected) true iff this is even
    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    function bnpExp(e,z) {
      if(e > 0xffffffff || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
      g.copyTo(r);
      while(--i >= 0) {
        z.sqrTo(r,r2);
        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
        else { var t = r; r = r2; r2 = t; }
      }
      return z.revert(r);
    }

    // (public) this^e % m, 0 <= e < 2^32
    function bnModPowInt(e,m) {
      var z;
      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
      return this.exp(e,z);
    }

    // protected
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;

    // public
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;

    // "constants"
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);

    // Copyright (c) 2005-2009  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Extended JavaScript BN functions, required for RSA private ops.

    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
    // Version 1.2: square() API, isProbablePrime fix

    // (public)
    function bnClone() { var r = nbi(); this.copyTo(r); return r; }

    // (public) return value as integer
    function bnIntValue() {
      if(this.s < 0) {
        if(this.t == 1) return this[0]-this.DV;
        else if(this.t == 0) return -1;
      }
      else if(this.t == 1) return this[0];
      else if(this.t == 0) return 0;
      // assumes 16 < DB < 32
      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
    }

    // (public) return value as byte
    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

    // (public) return value as short (assumes DB>=16)
    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

    // (protected) return x s.t. r^x < DV
    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

    // (public) 0 if this == 0, 1 if this > 0
    function bnSigNum() {
      if(this.s < 0) return -1;
      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
      else return 1;
    }

    // (protected) convert to radix string
    function bnpToRadix(b) {
      if(b == null) b = 10;
      if(this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b,cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d,y,z);
      while(y.signum() > 0) {
        r = (a+z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d,y,z);
      }
      return z.intValue().toString(b) + r;
    }

    // (protected) convert from radix string
    function bnpFromRadix(s,b) {
      this.fromInt(0);
      if(b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
      for(var i = 0; i < s.length; ++i) {
        var x = intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w = b*w+x;
        if(++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w,0);
          j = 0;
          w = 0;
        }
      }
      if(j > 0) {
        this.dMultiply(Math.pow(b,j));
        this.dAddOffset(w,0);
      }
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) alternate constructor
    function bnpFromNumber(a,b,c) {
      if("number" == typeof b) {
        // new BigInteger(int,int,RNG)
        if(a < 2) this.fromInt(1);
        else {
          this.fromNumber(a,c);
          if(!this.testBit(a-1))	// force MSB set
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
          if(this.isEven()) this.dAddOffset(1,0); // force odd
          while(!this.isProbablePrime(b)) {
            this.dAddOffset(2,0);
            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
          }
        }
      }
      else {
        // new BigInteger(int,RNG)
        var x = new Array(), t = a&7;
        x.length = (a>>3)+1;
        b.nextBytes(x);
        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
        this.fromString(x,256);
      }
    }

    // (public) convert to bigendian byte array
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB-(i*this.DB)%8, d, k = 0;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
          r[k++] = d|(this.s<<(this.DB-p));
        while(i >= 0) {
          if(p < 8) {
            d = (this[i]&((1<<p)-1))<<(8-p);
            d |= this[--i]>>(p+=this.DB-8);
          }
          else {
            d = (this[i]>>(p-=8))&0xff;
            if(p <= 0) { p += this.DB; --i; }
          }
          if((d&0x80) != 0) d |= -256;
          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
          if(k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }

    function bnEquals(a) { return(this.compareTo(a)==0); }
    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

    // (protected) r = this op a (bitwise)
    function bnpBitwiseTo(a,op,r) {
      var i, f, m = Math.min(a.t,this.t);
      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
      if(a.t < this.t) {
        f = a.s&this.DM;
        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
        r.t = this.t;
      }
      else {
        f = this.s&this.DM;
        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
        r.t = a.t;
      }
      r.s = op(this.s,a.s);
      r.clamp();
    }

    // (public) this & a
    function op_and(x,y) { return x&y; }
    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

    // (public) this | a
    function op_or(x,y) { return x|y; }
    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

    // (public) this ^ a
    function op_xor(x,y) { return x^y; }
    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

    // (public) this & ~a
    function op_andnot(x,y) { return x&~y; }
    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

    // (public) ~this
    function bnNot() {
      var r = nbi();
      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }

    // (public) this << n
    function bnShiftLeft(n) {
      var r = nbi();
      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
      return r;
    }

    // (public) this >> n
    function bnShiftRight(n) {
      var r = nbi();
      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
      return r;
    }

    // return index of lowest 1-bit in x, x < 2^31
    function lbit(x) {
      if(x == 0) return -1;
      var r = 0;
      if((x&0xffff) == 0) { x >>= 16; r += 16; }
      if((x&0xff) == 0) { x >>= 8; r += 8; }
      if((x&0xf) == 0) { x >>= 4; r += 4; }
      if((x&3) == 0) { x >>= 2; r += 2; }
      if((x&1) == 0) ++r;
      return r;
    }

    // (public) returns index of lowest 1-bit (or -1 if none)
    function bnGetLowestSetBit() {
      for(var i = 0; i < this.t; ++i)
        if(this[i] != 0) return i*this.DB+lbit(this[i]);
      if(this.s < 0) return this.t*this.DB;
      return -1;
    }

    // return number of 1 bits in x
    function cbit(x) {
      var r = 0;
      while(x != 0) { x &= x-1; ++r; }
      return r;
    }

    // (public) return number of set bits
    function bnBitCount() {
      var r = 0, x = this.s&this.DM;
      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
      return r;
    }

    // (public) true iff nth bit is set
    function bnTestBit(n) {
      var j = Math.floor(n/this.DB);
      if(j >= this.t) return(this.s!=0);
      return((this[j]&(1<<(n%this.DB)))!=0);
    }

    // (protected) this op (1<<n)
    function bnpChangeBit(n,op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r,op,r);
      return r;
    }

    // (public) this | (1<<n)
    function bnSetBit(n) { return this.changeBit(n,op_or); }

    // (public) this & ~(1<<n)
    function bnClearBit(n) { return this.changeBit(n,op_andnot); }

    // (public) this ^ (1<<n)
    function bnFlipBit(n) { return this.changeBit(n,op_xor); }

    // (protected) r = this + a
    function bnpAddTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]+a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c += a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c += a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = (c<0)?-1:0;
      if(c > 0) r[i++] = c;
      else if(c < -1) r[i++] = this.DV+c;
      r.t = i;
      r.clamp();
    }

    // (public) this + a
    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

    // (public) this - a
    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

    // (public) this * a
    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

    // (public) this^2
    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

    // (public) this / a
    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

    // (public) this % a
    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

    // (public) [this/a,this%a]
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a,q,r);
      return new Array(q,r);
    }

    // (protected) this *= n, this >= 0, 1 < n < DV
    function bnpDMultiply(n) {
      this[this.t] = this.am(0,n-1,this,0,0,this.t);
      ++this.t;
      this.clamp();
    }

    // (protected) this += n << w words, this >= 0
    function bnpDAddOffset(n,w) {
      if(n == 0) return;
      while(this.t <= w) this[this.t++] = 0;
      this[w] += n;
      while(this[w] >= this.DV) {
        this[w] -= this.DV;
        if(++w >= this.t) this[this.t++] = 0;
        ++this[w];
      }
    }

    // A "null" reducer
    function NullExp() {}
    function nNop(x) { return x; }
    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
    function nSqrTo(x,r) { x.squareTo(r); }

    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;

    // (public) this^e
    function bnPow(e) { return this.exp(e,new NullExp()); }

    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    function bnpMultiplyLowerTo(a,n,r) {
      var i = Math.min(this.t+a.t,n);
      r.s = 0; // assumes a,this >= 0
      r.t = i;
      while(i > 0) r[--i] = 0;
      var j;
      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
      r.clamp();
    }

    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    function bnpMultiplyUpperTo(a,n,r) {
      --n;
      var i = r.t = this.t+a.t-n;
      r.s = 0; // assumes a,this >= 0
      while(--i >= 0) r[i] = 0;
      for(i = Math.max(n-this.t,0); i < a.t; ++i)
        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
      r.clamp();
      r.drShiftTo(1,r);
    }

    // Barrett modular reduction
    function Barrett(m) {
      // setup Barrett
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }

    function barrettConvert(x) {
      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
      else if(x.compareTo(this.m) < 0) return x;
      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
    }

    function barrettRevert(x) { return x; }

    // x = x mod m (HAC 14.42)
    function barrettReduce(x) {
      x.drShiftTo(this.m.t-1,this.r2);
      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
      x.subTo(this.r2,x);
      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = x^2 mod m; x != r
    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = x*y mod m; x,y != r
    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;

    // (public) this^e % m (HAC 14.85)
    function bnModPow(e,m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if(i <= 0) return r;
      else if(i < 18) k = 1;
      else if(i < 48) k = 3;
      else if(i < 144) k = 4;
      else if(i < 768) k = 5;
      else k = 6;
      if(i < 8)
        z = new Classic(m);
      else if(m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);

      // precomputation
      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
      g[1] = z.convert(this);
      if(k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1],g2);
        while(n <= km) {
          g[n] = nbi();
          z.mulTo(g2,g[n-2],g[n]);
          n += 2;
        }
      }

      var j = e.t-1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e[j])-1;
      while(j >= 0) {
        if(i >= k1) w = (e[j]>>(i-k1))&km;
        else {
          w = (e[j]&((1<<(i+1))-1))<<(k1-i);
          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
        }

        n = k;
        while((w&1) == 0) { w >>= 1; --n; }
        if((i -= n) < 0) { i += this.DB; --j; }
        if(is1) {	// ret == 1, don't bother squaring or multiplying it
          g[w].copyTo(r);
          is1 = false;
        }
        else {
          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
          z.mulTo(r2,g[w],r);
        }

        while(j >= 0 && (e[j]&(1<<i)) == 0) {
          z.sqrTo(r,r2); t = r; r = r2; r2 = t;
          if(--i < 0) { i = this.DB-1; --j; }
        }
      }
      return z.revert(r);
    }

    // (public) gcd(this,a) (HAC 14.54)
    function bnGCD(a) {
      var x = (this.s<0)?this.negate():this.clone();
      var y = (a.s<0)?a.negate():a.clone();
      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if(g < 0) return x;
      if(i < g) g = i;
      if(g > 0) {
        x.rShiftTo(g,x);
        y.rShiftTo(g,y);
      }
      while(x.signum() > 0) {
        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
        if(x.compareTo(y) >= 0) {
          x.subTo(y,x);
          x.rShiftTo(1,x);
        }
        else {
          y.subTo(x,y);
          y.rShiftTo(1,y);
        }
      }
      if(g > 0) y.lShiftTo(g,y);
      return y;
    }

    // (protected) this % n, n < 2^26
    function bnpModInt(n) {
      if(n <= 0) return 0;
      var d = this.DV%n, r = (this.s<0)?n-1:0;
      if(this.t > 0)
        if(d == 0) r = this[0]%n;
        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
      return r;
    }

    // (public) 1/this % m (HAC 14.61)
    function bnModInverse(m) {
      var ac = m.isEven();
      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while(u.signum() != 0) {
        while(u.isEven()) {
          u.rShiftTo(1,u);
          if(ac) {
            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
            a.rShiftTo(1,a);
          }
          else if(!b.isEven()) b.subTo(m,b);
          b.rShiftTo(1,b);
        }
        while(v.isEven()) {
          v.rShiftTo(1,v);
          if(ac) {
            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
            c.rShiftTo(1,c);
          }
          else if(!d.isEven()) d.subTo(m,d);
          d.rShiftTo(1,d);
        }
        if(u.compareTo(v) >= 0) {
          u.subTo(v,u);
          if(ac) a.subTo(c,a);
          b.subTo(d,b);
        }
        else {
          v.subTo(u,v);
          if(ac) c.subTo(a,c);
          d.subTo(b,d);
        }
      }
      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if(d.compareTo(m) >= 0) return d.subtract(m);
      if(d.signum() < 0) d.addTo(m,d); else return d;
      if(d.signum() < 0) return d.add(m); else return d;
    }

    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
    var lplim = (1<<26)/lowprimes[lowprimes.length-1];

    // (public) test primality with certainty >= 1-.5^t
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
        for(i = 0; i < lowprimes.length; ++i)
          if(x[0] == lowprimes[i]) return true;
        return false;
      }
      if(x.isEven()) return false;
      i = 1;
      while(i < lowprimes.length) {
        var m = lowprimes[i], j = i+1;
        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while(i < j) if(m%lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t);
    }

    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if(k <= 0) return false;
      var r = n1.shiftRight(k);
      t = (t+1)>>1;
      if(t > lowprimes.length) t = lowprimes.length;
      var a = nbi();
      for(var i = 0; i < t; ++i) {
        //Pick bases at random, instead of starting at 2
        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
        var y = a.modPow(r,this);
        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while(j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2,this);
            if(y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if(y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }

    // protected
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;

    // public
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

    // JSBN-specific extension
    BigInteger.prototype.square = bnSquare;

    // BigInteger interfaces not implemented in jsbn:

    // BigInteger(int signum, byte[] magnitude)
    // double doubleValue()
    // float floatValue()
    // int hashCode()
    // long longValue()
    // static BigInteger valueOf(long val)
    if (typeof exports !== 'undefined') {
        exports = module.exports = BigInteger;
    } else {
        this.BigInteger = BigInteger;
    }
    
}).call(this);
},{}],86:[function(require,module,exports){
var ndn = require('ndn-lib');
var ElementReader = ndn.ElementReader;
var ndnbuf = ndn.customBuffer;
var Name = ndn.Name
var Data = ndn.Data
var local = {}

local.transport = function (port) {
  this.port = port
};

/**
 * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost
 *   and connectedPort.  Once connected, call onopenCallback().
 * Listen on the port to read an entire binary XML encoded element and call
 *    face.onReceivedElement(element).
 */
local.transport.prototype.connect = function(face, onopenCallback)
{
  console.log(ndn, ElementReader)
  this.elementReader = new ElementReader(face);
  var self = this;
  this.port.onmessage = function(ev) {
    console.log('RecvHandle called on local face', ev);

    if (ev.data == null || ev.data == undefined || ev.data == "") {
      console.log('INVALID ANSWER');
    }
    else if (ev.data instanceof ArrayBuffer) {
      var bytearray = new ndnbuf(ev.data);
      console.log(ev.data)
      console.log(bytearray)
      try {
        // Find the end of the binary XML element and call face.onReceivedElement.
        self.elementReader.onReceivedData(bytearray);
      } catch (ex) {
        console.log("NDN.ws.onmessage exception: " + ex);
        return;
      }
      // garbage collect arraybuffer
      //var ms = new MessageChannel()
      //ms.port1.postMessage(ev.data, [ev.data])
    }
  };

  onopenCallback();

};

/**
 * Send the Uint8Array data.
 */
local.transport.prototype.send = function(data)
{
  if (true) {
        // If we directly use data.buffer to feed ws.send(),
        // WebSocket may end up sending a packet with 10000 bytes of data.
        // That is, WebSocket will flush the entire buffer
        // regardless of the offset of the Uint8Array. So we have to create
        // a new Uint8Array buffer with just the right size and copy the
        // content from binaryInterest to the new buffer.
        //    ---Wentao
        console.log("localtransport.port.postMessage", data)
        this.port.postMessage(data);

        //garbage collect
        //var ms = new MessageChannel();
        //ms.port1.postMessage(bytearray.buffer, [bytearray.buffer])
        //ms.port1.postMessage(data.buffer, [data.buffer])
    console.log('local.send() returned.');
  }
  else
    console.log('local connection is not established.');
};

module.exports = local;

},{"ndn-lib":96}],87:[function(require,module,exports){
module.exports=require(34)
},{"jsbn":138}],88:[function(require,module,exports){
module.exports=require(35)
},{}],89:[function(require,module,exports){
module.exports=require(36)
},{}],90:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./sha256.js":95,"jsbn":138}],91:[function(require,module,exports){
module.exports=require(38)
},{"jsbn":138}],92:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./rsa.js":91,"jsbn":138}],93:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./asn1hex-1.1.js":87,"./base64.js":88,"./rsa2.js":92}],94:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"./rsapem-1.1.js":93,"jsbn":138}],95:[function(require,module,exports){
module.exports=require(42)
},{"./core.js":89}],96:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"./js/browserify.js":98,"./js/closure.js":99,"./js/data.js":100,"./js/encoding/binary-xml-wire-format.js":104,"./js/encoding/data-utils.js":105,"./js/encoding/element-reader.js":107,"./js/encoding/encoding-utils.js":108,"./js/encoding/tlv-wire-format.js":110,"./js/encoding/tlv/tlv-decoder.js":111,"./js/encoding/tlv/tlv.js":114,"./js/encoding/wire-format.js":115,"./js/exclude.js":116,"./js/face.js":118,"./js/forwarding-flags.js":120,"./js/interest.js":121,"./js/key-locator.js":122,"./js/key.js":123,"./js/meta-info.js":125,"./js/name.js":126,"./js/publisher-public-key-digest.js":128,"./js/security/key-manager.js":129,"./js/util/blob.js":132,"./js/util/name-enumeration.js":134,"./js/util/ndn-time.js":136}],97:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"./transport/web-socket-transport.js":131}],98:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../contrib/securityLib/asn1hex-1.1.js":87,"../contrib/securityLib/base64.js":88,"../contrib/securityLib/crypto-1.0.js":90,"../contrib/securityLib/rsasign-1.2.js":94}],99:[function(require,module,exports){
module.exports=require(46)
},{}],100:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./buffer.js":98,"./crypto.js":98,"./encoding/binary-xml-encoder.js":102,"./encoding/binary-xml-wire-format.js":104,"./encoding/data-utils.js":105,"./encoding/wire-format.js":115,"./key-locator.js":122,"./meta-info.js":125,"./name.js":126,"./security/key-manager.js":129,"./signature.js":130,"./util/blob.js":132,"./util/ndn-protoco-id-tags.js":135,"./util/signed-blob.js":137,"buffer":1,"crypto":5}],101:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"../buffer.js":98,"../log.js":124,"../util/ndn-protoco-id-tags.js":135,"../util/ndn-time.js":136,"./data-utils.js":105,"./decoding-exception.js":106}],102:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"../buffer.js":98,"../log.js":124,"../util/dynamic-buffer.js":133,"../util/ndn-protoco-id-tags.js":135,"./data-utils.js":105}],103:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"../util/dynamic-buffer.js":133,"./binary-xml-decoder.js":101}],104:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"../exclude.js":116,"../key-locator.js":122,"../meta-info.js":125,"../name.js":126,"../publisher-public-key-digest.js":128,"../signature.js":130,"../util/blob.js":132,"../util/ndn-protoco-id-tags.js":135,"./binary-xml-decoder.js":101,"./binary-xml-encoder.js":102,"./data-utils.js":105,"./wire-format.js":115}],105:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"../buffer.js":98}],106:[function(require,module,exports){
module.exports=require(53)
},{}],107:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"../buffer.js":98,"../log.js":124,"./binary-xml-structure-decoder.js":103,"./data-utils.js":105,"./tlv/tlv-structure-decoder.js":113,"./tlv/tlv.js":114}],108:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"../data.js":100,"../face-instance.js":117,"../forwarding-entry.js":119,"../interest.js":121,"../key-locator.js":122,"../key.js":123,"../log.js":124,"./binary-xml-decoder.js":101,"./binary-xml-encoder.js":102,"./data-utils.js":105,"./wire-format.js":115}],109:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"../crypto.js":98,"../exclude.js":116,"../key-locator.js":122,"../meta-info.js":125,"../signature.js":130,"../util/blob.js":132,"./decoding-exception.js":106,"./tlv/tlv-decoder.js":111,"./tlv/tlv-encoder.js":112,"./tlv/tlv.js":114,"./wire-format.js":115,"crypto":5}],110:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"./tlv-0_1a2-wire-format.js":109,"./wire-format.js":115}],111:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"../../buffer.js":98,"../decoding-exception.js":106}],112:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"../../buffer.js":98,"../../util/dynamic-buffer.js":133}],113:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"../../buffer.js":98,"./tlv-decoder.js":111}],114:[function(require,module,exports){
module.exports=require(61)
},{}],115:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"../buffer.js":98,"./tlv-wire-format.js":110}],116:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./buffer.js":98,"./encoding/binary-xml-decoder.js":101,"./encoding/binary-xml-encoder.js":102,"./encoding/data-utils.js":105,"./name.js":126,"./util/ndn-protoco-id-tags.js":135}],117:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"./publisher-public-key-digest.js":128,"./util/ndn-protoco-id-tags.js":135}],118:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"./buffer.js":98,"./closure.js":99,"./crypto.js":98,"./data.js":100,"./encoding/binary-xml-decoder.js":101,"./encoding/binary-xml-encoder.js":102,"./encoding/binary-xml-wire-format.js":104,"./encoding/data-utils.js":105,"./encoding/tlv-wire-format.js":110,"./encoding/tlv/tlv-decoder.js":111,"./encoding/tlv/tlv.js":114,"./forwarding-entry.js":119,"./forwarding-flags.js":120,"./interest.js":121,"./key-locator.js":122,"./key.js":123,"./log.js":124,"./meta-info.js":125,"./name.js":126,"./transport/tcp-transport.js":97,"./util/ndn-protoco-id-tags.js":135,"crypto":5}],119:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"./name.js":126,"./publisher-public-key-digest.js":128,"./util/ndn-protoco-id-tags.js":135}],120:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"./forwarding-entry.js":119}],121:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"./buffer.js":98,"./encoding/binary-xml-wire-format.js":104,"./encoding/wire-format.js":115,"./exclude.js":116,"./key-locator.js":122,"./log.js":124,"./name.js":126,"./publisher-public-key-digest.js":128,"./util/blob.js":132}],122:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"./buffer.js":98,"./log.js":124,"./name.js":126,"./publisher-id.js":127,"./util/ndn-protoco-id-tags.js":135}],123:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"./buffer.js":98,"./crypto.js":98,"./encoding/data-utils.js":105,"./log.js":124}],124:[function(require,module,exports){
module.exports=require(71)
},{}],125:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"./buffer.js":98,"./encoding/binary-xml-decoder.js":101,"./encoding/binary-xml-encoder.js":102,"./key-locator.js":122,"./log.js":124,"./name.js":126,"./publisher-public-key-digest.js":128,"./security/key-manager.js":129,"./util/blob.js":132,"./util/ndn-protoco-id-tags.js":135,"./util/ndn-time.js":136}],126:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"./buffer.js":98,"./encoding/binary-xml-decoder.js":101,"./encoding/binary-xml-encoder.js":102,"./encoding/data-utils.js":105,"./log.js":124,"./util/blob.js":132,"./util/ndn-protoco-id-tags.js":135}],127:[function(require,module,exports){
module.exports=require(74)
},{"./encoding/decoding-exception.js":106,"./util/ndn-protoco-id-tags.js":135}],128:[function(require,module,exports){
module.exports=require(75)
},{"./log.js":124,"./util/ndn-protoco-id-tags.js":135}],129:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"../key.js":123}],130:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./buffer.js":98,"./encoding/binary-xml-decoder.js":101,"./encoding/binary-xml-encoder.js":102,"./key-locator.js":122,"./log.js":124,"./util/blob.js":132,"./util/ndn-protoco-id-tags.js":135}],131:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"../buffer.js":98,"../encoding/data-utils.js":105,"../encoding/element-reader.js":107,"../log.js":124}],132:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../buffer.js":98}],133:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../buffer.js":98}],134:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../buffer.js":98,"../encoding/binary-xml-decoder.js":101,"../encoding/data-utils.js":105,"../name.js":126,"./ndn-protoco-id-tags.js":135,"buffer":1}],135:[function(require,module,exports){
module.exports=require(82)
},{}],136:[function(require,module,exports){
module.exports=require(83)
},{"../log.js":124}],137:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"../buffer.js":98,"./blob.js":132}],138:[function(require,module,exports){
module.exports=require(85)
},{}],139:[function(require,module,exports){

var self

var ndn = require("ndn-lib");
var ElementReader = ndn.ElementReader;
var ndnbuf = ndn.customBuffer;
var Name = ndn.Name
var Data = ndn.Data

var telehash = {}

telehash.transport = function (hashname, channel) {
  this.hashname = hashname
  var faceSelf = this
  if (channel) {
    this.channel = channel

  }
};

telehash.start = function(appname, listenCallback) {
  function assigner (selfie){
    self = selfie
    listenCallback(self)
  }
  require("./lib/node/init.js")(appname, assigner, "testbspassword")
}

/**
 * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost
 *   and connectedPort.  Once connected, call onopenCallback().
 * Listen on the port to read an entire binary XML encoded element and call
 *    face.onReceivedElement(element).
 */
telehash.transport.prototype.connect = function(face, onopenCallback)
{
  this.elementReader = new ElementReader(face);
  var faceSelf= this;
  face.transport = this
  //console.log("call to connec!!!!!!!!!!!!!!!!!!!!!!")

  function listener (end, packet, chan, cb) {
    //console.log("got packet!", chan, packet)
    if (packet.js == "ndn"){

      var ev = packet.body
      console.log('RecvHandle called on telehash face', ev, typeof ev);
      try {
        // Find the end of the binary XML element and call face.onReceivedElement.
        faceSelf.elementReader.onReceivedData(ev);
      } catch (ex) {
        console.log("NDN.ws.onmessage exception: " + ex);
        return;
      }
      // garbage collect arraybuffer
      //var ms = new MessageChannel()

    }
    cb(true)
  }
  if (!face.transport.channel || face.transport.channel.ended){
    //console.log("channel not defined, begin listening")
    self.start(face.transport.hashname, "ndn", {js:"incoming"}, function(err, packet, chan, callb){
      //console.log("defined channel", chan, packet)
      listener(err, packet, chan, callb)
      chan.callback = listener
      face.transport.channel = chan
      face.transport.channel.callback = listener
      callb(true)
      onopenCallback()

    })

  } else {
    face.transport.channel.callback = listener
    //console.log("channel defined, callingback", face.transport.channel.callback)
    onopenCallback()
  }



};

/**
 * Send the Uint8Array data.
 */
telehash.transport.prototype.send = function(data)
{
  console.log(!this.channel, !this.channel.ended)
  if ((!this.channel == false) && !this.channel.ended) {
    //console.log(data)
    this.channel.send({js:"ndn", body: data})

  }
  else
    console.log('telehash connection is not established.');
};

module.exports = telehash;

},{"./lib/node/init.js":140,"ndn-lib":150}],140:[function(require,module,exports){
var th = require("telehash")
  , seeds = require("telehash-seeds")

module.exports = function(prefix, callback, password){
  if (localStorage[prefix + 'telehashID'] == undefined) {
    var self = this;
    console.log('generating keypair', th)
    th.init({}, function(err, selfie){
      if(err) return console.log("hashname generation/startup failed",err);
      var hn = selfie
      localStorage[prefix + 'telehashID'] = JSON.stringify(hn.id)
      seeds.install(hn)
      callback(hn)
    });
  } else {
    th.init({id:JSON.parse(localStorage[prefix + 'telehashID'])}, function(err, selfie){
      if(err) return console.log("hashname failed to come online",err);
      console.log("hashname online")
      self = selfie
      seeds.install(selfie)
      callback(selfie)
    });
  }
}

},{"telehash":195,"telehash-seeds":193}],141:[function(require,module,exports){
module.exports=require(34)
},{"jsbn":192}],142:[function(require,module,exports){
module.exports=require(35)
},{}],143:[function(require,module,exports){
module.exports=require(36)
},{}],144:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./sha256.js":149,"jsbn":192}],145:[function(require,module,exports){
module.exports=require(38)
},{"jsbn":192}],146:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./rsa.js":145,"jsbn":192}],147:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./asn1hex-1.1.js":141,"./base64.js":142,"./rsa2.js":146}],148:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"./rsapem-1.1.js":147,"jsbn":192}],149:[function(require,module,exports){
module.exports=require(42)
},{"./core.js":143}],150:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"./js/browserify.js":152,"./js/closure.js":153,"./js/data.js":154,"./js/encoding/binary-xml-wire-format.js":158,"./js/encoding/data-utils.js":159,"./js/encoding/element-reader.js":161,"./js/encoding/encoding-utils.js":162,"./js/encoding/tlv-wire-format.js":164,"./js/encoding/tlv/tlv-decoder.js":165,"./js/encoding/tlv/tlv.js":168,"./js/encoding/wire-format.js":169,"./js/exclude.js":170,"./js/face.js":172,"./js/forwarding-flags.js":174,"./js/interest.js":175,"./js/key-locator.js":176,"./js/key.js":177,"./js/meta-info.js":179,"./js/name.js":180,"./js/publisher-public-key-digest.js":182,"./js/security/key-manager.js":183,"./js/util/blob.js":186,"./js/util/name-enumeration.js":188,"./js/util/ndn-time.js":190}],151:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"./transport/web-socket-transport.js":185}],152:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../contrib/securityLib/asn1hex-1.1.js":141,"../contrib/securityLib/base64.js":142,"../contrib/securityLib/crypto-1.0.js":144,"../contrib/securityLib/rsasign-1.2.js":148}],153:[function(require,module,exports){
module.exports=require(46)
},{}],154:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./buffer.js":152,"./crypto.js":152,"./encoding/binary-xml-encoder.js":156,"./encoding/binary-xml-wire-format.js":158,"./encoding/data-utils.js":159,"./encoding/wire-format.js":169,"./key-locator.js":176,"./meta-info.js":179,"./name.js":180,"./security/key-manager.js":183,"./signature.js":184,"./util/blob.js":186,"./util/ndn-protoco-id-tags.js":189,"./util/signed-blob.js":191,"buffer":1,"crypto":5}],155:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"../buffer.js":152,"../log.js":178,"../util/ndn-protoco-id-tags.js":189,"../util/ndn-time.js":190,"./data-utils.js":159,"./decoding-exception.js":160}],156:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"../buffer.js":152,"../log.js":178,"../util/dynamic-buffer.js":187,"../util/ndn-protoco-id-tags.js":189,"./data-utils.js":159}],157:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"../util/dynamic-buffer.js":187,"./binary-xml-decoder.js":155}],158:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"../exclude.js":170,"../key-locator.js":176,"../meta-info.js":179,"../name.js":180,"../publisher-public-key-digest.js":182,"../signature.js":184,"../util/blob.js":186,"../util/ndn-protoco-id-tags.js":189,"./binary-xml-decoder.js":155,"./binary-xml-encoder.js":156,"./data-utils.js":159,"./wire-format.js":169}],159:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"../buffer.js":152}],160:[function(require,module,exports){
module.exports=require(53)
},{}],161:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"../buffer.js":152,"../log.js":178,"./binary-xml-structure-decoder.js":157,"./data-utils.js":159,"./tlv/tlv-structure-decoder.js":167,"./tlv/tlv.js":168}],162:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"../data.js":154,"../face-instance.js":171,"../forwarding-entry.js":173,"../interest.js":175,"../key-locator.js":176,"../key.js":177,"../log.js":178,"./binary-xml-decoder.js":155,"./binary-xml-encoder.js":156,"./data-utils.js":159,"./wire-format.js":169}],163:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"../crypto.js":152,"../exclude.js":170,"../key-locator.js":176,"../meta-info.js":179,"../signature.js":184,"../util/blob.js":186,"./decoding-exception.js":160,"./tlv/tlv-decoder.js":165,"./tlv/tlv-encoder.js":166,"./tlv/tlv.js":168,"./wire-format.js":169,"crypto":5}],164:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"./tlv-0_1a2-wire-format.js":163,"./wire-format.js":169}],165:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"../../buffer.js":152,"../decoding-exception.js":160}],166:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"../../buffer.js":152,"../../util/dynamic-buffer.js":187}],167:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"../../buffer.js":152,"./tlv-decoder.js":165}],168:[function(require,module,exports){
module.exports=require(61)
},{}],169:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"../buffer.js":152,"./tlv-wire-format.js":164}],170:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./buffer.js":152,"./encoding/binary-xml-decoder.js":155,"./encoding/binary-xml-encoder.js":156,"./encoding/data-utils.js":159,"./name.js":180,"./util/ndn-protoco-id-tags.js":189}],171:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"./publisher-public-key-digest.js":182,"./util/ndn-protoco-id-tags.js":189}],172:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"./buffer.js":152,"./closure.js":153,"./crypto.js":152,"./data.js":154,"./encoding/binary-xml-decoder.js":155,"./encoding/binary-xml-encoder.js":156,"./encoding/binary-xml-wire-format.js":158,"./encoding/data-utils.js":159,"./encoding/tlv-wire-format.js":164,"./encoding/tlv/tlv-decoder.js":165,"./encoding/tlv/tlv.js":168,"./forwarding-entry.js":173,"./forwarding-flags.js":174,"./interest.js":175,"./key-locator.js":176,"./key.js":177,"./log.js":178,"./meta-info.js":179,"./name.js":180,"./transport/tcp-transport.js":151,"./util/ndn-protoco-id-tags.js":189,"crypto":5}],173:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"./name.js":180,"./publisher-public-key-digest.js":182,"./util/ndn-protoco-id-tags.js":189}],174:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"./forwarding-entry.js":173}],175:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"./buffer.js":152,"./encoding/binary-xml-wire-format.js":158,"./encoding/wire-format.js":169,"./exclude.js":170,"./key-locator.js":176,"./log.js":178,"./name.js":180,"./publisher-public-key-digest.js":182,"./util/blob.js":186}],176:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"./buffer.js":152,"./log.js":178,"./name.js":180,"./publisher-id.js":181,"./util/ndn-protoco-id-tags.js":189}],177:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"./buffer.js":152,"./crypto.js":152,"./encoding/data-utils.js":159,"./log.js":178}],178:[function(require,module,exports){
module.exports=require(71)
},{}],179:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"./buffer.js":152,"./encoding/binary-xml-decoder.js":155,"./encoding/binary-xml-encoder.js":156,"./key-locator.js":176,"./log.js":178,"./name.js":180,"./publisher-public-key-digest.js":182,"./security/key-manager.js":183,"./util/blob.js":186,"./util/ndn-protoco-id-tags.js":189,"./util/ndn-time.js":190}],180:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"./buffer.js":152,"./encoding/binary-xml-decoder.js":155,"./encoding/binary-xml-encoder.js":156,"./encoding/data-utils.js":159,"./log.js":178,"./util/blob.js":186,"./util/ndn-protoco-id-tags.js":189}],181:[function(require,module,exports){
module.exports=require(74)
},{"./encoding/decoding-exception.js":160,"./util/ndn-protoco-id-tags.js":189}],182:[function(require,module,exports){
module.exports=require(75)
},{"./log.js":178,"./util/ndn-protoco-id-tags.js":189}],183:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"../key.js":177}],184:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./buffer.js":152,"./encoding/binary-xml-decoder.js":155,"./encoding/binary-xml-encoder.js":156,"./key-locator.js":176,"./log.js":178,"./util/blob.js":186,"./util/ndn-protoco-id-tags.js":189}],185:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"../buffer.js":152,"../encoding/data-utils.js":159,"../encoding/element-reader.js":161,"../log.js":178}],186:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../buffer.js":152}],187:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../buffer.js":152}],188:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../buffer.js":152,"../encoding/binary-xml-decoder.js":155,"../encoding/data-utils.js":159,"../name.js":180,"./ndn-protoco-id-tags.js":189,"buffer":1}],189:[function(require,module,exports){
module.exports=require(82)
},{}],190:[function(require,module,exports){
module.exports=require(83)
},{"../log.js":178}],191:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"../buffer.js":152,"./blob.js":186}],192:[function(require,module,exports){
module.exports=require(85)
},{}],193:[function(require,module,exports){
exports.json = require("./seeds.json");
exports.install = function(self, args)
{
  var seeds = exports.json;
  if(args && args.seeds)
  {
    if(typeof args.seeds == "string") seeds = require(args.seeds);
    if(typeof args.seeds == "object") seeds = args.seeds;
  }
  Object.keys(seeds).forEach(function(seed){self.addSeed(seeds[seed])});
}
},{"./seeds.json":194}],194:[function(require,module,exports){
module.exports={
  "ce9d2cfccf34345b1c1a1c5b6c72cb0cf625ec88cdc64b54921303b26a655949": {
    "admin":"http://github.com/quartzjer",
    "paths": [
      {
        "type": "http",
        "http": "http://208.68.164.253:42424"
      },
      {
        "type": "ipv4",
        "ip": "208.68.164.253",
        "port": 42424
      },
      {
        "type": "ipv6",
        "ip": "2605:da00:5222:5269:230:48ff:fe35:6572",
        "port": 42424
      }
    ],
    "parts": {
      "3a": "61b979399a285ec8a7159ea75f2953090612f26fe8ec80b4bdd3d746c7cba1f8",
      "2a": "df99cf38a79eb730b7b5c583faa4bcb21ccb044b5548df27837e608a3da8c57a",
      "1a": "4dd170c2523653dfaca8d2eca6c10ef4f703b3a95f4b77f57b81476d037e40b1"
    },
    "keys": {
      "3a": "azQ23XvFzj3238HlcUNsnIntl5VJY7ABMSQZWB6SFgo=",
      "2a": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6mvKCqjGj7PI2o+NXLRdgwDXx98271HN01ut873FrbJ4kkk3OmA//TpYTRKaE6xmeetXZnocci4q6X09TbfKpm2eNK0d898vWiYpGiRvQuy/5nUGM2bge3CPOS3wQZWv5ZSvpRkhGufekzCg5p6WpdUG0u9D382E9LzdLidFnzHvIdfp0eOc2EMcX7/JSj5w7BbwsXfZNaWpOkUAQEYfPi/qF/teo0y8cTh70JVufCRDx+2/FtA/c8+JpjtgeCZoFO3bYuKjCQiYmm4Zqcu1A6DYttCPkSKPXjirn9pdZFZBRH7IS7Mj5AJo2/L9nFYyLAE5xwMpBCE2rCY6wyzs7wIDAQAB",
      "1a": "vRQvjqB6PM7QevqIW2YF3hY/AgDlhP7d0YDo1H6dZJAcYxbcsS/1Qw=="
    }
  }
}

},{}],195:[function(require,module,exports){
var thjs = require("telehash-js");
exports.debug = thjs.debug;
exports.info = thjs.info;

exports.init = function(args, cbDone)
{
  if(!args) args = {};
  var self = new thjs.switch();

  require("telehash-cs1a").install(self, args);
  if(args.cs2a) require("telehash-cs2a").install(self, args); // slow on most browsers
  require("telehash-http").install(self, args);
  require("telehash-webrtc").install(self, args);

  // extensions
  require("telehash-stream").install(self, args);
  require("telehash-telesocket").install(self, args);
  require("telehash-thtp").install(self, args);
  require("telehash-token").install(self, args);

  function seed()
  {
    require("telehash-seeds").install(self, args);
    
    self.online(function(err){
      cbDone(err, self);      
    });
    return self;
  }

  if(args.id)
  {
    if(typeof args.id == "string" && localStorage && localStorage.getItem(args.id)) args.id = JSON.parse(localStorage.getItem(args.id));
    if(typeof args.id == "object")
    {
      var err;
      if((err = self.load(args.id))) return cbDone("error loading id, "+err+": "+JSON.stringify(args.id));
      return seed();
    }    
  }

  self.make(function(err,id){
    if(err) return cbDone("error creating id, "+err);
    if(typeof args.id == "string" && localStorage) localStorage.setItem(args.id, JSON.stringify(id));
    args.id = id;
    self.load(id);
    return seed();      
  });
  
  return self;
}
},{"telehash-cs1a":196,"telehash-cs2a":203,"telehash-http":211,"telehash-js":213,"telehash-seeds":193,"telehash-stream":214,"telehash-telesocket":215,"telehash-thtp":216,"telehash-token":217,"telehash-webrtc":218}],196:[function(require,module,exports){
(function (Buffer){
var crypto = require("crypto");
var cs1a = require("./cs1a.js");

var ecc = require("ecc-jsbn");  
require("./forge.min.js"); // PITA not browserify compat
cs1a.crypt(ecc,function(enc, key, iv, body)
{
	var cipher = enc ? forge.aes.createEncryptionCipher(key.toString("binary"), "CTR") : forge.aes.createDecryptionCipher(key.toString("binary"), "CTR");
	cipher.start(iv.toString("binary"));
	cipher.update(forge.util.createBuffer(body.toString('binary')));
	cipher.finish();
  return new Buffer(cipher.output.getBytes(), "binary");
});

Object.keys(cs1a).forEach(function(f){ exports[f] = cs1a[f]; });

}).call(this,require("buffer").Buffer)
},{"./cs1a.js":197,"./forge.min.js":198,"buffer":1,"crypto":5,"ecc-jsbn":199}],197:[function(require,module,exports){
(function (Buffer){
var crypto = require("crypto");

var self;
exports.install = function(telehash)
{
  self = telehash;
  telehash.CSets["1a"] = exports;
}

exports.crypt = function(ecc,aes)
{
  crypto.ecc = ecc;
  crypto.aes = aes;
}

// simple xor buffer folder
function fold(count, buf)
{
  if(!count || buf.length % 2) return buf;
  var ret = buf.slice(0,buf.length/2);
  for(i = 0; i < ret.length; i++) ret[i] = ret[i] ^ buf[i+ret.length];
  return fold(count-1,ret);
}

exports.genkey = function(ret,cbDone,cbStep)
{
  var k = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1);
  ret["1a"] = k.PublicKey.slice(1).toString("base64");
  ret["1a_secret"] = k.PrivateKey.toString("base64");
  cbDone();
}

exports.loadkey = function(id, pub, priv)
{
  if(typeof pub == "string") pub = new Buffer(pub,"base64");
  if(!Buffer.isBuffer(pub) || pub.length != 40) return "invalid public key";
  id.key = pub;
  id.public = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, Buffer.concat([new Buffer("04","hex"),id.key]), true);
  if(!id.public) return "public key load failed";

  if(priv)
  {
    if(typeof priv == "string") priv = new Buffer(priv,"base64");
    if(!Buffer.isBuffer(priv) || priv.length != 20) return "invalid private key";
    id.private = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, priv);
    if(!id.private) return "private key load failed";
  }
  return false;
}

exports.openize = function(id, to, inner)
{
	if(!to.ecc) to.ecc = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1);
  var eccpub = to.ecc.PublicKey.slice(1);

  // get the shared secret to create the iv+key for the open aes
  var secret = to.ecc.deriveSharedSecret(to.public);
  var key = fold(1,crypto.createHash("sha256").update(secret).digest());
  var iv = new Buffer("00000000000000000000000000000001","hex");

  // encrypt the inner
  var body = (!Buffer.isBuffer(inner)) ? self.pencode(inner,id.cs["1a"].key) : inner;
  var cbody = crypto.aes(true, key, iv, body);

  // prepend the line public key and hmac it  
  var secret = id.cs["1a"].private.deriveSharedSecret(to.public);
  var macd = Buffer.concat([eccpub,cbody]);
  var hmac = fold(3,crypto.createHmac("sha256", secret).update(macd).digest());

  // create final body
  var body = Buffer.concat([hmac,macd]);
  return self.pencode(0x1a, body);
},

exports.deopenize = function(id, open)
{
  var ret = {verify:false};
  if(!open.body) return ret;

  var mac1 = open.body.slice(0,4).toString("hex");
  var pub = open.body.slice(4,44);
  var cbody = open.body.slice(44);

  try{
    ret.linepub = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, Buffer.concat([new Buffer("04","hex"),pub]), true);      
  }catch(E){
    console.log("ecc err",E);
  }
  if(!ret.linepub) return ret;

  var secret = id.cs["1a"].private.deriveSharedSecret(ret.linepub);
  var key = fold(1,crypto.createHash("sha256").update(secret).digest());
  var iv = new Buffer("00000000000000000000000000000001","hex");

  // aes-128 decipher the inner
  var body = crypto.aes(false, key, iv, cbody);
  var inner = self.pdecode(body);
  if(!inner) return ret;
  ret.inner = inner;

  // verify+load inner key info
  var epub;
  if(!open.from)
  {
    epub = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp160r1, Buffer.concat([new Buffer("04","hex"),inner.body]), true);
    if(!epub) return ret;
    ret.key = inner.body;
  }else{
    epub = open.from.public;
  }

  // verify the hmac
  var secret = id.cs["1a"].private.deriveSharedSecret(epub);
  var mac2 = fold(3,crypto.createHmac("sha256", secret).update(open.body.slice(4)).digest()).toString("hex");
  if(mac2 != mac1) return ret;

  // all good, cache+return
  ret.verify = true;
  ret.js = inner.js;
  return ret;
},

// set up the line enc/dec keys
exports.openline = function(from, open)
{
  from.lineIV = crypto.randomBytes(4).readUInt32LE(0); // start from random place
  from.lineInB = new Buffer(from.lineIn, "hex");
  var ecdhe = from.ecc.deriveSharedSecret(open.linepub);
  from.encKey = fold(1,crypto.createHash("sha256")
    .update(ecdhe)
    .update(new Buffer(from.lineOut, "hex"))
    .update(from.lineInB)
    .digest());
  from.decKey = fold(1,crypto.createHash("sha256")
    .update(ecdhe)
    .update(from.lineInB)
    .update(new Buffer(from.lineOut, "hex"))
    .digest());
  return true;
},

exports.lineize = function(to, packet)
{
	// now encrypt the packet
  var iv = new Buffer(16);
  iv.fill(0);
  iv.writeUInt32LE(to.lineIV++,12);

  var cbody = crypto.aes(true, to.encKey, iv, self.pencode(packet.js,packet.body));

  // prepend the IV and hmac it
  var mac = fold(3,crypto.createHmac("sha256", to.encKey).update(Buffer.concat([iv.slice(12),cbody])).digest());

  // create final body
  var body = Buffer.concat([to.lineInB,mac,iv.slice(12),cbody]);

  return self.pencode(null, body);
},

exports.delineize = function(from, packet)
{
  if(!packet.body) return "no body";
  // remove lineid
  packet.body = packet.body.slice(16);
  
  // validate the hmac
  var mac1 = packet.body.slice(0,4).toString("hex");
  var mac2 = fold(3,crypto.createHmac("sha256", from.decKey).update(packet.body.slice(4)).digest()).toString("hex");
  if(mac1 != mac2) return "invalid hmac";

  // decrypt body
  var iv = packet.body.slice(4,8);
  var ivz = new Buffer(12);
  ivz.fill(0);
  var body = packet.body.slice(8);
  var deciphered = self.pdecode(crypto.aes(false,from.decKey,Buffer.concat([ivz,iv]),body));
	if(!deciphered) return "invalid decrypted packet";

  packet.js = deciphered.js;
  packet.body = deciphered.body;
  return false;
}
}).call(this,require("buffer").Buffer)
},{"buffer":1,"crypto":5}],198:[function(require,module,exports){
(function (process){
(function(){var e,t,n;(function(r){function d(e,t){return h.call(e,t)}function v(e,t){var n,r,i,s,o,u,a,f,c,h,p,v=t&&t.split("/"),m=l.map,g=/\.js$/,y=m&&m["*"]||{};if(e&&e.charAt(0)===".")if(t){v=v.slice(0,v.length-1),e=e.split("/"),o=e.length-1,l.pkgs&&d(l.pkgs,v[0])&&g.test(e[o])&&(e[o]=e[o].replace(g,"")),e=v.concat(e);for(c=0;c<e.length;c+=1){p=e[c];if(p===".")e.splice(c,1),c-=1;else if(p===".."){if(c===1&&(e[2]===".."||e[0]===".."))break;c>0&&(e.splice(c-1,2),c-=2)}}e=e.join("/")}else e.indexOf("./")===0&&(e=e.substring(2));if((v||y)&&m){n=e.split("/");for(c=n.length;c>0;c-=1){r=n.slice(0,c).join("/");if(v)for(h=v.length;h>0;h-=1){i=m[v.slice(0,h).join("/")];if(i){i=i[r];if(i){s=i,u=c;break}}}if(s)break;!a&&y&&y[r]&&(a=y[r],f=c)}!s&&a&&(s=a,u=f),s&&(n.splice(0,u,s),e=n.join("/"))}return e}function m(e,t){return function(){return s.apply(r,p.call(arguments,0).concat([e,t]))}}function g(e){return function(t){return v(t,e)}}function y(e){return function(t){a[e]=t}}function b(e){if(d(f,e)){var t=f[e];delete f[e],c[e]=!0,i.apply(r,t)}if(!d(a,e)&&!d(c,e))throw new Error("No "+e);return a[e]}function w(e){var t,n=e?e.indexOf("!"):-1;return n>-1&&(t=e.substring(0,n),e=e.substring(n+1,e.length)),[t,e]}function E(e){return function(){return l&&l.config&&l.config[e]||{}}}var i,s,o,u,a={},f={},l={},c={},h=Object.prototype.hasOwnProperty,p=[].slice;o=function(e,t){var n,r=w(e),i=r[0];return e=r[1],i&&(i=v(i,t),n=b(i)),i?n&&n.normalize?e=n.normalize(e,g(t)):e=v(e,t):(e=v(e,t),r=w(e),i=r[0],e=r[1],i&&(n=b(i))),{f:i?i+"!"+e:e,n:e,pr:i,p:n}},u={require:function(e){return m(e)},exports:function(e){var t=a[e];return typeof t!="undefined"?t:a[e]={}},module:function(e){return{id:e,uri:"",exports:a[e],config:E(e)}}},i=function(e,t,n,i){var s,l,h,p,v,g=[],w=typeof n,E;i=i||e;if(w==="undefined"||w==="function"){t=!t.length&&n.length?["require","exports","module"]:t;for(v=0;v<t.length;v+=1){p=o(t[v],i),l=p.f;if(l==="require")g[v]=u.require(e);else if(l==="exports")g[v]=u.exports(e),E=!0;else if(l==="module")s=g[v]=u.module(e);else if(d(a,l)||d(f,l)||d(c,l))g[v]=b(l);else{if(!p.p)throw new Error(e+" missing "+l);p.p.load(p.n,m(i,!0),y(l),{}),g[v]=a[l]}}h=n?n.apply(a[e],g):undefined;if(e)if(s&&s.exports!==r&&s.exports!==a[e])a[e]=s.exports;else if(h!==r||!E)a[e]=h}else e&&(a[e]=n)},e=t=s=function(e,t,n,a,f){var c,h;if(typeof e=="string")return u[e]?u[e](t):b(o(e,t).f);if(!e.splice){l=e,l.deps&&s(l.deps,l.callback),h=l.packages;if(l.packages){l.pkgs={};for(c=0;c<h.length;c++)l.pkgs[h[c].name||h[c]]=!0}if(!t)return;t.splice?(e=t,t=n,n=null):e=r}return t=t||function(){},typeof n=="function"&&(n=a,a=f),a?i(r,e,t,n):setTimeout(function(){i(r,e,t,n)},4),s},s.config=function(e){return s(e)},e._defined=a,n=function(e,t,n){t.splice||(n=t,t=[]),!d(a,e)&&!d(f,e)&&(f[e]=[e,t,n])},n.amd={jQuery:!0}})(),n("node_modules/almond/almond",function(){}),function(){function e(e){var t=e.util=e.util||{};typeof process=="undefined"||!process.nextTick?typeof setImmediate=="function"?(t.setImmediate=setImmediate,t.nextTick=function(e){return setImmediate(e)}):(t.setImmediate=function(e){setTimeout(e,0)},t.nextTick=t.setImmediate):(t.nextTick=process.nextTick,typeof setImmediate=="function"?t.setImmediate=setImmediate:t.setImmediate=t.nextTick),t.isArray=Array.isArray||function(e){return Object.prototype.toString.call(e)==="[object Array]"},t.isArrayBuffer=function(e){return typeof ArrayBuffer!="undefined"&&e instanceof ArrayBuffer};var n=[];typeof Int8Array!="undefined"&&n.push(Int8Array),typeof Uint8Array!="undefined"&&n.push(Uint8Array),typeof Uint8ClampedArray!="undefined"&&n.push(Uint8ClampedArray),typeof Int16Array!="undefined"&&n.push(Int16Array),typeof Uint16Array!="undefined"&&n.push(Uint16Array),typeof Int32Array!="undefined"&&n.push(Int32Array),typeof Uint32Array!="undefined"&&n.push(Uint32Array),typeof Float32Array!="undefined"&&n.push(Float32Array),typeof Float64Array!="undefined"&&n.push(Float64Array),t.isArrayBufferView=function(e){for(var t=0;t<n.length;++t)if(e instanceof n[t])return!0;return!1},t.ByteBuffer=function(e){this.data="",this.read=0;if(typeof e=="string")this.data=e;else if(t.isArrayBuffer(e)||t.isArrayBufferView(e)){var n=new Uint8Array(e);try{this.data=String.fromCharCode.apply(null,n)}catch(r){for(var i=0;i<n.length;++i)this.putByte(n[i])}}},t.ByteBuffer.prototype.length=function(){return this.data.length-this.read},t.ByteBuffer.prototype.isEmpty=function(){return this.length()<=0},t.ByteBuffer.prototype.putByte=function(e){return this.data+=String.fromCharCode(e),this},t.ByteBuffer.prototype.fillWithByte=function(e,t){e=String.fromCharCode(e);var n=this.data;while(t>0)t&1&&(n+=e),t>>>=1,t>0&&(e+=e);return this.data=n,this},t.ByteBuffer.prototype.putBytes=function(e){return this.data+=e,this},t.ByteBuffer.prototype.putString=function(e){return this.data+=t.encodeUtf8(e),this},t.ByteBuffer.prototype.putInt16=function(e){return this.data+=String.fromCharCode(e>>8&255)+String.fromCharCode(e&255),this},t.ByteBuffer.prototype.putInt24=function(e){return this.data+=String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255),this},t.ByteBuffer.prototype.putInt32=function(e){return this.data+=String.fromCharCode(e>>24&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255),this},t.ByteBuffer.prototype.putInt16Le=function(e){return this.data+=String.fromCharCode(e&255)+String.fromCharCode(e>>8&255),this},t.ByteBuffer.prototype.putInt24Le=function(e){return this.data+=String.fromCharCode(e&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e>>16&255),this},t.ByteBuffer.prototype.putInt32Le=function(e){return this.data+=String.fromCharCode(e&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>24&255),this},t.ByteBuffer.prototype.putInt=function(e,t){do t-=8,this.data+=String.fromCharCode(e>>t&255);while(t>0);return this},t.ByteBuffer.prototype.putSignedInt=function(e,t){return e<0&&(e+=2<<t-1),this.putInt(e,t)},t.ByteBuffer.prototype.putBuffer=function(e){return this.data+=e.getBytes(),this},t.ByteBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++)},t.ByteBuffer.prototype.getInt16=function(){var e=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);return this.read+=2,e},t.ByteBuffer.prototype.getInt24=function(){var e=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);return this.read+=3,e},t.ByteBuffer.prototype.getInt32=function(){var e=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);return this.read+=4,e},t.ByteBuffer.prototype.getInt16Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;return this.read+=2,e},t.ByteBuffer.prototype.getInt24Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;return this.read+=3,e},t.ByteBuffer.prototype.getInt32Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;return this.read+=4,e},t.ByteBuffer.prototype.getInt=function(e){var t=0;do t=(t<<8)+this.data.charCodeAt(this.read++),e-=8;while(e>0);return t},t.ByteBuffer.prototype.getSignedInt=function(e){var t=this.getInt(e),n=2<<e-2;return t>=n&&(t-=n<<1),t},t.ByteBuffer.prototype.getBytes=function(e){var t;return e?(e=Math.min(this.length(),e),t=this.data.slice(this.read,this.read+e),this.read+=e):e===0?t="":(t=this.read===0?this.data:this.data.slice(this.read),this.clear()),t},t.ByteBuffer.prototype.bytes=function(e){return typeof e=="undefined"?this.data.slice(this.read):this.data.slice(this.read,this.read+e)},t.ByteBuffer.prototype.at=function(e){return this.data.charCodeAt(this.read+e)},t.ByteBuffer.prototype.setAt=function(e,t){return this.data=this.data.substr(0,this.read+e)+String.fromCharCode(t)+this.data.substr(this.read+e+1),this},t.ByteBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1)},t.ByteBuffer.prototype.copy=function(){var e=t.createBuffer(this.data);return e.read=this.read,e},t.ByteBuffer.prototype.compact=function(){return this.read>0&&(this.data=this.data.slice(this.read),this.read=0),this},t.ByteBuffer.prototype.clear=function(){return this.data="",this.read=0,this},t.ByteBuffer.prototype.truncate=function(e){var t=Math.max(0,this.length()-e);return this.data=this.data.substr(this.read,t),this.read=0,this},t.ByteBuffer.prototype.toHex=function(){var e="";for(var t=this.read;t<this.data.length;++t){var n=this.data.charCodeAt(t);n<16&&(e+="0"),e+=n.toString(16)}return e},t.ByteBuffer.prototype.toString=function(){return t.decodeUtf8(this.bytes())},t.createBuffer=function(e,n){return n=n||"raw",e!==undefined&&n==="utf8"&&(e=t.encodeUtf8(e)),new t.ByteBuffer(e)},t.fillString=function(e,t){var n="";while(t>0)t&1&&(n+=e),t>>>=1,t>0&&(e+=e);return n},t.xorBytes=function(e,t,n){var r="",i="",s="",o=0,u=0;for(;n>0;--n,++o)i=e.charCodeAt(o)^t.charCodeAt(o),u>=10&&(r+=s,s="",u=0),s+=String.fromCharCode(i),++u;return r+=s,r},t.hexToBytes=function(e){var t="",n=0;e.length&!0&&(n=1,t+=String.fromCharCode(parseInt(e[0],16)));for(;n<e.length;n+=2)t+=String.fromCharCode(parseInt(e.substr(n,2),16));return t},t.bytesToHex=function(e){return t.createBuffer(e).toHex()},t.int32ToBytes=function(e){return String.fromCharCode(e>>24&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255)};var r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",i=[62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,64,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];t.encode64=function(e,t){var n="",i="",s,o,u,a=0;while(a<e.length)s=e.charCodeAt(a++),o=e.charCodeAt(a++),u=e.charCodeAt(a++),n+=r.charAt(s>>2),n+=r.charAt((s&3)<<4|o>>4),isNaN(o)?n+="==":(n+=r.charAt((o&15)<<2|u>>6),n+=isNaN(u)?"=":r.charAt(u&63)),t&&n.length>t&&(i+=n.substr(0,t)+"\r\n",n=n.substr(t));return i+=n,i},t.decode64=function(e){e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");var t="",n,r,s,o,u=0;while(u<e.length)n=i[e.charCodeAt(u++)-43],r=i[e.charCodeAt(u++)-43],s=i[e.charCodeAt(u++)-43],o=i[e.charCodeAt(u++)-43],t+=String.fromCharCode(n<<2|r>>4),s!==64&&(t+=String.fromCharCode((r&15)<<4|s>>2),o!==64&&(t+=String.fromCharCode((s&3)<<6|o)));return t},t.encodeUtf8=function(e){return unescape(encodeURIComponent(e))},t.decodeUtf8=function(e){return decodeURIComponent(escape(e))},t.deflate=function(e,n,r){n=t.decode64(e.deflate(t.encode64(n)).rval);if(r){var i=2,s=n.charCodeAt(1);s&32&&(i=6),n=n.substring(i,n.length-4)}return n},t.inflate=function(e,n,r){var i=e.inflate(t.encode64(n)).rval;return i===null?null:t.decode64(i)};var s=function(e,n,r){if(!e)throw{message:"WebStorage not available."};var i;r===null?i=e.removeItem(n):(r=t.encode64(JSON.stringify(r)),i=e.setItem(n,r));if(typeof i!="undefined"&&i.rval!==!0)throw i.error},o=function(e,n){if(!e)throw{message:"WebStorage not available."};var r=e.getItem(n);if(e.init)if(r.rval===null){if(r.error)throw r.error;r=null}else r=r.rval;return r!==null&&(r=JSON.parse(t.decode64(r))),r},u=function(e,t,n,r){var i=o(e,t);i===null&&(i={}),i[n]=r,s(e,t,i)},a=function(e,t,n){var r=o(e,t);return r!==null&&(r=n in r?r[n]:null),r},f=function(e,t,n){var r=o(e,t);if(r!==null&&n in r){delete r[n];var i=!0;for(var u in r){i=!1;break}i&&(r=null),s(e,t,r)}},l=function(e,t){s(e,t,null)},c=function(e,t,n){var r=null;typeof n=="undefined"&&(n=["web","flash"]);var i,s=!1,o=null;for(var u in n){i=n[u];try{if(i==="flash"||i==="both"){if(t[0]===null)throw{message:"Flash local storage not available."};r=e.apply(this,t),s=i==="flash"}if(i==="web"||i==="both")t[0]=localStorage,r=e.apply(this,t),s=!0}catch(a){o=a}if(s)break}if(!s)throw o;return r};t.setItem=function(e,t,n,r,i){c(u,arguments,i)},t.getItem=function(e,t,n,r){return c(a,arguments,r)},t.removeItem=function(e,t,n,r){c(f,arguments,r)},t.clearItems=function(e,t,n){c(l,arguments,n)},t.parseUrl=function(e){var t=/^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;t.lastIndex=0;var n=t.exec(e),r=n===null?null:{full:e,scheme:n[1],host:n[2],port:n[3],path:n[4]};return r&&(r.fullHost=r.host,r.port?r.port!==80&&r.scheme==="http"?r.fullHost+=":"+r.port:r.port!==443&&r.scheme==="https"&&(r.fullHost+=":"+r.port):r.scheme==="http"?r.port=80:r.scheme==="https"&&(r.port=443),r.full=r.scheme+"://"+r.fullHost),r};var h=null;t.getQueryVariables=function(e){var t=function(e){var t={},n=e.split("&");for(var r=0;r<n.length;r++){var i=n[r].indexOf("="),s,o;i>0?(s=n[r].substring(0,i),o=n[r].substring(i+1)):(s=n[r],o=null),s in t||(t[s]=[]),!(s in Object.prototype)&&o!==null&&t[s].push(unescape(o))}return t},n;return typeof e=="undefined"?(h===null&&(typeof window=="undefined"?h={}:h=t(window.location.search.substring(1))),n=h):n=t(e),n},t.parseFragment=function(e){var n=e,r="",i=e.indexOf("?");i>0&&(n=e.substring(0,i),r=e.substring(i+1));var s=n.split("/");s.length>0&&s[0]===""&&s.shift();var o=r===""?{}:t.getQueryVariables(r);return{pathString:n,queryString:r,path:s,query:o}},t.makeRequest=function(e){var n=t.parseFragment(e),r={path:n.pathString,query:n.queryString,getPath:function(e){return typeof e=="undefined"?n.path:n.path[e]},getQuery:function(e,t){var r;return typeof e=="undefined"?r=n.query:(r=n.query[e],r&&typeof t!="undefined"&&(r=r[t])),r},getQueryLast:function(e,t){var n,i=r.getQuery(e);return i?n=i[i.length-1]:n=t,n}};return r},t.makeLink=function(e,t,n){e=jQuery.isArray(e)?e.join("/"):e;var r=jQuery.param(t||{});return n=n||"",e+(r.length>0?"?"+r:"")+(n.length>0?"#"+n:"")},t.setPath=function(e,t,n){if(typeof e=="object"&&e!==null){var r=0,i=t.length;while(r<i){var s=t[r++];if(r==i)e[s]=n;else{var o=s in e;if(!o||o&&typeof e[s]!="object"||o&&e[s]===null)e[s]={};e=e[s]}}}},t.getPath=function(e,t,n){var r=0,i=t.length,s=!0;while(s&&r<i&&typeof e=="object"&&e!==null){var o=t[r++];s=o in e,s&&(e=e[o])}return s?e:n},t.deletePath=function(e,t){if(typeof e=="object"&&e!==null){var n=0,r=t.length;while(n<r){var i=t[n++];if(n==r)delete e[i];else{if(!(i in e&&typeof e[i]=="object"&&e[i]!==null))break;e=e[i]}}}},t.isEmpty=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},t.format=function(e){var t=/%./g,n,r,i=0,s=[],o=0;while(n=t.exec(e)){r=e.substring(o,t.lastIndex-2),r.length>0&&s.push(r),o=t.lastIndex;var u=n[0][1];switch(u){case"s":case"o":i<arguments.length?s.push(arguments[i++ +1]):s.push("<?>");break;case"%":s.push("%");break;default:s.push("<%"+u+"?>")}}return s.push(e.substring(o)),s.join("")},t.formatNumber=function(e,t,n,r){var i=e,s=isNaN(t=Math.abs(t))?2:t,o=n===undefined?",":n,u=r===undefined?".":r,a=i<0?"-":"",f=parseInt(i=Math.abs(+i||0).toFixed(s),10)+"",l=f.length>3?f.length%3:0;return a+(l?f.substr(0,l)+u:"")+f.substr(l).replace(/(\d{3})(?=\d)/g,"$1"+u)+(s?o+Math.abs(i-f).toFixed(s).slice(2):"")},t.formatSize=function(e){return e>=1073741824?e=t.formatNumber(e/1073741824,2,".","")+" GiB":e>=1048576?e=t.formatNumber(e/1048576,2,".","")+" MiB":e>=1024?e=t.formatNumber(e/1024,0)+" KiB":e=t.formatNumber(e,0)+" bytes",e},t.bytesFromIP=function(e){return e.indexOf(".")!==-1?t.bytesFromIPv4(e):e.indexOf(":")!==-1?t.bytesFromIPv6(e):null},t.bytesFromIPv4=function(e){e=e.split(".");if(e.length!==4)return null;var n=t.createBuffer();for(var r=0;r<e.length;++r){var i=parseInt(e[r],10);if(isNaN(i))return null;n.putByte(i)}return n.getBytes()},t.bytesFromIPv6=function(e){var n=0;e=e.split(":").filter(function(e){return e.length===0&&++n,!0});var r=(8-e.length+n)*2,i=t.createBuffer();for(var s=0;s<8;++s){if(!e[s]||e[s].length===0){i.fillWithByte(0,r),r=0;continue}var o=t.hexToBytes(e[s]);o.length<2&&i.putByte(0),i.putBytes(o)}return i.getBytes()},t.bytesToIP=function(e){return e.length===4?t.bytesToIPv4(e):e.length===16?t.bytesToIPv6(e):null},t.bytesToIPv4=function(e){if(e.length!==4)return null;var t=[];for(var n=0;n<e.length;++n)t.push(e.charCodeAt(n));return t.join(".")},t.bytesToIPv6=function(e){if(e.length!==16)return null;var n=[],r=[],i=0;for(var s=0;s<e.length;s+=2){var o=t.bytesToHex(e[s]+e[s+1]);while(o[0]==="0"&&o!=="0")o=o.substr(1);if(o==="0"){var u=r[r.length-1],a=n.length;!u||a!==u.end+1?r.push({start:a,end:a}):(u.end=a,u.end-u.start>r[i].end-r[i].start&&(i=r.length-1))}n.push(o)}if(r.length>0){var f=r[i];f.end-f.start>0&&(n.splice(f.start,f.end-f.start+1,""),f.start===0&&n.unshift(""),f.end===7&&n.push(""))}return n.join(":")}}var r="util";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/util",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=!1,n=4,r,i,s,o,u,a=function(){t=!0,s=[0,1,2,4,8,16,32,64,128,27,54];var e=new Array(256);for(var n=0;n<128;++n)e[n]=n<<1,e[n+128]=n+128<<1^283;r=new Array(256),i=new Array(256),o=new Array(4),u=new Array(4);for(var n=0;n<4;++n)o[n]=new Array(256),u[n]=new Array(256);var a=0,f=0,l,c,h,p,d,v,m;for(var n=0;n<256;++n){p=f^f<<1^f<<2^f<<3^f<<4,p=p>>8^p&255^99,r[a]=p,i[p]=a,d=e[p],l=e[a],c=e[l],h=e[c],v=d<<24^p<<16^p<<8^(p^d),m=(l^c^h)<<24^(a^h)<<16^(a^c^h)<<8^(a^l^h);for(var g=0;g<4;++g)o[g][a]=v,u[g][p]=m,v=v<<24|v>>>8,m=m<<24|m>>>8;a===0?a=f=1:(a=l^e[e[e[l^h]]],f^=e[e[f]])}},f=function(e,t){var i=e.slice(0),o,a=1,f=i.length,l=f+6+1,c=n*l;for(var h=f;h<c;++h)o=i[h-1],h%f===0?(o=r[o>>>16&255]<<24^r[o>>>8&255]<<16^r[o&255]<<8^r[o>>>24]^s[a]<<24,a++):f>6&&h%f===4&&(o=r[o>>>24]<<24^r[o>>>16&255]<<16^r[o>>>8&255]<<8^r[o&255]),i[h]=i[h-f]^o;if(t){var p,d=u[0],v=u[1],m=u[2],g=u[3],y=i.slice(0),c=i.length;for(var h=0,b=c-n;h<c;h+=n,b-=n)if(h===0||h===c-n)y[h]=i[b],y[h+1]=i[b+3],y[h+2]=i[b+2],y[h+3]=i[b+1];else for(var w=0;w<n;++w)p=i[b+w],y[h+(3&-w)]=d[r[p>>>24]]^v[r[p>>>16&255]]^m[r[p>>>8&255]]^g[r[p&255]];i=y}return i},l=function(e,t,n,s){var a=e.length/4-1,f,l,c,h,p;s?(f=u[0],l=u[1],c=u[2],h=u[3],p=i):(f=o[0],l=o[1],c=o[2],h=o[3],p=r);var d,v,m,g,y,b,w;d=t[0]^e[0],v=t[s?3:1]^e[1],m=t[2]^e[2],g=t[s?1:3]^e[3];var E=3;for(var S=1;S<a;++S)y=f[d>>>24]^l[v>>>16&255]^c[m>>>8&255]^h[g&255]^e[++E],b=f[v>>>24]^l[m>>>16&255]^c[g>>>8&255]^h[d&255]^e[++E],w=f[m>>>24]^l[g>>>16&255]^c[d>>>8&255]^h[v&255]^e[++E],g=f[g>>>24]^l[d>>>16&255]^c[v>>>8&255]^h[m&255]^e[++E],d=y,v=b,m=w;n[0]=p[d>>>24]<<24^p[v>>>16&255]<<16^p[m>>>8&255]<<8^p[g&255]^e[++E],n[s?3:1]=p[v>>>24]<<24^p[m>>>16&255]<<16^p[g>>>8&255]<<8^p[d&255]^e[++E],n[2]=p[m>>>24]<<24^p[g>>>16&255]<<16^p[d>>>8&255]<<8^p[v&255]^e[++E],n[s?1:3]=p[g>>>24]<<24^p[d>>>16&255]<<16^p[v>>>8&255]<<8^p[m&255]^e[++E]},c=function(r,i,s,o,u){function C(){if(o)for(var e=0;e<n;++e)E[e]=b.getInt32();else for(var e=0;e<n;++e)E[e]=x[e]^b.getInt32();l(g,E,S,o);if(o){for(var e=0;e<n;++e)w.putInt32(x[e]^S[e]);x=E.slice(0)}else{for(var e=0;e<n;++e)w.putInt32(S[e]);x=S}}function k(){l(g,E,S,!1);for(var e=0;e<n;++e)E[e]=b.getInt32();for(var e=0;e<n;++e){var t=E[e]^S[e];o||(E[e]=t),w.putInt32(t)}}function L(){l(g,E,S,!1);for(var e=0;e<n;++e)E[e]=b.getInt32();for(var e=0;e<n;++e)w.putInt32(E[e]^S[e]),E[e]=S[e]}function A(){l(g,E,S,!1);for(var e=n-1;e>=0;--e){if(E[e]!==4294967295){++E[e];break}E[e]=0}for(var e=0;e<n;++e)w.putInt32(b.getInt32()^S[e])}var c=null;t||a(),u=(u||"CBC").toUpperCase();if(typeof r!="string"||r.length!==16&&r.length!==24&&r.length!==32){if(e.util.isArray(r)&&(r.length===16||r.length===24||r.length===32)){var h=r,r=e.util.createBuffer();for(var p=0;p<h.length;++p)r.putByte(h[p])}}else r=e.util.createBuffer(r);if(!e.util.isArray(r)){var h=r;r=[];var d=h.length();if(d===16||d===24||d===32){d>>>=2;for(var p=0;p<d;++p)r.push(h.getInt32())}}if(!e.util.isArray(r)||r.length!==4&&r.length!==6&&r.length!==8)return c;var v=["CFB","OFB","CTR"].indexOf(u)!==-1,m=u==="CBC",g=f(r,o&&!v),y=n<<2,b,w,E,S,x,T,N;c={output:null};if(u==="CBC")N=C;else if(u==="CFB")N=k;else if(u==="OFB")N=L;else{if(u!=="CTR")throw{message:'Unsupported block cipher mode of operation: "'+u+'"'};N=A}return c.update=function(e){T||b.putBuffer(e);while(b.length()>=y||b.length()>0&&T)N()},c.finish=function(e){var t=!0,r=b.length()%y;if(!o)if(e)t=e(y,b,o);else if(m){var i=b.length()===y?y:y-b.length();b.fillWithByte(i,i)}t&&(T=!0,c.update());if(o){m&&(t=r===0);if(t)if(e)t=e(y,w,o);else if(m){var s=w.length(),u=w.at(s-1);u>n<<2?t=!1:w.truncate(u)}}return!m&&!e&&r>0&&w.truncate(y-r),t},c.start=function(t,r){t===null&&(t=x.slice(0));if(typeof t=="string"&&t.length===16)t=e.util.createBuffer(t);else if(e.util.isArray(t)&&t.length===16){var i=t,t=e.util.createBuffer();for(var s=0;s<16;++s)t.putByte(i[s])}if(!e.util.isArray(t)){var i=t;t=new Array(4),t[0]=i.getInt32(),t[1]=i.getInt32(),t[2]=i.getInt32(),t[3]=i.getInt32()}b=e.util.createBuffer(),w=r||e.util.createBuffer(),x=t.slice(0),E=new Array(n),S=new Array(n),T=!1,c.output=w;if(["CFB","OFB","CTR"].indexOf(u)!==-1){for(var s=0;s<n;++s)E[s]=x[s];x=null}},i!==null&&c.start(i,s),c};e.aes=e.aes||{},e.aes.startEncrypting=function(e,t,n,r){return c(e,t,n,!1,r)},e.aes.createEncryptionCipher=function(e,t){return c(e,null,null,!1,t)},e.aes.startDecrypting=function(e,t,n,r){return c(e,t,n,!0,r)},e.aes.createDecryptionCipher=function(e,t){return c(e,null,null,!0,t)},e.aes._expandKey=function(e,n){return t||a(),f(e,n)},e.aes._updateBlock=l}var r="aes";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/aes",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.pki=e.pki||{};var t=e.pki.oids=e.oids=e.oids||{};t["1.2.840.113549.1.1.1"]="rsaEncryption",t.rsaEncryption="1.2.840.113549.1.1.1",t["1.2.840.113549.1.1.4"]="md5WithRSAEncryption",t.md5WithRSAEncryption="1.2.840.113549.1.1.4",t["1.2.840.113549.1.1.5"]="sha1WithRSAEncryption",t.sha1WithRSAEncryption="1.2.840.113549.1.1.5",t["1.2.840.113549.1.1.7"]="RSAES-OAEP",t["RSAES-OAEP"]="1.2.840.113549.1.1.7",t["1.2.840.113549.1.1.8"]="mgf1",t.mgf1="1.2.840.113549.1.1.8",t["1.2.840.113549.1.1.9"]="pSpecified",t.pSpecified="1.2.840.113549.1.1.9",t["1.2.840.113549.1.1.10"]="RSASSA-PSS",t["RSASSA-PSS"]="1.2.840.113549.1.1.10",t["1.2.840.113549.1.1.11"]="sha256WithRSAEncryption",t.sha256WithRSAEncryption="1.2.840.113549.1.1.11",t["1.2.840.113549.1.1.12"]="sha384WithRSAEncryption",t.sha384WithRSAEncryption="1.2.840.113549.1.1.12",t["1.2.840.113549.1.1.13"]="sha512WithRSAEncryption",t.sha512WithRSAEncryption="1.2.840.113549.1.1.13",t["1.3.14.3.2.7"]="desCBC",t.desCBC="1.3.14.3.2.7",t["1.3.14.3.2.26"]="sha1",t.sha1="1.3.14.3.2.26",t["2.16.840.1.101.3.4.2.1"]="sha256",t.sha256="2.16.840.1.101.3.4.2.1",t["2.16.840.1.101.3.4.2.2"]="sha384",t.sha384="2.16.840.1.101.3.4.2.2",t["2.16.840.1.101.3.4.2.3"]="sha512",t.sha512="2.16.840.1.101.3.4.2.3",t["1.2.840.113549.2.5"]="md5",t.md5="1.2.840.113549.2.5",t["1.2.840.113549.1.7.1"]="data",t.data="1.2.840.113549.1.7.1",t["1.2.840.113549.1.7.2"]="signedData",t.signedData="1.2.840.113549.1.7.2",t["1.2.840.113549.1.7.3"]="envelopedData",t.envelopedData="1.2.840.113549.1.7.3",t["1.2.840.113549.1.7.4"]="signedAndEnvelopedData",t.signedAndEnvelopedData="1.2.840.113549.1.7.4",t["1.2.840.113549.1.7.5"]="digestedData",t.digestedData="1.2.840.113549.1.7.5",t["1.2.840.113549.1.7.6"]="encryptedData",t.encryptedData="1.2.840.113549.1.7.6",t["1.2.840.113549.1.9.1"]="emailAddress",t.emailAddress="1.2.840.113549.1.9.1",t["1.2.840.113549.1.9.2"]="unstructuredName",t.unstructuredName="1.2.840.113549.1.9.2",t["1.2.840.113549.1.9.3"]="contentType",t.contentType="1.2.840.113549.1.9.3",t["1.2.840.113549.1.9.4"]="messageDigest",t.messageDigest="1.2.840.113549.1.9.4",t["1.2.840.113549.1.9.5"]="signingTime",t.signingTime="1.2.840.113549.1.9.5",t["1.2.840.113549.1.9.6"]="counterSignature",t.counterSignature="1.2.840.113549.1.9.6",t["1.2.840.113549.1.9.7"]="challengePassword",t.challengePassword="1.2.840.113549.1.9.7",t["1.2.840.113549.1.9.8"]="unstructuredAddress",t.unstructuredAddress="1.2.840.113549.1.9.8",t["1.2.840.113549.1.9.20"]="friendlyName",t.friendlyName="1.2.840.113549.1.9.20",t["1.2.840.113549.1.9.21"]="localKeyId",t.localKeyId="1.2.840.113549.1.9.21",t["1.2.840.113549.1.9.22.1"]="x509Certificate",t.x509Certificate="1.2.840.113549.1.9.22.1",t["1.2.840.113549.1.12.10.1.1"]="keyBag",t.keyBag="1.2.840.113549.1.12.10.1.1",t["1.2.840.113549.1.12.10.1.2"]="pkcs8ShroudedKeyBag",t.pkcs8ShroudedKeyBag="1.2.840.113549.1.12.10.1.2",t["1.2.840.113549.1.12.10.1.3"]="certBag",t.certBag="1.2.840.113549.1.12.10.1.3",t["1.2.840.113549.1.12.10.1.4"]="crlBag",t.crlBag="1.2.840.113549.1.12.10.1.4",t["1.2.840.113549.1.12.10.1.5"]="secretBag",t.secretBag="1.2.840.113549.1.12.10.1.5",t["1.2.840.113549.1.12.10.1.6"]="safeContentsBag",t.safeContentsBag="1.2.840.113549.1.12.10.1.6",t["1.2.840.113549.1.5.13"]="pkcs5PBES2",t.pkcs5PBES2="1.2.840.113549.1.5.13",t["1.2.840.113549.1.5.12"]="pkcs5PBKDF2",t.pkcs5PBKDF2="1.2.840.113549.1.5.12",t["1.2.840.113549.1.12.1.1"]="pbeWithSHAAnd128BitRC4",t.pbeWithSHAAnd128BitRC4="1.2.840.113549.1.12.1.1",t["1.2.840.113549.1.12.1.2"]="pbeWithSHAAnd40BitRC4",t.pbeWithSHAAnd40BitRC4="1.2.840.113549.1.12.1.2",t["1.2.840.113549.1.12.1.3"]="pbeWithSHAAnd3-KeyTripleDES-CBC",t["pbeWithSHAAnd3-KeyTripleDES-CBC"]="1.2.840.113549.1.12.1.3",t["1.2.840.113549.1.12.1.4"]="pbeWithSHAAnd2-KeyTripleDES-CBC",t["pbeWithSHAAnd2-KeyTripleDES-CBC"]="1.2.840.113549.1.12.1.4",t["1.2.840.113549.1.12.1.5"]="pbeWithSHAAnd128BitRC2-CBC",t["pbeWithSHAAnd128BitRC2-CBC"]="1.2.840.113549.1.12.1.5",t["1.2.840.113549.1.12.1.6"]="pbewithSHAAnd40BitRC2-CBC",t["pbewithSHAAnd40BitRC2-CBC"]="1.2.840.113549.1.12.1.6",t["1.2.840.113549.3.7"]="des-EDE3-CBC",t["des-EDE3-CBC"]="1.2.840.113549.3.7",t["2.16.840.1.101.3.4.1.2"]="aes128-CBC",t["aes128-CBC"]="2.16.840.1.101.3.4.1.2",t["2.16.840.1.101.3.4.1.22"]="aes192-CBC",t["aes192-CBC"]="2.16.840.1.101.3.4.1.22",t["2.16.840.1.101.3.4.1.42"]="aes256-CBC",t["aes256-CBC"]="2.16.840.1.101.3.4.1.42",t["2.5.4.3"]="commonName",t.commonName="2.5.4.3",t["2.5.4.5"]="serialName",t.serialName="2.5.4.5",t["2.5.4.6"]="countryName",t.countryName="2.5.4.6",t["2.5.4.7"]="localityName",t.localityName="2.5.4.7",t["2.5.4.8"]="stateOrProvinceName",t.stateOrProvinceName="2.5.4.8",t["2.5.4.10"]="organizationName",t.organizationName="2.5.4.10",t["2.5.4.11"]="organizationalUnitName",t.organizationalUnitName="2.5.4.11",t["2.16.840.1.113730.1.1"]="nsCertType",t.nsCertType="2.16.840.1.113730.1.1",t["2.5.29.1"]="authorityKeyIdentifier",t["2.5.29.2"]="keyAttributes",t["2.5.29.3"]="certificatePolicies",t["2.5.29.4"]="keyUsageRestriction",t["2.5.29.5"]="policyMapping",t["2.5.29.6"]="subtreesConstraint",t["2.5.29.7"]="subjectAltName",t["2.5.29.8"]="issuerAltName",t["2.5.29.9"]="subjectDirectoryAttributes",t["2.5.29.10"]="basicConstraints",t["2.5.29.11"]="nameConstraints",t["2.5.29.12"]="policyConstraints",t["2.5.29.13"]="basicConstraints",t["2.5.29.14"]="subjectKeyIdentifier",t.subjectKeyIdentifier="2.5.29.14",t["2.5.29.15"]="keyUsage",t.keyUsage="2.5.29.15",t["2.5.29.16"]="privateKeyUsagePeriod",t["2.5.29.17"]="subjectAltName",t.subjectAltName="2.5.29.17",t["2.5.29.18"]="issuerAltName",t.issuerAltName="2.5.29.18",t["2.5.29.19"]="basicConstraints",t.basicConstraints="2.5.29.19",t["2.5.29.20"]="cRLNumber",t["2.5.29.21"]="cRLReason",t["2.5.29.22"]="expirationDate",t["2.5.29.23"]="instructionCode",t["2.5.29.24"]="invalidityDate",t["2.5.29.25"]="cRLDistributionPoints",t["2.5.29.26"]="issuingDistributionPoint",t["2.5.29.27"]="deltaCRLIndicator",t["2.5.29.28"]="issuingDistributionPoint",t["2.5.29.29"]="certificateIssuer",t["2.5.29.30"]="nameConstraints",t["2.5.29.31"]="cRLDistributionPoints",t["2.5.29.32"]="certificatePolicies",t["2.5.29.33"]="policyMappings",t["2.5.29.34"]="policyConstraints",t["2.5.29.35"]="authorityKeyIdentifier",t["2.5.29.36"]="policyConstraints",t["2.5.29.37"]="extKeyUsage",t.extKeyUsage="2.5.29.37",t["2.5.29.46"]="freshestCRL",t["2.5.29.54"]="inhibitAnyPolicy",t["1.3.6.1.5.5.7.3.1"]="serverAuth",t.serverAuth="1.3.6.1.5.5.7.3.1",t["1.3.6.1.5.5.7.3.2"]="clientAuth",t.clientAuth="1.3.6.1.5.5.7.3.2",t["1.3.6.1.5.5.7.3.3"]="codeSigning",t.codeSigning="1.3.6.1.5.5.7.3.3",t["1.3.6.1.5.5.7.3.4"]="emailProtection",t.emailProtection="1.3.6.1.5.5.7.3.4",t["1.3.6.1.5.5.7.3.8"]="timeStamping",t.timeStamping="1.3.6.1.5.5.7.3.8"}var r="oids";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/oids",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1=e.asn1||{};t.Class={UNIVERSAL:0,APPLICATION:64,CONTEXT_SPECIFIC:128,PRIVATE:192},t.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30},t.create=function(t,n,r,i){if(e.util.isArray(i)){var s=[];for(var o=0;o<i.length;++o)i[o]!==undefined&&s.push(i[o]);i=s}return{tagClass:t,type:n,constructed:r,composed:r||e.util.isArray(i),value:i}};var n=function(e){var t=e.getByte();if(t===128)return undefined;var n,r=t&128;return r?n=e.getInt((t&127)<<3):n=t,n};t.fromDer=function(r,i){i===undefined&&(i=!0),typeof r=="string"&&(r=e.util.createBuffer(r));if(r.length()<2)throw{message:"Too few bytes to parse DER.",bytes:r.length()};var s=r.getByte(),o=s&192,u=s&31,a=n(r);if(r.length()<a){if(i)throw{message:"Too few bytes to read ASN.1 value.",detail:r.length()+" < "+a};a=r.length()}var f,l=(s&32)===32,c=l;if(!c&&o===t.Class.UNIVERSAL&&u===t.Type.BITSTRING&&a>1){var h=r.read,p=r.getByte();if(p===0){s=r.getByte();var d=s&192;if(d===t.Class.UNIVERSAL||d===t.Class.CONTEXT_SPECIFIC)try{var v=n(r);c=v===a-(r.read-h),c&&(++h,--a)}catch(m){}}r.read=h}if(c){f=[];if(a===undefined)for(;;){if(r.bytes(2)===String.fromCharCode(0,0)){r.getBytes(2);break}f.push(t.fromDer(r,i))}else{var g=r.length();while(a>0)f.push(t.fromDer(r,i)),a-=g-r.length(),g=r.length()}}else{if(a===undefined){if(i)throw{message:"Non-constructed ASN.1 object of indefinite length."};a=r.length()}if(u===t.Type.BMPSTRING){f="";for(var y=0;y<a;y+=2)f+=String.fromCharCode(r.getInt16())}else f=r.getBytes(a)}return t.create(o,u,l,f)},t.toDer=function(n){var r=e.util.createBuffer(),i=n.tagClass|n.type,s=e.util.createBuffer();if(n.composed){n.constructed?i|=32:s.putByte(0);for(var o=0;o<n.value.length;++o)n.value[o]!==undefined&&s.putBuffer(t.toDer(n.value[o]))}else if(n.type===t.Type.BMPSTRING)for(var o=0;o<n.value.length;++o)s.putInt16(n.value.charCodeAt(o));else s.putBytes(n.value);r.putByte(i);if(s.length()<=127)r.putByte(s.length()&127);else{var u=s.length(),a="";do a+=String.fromCharCode(u&255),u>>>=8;while(u>0);r.putByte(a.length|128);for(var o=a.length-1;o>=0;--o)r.putByte(a.charCodeAt(o))}return r.putBuffer(s),r},t.oidToDer=function(t){var n=t.split("."),r=e.util.createBuffer();r.putByte(40*parseInt(n[0],10)+parseInt(n[1],10));var i,s,o,u;for(var a=2;a<n.length;++a){i=!0,s=[],o=parseInt(n[a],10);do u=o&127,o>>>=7,i||(u|=128),s.push(u),i=!1;while(o>0);for(var f=s.length-1;f>=0;--f)r.putByte(s[f])}return r},t.derToOid=function(t){var n;typeof t=="string"&&(t=e.util.createBuffer(t));var r=t.getByte();n=Math.floor(r/40)+"."+r%40;var i=0;while(t.length()>0)r=t.getByte(),i<<=7,r&128?i+=r&127:(n+="."+(i+r),i=0);return n},t.utcTimeToDate=function(e){var t=new Date,n=parseInt(e.substr(0,2),10);n=n>=50?1900+n:2e3+n;var r=parseInt(e.substr(2,2),10)-1,i=parseInt(e.substr(4,2),10),s=parseInt(e.substr(6,2),10),o=parseInt(e.substr(8,2),10),u=0;if(e.length>11){var a=e.charAt(10),f=10;a!=="+"&&a!=="-"&&(u=parseInt(e.substr(10,2),10),f+=2)}t.setUTCFullYear(n,r,i),t.setUTCHours(s,o,u,0);if(f){a=e.charAt(f);if(a==="+"||a==="-"){var l=parseInt(e.substr(f+1,2),10),c=parseInt(e.substr(f+4,2),10),h=l*60+c;h*=6e4,a==="+"?t.setTime(+t-h):t.setTime(+t+h)}}return t},t.generalizedTimeToDate=function(e){var t=new Date,n=parseInt(e.substr(0,4),10),r=parseInt(e.substr(4,2),10)-1,i=parseInt(e.substr(6,2),10),s=parseInt(e.substr(8,2),10),o=parseInt(e.substr(10,2),10),u=parseInt(e.substr(12,2),10),a=0,f=0,l=!1;e.charAt(e.length-1)==="Z"&&(l=!0);var c=e.length-5,h=e.charAt(c);if(h==="+"||h==="-"){var p=parseInt(e.substr(c+1,2),10),d=parseInt(e.substr(c+4,2),10);f=p*60+d,f*=6e4,h==="+"&&(f*=-1),l=!0}return e.charAt(14)==="."&&(a=parseFloat(e.substr(14),10)*1e3),l?(t.setUTCFullYear(n,r,i),t.setUTCHours(s,o,u,a),t.setTime(+t+f)):(t.setFullYear(n,r,i),t.setHours(s,o,u,a)),t},t.dateToUtcTime=function(e){var t="",n=[];n.push((""+e.getUTCFullYear()).substr(2)),n.push(""+(e.getUTCMonth()+1)),n.push(""+e.getUTCDate()),n.push(""+e.getUTCHours()),n.push(""+e.getUTCMinutes()),n.push(""+e.getUTCSeconds());for(var r=0;r<n.length;++r)n[r].length<2&&(t+="0"),t+=n[r];return t+="Z",t},t.integerToDer=function(t){var n=e.util.createBuffer();if(t>=-128&&t<128)return n.putSignedInt(t,8);if(t>=-32768&&t<32768)return n.putSignedInt(t,16);if(t>=-8388608&&t<8388608)return n.putSignedInt(t,24);if(t>=-2147483648&&t<2147483648)return n.putSignedInt(t,32);throw{message:"Integer too large; max is 32-bits.",integer:t}},t.derToInteger=function(t){typeof t=="string"&&(t=e.util.createBuffer(t));var n=t.length()*8;if(n>32)throw{message:"Integer too large; max is 32-bits."};return t.getSignedInt(n)},t.validate=function(n,r,i,s){var o=!1;if(n.tagClass!==r.tagClass&&typeof r.tagClass!="undefined"||n.type!==r.type&&typeof r.type!="undefined")s&&(n.tagClass!==r.tagClass&&s.push("["+r.name+"] "+'Expected tag class "'+r.tagClass+'", got "'+n.tagClass+'"'),n.type!==r.type&&s.push("["+r.name+"] "+'Expected type "'+r.type+'", got "'+n.type+'"'));else if(n.constructed===r.constructed||typeof r.constructed=="undefined"){o=!0;if(r.value&&e.util.isArray(r.value)){var u=0;for(var a=0;o&&a<r.value.length;++a)o=r.value[a].optional||!1,n.value[u]&&(o=t.validate(n.value[u],r.value[a],i,s),o?++u:r.value[a].optional&&(o=!0)),!o&&s&&s.push("["+r.name+"] "+'Tag class "'+r.tagClass+'", type "'+r.type+'" expected value length "'+r.value.length+'", got "'+n.value.length+'"')}o&&i&&(r.capture&&(i[r.capture]=n.value),r.captureAsn1&&(i[r.captureAsn1]=n))}else s&&s.push("["+r.name+"] "+'Expected constructed "'+r.constructed+'", got "'+n.constructed+'"');return o};var r=/[^\\u0000-\\u00ff]/;t.prettyPrint=function(n,i,s){var o="";i=i||0,s=s||2,i>0&&(o+="\n");var u="";for(var a=0;a<i*s;++a)u+=" ";o+=u+"Tag: ";switch(n.tagClass){case t.Class.UNIVERSAL:o+="Universal:";break;case t.Class.APPLICATION:o+="Application:";break;case t.Class.CONTEXT_SPECIFIC:o+="Context-Specific:";break;case t.Class.PRIVATE:o+="Private:"}if(n.tagClass===t.Class.UNIVERSAL){o+=n.type;switch(n.type){case t.Type.NONE:o+=" (None)";break;case t.Type.BOOLEAN:o+=" (Boolean)";break;case t.Type.BITSTRING:o+=" (Bit string)";break;case t.Type.INTEGER:o+=" (Integer)";break;case t.Type.OCTETSTRING:o+=" (Octet string)";break;case t.Type.NULL:o+=" (Null)";break;case t.Type.OID:o+=" (Object Identifier)";break;case t.Type.ODESC:o+=" (Object Descriptor)";break;case t.Type.EXTERNAL:o+=" (External or Instance of)";break;case t.Type.REAL:o+=" (Real)";break;case t.Type.ENUMERATED:o+=" (Enumerated)";break;case t.Type.EMBEDDED:o+=" (Embedded PDV)";break;case t.Type.UTF8:o+=" (UTF8)";break;case t.Type.ROID:o+=" (Relative Object Identifier)";break;case t.Type.SEQUENCE:o+=" (Sequence)";break;case t.Type.SET:o+=" (Set)";break;case t.Type.PRINTABLESTRING:o+=" (Printable String)";break;case t.Type.IA5String:o+=" (IA5String (ASCII))";break;case t.Type.UTCTIME:o+=" (UTC time)";break;case t.Type.GENERALIZEDTIME:o+=" (Generalized time)";break;case t.Type.BMPSTRING:o+=" (BMP String)"}}else o+=n.type;o+="\n",o+=u+"Constructed: "+n.constructed+"\n";if(n.composed){var f=0,l="";for(var a=0;a<n.value.length;++a)n.value[a]!==undefined&&(f+=1,l+=t.prettyPrint(n.value[a],i+1,s),a+1<n.value.length&&(l+=","));o+=u+"Sub values: "+f+l}else{o+=u+"Value: ";if(n.type===t.Type.OID){var c=t.derToOid(n.value);o+=c,e.pki&&e.pki.oids&&c in e.pki.oids&&(o+=" ("+e.pki.oids[c]+")")}if(n.type===t.Type.INTEGER)try{o+=t.derToInteger(n.value)}catch(h){o+="0x"+e.util.bytesToHex(n.value)}else r.test(n.value)?o+="0x"+e.util.createBuffer(n.value,"utf8").toHex():n.value.length===0?o+="[null]":o+=n.value}return o}}var r="asn1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/asn1",["require","module","./util","./oids"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.md5=e.md5||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.md5=e.md.algorithms.md5=t;var n=null,r=null,i=null,s=null,o=!1,u=function(){n=String.fromCharCode(128),n+=e.util.fillString(String.fromCharCode(0),64),r=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9],i=[7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21],s=new Array(64);for(var t=0;t<64;++t)s[t]=Math.floor(Math.abs(Math.sin(t+1))*4294967296);o=!0},a=function(e,t,n){var o,u,a,f,l,c,h,p,d=n.length();while(d>=64){u=e.h0,a=e.h1,f=e.h2,l=e.h3;for(p=0;p<16;++p)t[p]=n.getInt32Le(),c=l^a&(f^l),o=u+c+s[p]+t[p],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;for(;p<32;++p)c=f^l&(a^f),o=u+c+s[p]+t[r[p]],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;for(;p<48;++p)c=a^f^l,o=u+c+s[p]+t[r[p]],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;for(;p<64;++p)c=f^(a|~l),o=u+c+s[p]+t[r[p]],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;e.h0=e.h0+u&4294967295,e.h1=e.h1+a&4294967295,e.h2=e.h2+f&4294967295,e.h3=e.h3+l&4294967295,d-=64}};t.create=function(){o||u();var t=null,r=e.util.createBuffer(),i=new Array(16),s={algorithm:"md5",blockLength:64,digestLength:16,messageLength:0};return s.start=function(){return s.messageLength=0,r=e.util.createBuffer(),t={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878},s},s.start(),s.update=function(n,o){return o==="utf8"&&(n=e.util.encodeUtf8(n)),s.messageLength+=n.length,r.putBytes(n),a(t,i,r),(r.read>2048||r.length()===0)&&r.compact(),s},s.digest=function(){var o=s.messageLength,u=e.util.createBuffer();u.putBytes(r.bytes()),u.putBytes(n.substr(0,64-(o+8)%64)),u.putInt32Le(o<<3&4294967295),u.putInt32Le(o>>>29&255);var f={h0:t.h0,h1:t.h1,h2:t.h2,h3:t.h3};a(f,i,u);var l=e.util.createBuffer();return l.putInt32Le(f.h0),l.putInt32Le(f.h1),l.putInt32Le(f.h2),l.putInt32Le(f.h3),l},s}}var r="md5";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/md5",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.sha1=e.sha1||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.sha1=e.md.algorithms.sha1=t;var n=null,r=!1,i=function(){n=String.fromCharCode(128),n+=e.util.fillString(String.fromCharCode(0),64),r=!0},s=function(e,t,n){var r,i,s,o,u,a,f,l,c=n.length();while(c>=64){i=e.h0,s=e.h1,o=e.h2,u=e.h3,a=e.h4;for(l=0;l<16;++l)r=n.getInt32(),t[l]=r,f=u^s&(o^u),r=(i<<5|i>>>27)+f+a+1518500249+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<20;++l)r=t[l-3]^t[l-8]^t[l-14]^t[l-16],r=r<<1|r>>>31,t[l]=r,f=u^s&(o^u),r=(i<<5|i>>>27)+f+a+1518500249+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<32;++l)r=t[l-3]^t[l-8]^t[l-14]^t[l-16],r=r<<1|r>>>31,t[l]=r,f=s^o^u,r=(i<<5|i>>>27)+f+a+1859775393+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<40;++l)r=t[l-6]^t[l-16]^t[l-28]^t[l-32],r=r<<2|r>>>30,t[l]=r,f=s^o^u,r=(i<<5|i>>>27)+f+a+1859775393+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<60;++l)r=t[l-6]^t[l-16]^t[l-28]^t[l-32],r=r<<2|r>>>30,t[l]=r,f=s&o|u&(s^o),r=(i<<5|i>>>27)+f+a+2400959708+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<80;++l)r=t[l-6]^t[l-16]^t[l-28]^t[l-32],r=r<<2|r>>>30,t[l]=r,f=s^o^u,r=(i<<5|i>>>27)+f+a+3395469782+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;e.h0+=i,e.h1+=s,e.h2+=o,e.h3+=u,e.h4+=a,c-=64}};t.create=function(){r||i();var t=null,o=e.util.createBuffer(),u=new Array(80),a={algorithm:"sha1",blockLength:64,digestLength:20,messageLength:0};return a.start=function(){return a.messageLength=0,o=e.util.createBuffer(),t={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878,h4:3285377520},a},a.start(),a.update=function(n,r){return r==="utf8"&&(n=e.util.encodeUtf8(n)),a.messageLength+=n.length,o.putBytes(n),s(t,u,o),(o.read>2048||o.length()===0)&&o.compact(),a},a.digest=function(){var r=a.messageLength,i=e.util.createBuffer();i.putBytes(o.bytes()),i.putBytes(n.substr(0,64-(r+8)%64)),i.putInt32(r>>>29&255),i.putInt32(r<<3&4294967295);var f={h0:t.h0,h1:t.h1,h2:t.h2,h3:t.h3,h4:t.h4};s(f,u,i);var l=e.util.createBuffer();return l.putInt32(f.h0),l.putInt32(f.h1),l.putInt32(f.h2),l.putInt32(f.h3),l.putInt32(f.h4),l},a}}var r="sha1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/sha1",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.sha256=e.sha256||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.sha256=e.md.algorithms.sha256=t;var n=null,r=!1,i=null,s=function(){n=String.fromCharCode(128),n+=e.util.fillString(String.fromCharCode(0),64),i=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],r=!0},o=function(e,t,n){var r,s,o,u,a,f,l,c,h,p,d,v,m,g,y,b=n.length();while(b>=64){for(l=0;l<16;++l)t[l]=n.getInt32();for(;l<64;++l)r=t[l-2],r=(r>>>17|r<<15)^(r>>>19|r<<13)^r>>>10,s=t[l-15],s=(s>>>7|s<<25)^(s>>>18|s<<14)^s>>>3,t[l]=r+t[l-7]+s+t[l-16]&4294967295;c=e.h0,h=e.h1,p=e.h2,d=e.h3,v=e.h4,m=e.h5,g=e.h6,y=e.h7;for(l=0;l<64;++l)u=(v>>>6|v<<26)^(v>>>11|v<<21)^(v>>>25|v<<7),a=g^v&(m^g),o=(c>>>2|c<<30)^(c>>>13|c<<19)^(c>>>22|c<<10),f=c&h|p&(c^h),r=y+u+a+i[l]+t[l],s=o+f,y=g,g=m,m=v,v=d+r&4294967295,d=p,p=h,h=c,c=r+s&4294967295;e.h0=e.h0+c&4294967295,e.h1=e.h1+h&4294967295,e.h2=e.h2+p&4294967295,e.h3=e.h3+d&4294967295,e.h4=e.h4+v&4294967295,e.h5=e.h5+m&4294967295,e.h6=e.h6+g&4294967295,e.h7=e.h7+y&4294967295,b-=64}};t.create=function(){r||s();var t=null,i=e.util.createBuffer(),u=new Array(64),a={algorithm:"sha256",blockLength:64,digestLength:32,messageLength:0};return a.start=function(){return a.messageLength=0,i=e.util.createBuffer(),t={h0:1779033703,h1:3144134277,h2:1013904242,h3:2773480762,h4:1359893119,h5:2600822924,h6:528734635,h7:1541459225},a},a.start(),a.update=function(n,r){return r==="utf8"&&(n=e.util.encodeUtf8(n)),a.messageLength+=n.length,i.putBytes(n),o(t,u,i),(i.read>2048||i.length()===0)&&i.compact(),a},a.digest=function(){var r=a.messageLength,s=e.util.createBuffer();s.putBytes(i.bytes()),s.putBytes(n.substr(0,64-(r+8)%64)),s.putInt32(r>>>29&255),s.putInt32(r<<3&4294967295);var f={h0:t.h0,h1:t.h1,h2:t.h2,h3:t.h3,h4:t.h4,h5:t.h5,h6:t.h6,h7:t.h7};o(f,u,s);var l=e.util.createBuffer();return l.putInt32(f.h0),l.putInt32(f.h1),l.putInt32(f.h2),l.putInt32(f.h3),l.putInt32(f.h4),l.putInt32(f.h5),l.putInt32(f.h6),l.putInt32(f.h7),l},a}}var r="sha256";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/sha256",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.md=e.md||{},e.md.algorithms={md5:e.md5,sha1:e.sha1,sha256:e.sha256},e.md.md5=e.md5,e.md.sha1=e.sha1,e.md.sha256=e.sha256}var r="md";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/md",["require","module","./md5","./sha1","./sha256"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.hmac=e.hmac||{};t.create=function(){var t=null,n=null,r=null,i=null,s={};return s.start=function(s,o){if(s!==null)if(typeof s=="string"){s=s.toLowerCase();if(!(s in e.md.algorithms))throw'Unknown hash algorithm "'+s+'"';n=e.md.algorithms[s].create()}else n=s;if(o===null)o=t;else{if(typeof o=="string")o=e.util.createBuffer(o);else if(e.util.isArray(o)){var u=o;o=e.util.createBuffer();for(var a=0;a<u.length;++a)o.putByte(u[a])}var f=o.length();f>n.blockLength&&(n.start(),n.update(o.bytes()),o=n.digest()),r=e.util.createBuffer(),i=e.util.createBuffer(),f=o.length();for(var a=0;a<f;++a){var u=o.at(a);r.putByte(54^u),i.putByte(92^u)}if(f<n.blockLength){var u=n.blockLength-f;for(var a=0;a<u;++a)r.putByte(54),i.putByte(92)}t=o,r=r.bytes(),i=i.bytes()}n.start(),n.update(r)},s.update=function(e){n.update(e)},s.getMac=function(){var e=n.digest().bytes();return n.start(),n.update(i),n.update(e),n.digest()},s.digest=s.getMac,s}}var r="hmac";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/hmac",["require","module","./md","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(e){var t=e.name+": ",n=[];for(var r=0;r<e.values.length;++r)n.push(e.values[r].replace(/^(\S+\r\n)/,function(e,t){return" "+t}));t+=n.join(",")+"\r\n";var i=0,s=-1;for(var r=0;r<t.length;++r,++i)if(i>65&&s!==-1){var o=t[s];o===","?(++s,t=t.substr(0,s)+"\r\n "+t.substr(s)):t=t.substr(0,s)+"\r\n"+o+t.substr(s+1),i=r-s-1,s=-1,++r}else if(t[r]===" "||t[r]==="	"||t[r]===",")s=r;return t}function r(e){return e.replace(/^\s+/,"")}var t=e.pem=e.pem||{};t.encode=function(t,r){r=r||{};var i="-----BEGIN "+t.type+"-----\r\n",s;t.procType&&(s={name:"Proc-Type",values:[String(t.procType.version),t.procType.type]},i+=n(s)),t.contentDomain&&(s={name:"Content-Domain",values:[t.contentDomain]},i+=n(s)),t.dekInfo&&(s={name:"DEK-Info",values:[t.dekInfo.algorithm]},t.dekInfo.parameters&&s.values.push(t.dekInfo.parameters),i+=n(s));if(t.headers)for(var o=0;o<t.headers.length;++o)i+=n(t.headers[o]);return t.procType&&(i+="\r\n"),i+=e.util.encode64(t.body,r.maxline||64)+"\r\n",i+="-----END "+t.type+"-----\r\n",i},t.decode=function(t){var n=[],i=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,s=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,o=/\r?\n/,u;for(;;){u=i.exec(t);if(!u)break;var a={type:u[1],procType:null,contentDomain:null,dekInfo:null,headers:[],body:e.util.decode64(u[3])};n.push(a);if(!u[2])continue;var f=u[2].split(o),l=0;while(u&&l<f.length){var c=f[l].replace(/\s+$/,"");for(var h=l+1;h<f.length;++h){var p=f[h];if(!/\s/.test(p[0]))break;c+=p,l=h}u=c.match(s);if(u){var d={name:u[1],values:[]},v=u[2].split(",");for(var m=0;m<v.length;++m)d.values.push(r(v[m]));if(!a.procType){if(d.name!=="Proc-Type")throw{message:'Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".'};if(d.values.length!==2)throw{message:'Invalid PEM formatted message. The "Proc-Type" header must have two subfields.'};a.procType={version:v[0],type:v[1]}}else if(!a.contentDomain&&d.name==="Content-Domain")a.contentDomain=v[0]||"";else if(!a.dekInfo&&d.name==="DEK-Info"){if(d.values.length===0)throw{message:'Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.'};a.dekInfo={algorithm:v[0],parameters:v[1]||null}}else a.headers.push(d)}++l}if(a.procType==="ENCRYPTED"&&!a.dekInfo)throw{message:'Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".'}}if(n.length===0)throw{message:"Invalid PEM formatted message."};return n}}var r="pem";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pem",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function f(e){var t=[0,4,536870912,536870916,65536,65540,536936448,536936452,512,516,536871424,536871428,66048,66052,536936960,536936964],n=[0,1,1048576,1048577,67108864,67108865,68157440,68157441,256,257,1048832,1048833,67109120,67109121,68157696,68157697],r=[0,8,2048,2056,16777216,16777224,16779264,16779272,0,8,2048,2056,16777216,16777224,16779264,16779272],i=[0,2097152,134217728,136314880,8192,2105344,134225920,136323072,131072,2228224,134348800,136445952,139264,2236416,134356992,136454144],s=[0,262144,16,262160,0,262144,16,262160,4096,266240,4112,266256,4096,266240,4112,266256],o=[0,1024,32,1056,0,1024,32,1056,33554432,33555456,33554464,33555488,33554432,33555456,33554464,33555488],u=[0,268435456,524288,268959744,2,268435458,524290,268959746,0,268435456,524288,268959744,2,268435458,524290,268959746],a=[0,65536,2048,67584,536870912,536936448,536872960,536938496,131072,196608,133120,198656,537001984,537067520,537004032,537069568],f=[0,262144,0,262144,2,262146,2,262146,33554432,33816576,33554432,33816576,33554434,33816578,33554434,33816578],l=[0,268435456,8,268435464,0,268435456,8,268435464,1024,268436480,1032,268436488,1024,268436480,1032,268436488],c=[0,32,0,32,1048576,1048608,1048576,1048608,8192,8224,8192,8224,1056768,1056800,1056768,1056800],h=[0,16777216,512,16777728,2097152,18874368,2097664,18874880,67108864,83886080,67109376,83886592,69206016,85983232,69206528,85983744],p=[0,4096,134217728,134221824,524288,528384,134742016,134746112,16,4112,134217744,134221840,524304,528400,134742032,134746128],d=[0,4,256,260,0,4,256,260,1,5,257,261,1,5,257,261],v=e.length()>8?3:1,m=[],g=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0],y=0,b;for(var w=0;w<v;w++){var E=e.getInt32(),S=e.getInt32();b=(E>>>4^S)&252645135,S^=b,E^=b<<4,b=(S>>>-16^E)&65535,E^=b,S^=b<<-16,b=(E>>>2^S)&858993459,S^=b,E^=b<<2,b=(S>>>-16^E)&65535,E^=b,S^=b<<-16,b=(E>>>1^S)&1431655765,S^=b,E^=b<<1,b=(S>>>8^E)&16711935,E^=b,S^=b<<8,b=(E>>>1^S)&1431655765,S^=b,E^=b<<1,b=E<<8|S>>>20&240,E=S<<24|S<<8&16711680|S>>>8&65280|S>>>24&240,S=b;for(var x=0;x<g.length;x++){g[x]?(E=E<<2|E>>>26,S=S<<2|S>>>26):(E=E<<1|E>>>27,S=S<<1|S>>>27),E&=-15,S&=-15;var T=t[E>>>28]|n[E>>>24&15]|r[E>>>20&15]|i[E>>>16&15]|s[E>>>12&15]|o[E>>>8&15]|u[E>>>4&15],N=a[S>>>28]|f[S>>>24&15]|l[S>>>20&15]|c[S>>>16&15]|h[S>>>12&15]|p[S>>>8&15]|d[S>>>4&15];b=(N>>>16^T)&65535,m[y++]=T^b,m[y++]=N^b<<16}}return m}var t=[16843776,0,65536,16843780,16842756,66564,4,65536,1024,16843776,16843780,1024,16778244,16842756,16777216,4,1028,16778240,16778240,66560,66560,16842752,16842752,16778244,65540,16777220,16777220,65540,0,1028,66564,16777216,65536,16843780,4,16842752,16843776,16777216,16777216,1024,16842756,65536,66560,16777220,1024,4,16778244,66564,16843780,65540,16842752,16778244,16777220,1028,66564,16843776,1028,16778240,16778240,0,65540,66560,0,16842756],n=[-2146402272,-2147450880,32768,1081376,1048576,32,-2146435040,-2147450848,-2147483616,-2146402272,-2146402304,-2147483648,-2147450880,1048576,32,-2146435040,1081344,1048608,-2147450848,0,-2147483648,32768,1081376,-2146435072,1048608,-2147483616,0,1081344,32800,-2146402304,-2146435072,32800,0,1081376,-2146435040,1048576,-2147450848,-2146435072,-2146402304,32768,-2146435072,-2147450880,32,-2146402272,1081376,32,32768,-2147483648,32800,-2146402304,1048576,-2147483616,1048608,-2147450848,-2147483616,1048608,1081344,0,-2147450880,32800,-2147483648,-2146435040,-2146402272,1081344],r=[520,134349312,0,134348808,134218240,0,131592,134218240,131080,134217736,134217736,131072,134349320,131080,134348800,520,134217728,8,134349312,512,131584,134348800,134348808,131592,134218248,131584,131072,134218248,8,134349320,512,134217728,134349312,134217728,131080,520,131072,134349312,134218240,0,512,131080,134349320,134218240,134217736,512,0,134348808,134218248,131072,134217728,134349320,8,131592,131584,134217736,134348800,134218248,520,134348800,131592,8,134348808,131584],i=[8396801,8321,8321,128,8396928,8388737,8388609,8193,0,8396800,8396800,8396929,129,0,8388736,8388609,1,8192,8388608,8396801,128,8388608,8193,8320,8388737,1,8320,8388736,8192,8396928,8396929,129,8388736,8388609,8396800,8396929,129,0,0,8396800,8320,8388736,8388737,1,8396801,8321,8321,128,8396929,129,1,8192,8388609,8193,8396928,8388737,8193,8320,8388608,8396801,128,8388608,8192,8396928],s=[256,34078976,34078720,1107296512,524288,256,1073741824,34078720,1074266368,524288,33554688,1074266368,1107296512,1107820544,524544,1073741824,33554432,1074266112,1074266112,0,1073742080,1107820800,1107820800,33554688,1107820544,1073742080,0,1107296256,34078976,33554432,1107296256,524544,524288,1107296512,256,33554432,1073741824,34078720,1107296512,1074266368,33554688,1073741824,1107820544,34078976,1074266368,256,33554432,1107820544,1107820800,524544,1107296256,1107820800,34078720,0,1074266112,1107296256,524544,33554688,1073742080,524288,0,1074266112,34078976,1073742080],o=[536870928,541065216,16384,541081616,541065216,16,541081616,4194304,536887296,4210704,4194304,536870928,4194320,536887296,536870912,16400,0,4194320,536887312,16384,4210688,536887312,16,541065232,541065232,0,4210704,541081600,16400,4210688,541081600,536870912,536887296,16,541065232,4210688,541081616,4194304,16400,536870928,4194304,536887296,536870912,16400,536870928,541081616,4210688,541065216,4210704,541081600,0,541065232,16,16384,541065216,4210704,16384,4194320,536887312,0,541081600,536870912,4194320,536887312],u=[2097152,69206018,67110914,0,2048,67110914,2099202,69208064,69208066,2097152,0,67108866,2,67108864,69206018,2050,67110912,2099202,2097154,67110912,67108866,69206016,69208064,2097154,69206016,2048,2050,69208066,2099200,2,67108864,2099200,67108864,2099200,2097152,67110914,67110914,69206018,69206018,2,2097154,67108864,67110912,2097152,69208064,2050,2099202,69208064,2050,67108866,69208066,69206016,2099200,0,2,69208066,0,2099202,69206016,2048,67108866,67110912,2048,2097154],a=[268439616,4096,262144,268701760,268435456,268439616,64,268435456,262208,268697600,268701760,266240,268701696,266304,4096,64,268697600,268435520,268439552,4160,266240,262208,268697664,268701696,4160,0,0,268697664,268435520,268439552,266304,262144,266304,262144,268701696,4096,64,268697664,4096,266304,268439552,64,268435520,268697600,268697664,268435456,262144,268439616,0,268701760,262208,268435520,268697600,268439552,268439616,0,268701760,266240,266240,4160,4160,262208,268435456,268701696],l=function(l,c){typeof l=="string"&&(l.length===8||l.length===24)&&(l=e.util.createBuffer(l));var h=f(l),p=1,d=0,v=0,m=0,g=0,y=!1,b=null,w=null,E=h.length===32?3:9,S;E===3?S=c?[0,32,2]:[30,-2,-2]:S=c?[0,32,2,62,30,-2,64,96,2]:[94,62,-2,32,64,2,30,-2,-2];var x=null;return x={start:function(t,n){t?(typeof t=="string"&&t.length===8&&(t=e.util.createBuffer(t)),p=1,d=t.getInt32(),m=t.getInt32()):p=0,y=!1,b=e.util.createBuffer(),w=n||e.util.createBuffer(),x.output=w},update:function(e){y||b.putBuffer(e);while(b.length()>=8){var f,l=b.getInt32(),x=b.getInt32();p===1&&(c?(l^=d,x^=m):(v=d,g=m,d=l,m=x)),f=(l>>>4^x)&252645135,x^=f,l^=f<<4,f=(l>>>16^x)&65535,x^=f,l^=f<<16,f=(x>>>2^l)&858993459,l^=f,x^=f<<2,f=(x>>>8^l)&16711935,l^=f,x^=f<<8,f=(l>>>1^x)&1431655765,x^=f,l^=f<<1,l=l<<1|l>>>31,x=x<<1|x>>>31;for(var T=0;T<E;T+=3){var N=S[T+1],C=S[T+2];for(var k=S[T];k!=N;k+=C){var L=x^h[k],A=(x>>>4|x<<28)^h[k+1];f=l,l=x,x=f^(n[L>>>24&63]|i[L>>>16&63]|o[L>>>8&63]|a[L&63]|t[A>>>24&63]|r[A>>>16&63]|s[A>>>8&63]|u[A&63])}f=l,l=x,x=f}l=l>>>1|l<<31,x=x>>>1|x<<31,f=(l>>>1^x)&1431655765,x^=f,l^=f<<1,f=(x>>>8^l)&16711935,l^=f,x^=f<<8,f=(x>>>2^l)&858993459,l^=f,x^=f<<2,f=(l>>>16^x)&65535,x^=f,l^=f<<16,f=(l>>>4^x)&252645135,x^=f,l^=f<<4,p===1&&(c?(d=l,m=x):(l^=v,x^=g)),w.putInt32(l),w.putInt32(x)}},finish:function(e){var t=!0;if(c)if(e)t=e(8,b,!c);else{var n=b.length()===8?8:8-b.length();b.fillWithByte(n,n)}t&&(y=!0,x.update());if(!c){t=b.length()===0;if(t)if(e)t=e(8,w,!c);else{var r=w.length(),i=w.at(r-1);i>r?t=!1:w.truncate(i)}}return t}},x};e.des=e.des||{},e.des.startEncrypting=function(e,t,n){var r=l(e,!0);return r.start(t,n),r},e.des.createEncryptionCipher=function(e){return l(e,!0)},e.des.startDecrypting=function(e,t,n){var r=l(e,!1);return r.start(t,n),r},e.des.createDecryptionCipher=function(e){return l(e,!1)}}var r="des";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/des",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.pkcs5=e.pkcs5||{};e.pbkdf2=t.pbkdf2=function(t,n,r,i,s){if(typeof s=="undefined"||s===null)s=e.md.sha1.create();var o=s.digestLength;if(i>4294967295*o)throw{message:"Derived key is too long."};var u=Math.ceil(i/o),a=i-(u-1)*o,f=e.hmac.create();f.start(s,t);var l="",c,h,p;for(var d=1;d<=u;++d){f.start(null,null),f.update(n),f.update(e.util.int32ToBytes(d)),c=p=f.digest().getBytes();for(var v=2;v<=r;++v)f.start(null,null),f.update(p),h=f.digest().getBytes(),c=e.util.xorBytes(c,h,o),p=h;l+=d<u?c:c.substr(0,a)}return l}}var r="pbkdf2";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pbkdf2",["require","module","./hmac","./md","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var n=typeof process!="undefined"&&process.versions&&process.versions.node,r=null;!e.disableNativeCode&&n&&(r=t("crypto"));var i=e.prng=e.prng||{};i.create=function(t){function u(e){if(n.pools[0].messageLength>=32)return f(),e();var t=32-n.pools[0].messageLength<<5;n.seedFile(t,function(t,r){if(t)return e(t);n.collect(r),f(),e()})}function a(){if(n.pools[0].messageLength>=32)return f();var e=32-n.pools[0].messageLength<<5;n.collect(n.seedFileSync(e)),f()}function f(){var t=e.md.sha1.create();t.update(n.pools[0].digest().getBytes()),n.pools[0].start();var r=1;for(var i=1;i<32;++i)r=r===31?2147483648:r<<2,r%n.reseeds===0&&(t.update(n.pools[i].digest().getBytes()),n.pools[i].start());var s=t.digest().getBytes();t.start(),t.update(s);var o=t.digest().getBytes();n.key=n.plugin.formatKey(s),n.seed=n.plugin.formatSeed(o),++n.reseeds,n.generated=0,n.time=+(new Date)}function l(t){var n=null;if(typeof window!="undefined"){var r=window.crypto||window.msCrypto;r&&r.getRandomValues&&(n=function(e){return r.getRandomValues(e)})}var i=e.util.createBuffer();if(n)while(i.length()<t){var s=Math.max(1,Math.min(t-i.length(),65536)/4),o=new Uint32Array(Math.floor(s));try{n(o);for(var u=0;u<o.length;++u)i.putInt32(o[u])}catch(a){if(!(typeof QuotaExceededError!="undefined"&&a instanceof QuotaExceededError))throw a}}if(i.length()<t){var f,l,c,h=Math.floor(Math.random()*65536);while(i.length()<t){l=16807*(h&65535),f=16807*(h>>16),l+=(f&32767)<<16,l+=f>>15,l=(l&2147483647)+(l>>31),h=l&4294967295;for(var u=0;u<3;++u)c=h>>>(u<<3),c^=Math.floor(Math.random()*256),i.putByte(String.fromCharCode(c&255))}}return i.getBytes(t)}var n={plugin:t,key:null,seed:null,time:null,reseeds:0,generated:0},i=t.md,s=new Array(32);for(var o=0;o<32;++o)s[o]=i.create();return n.pools=s,n.pool=0,n.generate=function(t,r){function l(c){if(c)return r(c);if(f.length()>=t)return r(null,f.getBytes(t));if(n.generated>=1048576){var h=+(new Date);if(n.time===null||h-n.time>100)n.key=null}if(n.key===null)return u(l);var p=i(n.key,n.seed);n.generated+=p.length,f.putBytes(p),n.key=o(i(n.key,s(n.seed))),n.seed=a(i(n.key,n.seed)),e.util.setImmediate(l)}if(!r)return n.generateSync(t);var i=n.plugin.cipher,s=n.plugin.increment,o=n.plugin.formatKey,a=n.plugin.formatSeed,f=e.util.createBuffer();l()},n.generateSync=function(t){var r=n.plugin.cipher,i=n.plugin.increment,s=n.plugin.formatKey,o=n.plugin.formatSeed,u=e.util.createBuffer();while(u.length()<t){if(n.generated>=1048576){var f=+(new Date);if(n.time===null||f-n.time>100)n.key=null}n.key===null&&a();var l=r(n.key,n.seed);n.generated+=l.length,u.putBytes(l),n.key=s(r(n.key,i(n.seed))),n.seed=o(r(n.key,n.seed))}return u.getBytes(t)},r?(n.seedFile=function(e,t){r.randomBytes(e,function(e,n){if(e)return t(e);t(null,n.toString())})},n.seedFileSync=function(e){return r.randomBytes(e).toString()}):(n.seedFile=function(e,t){try{t(null,l(e))}catch(n){t(n)}},n.seedFileSync=l),n.collect=function(e){var t=e.length;for(var r=0;r<t;++r)n.pools[n.pool].update(e.substr(r,1)),n.pool=n.pool===31?0:n.pool+1},n.collectInt=function(e,t){var r="";for(var i=0;i<t;i+=8)r+=String.fromCharCode(e>>i&255);n.collect(r)},n.registerWorker=function(e){if(e===self)n.seedFile=function(e,t){function n(e){var r=e.data;r.forge&&r.forge.prng&&(self.removeEventListener("message",n),t(r.forge.prng.err,r.forge.prng.bytes))}self.addEventListener("message",n),self.postMessage({forge:{prng:{needed:e}}})};else{function t(t){var r=t.data;r.forge&&r.forge.prng&&n.seedFile(r.forge.prng.needed,function(t,n){e.postMessage({forge:{prng:{err:t,bytes:n}}})})}e.addEventListener("message",t)}},n}}var r="prng";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/prng",["require","module","./md","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){if(e.random&&e.random.getBytes)return;(function(t){var n={},r=new Array(4),i=e.util.createBuffer();n.formatKey=function(t){var n=e.util.createBuffer(t);return t=new Array(4),t[0]=n.getInt32(),t[1]=n.getInt32(),t[2]=n.getInt32(),t[3]=n.getInt32(),e.aes._expandKey(t,!1)},n.formatSeed=function(t){var n=e.util.createBuffer(t);return t=new Array(4),t[0]=n.getInt32(),t[1]=n.getInt32(),t[2]=n.getInt32(),t[3]=n.getInt32(),t},n.cipher=function(t,n){return e.aes._updateBlock(t,n,r,!1),i.putInt32(r[0]),i.putInt32(r[1]),i.putInt32(r[2]),i.putInt32(r[3]),i.getBytes()},n.increment=function(e){return++e[3],e},n.md=e.md.sha1;var s=e.prng.create(n),o=typeof process!="undefined"&&process.versions&&process.versions.node,u=null;if(typeof window!="undefined"){var a=window.crypto||window.msCrypto;a&&a.getRandomValues&&(u=function(e){return a.getRandomValues(e)})}if(e.disableNativeCode||!o&&!u){typeof window=="undefined"||window.document===undefined,s.collectInt(+(new Date),32);if(typeof navigator!="undefined"){var f="";for(var l in navigator)try{typeof navigator[l]=="string"&&(f+=navigator[l])}catch(c){}s.collect(f),f=null}t&&(t().mousemove(function(e){s.collectInt(e.clientX,16),s.collectInt(e.clientY,16)}),t().keypress(function(e){s.collectInt(e.charCode,8)}))}if(!e.random)e.random=s;else for(var l in s)e.random[l]=s[l];e.random.getBytes=function(t,n){return e.random.generate(t,n)},e.random.getBytesSync=function(t){return e.random.generate(t)}})(typeof jQuery!="undefined"?jQuery:null)}var r="random";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/random",["require","module","./aes","./md","./prng","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=[217,120,249,196,25,221,181,237,40,233,253,121,74,160,216,157,198,126,55,131,43,118,83,142,98,76,100,136,68,139,251,162,23,154,89,245,135,179,79,19,97,69,109,141,9,129,125,50,189,143,64,235,134,183,123,11,240,149,33,34,92,107,78,130,84,214,101,147,206,96,178,28,115,86,192,20,167,140,241,220,18,117,202,31,59,190,228,209,66,61,212,48,163,60,182,38,111,191,14,218,70,105,7,87,39,242,29,155,188,148,67,3,248,17,199,246,144,239,62,231,6,195,213,47,200,102,30,215,8,232,234,222,128,82,238,247,132,170,114,172,53,77,106,42,150,26,210,113,90,21,73,116,75,159,208,94,4,24,164,236,194,224,65,110,15,81,203,204,36,145,175,80,161,244,112,57,153,124,58,133,35,184,180,122,252,2,54,91,37,85,151,49,45,93,250,152,227,138,146,174,5,223,41,16,103,108,186,201,211,0,230,207,225,158,168,44,99,22,1,63,88,226,137,169,13,56,52,27,171,51,255,176,187,72,12,95,185,177,205,46,197,243,219,71,229,165,156,119,10,166,32,104,254,127,193,173],n=[1,2,3,5],r=function(e,t){return e<<t&65535|(e&65535)>>16-t},i=function(e,t){return(e&65535)>>t|e<<16-t&65535};e.rc2=e.rc2||{},e.rc2.expandKey=function(n,r){typeof n=="string"&&(n=e.util.createBuffer(n)),r=r||128;var i=n,s=n.length(),o=r,u=Math.ceil(o/8),a=255>>(o&7),f;for(f=s;f<128;f++)i.putByte(t[i.at(f-1)+i.at(f-s)&255]);i.setAt(128-u,t[i.at(128-u)&a]);for(f=127-u;f>=0;f--)i.setAt(f,t[i.at(f+1)^i.at(f+u)]);return i};var s=function(t,s,o){var u=!1,a=null,f=null,l=null,c,h,p,d,v=[];t=e.rc2.expandKey(t,s);for(p=0;p<64;p++)v.push(t.getInt16Le());o?(c=function(e){for(p=0;p<4;p++)e[p]+=v[d]+(e[(p+3)%4]&e[(p+2)%4])+(~e[(p+3)%4]&e[(p+1)%4]),e[p]=r(e[p],n[p]),d++},h=function(e){for(p=0;p<4;p++)e[p]+=v[e[(p+3)%4]&63]}):(c=function(e){for(p=3;p>=0;p--)e[p]=i(e[p],n[p]),e[p]-=v[d]+(e[(p+3)%4]&e[(p+2)%4])+(~e[(p+3)%4]&e[(p+1)%4]),d--},h=function(e){for(p=3;p>=0;p--)e[p]-=v[e[(p+3)%4]&63]});var m=function(e){var t=[];for(p=0;p<4;p++){var n=a.getInt16Le();l!==null&&(o?n^=l.getInt16Le():l.putInt16Le(n)),t.push(n&65535)}d=o?0:63;for(var r=0;r<e.length;r++)for(var i=0;i<e[r][0];i++)e[r][1](t);for(p=0;p<4;p++)l!==null&&(o?l.putInt16Le(t[p]):t[p]^=l.getInt16Le()),f.putInt16Le(t[p])},g=null;return g={start:function(t,n){t&&typeof t=="string"&&(t=e.util.createBuffer(t)),u=!1,a=e.util.createBuffer(),f=n||new e.util.createBuffer,l=t,g.output=f},update:function(e){u||a.putBuffer(e);while(a.length()>=8)m([[5,c],[1,h],[6,c],[1,h],[5,c]])},finish:function(e){var t=!0;if(o)if(e)t=e(8,a,!o);else{var n=a.length()===8?8:8-a.length();a.fillWithByte(n,n)}t&&(u=!0,g.update());if(!o){t=a.length()===0;if(t)if(e)t=e(8,f,!o);else{var r=f.length(),i=f.at(r-1);i>r?t=!1:f.truncate(i)}}return t}},g};e.rc2.startEncrypting=function(t,n,r){var i=e.rc2.createEncryptionCipher(t,128);return i.start(n,r),i},e.rc2.createEncryptionCipher=function(e,t){return s(e,t,!0)},e.rc2.startDecrypting=function(t,n,r){var i=e.rc2.createDecryptionCipher(t,128);return i.start(n,r),i},e.rc2.createDecryptionCipher=function(e,t){return s(e,t,!1)}}var r="rc2";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/rc2",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function i(e,t,n){this.data=[],e!=null&&("number"==typeof e?this.fromNumber(e,t,n):t==null&&"string"!=typeof e?this.fromString(e,256):this.fromString(e,t))}function s(){return new i(null)}function o(e,t,n,r,i,s){while(--s>=0){var o=t*this.data[e++]+n.data[r]+i;i=Math.floor(o/67108864),n.data[r++]=o&67108863}return i}function u(e,t,n,r,i,s){var o=t&32767,u=t>>15;while(--s>=0){var a=this.data[e]&32767,f=this.data[e++]>>15,l=u*a+f*o;a=o*a+((l&32767)<<15)+n.data[r]+(i&1073741823),i=(a>>>30)+(l>>>15)+u*f+(i>>>30),n.data[r++]=a&1073741823}return i}function a(e,t,n,r,i,s){var o=t&16383,u=t>>14;while(--s>=0){var a=this.data[e]&16383,f=this.data[e++]>>14,l=u*a+f*o;a=o*a+((l&16383)<<14)+n.data[r]+i,i=(a>>28)+(l>>14)+u*f,n.data[r++]=a&268435455}return i}function d(e){return l.charAt(e)}function v(e,t){var n=c[e.charCodeAt(t)];return n==null?-1:n}function m(e){for(var t=this.t-1;t>=0;--t)e.data[t]=this.data[t];e.t=this.t,e.s=this.s}function g(e){this.t=1,this.s=e<0?-1:0,e>0?this.data[0]=e:e<-1?this.data[0]=e+this.DV:this.t=0}function y(e){var t=s();return t.fromInt(e),t}function b(e,t){var n;if(t==16)n=4;else if(t==8)n=3;else if(t==256)n=8;else if(t==2)n=1;else if(t==32)n=5;else{if(t!=4){this.fromRadix(e,t);return}n=2}this.t=0,this.s=0;var r=e.length,s=!1,o=0;while(--r>=0){var u=n==8?e[r]&255:v(e,r);if(u<0){e.charAt(r)=="-"&&(s=!0);continue}s=!1,o==0?this.data[this.t++]=u:o+n>this.DB?(this.data[this.t-1]|=(u&(1<<this.DB-o)-1)<<o,this.data[this.t++]=u>>this.DB-o):this.data[this.t-1]|=u<<o,o+=n,o>=this.DB&&(o-=this.DB)}n==8&&(e[0]&128)!=0&&(this.s=-1,o>0&&(this.data[this.t-1]|=(1<<this.DB-o)-1<<o)),this.clamp(),s&&i.ZERO.subTo(this,this)}function w(){var e=this.s&this.DM;while(this.t>0&&this.data[this.t-1]==e)--this.t}function E(e){if(this.s<0)return"-"+this.negate().toString(e);var t;if(e==16)t=4;else if(e==8)t=3;else if(e==2)t=1;else if(e==32)t=5;else{if(e!=4)return this.toRadix(e);t=2}var n=(1<<t)-1,r,i=!1,s="",o=this.t,u=this.DB-o*this.DB%t;if(o-->0){u<this.DB&&(r=this.data[o]>>u)>0&&(i=!0,s=d(r));while(o>=0)u<t?(r=(this.data[o]&(1<<u)-1)<<t-u,r|=this.data[--o]>>(u+=this.DB-t)):(r=this.data[o]>>(u-=t)&n,u<=0&&(u+=this.DB,--o)),r>0&&(i=!0),i&&(s+=d(r))}return i?s:"0"}function S(){var e=s();return i.ZERO.subTo(this,e),e}function x(){return this.s<0?this.negate():this}function T(e){var t=this.s-e.s;if(t!=0)return t;var n=this.t;t=n-e.t;if(t!=0)return this.s<0?-t:t;while(--n>=0)if((t=this.data[n]-e.data[n])!=0)return t;return 0}function N(e){var t=1,n;return(n=e>>>16)!=0&&(e=n,t+=16),(n=e>>8)!=0&&(e=n,t+=8),(n=e>>4)!=0&&(e=n,t+=4),(n=e>>2)!=0&&(e=n,t+=2),(n=e>>1)!=0&&(e=n,t+=1),t}function C(){return this.t<=0?0:this.DB*(this.t-1)+N(this.data[this.t-1]^this.s&this.DM)}function k(e,t){var n;for(n=this.t-1;n>=0;--n)t.data[n+e]=this.data[n];for(n=e-1;n>=0;--n)t.data[n]=0;t.t=this.t+e,t.s=this.s}function L(e,t){for(var n=e;n<this.t;++n)t.data[n-e]=this.data[n];t.t=Math.max(this.t-e,0),t.s=this.s}function A(e,t){var n=e%this.DB,r=this.DB-n,i=(1<<r)-1,s=Math.floor(e/this.DB),o=this.s<<n&this.DM,u;for(u=this.t-1;u>=0;--u)t.data[u+s+1]=this.data[u]>>r|o,o=(this.data[u]&i)<<n;for(u=s-1;u>=0;--u)t.data[u]=0;t.data[s]=o,t.t=this.t+s+1,t.s=this.s,t.clamp()}function O(e,t){t.s=this.s;var n=Math.floor(e/this.DB);if(n>=this.t){t.t=0;return}var r=e%this.DB,i=this.DB-r,s=(1<<r)-1;t.data[0]=this.data[n]>>r;for(var o=n+1;o<this.t;++o)t.data[o-n-1]|=(this.data[o]&s)<<i,t.data[o-n]=this.data[o]>>r;r>0&&(t.data[this.t-n-1]|=(this.s&s)<<i),t.t=this.t-n,t.clamp()}function M(e,t){var n=0,r=0,i=Math.min(e.t,this.t);while(n<i)r+=this.data[n]-e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;if(e.t<this.t){r-=e.s;while(n<this.t)r+=this.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r+=this.s}else{r+=this.s;while(n<e.t)r-=e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r-=e.s}t.s=r<0?-1:0,r<-1?t.data[n++]=this.DV+r:r>0&&(t.data[n++]=r),t.t=n,t.clamp()}function _(e,t){var n=this.abs(),r=e.abs(),s=n.t;t.t=s+r.t;while(--s>=0)t.data[s]=0;for(s=0;s<r.t;++s)t.data[s+n.t]=n.am(0,r.data[s],t,s,0,n.t);t.s=0,t.clamp(),this.s!=e.s&&i.ZERO.subTo(t,t)}function D(e){var t=this.abs(),n=e.t=2*t.t;while(--n>=0)e.data[n]=0;for(n=0;n<t.t-1;++n){var r=t.am(n,t.data[n],e,2*n,0,1);(e.data[n+t.t]+=t.am(n+1,2*t.data[n],e,2*n+1,r,t.t-n-1))>=t.DV&&(e.data[n+t.t]-=t.DV,e.data[n+t.t+1]=1)}e.t>0&&(e.data[e.t-1]+=t.am(n,t.data[n],e,2*n,0,1)),e.s=0,e.clamp()}function P(e,t,n){var r=e.abs();if(r.t<=0)return;var o=this.abs();if(o.t<r.t){t!=null&&t.fromInt(0),n!=null&&this.copyTo(n);return}n==null&&(n=s());var u=s(),a=this.s,f=e.s,l=this.DB-N(r.data[r.t-1]);l>0?(r.lShiftTo(l,u),o.lShiftTo(l,n)):(r.copyTo(u),o.copyTo(n));var c=u.t,h=u.data[c-1];if(h==0)return;var p=h*(1<<this.F1)+(c>1?u.data[c-2]>>this.F2:0),d=this.FV/p,v=(1<<this.F1)/p,m=1<<this.F2,g=n.t,y=g-c,b=t==null?s():t;u.dlShiftTo(y,b),n.compareTo(b)>=0&&(n.data[n.t++]=1,n.subTo(b,n)),i.ONE.dlShiftTo(c,b),b.subTo(u,u);while(u.t<c)u.data[u.t++]=0;while(--y>=0){var w=n.data[--g]==h?this.DM:Math.floor(n.data[g]*d+(n.data[g-1]+m)*v);if((n.data[g]+=u.am(0,w,n,y,0,c))<w){u.dlShiftTo(y,b),n.subTo(b,n);while(n.data[g]<--w)n.subTo(b,n)}}t!=null&&(n.drShiftTo(c,t),a!=f&&i.ZERO.subTo(t,t)),n.t=c,n.clamp(),l>0&&n.rShiftTo(l,n),a<0&&i.ZERO.subTo(n,n)}function H(e){var t=s();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(i.ZERO)>0&&e.subTo(t,t),t}function B(e){this.m=e}function j(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e}function F(e){return e}function I(e){e.divRemTo(this.m,null,e)}function q(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function R(e,t){e.squareTo(t),this.reduce(t)}function U(){if(this.t<1)return 0;var e=this.data[0];if((e&1)==0)return 0;var t=e&3;return t=t*(2-(e&15)*t)&15,t=t*(2-(e&255)*t)&255,t=t*(2-((e&65535)*t&65535))&65535,t=t*(2-e*t%this.DV)%this.DV,t>0?this.DV-t:-t}function z(e){this.m=e,this.mp=e.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}function W(e){var t=s();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(i.ZERO)>0&&this.m.subTo(t,t),t}function X(e){var t=s();return e.copyTo(t),this.reduce(t),t}function V(e){while(e.t<=this.mt2)e.data[e.t++]=0;for(var t=0;t<this.m.t;++t){var n=e.data[t]&32767,r=n*this.mpl+((n*this.mph+(e.data[t]>>15)*this.mpl&this.um)<<15)&e.DM;n=t+this.m.t,e.data[n]+=this.m.am(0,r,e,t,0,this.m.t);while(e.data[n]>=e.DV)e.data[n]-=e.DV,e.data[++n]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)}function $(e,t){e.squareTo(t),this.reduce(t)}function J(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function K(){return(this.t>0?this.data[0]&1:this.s)==0}function Q(e,t){if(e>4294967295||e<1)return i.ONE;var n=s(),r=s(),o=t.convert(this),u=N(e)-1;o.copyTo(n);while(--u>=0){t.sqrTo(n,r);if((e&1<<u)>0)t.mulTo(r,o,n);else{var a=n;n=r,r=a}}return t.revert(n)}function G(e,t){var n;return e<256||t.isEven()?n=new B(t):n=new z(t),this.exp(e,n)}function Y(){var e=s();return this.copyTo(e),e}function Z(){if(this.s<0){if(this.t==1)return this.data[0]-this.DV;if(this.t==0)return-1}else{if(this.t==1)return this.data[0];if(this.t==0)return 0}return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0]}function et(){return this.t==0?this.s:this.data[0]<<24>>24}function tt(){return this.t==0?this.s:this.data[0]<<16>>16}function nt(e){return Math.floor(Math.LN2*this.DB/Math.log(e))}function rt(){return this.s<0?-1:this.t<=0||this.t==1&&this.data[0]<=0?0:1}function it(e){e==null&&(e=10);if(this.signum()==0||e<2||e>36)return"0";var t=this.chunkSize(e),n=Math.pow(e,t),r=y(n),i=s(),o=s(),u="";this.divRemTo(r,i,o);while(i.signum()>0)u=(n+o.intValue()).toString(e).substr(1)+u,i.divRemTo(r,i,o);return o.intValue().toString(e)+u}function st(e,t){this.fromInt(0),t==null&&(t=10);var n=this.chunkSize(t),r=Math.pow(t,n),s=!1,o=0,u=0;for(var a=0;a<e.length;++a){var f=v(e,a);if(f<0){e.charAt(a)=="-"&&this.signum()==0&&(s=!0);continue}u=t*u+f,++o>=n&&(this.dMultiply(r),this.dAddOffset(u,0),o=0,u=0)}o>0&&(this.dMultiply(Math.pow(t,o)),this.dAddOffset(u,0)),s&&i.ZERO.subTo(this,this)}function ot(e,t,n){if("number"==typeof t)if(e<2)this.fromInt(1);else{this.fromNumber(e,n),this.testBit(e-1)||this.bitwiseTo(i.ONE.shiftLeft(e-1),dt,this),this.isEven()&&this.dAddOffset(1,0);while(!this.isProbablePrime(t))this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(i.ONE.shiftLeft(e-1),this)}else{var r=new Array,s=e&7;r.length=(e>>3)+1,t.nextBytes(r),s>0?r[0]&=(1<<s)-1:r[0]=0,this.fromString(r,256)}}function ut(){var e=this.t,t=new Array;t[0]=this.s;var n=this.DB-e*this.DB%8,r,i=0;if(e-->0){n<this.DB&&(r=this.data[e]>>n)!=(this.s&this.DM)>>n&&(t[i++]=r|this.s<<this.DB-n);while(e>=0){n<8?(r=(this.data[e]&(1<<n)-1)<<8-n,r|=this.data[--e]>>(n+=this.DB-8)):(r=this.data[e]>>(n-=8)&255,n<=0&&(n+=this.DB,--e)),(r&128)!=0&&(r|=-256),i==0&&(this.s&128)!=(r&128)&&++i;if(i>0||r!=this.s)t[i++]=r}}return t}function at(e){return this.compareTo(e)==0}function ft(e){return this.compareTo(e)<0?this:e}function lt(e){return this.compareTo(e)>0?this:e}function ct(e,t,n){var r,i,s=Math.min(e.t,this.t);for(r=0;r<s;++r)n.data[r]=t(this.data[r],e.data[r]);if(e.t<this.t){i=e.s&this.DM;for(r=s;r<this.t;++r)n.data[r]=t(this.data[r],i);n.t=this.t}else{i=this.s&this.DM;for(r=s;r<e.t;++r)n.data[r]=t(i,e.data[r]);n.t=e.t}n.s=t(this.s,e.s),n.clamp()}function ht(e,t){return e&t}function pt(e){var t=s();return this.bitwiseTo(e,ht,t),t}function dt(e,t){return e|t}function vt(e){var t=s();return this.bitwiseTo(e,dt,t),t}function mt(e,t){return e^t}function gt(e){var t=s();return this.bitwiseTo(e,mt,t),t}function yt(e,t){return e&~t}function bt(e){var t=s();return this.bitwiseTo(e,yt,t),t}function wt(){var e=s();for(var t=0;t<this.t;++t)e.data[t]=this.DM&~this.data[t];return e.t=this.t,e.s=~this.s,e}function Et(e){var t=s();return e<0?this.rShiftTo(-e,t):this.lShiftTo(e,t),t}function St(e){var t=s();return e<0?this.lShiftTo(-e,t):this.rShiftTo(e,t),t}function xt(e){if(e==0)return-1;var t=0;return(e&65535)==0&&(e>>=16,t+=16),(e&255)==0&&(e>>=8,t+=8),(e&15)==0&&(e>>=4,t+=4),(e&3)==0&&(e>>=2,t+=2),(e&1)==0&&++t,t}function Tt(){for(var e=0;e<this.t;++e)if(this.data[e]!=0)return e*this.DB+xt(this.data[e]);return this.s<0?this.t*this.DB:-1}function Nt(e){var t=0;while(e!=0)e&=e-1,++t;return t}function Ct(){var e=0,t=this.s&this.DM;for(var n=0;n<this.t;++n)e+=Nt(this.data[n]^t);return e}function kt(e){var t=Math.floor(e/this.DB);return t>=this.t?this.s!=0:(this.data[t]&1<<e%this.DB)!=0}function Lt(e,t){var n=i.ONE.shiftLeft(e);return this.bitwiseTo(n,t,n),n}function At(e){return this.changeBit(e,dt)}function Ot(e){return this.changeBit(e,yt)}function Mt(e){return this.changeBit(e,mt)}function _t(e,t){var n=0,r=0,i=Math.min(e.t,this.t);while(n<i)r+=this.data[n]+e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;if(e.t<this.t){r+=e.s;while(n<this.t)r+=this.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r+=this.s}else{r+=this.s;while(n<e.t)r+=e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r+=e.s}t.s=r<0?-1:0,r>0?t.data[n++]=r:r<-1&&(t.data[n++]=this.DV+r),t.t=n,t.clamp()}function Dt(e){var t=s();return this.addTo(e,t),t}function Pt(e){var t=s();return this.subTo(e,t),t}function Ht(e){var t=s();return this.multiplyTo(e,t),t}function Bt(e){var t=s();return this.divRemTo(e,t,null),t}function jt(e){var t=s();return this.divRemTo(e,null,t),t}function Ft(e){var t=s(),n=s();return this.divRemTo(e,t,n),new Array(t,n)}function It(e){this.data[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()}function qt(e,t){if(e==0)return;while(this.t<=t)this.data[this.t++]=0;this.data[t]+=e;while(this.data[t]>=this.DV)this.data[t]-=this.DV,++t>=this.t&&(this.data[this.t++]=0),++this.data[t]}function Rt(){}function Ut(e){return e}function zt(e,t,n){e.multiplyTo(t,n)}function Wt(e,t){e.squareTo(t)}function Xt(e){return this.exp(e,new Rt)}function Vt(e,t,n){var r=Math.min(this.t+e.t,t);n.s=0,n.t=r;while(r>0)n.data[--r]=0;var i;for(i=n.t-this.t;r<i;++r)n.data[r+this.t]=this.am(0,e.data[r],n,r,0,this.t);for(i=Math.min(e.t,t);r<i;++r)this.am(0,e.data[r],n,r,0,t-r);n.clamp()}function $t(e,t,n){--t;var r=n.t=this.t+e.t-t;n.s=0;while(--r>=0)n.data[r]=0;for(r=Math.max(t-this.t,0);r<e.t;++r)n.data[this.t+r-t]=this.am(t-r,e.data[r],n,0,0,this.t+r-t);n.clamp(),n.drShiftTo(1,n)}function Jt(e){this.r2=s(),this.q3=s(),i.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e),this.m=e}function Kt(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;var t=s();return e.copyTo(t),this.reduce(t),t}function Qt(e){return e}function Gt(e){e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(e.compareTo(this.r2)<0)e.dAddOffset(1,this.m.t+1);e.subTo(this.r2,e);while(e.compareTo(this.m)>=0)e.subTo(this.m,e)}function Yt(e,t){e.squareTo(t),this.reduce(t)}function Zt(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function en(e,t){var n=e.bitLength(),r,i=y(1),o;if(n<=0)return i;n<18?r=1:n<48?r=3:n<144?r=4:n<768?r=5:r=6,n<8?o=new B(t):t.isEven()?o=new Jt(t):o=new z(t);var u=new Array,a=3,f=r-1,l=(1<<r)-1;u[1]=o.convert(this);if(r>1){var c=s();o.sqrTo(u[1],c);while(a<=l)u[a]=s(),o.mulTo(c,u[a-2],u[a]),a+=2}var h=e.t-1,p,d=!0,v=s(),m;n=N(e.data[h])-1;while(h>=0){n>=f?p=e.data[h]>>n-f&l:(p=(e.data[h]&(1<<n+1)-1)<<f-n,h>0&&(p|=e.data[h-1]>>this.DB+n-f)),a=r;while((p&1)==0)p>>=1,--a;(n-=a)<0&&(n+=this.DB,--h);if(d)u[p].copyTo(i),d=!1;else{while(a>1)o.sqrTo(i,v),o.sqrTo(v,i),a-=2;a>0?o.sqrTo(i,v):(m=i,i=v,v=m),o.mulTo(v,u[p],i)}while(h>=0&&(e.data[h]&1<<n)==0)o.sqrTo(i,v),m=i,i=v,v=m,--n<0&&(n=this.DB-1,--h)}return o.revert(i)}function tn(e){var t=this.s<0?this.negate():this.clone(),n=e.s<0?e.negate():e.clone();if(t.compareTo(n)<0){var r=t;t=n,n=r}var i=t.getLowestSetBit(),s=n.getLowestSetBit();if(s<0)return t;i<s&&(s=i),s>0&&(t.rShiftTo(s,t),n.rShiftTo(s,n));while(t.signum()>0)(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),(i=n.getLowestSetBit())>0&&n.rShiftTo(i,n),t.compareTo(n)>=0?(t.subTo(n,t),t.rShiftTo(1,t)):(n.subTo(t,n),n.rShiftTo(1,n));return s>0&&n.lShiftTo(s,n),n}function nn(e){if(e<=0)return 0;var t=this.DV%e,n=this.s<0?e-1:0;if(this.t>0)if(t==0)n=this.data[0]%e;else for(var r=this.t-1;r>=0;--r)n=(t*n+this.data[r])%e;return n}function rn(e){var t=e.isEven();if(this.isEven()&&t||e.signum()==0)return i.ZERO;var n=e.clone(),r=this.clone(),s=y(1),o=y(0),u=y(0),a=y(1);while(n.signum()!=0){while(n.isEven()){n.rShiftTo(1,n);if(t){if(!s.isEven()||!o.isEven())s.addTo(this,s),o.subTo(e,o);s.rShiftTo(1,s)}else o.isEven()||o.subTo(e,o);o.rShiftTo(1,o)}while(r.isEven()){r.rShiftTo(1,r);if(t){if(!u.isEven()||!a.isEven())u.addTo(this,u),a.subTo(e,a);u.rShiftTo(1,u)}else a.isEven()||a.subTo(e,a);a.rShiftTo(1,a)}n.compareTo(r)>=0?(n.subTo(r,n),t&&s.subTo(u,s),o.subTo(a,o)):(r.subTo(n,r),t&&u.subTo(s,u),a.subTo(o,a))}return r.compareTo(i.ONE)!=0?i.ZERO:a.compareTo(e)>=0?a.subtract(e):a.signum()<0?(a.addTo(e,a),a.signum()<0?a.add(e):a):a}function un(e){var t,n=this.abs();if(n.t==1&&n.data[0]<=sn[sn.length-1]){for(t=0;t<sn.length;++t)if(n.data[0]==sn[t])return!0;return!1}if(n.isEven())return!1;t=1;while(t<sn.length){var r=sn[t],i=t+1;while(i<sn.length&&r<on)r*=sn[i++];r=n.modInt(r);while(t<i)if(r%sn[t++]==0)return!1}return n.millerRabin(e)}function an(e){var t=this.subtract(i.ONE),n=t.getLowestSetBit();if(n<=0)return!1;var r=t.shiftRight(n),s=fn(),o;for(var u=0;u<e;++u){do o=new i(this.bitLength(),s);while(o.compareTo(i.ONE)<=0||o.compareTo(t)>=0);var a=o.modPow(r,this);if(a.compareTo(i.ONE)!=0&&a.compareTo(t)!=0){var f=1;while(f++<n&&a.compareTo(t)!=0){a=a.modPowInt(2,this);if(a.compareTo(i.ONE)==0)return!1}if(a.compareTo(t)!=0)return!1}}return!0}function fn(){return{nextBytes:function(e){for(var t=0;t<e.length;++t)e[t]=Math.floor(Math.random()*255)}}}var t,n=0xdeadbeefcafe,r=(n&16777215)==15715070;typeof navigator=="undefined"?(i.prototype.am=a,t=28):r&&navigator.appName=="Microsoft Internet Explorer"?(i.prototype.am=u,t=30):r&&navigator.appName!="Netscape"?(i.prototype.am=o,t=26):(i.prototype.am=a,t=28),i.prototype.DB=t,i.prototype.DM=(1<<t)-1,i.prototype.DV=1<<t;var f=52;i.prototype.FV=Math.pow(2,f),i.prototype.F1=f-t,i.prototype.F2=2*t-f;var l="0123456789abcdefghijklmnopqrstuvwxyz",c=new Array,h,p;h="0".charCodeAt(0);for(p=0;p<=9;++p)c[h++]=p;h="a".charCodeAt(0);for(p=10;p<36;++p)c[h++]=p;h="A".charCodeAt(0);for(p=10;p<36;++p)c[h++]=p;B.prototype.convert=j,B.prototype.revert=F,B.prototype.reduce=I,B.prototype.mulTo=q,B.prototype.sqrTo=R,z.prototype.convert=W,z.prototype.revert=X,z.prototype.reduce=V,z.prototype.mulTo=J,z.prototype.sqrTo=$,i.prototype.copyTo=m,i.prototype.fromInt=g,i.prototype.fromString=b,i.prototype.clamp=w,i.prototype.dlShiftTo=k,i.prototype.drShiftTo=L,i.prototype.lShiftTo=A,i.prototype.rShiftTo=O,i.prototype.subTo=M,i.prototype.multiplyTo=_,i.prototype.squareTo=D,i.prototype.divRemTo=P,i.prototype.invDigit=U,i.prototype.isEven=K,i.prototype.exp=Q,i.prototype.toString=E,i.prototype.negate=S,i.prototype.abs=x,i.prototype.compareTo=T,i.prototype.bitLength=C,i.prototype.mod=H,i.prototype.modPowInt=G,i.ZERO=y(0),i.ONE=y(1),Rt.prototype.convert=Ut,Rt.prototype.revert=Ut,Rt.prototype.mulTo=zt,Rt.prototype.sqrTo=Wt,Jt.prototype.convert=Kt,Jt.prototype.revert=Qt,Jt.prototype.reduce=Gt,Jt.prototype.mulTo=Zt,Jt.prototype.sqrTo=Yt;var sn=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509],on=(1<<26)/sn[sn.length-1];i.prototype.chunkSize=nt,i.prototype.toRadix=it,i.prototype.fromRadix=st,i.prototype.fromNumber=ot,i.prototype.bitwiseTo=ct,i.prototype.changeBit=Lt,i.prototype.addTo=_t,i.prototype.dMultiply=It,i.prototype.dAddOffset=qt,i.prototype.multiplyLowerTo=Vt,i.prototype.multiplyUpperTo=$t,i.prototype.modInt=nn,i.prototype.millerRabin=an,i.prototype.clone=Y,i.prototype.intValue=Z,i.prototype.byteValue=et,i.prototype.shortValue=tt,i.prototype.signum=rt,i.prototype.toByteArray=ut,i.prototype.equals=at,i.prototype.min=ft,i.prototype.max=lt,i.prototype.and=pt,i.prototype.or=vt,i.prototype.xor=gt,i.prototype.andNot=bt,i.prototype.not=wt,i.prototype.shiftLeft=Et,i.prototype.shiftRight=St,i.prototype.getLowestSetBit=Tt,i.prototype.bitCount=Ct,i.prototype.testBit=kt,i.prototype.setBit=At,i.prototype.clearBit=Ot,i.prototype.flipBit=Mt,i.prototype.add=Dt,i.prototype.subtract=Pt,i.prototype.multiply=Ht,i.prototype.divide=Bt,i.prototype.remainder=jt,i.prototype.divideAndRemainder=Ft,i.prototype.modPow=en,i.prototype.modInverse=rn,i.prototype.pow=Xt,i.prototype.gcd=tn,i.prototype.isProbablePrime=un,e.jsbn=e.jsbn||{},e.jsbn.BigInteger=i}var r="jsbn";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/jsbn",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(e,t,n){var r="",i=Math.ceil(t/n.digestLength);for(var s=0;s<i;++s){var o=String.fromCharCode(s>>24&255,s>>16&255,s>>8&255,s&255);n.start(),n.update(e+o),r+=n.digest().getBytes()}return r.substring(0,t)}var t=e.pkcs1=e.pkcs1||{};t.encode_rsa_oaep=function(t,r,i){var s=undefined,o=undefined,u=undefined;typeof i=="string"?(s=i,o=arguments[3]||undefined,u=arguments[4]||undefined):i&&(s=i.label||undefined,o=i.seed||undefined,u=i.md||undefined),u?u.start():u=e.md.sha1.create();var a=Math.ceil(t.n.bitLength()/8),f=a-2*u.digestLength-2;if(r.length>f)throw{message:"RSAES-OAEP input message length is too long.",length:r.length,maxLength:f};s||(s=""),u.update(s,"raw");var l=u.digest(),c="",h=f-r.length;for(var p=0;p<h;p++)c+="\0";var d=l.getBytes()+c+""+r;if(!o)o=e.random.getBytes(u.digestLength);else if(o.length!==u.digestLength)throw{message:"Invalid RSAES-OAEP seed. The seed length must match the digest length.",seedLength:o.length,digestLength:u.digestLength};var v=n(o,a-u.digestLength-1,u),m=e.util.xorBytes(d,v,d.length),g=n(m,u.digestLength,u),y=e.util.xorBytes(o,g,o.length);return"\0"+y+m},t.decode_rsa_oaep=function(t,r,i){var s=undefined,o=undefined;typeof i=="string"?(s=i,o=arguments[3]||undefined):i&&(s=i.label||undefined,o=i.md||undefined);var u=Math.ceil(t.n.bitLength()/8);if(r.length!==u)throw{message:"RSAES-OAEP encoded message length is invalid.",length:r.length,expectedLength:u};o===undefined?o=e.md.sha1.create():o.start();if(u<2*o.digestLength+2)throw{message:"RSAES-OAEP key is too short for the hash function."};s||(s=""),o.update(s,"raw");var a=o.digest().getBytes(),f=r.charAt(0),l=r.substring(1,o.digestLength+1),c=r.substring(1+o.digestLength),h=n(c,o.digestLength,o),p=e.util.xorBytes(l,h,l.length),d=n(p,u-o.digestLength-1,o),v=e.util.xorBytes(c,d,c.length),m=v.substring(0,o.digestLength),g=f!=="\0";for(var y=0;y<o.digestLength;++y)g|=a.charAt(y)!==m.charAt(y);var b=1,w=o.digestLength;for(var E=o.digestLength;E<v.length;E++){var S=v.charCodeAt(E),x=S&1^1,T=b?65534:0;g|=S&T,b&=x,w+=b}if(g||v.charCodeAt(w)!==1)throw{message:"Invalid RSAES-OAEP padding."};return v.substring(w+1)}}var r="pkcs1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs1",["require","module","./util","./random","./sha1"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function c(t,n,r){var i=e.util.createBuffer(),s=Math.ceil(n.n.bitLength()/8);if(t.length>s-11)throw{message:"Message is too long for PKCS#1 v1.5 padding.",length:t.length,max:s-11};i.putByte(0),i.putByte(r);var o=s-3-t.length,u;if(r===0||r===1){u=r===0?0:255;for(var a=0;a<o;++a)i.putByte(u)}else while(o>0){var f=0,l=e.random.getBytes(o);for(var a=0;a<o;++a)u=l.charCodeAt(a),u===0?++f:i.putByte(u);o=f}return i.putByte(0),i.putBytes(t),i}function h(t,n,r,i){var s=Math.ceil(n.n.bitLength()/8),o=e.util.createBuffer(t),u=o.getByte(),a=o.getByte();if(u!==0||r&&a!==0&&a!==1||!r&&a!=2||r&&a===0&&typeof i=="undefined")throw{message:"Encryption block is invalid."};var f=0;if(a===0){f=s-3-i;for(var l=0;l<f;++l)if(o.getByte()!==0)throw{message:"Encryption block is invalid."}}else if(a===1){f=0;while(o.length()>1){if(o.getByte()!==255){--o.read;break}++f}}else if(a===2){f=0;while(o.length()>1){if(o.getByte()===0){--o.read;break}++f}}var c=o.getByte();if(c!==0||f!==s-3-o.length())throw{message:"Encryption block is invalid."};return o.getBytes()}function p(n,i,s){function p(){d(n.pBits,function(e,t){if(e)return s(e);n.p=t,d(n.qBits,v)})}function d(e,r){function p(){var r=e-1,i=new t(e,n.rng);return i.testBit(r)||i.bitwiseTo(t.ONE.shiftLeft(r),h,i),i.dAddOffset(31-i.mod(c).byteValue(),0),i}function v(s){if(d)return;--o;var u=s.data;if(u.found){for(var c=0;c<i.length;++c)i[c].terminate();return d=!0,r(null,new t(u.prime,16))}l.bitLength()>e&&(l=p());var h=l.toString(16);s.target.postMessage({e:n.eInt,hex:h,workLoad:a}),l.dAddOffset(f,0)}var i=[];for(var s=0;s<u;++s)i[s]=new Worker("./forge/prime.worker.js");var o=u,l=p();for(var s=0;s<u;++s)i[s].addEventListener("message",v);var d=!1}function v(e,i){n.q=i;if(n.p.compareTo(n.q)<0){var o=n.p;n.p=n.q,n.q=o}n.p1=n.p.subtract(t.ONE),n.q1=n.q.subtract(t.ONE),n.phi=n.p1.multiply(n.q1);if(n.phi.gcd(n.e).compareTo(t.ONE)!==0){n.p=n.q=null,p();return}n.n=n.p.multiply(n.q);if(n.n.bitLength()!==n.bits){n.q=null,d(n.qBits,v);return}var u=n.e.modInverse(n.phi);n.keys={privateKey:r.rsa.setPrivateKey(n.n,n.e,u,n.p,n.q,u.mod(n.p1),u.mod(n.q1),n.q.modInverse(n.p)),publicKey:r.rsa.setPublicKey(n.n,n.e)},s(null,n.keys)}typeof i=="function"&&(s=i,i={});if(typeof Worker=="undefined"){function o(){if(r.rsa.stepKeyPairGenerationState(n,10))return s(null,n.keys);e.util.setImmediate(o)}return o()}var u=i.workers||2,a=i.workLoad||100,f=a*30/8,l=i.workerScript||"forge/prime.worker.js",c=new t(null);c.fromInt(30);var h=function(e,t){return e|t};p()}function d(t){var n=t.toString(16);return n[0]>="8"&&(n="00"+n),e.util.hexToBytes(n)}function v(e){return e<=100?27:e<=150?18:e<=200?15:e<=250?12:e<=300?9:e<=350?8:e<=400?7:e<=500?6:e<=600?5:e<=800?4:e<=1250?3:2}if(typeof t=="undefined")var t=e.jsbn.BigInteger;var n=e.asn1;e.pki=e.pki||{},e.pki.rsa=e.rsa=e.rsa||{};var r=e.pki,i=[6,4,2,4,2,4,6,2],s={name:"PrivateKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PrivateKeyInfo.version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"PrivateKeyInfo.privateKeyAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"privateKeyOid"}]},{name:"PrivateKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"privateKey"}]},o={name:"RSAPrivateKey",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPrivateKey.version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"RSAPrivateKey.modulus",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyModulus"},{name:"RSAPrivateKey.publicExponent",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPublicExponent"},{name:"RSAPrivateKey.privateExponent",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPrivateExponent"},{name:"RSAPrivateKey.prime1",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPrime1"},{name:"RSAPrivateKey.prime2",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPrime2"},{name:"RSAPrivateKey.exponent1",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyExponent1"},{name:"RSAPrivateKey.exponent2",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyExponent2"},{name:"RSAPrivateKey.coefficient",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyCoefficient"}]},u={name:"RSAPublicKey",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPublicKey.modulus",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"publicKeyModulus"},{name:"RSAPublicKey.exponent",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"publicKeyExponent"}]},a=e.pki.rsa.publicKeyValidator={name:"SubjectPublicKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"subjectPublicKeyInfo",value:[{name:"SubjectPublicKeyInfo.AlgorithmIdentifier",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"publicKeyOid"}]},{name:"SubjectPublicKeyInfo.subjectPublicKey",tagClass:n.Class.UNIVERSAL,type:n.Type.BITSTRING,constructed:!1,value:[{name:"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"rsaPublicKey"}]}]},f=function(e){var t;if(e.algorithm in r.oids){t=r.oids[e.algorithm];var i=n.oidToDer(t).getBytes(),s=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]),o=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]);o.value.push(n.create(n.Class.UNIVERSAL,n.Type.OID,!1,i)),o.value.push(n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,""));var u=n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,e.digest().getBytes());return s.value.push(o),s.value.push(u),n.toDer(s).getBytes()}throw{message:"Unknown message digest algorithm.",algorithm:e.algorithm}},l=function(e,n,r){var i;if(r)i=e.modPow(n.e,n.n);else if(!n.p||!n.q)i=e.modPow(n.d,n.n);else{n.dP||(n.dP=n.d.mod(n.p.subtract(t.ONE))),n.dQ||(n.dQ=n.d.mod(n.q.subtract(t.ONE))),n.qInv||(n.qInv=n.q.modInverse(n.p));var s=e.mod(n.p).modPow(n.dP,n.p),o=e.mod(n.q).modPow(n.dQ,n.q);while(s.compareTo(o)<0)s=s.add(n.p);i=s.subtract(o).multiply(n.qInv).mod(n.p).multiply(n.q).add(o)}return i};r.rsa.encrypt=function(n,r,i){var s=i,o,u=Math.ceil(r.n.bitLength()/8);i!==!1&&i!==!0?(s=i===2,o=c(n,r,i)):(o=e.util.createBuffer(),o.putBytes(n));var a=new t(o.toHex(),16),f=l(a,r,s),h=f.toString(16),p=e.util.createBuffer(),d=u-Math.ceil(h.length/2);while(d>0)p.putByte(0),--d;return p.putBytes(e.util.hexToBytes(h)),p.getBytes()},r.rsa.decrypt=function(n,r,i,s){var o=Math.ceil(r.n.bitLength()/8);if(n.length!==o)throw{message:"Encrypted message length is invalid.",length:n.length,expected:o};var u=new t(e.util.createBuffer(n).toHex(),16);if(u.compareTo(r.n)>=0)throw{message:"Encrypted message is invalid."};var a=l(u,r,i),f=a.toString(16),c=e.util.createBuffer(),p=o-Math.ceil(f.length/2);while(p>0)c.putByte(0),--p;return c.putBytes(e.util.hexToBytes(f)),s!==!1?h(c.getBytes(),r,i):c.getBytes()},r.rsa.createKeyPairGenerationState=function(n,r){typeof n=="string"&&(n=parseInt(n,10)),n=n||2048;var i={nextBytes:function(t){var n=e.random.getBytes(t.length);for(var r=0;r<t.length;++r)t[r]=n.charCodeAt(r)}},s={state:0,bits:n,rng:i,eInt:r||65537,e:new t(null),p:null,q:null,qBits:n>>1,pBits:n-(n>>1),pqState:0,num:null,keys:null};return s.e.fromInt(s.eInt),s},r.rsa.stepKeyPairGenerationState=function(e,n){var s=new t(null);s.fromInt(30);var o=0,u=function(e,t){return e|t},a=+(new Date),f,l=0;while(e.keys===null&&(n<=0||l<n)){if(e.state===0){var c=e.p===null?e.pBits:e.qBits,h=c-1;e.pqState===0?(e.num=new t(c,e.rng),e.num.testBit(h)||e.num.bitwiseTo(t.ONE.shiftLeft(h),u,e.num),e.num.dAddOffset(31-e.num.mod(s).byteValue(),0),o=0,++e.pqState):e.pqState===1?e.num.bitLength()>c?e.pqState=0:e.num.isProbablePrime(v(e.num.bitLength()))?++e.pqState:e.num.dAddOffset(i[o++%8],0):e.pqState===2?e.pqState=e.num.subtract(t.ONE).gcd(e.e).compareTo(t.ONE)===0?3:0:e.pqState===3&&(e.pqState=0,e.p===null?e.p=e.num:e.q=e.num,e.p!==null&&e.q!==null&&++e.state,e.num=null)}else if(e.state===1)e.p.compareTo(e.q)<0&&(e.num=e.p,e.p=e.q,e.q=e.num),++e.state;else if(e.state===2)e.p1=e.p.subtract(t.ONE),e.q1=e.q.subtract(t.ONE),e.phi=e.p1.multiply(e.q1),++e.state;else if(e.state===3)e.phi.gcd(e.e).compareTo(t.ONE)===0?++e.state:(e.p=null,e.q=null,e.state=0);else if(e.state===4)e.n=e.p.multiply(e.q),e.n.bitLength()===e.bits?++e.state:(e.q=null,e.state=0);else if(e.state===5){var p=e.e.modInverse(e.phi);e.keys={privateKey:r.rsa.setPrivateKey(e.n,e.e,p,e.p,e.q,p.mod(e.p1),p.mod(e.q1),e.q.modInverse(e.p)),publicKey:r.rsa.setPublicKey(e.n,e.e)}}f=+(new Date),l+=f-a,a=f}return e.keys!==null},r.rsa.generateKeyPair=function(e,t,n,i){arguments.length===1?typeof e=="object"?(n=e,e=undefined):typeof e=="function"&&(i=e,e=undefined):arguments.length===2?(typeof e=="number"?typeof t=="function"?i=t:n=t:(n=e,i=t,e=undefined),t=undefined):arguments.length===3&&(typeof t=="number"?typeof n=="function"&&(i=n,n=undefined):(i=n,n=t,t=undefined)),n=n||{},e===undefined&&(e=n.bits||2048),t===undefined&&(t=n.e||65537);var s=r.rsa.createKeyPairGenerationState(e,t);if(!i)return r.rsa.stepKeyPairGenerationState(s,0),s.keys;p(s,n,i)},r.setRsaPublicKey=r.rsa.setPublicKey=function(t,i){var s={n:t,e:i};return s.encrypt=function(t,n,i){typeof n=="string"?n=n.toUpperCase():n===undefined&&(n="RSAES-PKCS1-V1_5");if(n==="RSAES-PKCS1-V1_5")n={encode:function(e,t,n){return c(e,t,2).getBytes()}};else if(n==="RSA-OAEP"||n==="RSAES-OAEP")n={encode:function(t,n){return e.pkcs1.encode_rsa_oaep(n,t,i)}};else{if(["RAW","NONE","NULL",null].indexOf(n)===-1)throw{message:'Unsupported encryption scheme: "'+n+'".'};n={encode:function(e){return e}}}var o=n.encode(t,s,!0);return r.rsa.encrypt(o,s,!0)},s.verify=function(e,t,i){typeof i=="string"?i=i.toUpperCase():i===undefined&&(i="RSASSA-PKCS1-V1_5");if(i==="RSASSA-PKCS1-V1_5")i={verify:function(e,t){t=h(t,s,!0);var r=n.fromDer(t);return e===r.value[1].value}};else if(i==="NONE"||i==="NULL"||i===null)i={verify:function(e,t){return t=h(t,s,!0),e===t}};var o=r.rsa.decrypt(t,s,!0,!1);return i.verify(e,o,s.n.bitLength())},s},r.setRsaPrivateKey=r.rsa.setPrivateKey=function(t,n,i,s,o,u,a,l){var c={n:t,e:n,d:i,p:s,q:o,dP:u,dQ:a,qInv:l};return c.decrypt=function(t,n,i){typeof n=="string"?n=n.toUpperCase():n===undefined&&(n="RSAES-PKCS1-V1_5");var s=r.rsa.decrypt(t,c,!1,!1);if(n==="RSAES-PKCS1-V1_5")n={decode:h};else if(n==="RSA-OAEP"||n==="RSAES-OAEP")n={decode:function(t,n){return e.pkcs1.decode_rsa_oaep(n,t,i)}};else{if(["RAW","NONE","NULL",null].indexOf(n)===-1)throw{message:'Unsupported encryption scheme: "'+n+'".'};n={decode:function(e){return e}}}return n.decode(s,c,!1)},c.sign=function(e,t){var n=!1;typeof t=="string"&&(t=t.toUpperCase());if(t===undefined||t==="RSASSA-PKCS1-V1_5")t={encode:f},n=1;else if(t==="NONE"||t==="NULL"||t===null)t={encode:function(){return e}},n=1;var i=t.encode(e,c.n.bitLength());return r.rsa.encrypt(i,c,n)},c},r.wrapRsaPrivateKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(0).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(r.oids.rsaEncryption).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]),n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,n.toDer(e).getBytes())])},r.wrapRsaPrivateKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(0).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(r.oids.rsaEncryption).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]),n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,n.toDer(e).getBytes())])},r.privateKeyFromAsn1=function(i){var u={},a=[];n.validate(i,s,u,a)&&(i=n.fromDer(e.util.createBuffer(u.privateKey))),u={},a=[];if(!n.validate(i,o,u,a))throw{message:"Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.",errors:a};var f,l,c,h,p,d,v,m;return f=e.util.createBuffer(u.privateKeyModulus).toHex(),l=e.util.createBuffer(u.privateKeyPublicExponent).toHex(),c=e.util.createBuffer(u.privateKeyPrivateExponent).toHex(),h=e.util.createBuffer(u.privateKeyPrime1).toHex(),p=e.util.createBuffer(u.privateKeyPrime2).toHex(),d=e.util.createBuffer(u.privateKeyExponent1).toHex(),v=e.util.createBuffer(u.privateKeyExponent2).toHex(),m=e.util.createBuffer(u.privateKeyCoefficient).toHex(),r.setRsaPrivateKey(new t(f,16),new t(l,16),new t(c,16),new t(h,16),new t(p,16),new t(d,16),new t(v,16),new t(m,16))},r.privateKeyToAsn1=r.privateKeyToRSAPrivateKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(0).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.n)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.e)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.d)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.p)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.q)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.dP)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.dQ)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.qInv))])},r.publicKeyFromAsn1=function(i){var s={},o=[];if(n.validate(i,a,s,o)){var f=n.derToOid(s.publicKeyOid);if(f!==r.oids.rsaEncryption)throw{message:"Cannot read public key. Unknown OID.",oid:f};i=s.rsaPublicKey}o=[];if(!n.validate(i,u,s,o))throw{message:"Cannot read public key. ASN.1 object does not contain an RSAPublicKey.",errors:o};var l=e.util.createBuffer(s.publicKeyModulus).toHex(),c=e.util.createBuffer(s.publicKeyExponent).toHex();return r.setRsaPublicKey(new t(l,16),new t(c,16))},r.publicKeyToAsn1=r.publicKeyToSubjectPublicKeyInfo=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(r.oids.rsaEncryption).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]),n.create(n.Class.UNIVERSAL,n.Type.BITSTRING,!1,[r.publicKeyToRSAPublicKey(e)])])},r.publicKeyToRSAPublicKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.n)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.e))])}}var r="rsa";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/rsa",["require","module","./asn1","./oids","./random","./util","./jsbn","./pkcs1"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function a(e,t,n){var r=[f(e+t)];for(var i=16,s=1;i<n;++s,i+=16)r.push(f(r[s-1]+e+t));return r.join("").substr(0,n)}function f(t){return e.md.md5.create().update(t).digest().getBytes()}if(typeof t=="undefined")var t=e.jsbn.BigInteger;var n=e.asn1,r=e.pki=e.pki||{};r.pbe=e.pbe=e.pbe||{};var i=r.oids,s={name:"EncryptedPrivateKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedPrivateKeyInfo.encryptionAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"encryptionOid"},{name:"AlgorithmIdentifier.parameters",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"encryptionParams"}]},{name:"EncryptedPrivateKeyInfo.encryptedData",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"encryptedData"}]},o={name:"PBES2Algorithms",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc.oid",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"kdfOid"},{name:"PBES2Algorithms.params",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.params.salt",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"kdfSalt"},{name:"PBES2Algorithms.params.iterationCount",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,onstructed:!0,capture:"kdfIterationCount"}]}]},{name:"PBES2Algorithms.encryptionScheme",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.encryptionScheme.oid",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"encOid"},{name:"PBES2Algorithms.encryptionScheme.iv",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"encIv"}]}]},u={name:"pkcs-12PbeParams",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"pkcs-12PbeParams.salt",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"salt"},{name:"pkcs-12PbeParams.iterations",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"iterations"}]};r.encryptPrivateKeyInfo=function(t,s,o){o=o||{},o.saltSize=o.saltSize||8,o.count=o.count||2048,o.algorithm=o.algorithm||"aes128";var u=e.random.getBytes(o.saltSize),a=o.count,f=n.integerToDer(a),l,c,h;if(o.algorithm.indexOf("aes")===0){var p;if(o.algorithm==="aes128")l=16,p=i["aes128-CBC"];else if(o.algorithm==="aes192")l=24,p=i["aes192-CBC"];else{if(o.algorithm!=="aes256")throw{message:"Cannot encrypt private key. Unknown encryption algorithm.",algorithm:o.algorithm};l=32,p=i["aes256-CBC"]}var d=e.pkcs5.pbkdf2(s,u,a,l),v=e.random.getBytes(16),m=e.aes.createEncryptionCipher(d);m.start(v),m.update(n.toDer(t)),m.finish(),h=m.output.getBytes(),c=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(i.pkcs5PBES2).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(i.pkcs5PBKDF2).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,u),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,f.getBytes())])]),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(p).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,v)])])])}else{if(o.algorithm!=="3des")throw{message:"Cannot encrypt private key. Unknown encryption algorithm.",algorithm:o.algorithm};l=24;var g=new e.util.ByteBuffer(u),d=r.pbe.generatePkcs12Key(s,g,1,a,l),v=r.pbe.generatePkcs12Key(s,g,2,a,l),m=e.des.createEncryptionCipher(d);m.start(v),m.update(n.toDer(t)),m.finish(),h=m.output.getBytes(),c=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(i["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,u),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,f.getBytes())])])}var y=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[c,n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,h)]);return y},r.decryptPrivateKeyInfo=function(t,i){var o=null,u={},a=[];if(!n.validate(t,s,u,a))throw{message:"Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",errors:a};var f=n.derToOid(u.encryptionOid),l=r.pbe.getCipher(f,u.encryptionParams,i),c=e.util.createBuffer(u.encryptedData);return l.update(c),l.finish()&&(o=n.fromDer(l.output)),o},r.encryptedPrivateKeyToPem=function(t,r){var i={type:"ENCRYPTED PRIVATE KEY",body:n.toDer(t).getBytes()};return e.pem.encode(i,{maxline:r})},r.encryptedPrivateKeyFromPem=function(t){var r=e.pem.decode(t)[0];if(r.type!=="ENCRYPTED PRIVATE KEY")throw{message:'Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".',headerType:r.type};if(r.procType&&r.procType.type==="ENCRYPTED")throw{message:"Could not convert encrypted private key from PEM; PEM is encrypted."};return n.fromDer(r.body)},r.encryptRsaPrivateKey=function(t,i,s){s=s||{};if(!s.legacy){var o=r.wrapRsaPrivateKey(r.privateKeyToAsn1(t));return o=r.encryptPrivateKeyInfo(o,i,s),r.encryptedPrivateKeyToPem(o)}var u,f,l,c;switch(s.algorithm){case"aes128":u="AES-128-CBC",l=16,f=e.random.getBytes(16),c=e.aes.createEncryptionCipher;break;case"aes192":u="AES-192-CBC",l=24,f=e.random.getBytes(16),c=e.aes.createEncryptionCipher;break;case"aes256":u="AES-256-CBC",l=32,f=e.random.getBytes(16),c=e.aes.createEncryptionCipher;break;case"3des":u="DES-EDE3-CBC",l=24,f=e.random.getBytes(8),c=e.des.createEncryptionCipher;break;default:throw{message:'Could not encrypt RSA private key; unsupported encryption algorithm "'+s.algorithm+'".',algorithm:s.algorithm}}var h=a(i,f.substr(0,8),l),p=c(h);p.start(f),p.update(n.toDer(r.privateKeyToAsn1(t))),p.finish();var d={type:"RSA PRIVATE KEY",procType:{version:"4",type:"ENCRYPTED"},dekInfo:{algorithm:u,parameters:e.util.bytesToHex(f).toUpperCase()},body:p.output.getBytes()};return e.pem.encode(d)},r.decryptRsaPrivateKey=function(t,i){var s=null,o=e.pem.decode(t)[0];if(o.type!=="ENCRYPTED PRIVATE KEY"&&o.type!=="PRIVATE KEY"&&o.type!=="RSA PRIVATE KEY")throw{message:'Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".',headerType:o.type};if(o.procType&&o.procType.type==="ENCRYPTED"){var u,f;switch(o.dekInfo.algorithm){case"DES-EDE3-CBC":u=24,f=e.des.createDecryptionCipher;break;case"AES-128-CBC":u=16,f=e.aes.createDecryptionCipher;break;case"AES-192-CBC":u=24,f=e.aes.createDecryptionCipher;break;case"AES-256-CBC":u=32,f=e.aes.createDecryptionCipher;break;case"RC2-40-CBC":u=5,f=function(t){return e.rc2.createDecryptionCipher(t,40)};break;case"RC2-64-CBC":u=8,f=function(t){return e.rc2.createDecryptionCipher(t,64)};break;case"RC2-128-CBC":u=16,f=function(t){return e.rc2.createDecryptionCipher(t,128)};break;default:throw{message:'Could not decrypt private key; unsupported encryption algorithm "'+o.dekInfo.algorithm+'".',algorithm:o.dekInfo.algorithm}}var l=e.util.hexToBytes(o.dekInfo.parameters),c=a(i,l.substr(0,8),u),h=f(c);h.start(l),h.update(e.util.createBuffer(o.body));if(!h.finish())return s;s=h.output.getBytes()}else s=o.body;return o.type==="ENCRYPTED PRIVATE KEY"?s=r.decryptPrivateKeyInfo(n.fromDer(s),i):s=n.fromDer(s),s!==null&&(s=r.privateKeyFromAsn1(s)),s},r.pbe.generatePkcs12Key=function(t,n,r,i,s,o){var u,a;if(typeof o=="undefined"||o===null)o=e.md.sha1.create();var f=o.digestLength,l=o.blockLength,c=new e.util.ByteBuffer,h=new e.util.ByteBuffer;for(a=0;a<t.length;a++)h.putInt16(t.charCodeAt(a));h.putInt16(0);var p=h.length(),d=n.length(),v=new e.util.ByteBuffer;v.fillWithByte(r,l);var m=l*Math.ceil(d/l),g=new e.util.ByteBuffer;for(a=0;a<m;a++)g.putByte(n.at(a%d));var y=l*Math.ceil(p/l),b=new e.util.ByteBuffer;for(a=0;a<y;a++)b.putByte(h.at(a%p));var w=g;w.putBuffer(b);var E=Math.ceil(s/f);for(var S=1;S<=E;S++){var x=new e.util.ByteBuffer;x.putBytes(v.bytes()),x.putBytes(w.bytes());for(var T=0;T<i;T++)o.start(),o.update(x.getBytes()),x=o.digest();var N=new e.util.ByteBuffer;for(a=0;a<l;a++)N.putByte(x.at(a%f));var C=Math.ceil(d/l)+Math.ceil(p/l),k=new e.util.ByteBuffer;for(u=0;u<C;u++){var L=new e.util.ByteBuffer(w.getBytes(l)),A=511;for(a=N.length()-1;a>=0;a--)A>>=8,A+=N.at(a)+L.at(a),L.setAt(a,A&255);k.putBuffer(L)}w=k,c.putBuffer(x)}return c.truncate(c.length()-s),c},r.pbe.getCipher=function(e,t,n){switch(e){case r.oids.pkcs5PBES2:return r.pbe.getCipherForPBES2(e,t,n);case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:case r.oids["pbewithSHAAnd40BitRC2-CBC"]:return r.pbe.getCipherForPKCS12PBE(e,t,n);default:throw{message:"Cannot read encrypted PBE data block. Unsupported OID.",oid:e,supportedOids:["pkcs5PBES2","pbeWithSHAAnd3-KeyTripleDES-CBC","pbewithSHAAnd40BitRC2-CBC"]}}},r.pbe.getCipherForPBES2=function(t,i,s){var u={},a=[];if(!n.validate(i,o,u,a))throw{message:"Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",errors:a};t=n.derToOid(u.kdfOid);if(t!==r.oids.pkcs5PBKDF2)throw{message:"Cannot read encrypted private key. Unsupported key derivation function OID.",oid:t,supportedOids:["pkcs5PBKDF2"]};t=n.derToOid(u.encOid);if(t!==r.oids["aes128-CBC"]&&t!==r.oids["aes192-CBC"]&&t!==r.oids["aes256-CBC"])throw{message:"Cannot read encrypted private key. Unsupported encryption scheme OID.",oid:t,supportedOids:["aes128-CBC","aes192-CBC","aes256-CBC"]};var f=u.kdfSalt,l=e.util.createBuffer(u.kdfIterationCount);l=l.getInt(l.length()<<3);var c;t===r.oids["aes128-CBC"]?c=16:t===r.oids["aes192-CBC"]?c=24:t===r.oids["aes256-CBC"]&&(c=32);var h=e.pkcs5.pbkdf2(s,f,l,c),p=u.encIv,d=e.aes.createDecryptionCipher(h);return d.start(p),d},r.pbe.getCipherForPKCS12PBE=function(t,i,s){var o={},a=[];if(!n.validate(i,u,o,a))throw{message:"Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",errors:a};var f=e.util.createBuffer(o.salt),l=e.util.createBuffer(o.iterations);l=l.getInt(l.length()<<3);var c,h,p;switch(t){case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:c=24,h=8,p=e.des.startDecrypting;break;case r.oids["pbewithSHAAnd40BitRC2-CBC"]:c=5,h=8,p=function(t,n){var r=e.rc2.createDecryptionCipher(t,40);return r.start(n,null),r};break;default:throw{message:"Cannot read PKCS #12 PBE data block. Unsupported OID.",oid:t}}var d=r.pbe.generatePkcs12Key(s,f,1,l,c),v=r.pbe.generatePkcs12Key(s,f,2,l,h);return p(d,v)}}var r="pbe";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pbe",["require","module","./aes","./asn1","./des","./md","./oids","./pem","./pbkdf2","./random","./rc2","./rsa","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1,n=e.pkcs7asn1=e.pkcs7asn1||{};e.pkcs7=e.pkcs7||{},e.pkcs7.asn1=n;var r={name:"ContentInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.ContentType",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,captureAsn1:"content"}]};n.contentInfoValidator=r;var i={name:"EncryptedContentInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentType",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"contentType"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm.parameter",tagClass:t.Class.UNIVERSAL,captureAsn1:"encParameter"}]},{name:"EncryptedContentInfo.encryptedContent",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,capture:"encryptedContent"}]};n.envelopedDataValidator={name:"EnvelopedData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EnvelopedData.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},{name:"EnvelopedData.RecipientInfos",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,captureAsn1:"recipientInfos"}].concat(i)},n.encryptedDataValidator={name:"EncryptedData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedData.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"}].concat(i)};var s={name:"SignerInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1},{name:"SignerInfo.IssuerAndSerialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0},{name:"SignerInfo.DigestAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0},{name:"SignerInfo.AuthenticatedAttributes",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"authenticatedAttributes"},{name:"SignerInfo.DigestEncryptionAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0},{name:"SignerInfo.EncryptedDigest",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"signature"},{name:"SignerInfo.UnauthenticatedAttributes",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0}]};n.signedDataValidator={name:"SignedData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SignedData.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},{name:"SignedData.DigestAlgorithms",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,captureAsn1:"digestAlgorithms"},r,{name:"SignedData.Certificates",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,optional:!0,captureAsn1:"certificates"},{name:"SignedData.CertificateRevocationLists",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,optional:!0,captureAsn1:"crls"},{name:"SignedData.SignerInfos",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,capture:"signerInfos",optional:!0,value:[s]}]},n.recipientInfoValidator={name:"RecipientInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},{name:"RecipientInfo.issuerAndSerial",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.issuerAndSerial.issuer",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"issuer"},{name:"RecipientInfo.issuerAndSerial.serialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"serial"}]},{name:"RecipientInfo.keyEncryptionAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.keyEncryptionAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"RecipientInfo.keyEncryptionAlgorithm.parameter",tagClass:t.Class.UNIVERSAL,constructed:!1,captureAsn1:"encParameter"}]},{name:"RecipientInfo.encryptedKey",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"encKey"}]}}var r="pkcs7asn1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs7asn1",["require","module","./asn1","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.mgf=e.mgf||{};var t=e.mgf.mgf1=e.mgf1=e.mgf1||{};t.create=function(t){var n={generate:function(n,r){var i=new e.util.ByteBuffer,s=Math.ceil(r/t.digestLength);for(var o=0;o<s;o++){var u=new e.util.ByteBuffer;u.putInt32(o),t.start(),t.update(n+u.getBytes()),i.putBuffer(t.digest())}return i.truncate(i.length()-r),i.getBytes()}};return n}}var r="mgf1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/mgf1",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.mgf=e.mgf||{},e.mgf.mgf1=e.mgf1}var r="mgf";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/mgf",["require","module","./mgf1"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.pss=e.pss||{};t.create=function(t,n,r){var i=t.digestLength,s={};return s.verify=function(s,o,u){var a,f=u-1,l=Math.ceil(f/8);o=o.substr(-l);if(l<i+r+2)throw{message:"Inconsistent parameters to PSS signature verification."};if(o.charCodeAt(l-1)!==188)throw{message:"Encoded message does not end in 0xBC."};var c=l-i-1,h=o.substr(0,c),p=o.substr(c,i),d=65280>>8*l-f&255;if((h.charCodeAt(0)&d)!==0)throw{message:"Bits beyond keysize not zero as expected."};var v=n.generate(p,c),m="";for(a=0;a<c;a++)m+=String.fromCharCode(h.charCodeAt(a)^v.charCodeAt(a));m=String.fromCharCode(m.charCodeAt(0)&~d)+m.substr(1);var g=l-i-r-2;for(a=0;a<g;a++)if(m.charCodeAt(a)!==0)throw{message:"Leftmost octets not zero as expected"};if(m.charCodeAt(g)!==1)throw{message:"Inconsistent PSS signature, 0x01 marker not found"};var y=m.substr(-r),b=new e.util.ByteBuffer;b.fillWithByte(0,8),b.putBytes(s),b.putBytes(y),t.start(),t.update(b.getBytes());var w=t.digest().getBytes();return p===w},s.encode=function(s,o){var u,a=o-1,f=Math.ceil(a/8),l=s.digest().getBytes();if(f<i+r+2)throw{message:"Message is too long to encrypt"};var c=e.random.getBytes(r),h=new e.util.ByteBuffer;h.fillWithByte(0,8),h.putBytes(l),h.putBytes(c),t.start(),t.update(h.getBytes());var p=t.digest().getBytes(),d=new e.util.ByteBuffer;d.fillWithByte(0,f-r-i-2),d.putByte(1),d.putBytes(c);var v=d.getBytes(),m=f-i-1,g=n.generate(p,m),y="";for(u=0;u<m;u++)y+=String.fromCharCode(v.charCodeAt(u)^g.charCodeAt(u));var b=65280>>8*f-a&255;return y=String.fromCharCode(y.charCodeAt(0)&~b)+y.substr(1),y+p+String.fromCharCode(188)},s}}var r="pss";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pss",["require","module","./random","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function l(e,t){typeof t=="string"&&(t={shortName:t});var n=null,r;for(var i=0;n===null&&i<e.attributes.length;++i)r=e.attributes[i],t.type&&t.type===r.type?n=r:t.name&&t.name===r.name?n=r:t.shortName&&t.shortName===r.shortName&&(n=r);return n}function p(n){var r=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]),i,s,o=n.attributes;for(var u=0;u<o.length;++u){i=o[u];var a=i.value,f=t.Type.PRINTABLESTRING;"valueTagClass"in i&&(f=i.valueTagClass,f===t.Type.UTF8&&(a=e.util.encodeUtf8(a))),s=t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(i.type).getBytes()),t.create(t.Class.UNIVERSAL,f,!1,a)])]),r.value.push(s)}return r}function d(e){var n=t.create(t.Class.CONTEXT_SPECIFIC,3,!0,[]),r=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);n.value.push(r);var i,s;for(var o=0;o<e.length;++o){i=e[o],s=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]),r.value.push(s),s.value.push(t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(i.id).getBytes())),i.critical&&s.value.push(t.create(t.Class.UNIVERSAL,t.Type.BOOLEAN,!1,String.fromCharCode(255)));var u=i.value;typeof i.value!="string"&&(u=t.toDer(u).getBytes()),s.value.push(t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,u))}return n}function v(n){var r={};for(var i=0;i<n.length;++i){var s=n[i];console.log("attr",s);if(s.shortName&&(s.valueTagClass===t.Type.UTF8||s.valueTagClass===t.Type.PRINTABLESTRING||s.valueTagClass===t.Type.IA5String)){var o=s.value;s.valueTagClass===t.Type.UTF8&&(o=e.util.encodeUtf8(s.value)),s.shortName in r?e.util.isArray(r[s.shortName])?r[s.shortName].push(o):r[s.shortName]=[r[s.shortName],o]:r[s.shortName]=o}}return r}function m(e){var t;for(var r=0;r<e.length;++r){t=e[r],typeof t.name=="undefined"&&(t.type&&t.type in n.oids?t.name=n.oids[t.type]:t.shortName&&t.shortName in i&&(t.name=n.oids[i[t.shortName]]));if(typeof t.type=="undefined"){if(!(t.name&&t.name in n.oids))throw{message:"Attribute type not specified.",attribute:t};t.type=n.oids[t.name]}typeof t.shortName=="undefined"&&t.name&&t.name in i&&(t.shortName=i[t.name]);if(typeof t.value=="undefined")throw{message:"Attribute value not specified.",attribute:t}}}function g(e,n){switch(e){case r["RSASSA-PSS"]:var i=[];return n.hash.algorithmOid!==undefined&&i.push(t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.hash.algorithmOid).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")])])),n.mgf.algorithmOid!==undefined&&i.push(t.create(t.Class.CONTEXT_SPECIFIC,1,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.mgf.algorithmOid).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.mgf.hash.algorithmOid).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")])])])),n.saltLength!==undefined&&i.push(t.create(t.Class.CONTEXT_SPECIFIC,2,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(n.saltLength).getBytes())])),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,i);default:return t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")}}function y(n){var r=t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[]);if(n.attributes.length===0)return r;var i=n.attributes;for(var s=0;s<i.length;++s){var o=i[s],u=o.value,a=t.Type.UTF8;"valueTagClass"in o&&(a=o.valueTagClass),a===t.Type.UTF8&&(u=e.util.encodeUtf8(u));var f=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(o.type).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,a,!1,u)])]);r.value.push(f)}return r}var t=e.asn1,n=e.pki=e.pki||{},r=n.oids,i={};i.CN=r.commonName,i.commonName="CN",i.C=r.countryName,i.countryName="C",i.L=r.localityName,i.localityName="L",i.ST=r.stateOrProvinceName,i.stateOrProvinceName="ST",i.O=r.organizationName,i.organizationName="O",i.OU=r.organizationalUnitName,i.organizationalUnitName="OU",i.E=r.emailAddress,i.emailAddress="E";var s=e.pki.rsa.publicKeyValidator,o={name:"Certificate",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"tbsCertificate",value:[{name:"Certificate.TBSCertificate.version",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.version.integer",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"certVersion"}]},{name:"Certificate.TBSCertificate.serialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"certSerialNumber"},{name:"Certificate.TBSCertificate.signature",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.signature.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"certinfoSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:t.Class.UNIVERSAL,optional:!0,captureAsn1:"certinfoSignatureParams"}]},{name:"Certificate.TBSCertificate.issuer",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certIssuer"},{name:"Certificate.TBSCertificate.validity",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.validity.notBefore (utc)",tagClass:t.Class.UNIVERSAL,type:t.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity1UTCTime"},{name:"Certificate.TBSCertificate.validity.notBefore (generalized)",tagClass:t.Class.UNIVERSAL,type:t.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity2GeneralizedTime"},{name:"Certificate.TBSCertificate.validity.notAfter (utc)",tagClass:t.Class.UNIVERSAL,type:t.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity3UTCTime"},{name:"Certificate.TBSCertificate.validity.notAfter (generalized)",tagClass:t.Class.UNIVERSAL,type:t.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity4GeneralizedTime"}]},{name:"Certificate.TBSCertificate.subject",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certSubject"},s,{name:"Certificate.TBSCertificate.issuerUniqueID",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.issuerUniqueID.id",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"certIssuerUniqueId"}]},{name:"Certificate.TBSCertificate.subjectUniqueID",tagClass:t.Class.CONTEXT_SPECIFIC,type:2,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.subjectUniqueID.id",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"certSubjectUniqueId"}]},{name:"Certificate.TBSCertificate.extensions",tagClass:t.Class.CONTEXT_SPECIFIC,type:3,constructed:!0,captureAsn1:"certExtensions",optional:!0}]},{name:"Certificate.signatureAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.signatureAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"certSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:t.Class.UNIVERSAL,optional:!0,captureAsn1:"certSignatureParams"}]},{name:"Certificate.signatureValue",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"certSignature"}]},u={name:"rsapss",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.hashAlgorithm",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier",tagClass:t.Class.UNIVERSAL,type:t.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"hashOid"}]}]},{name:"rsapss.maskGenAlgorithm",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier",tagClass:t.Class.UNIVERSAL,type:t.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"maskGenOid"},{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"maskGenHashOid"}]}]}]},{name:"rsapss.saltLength",tagClass:t.Class.CONTEXT_SPECIFIC,type:2,optional:!0,value:[{name:"rsapss.saltLength.saltLength",tagClass:t.Class.UNIVERSAL,type:t.Class.INTEGER,constructed:!1,capture:"saltLength"}]},{name:"rsapss.trailerField",tagClass:t.Class.CONTEXT_SPECIFIC,type:3,optional:!0,value:[{name:"rsapss.trailer.trailer",tagClass:t.Class.UNIVERSAL,type:t.Class.INTEGER,constructed:!1,capture:"trailer"}]}]},a={name:"CertificationRequestInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfo",value:[{name:"CertificationRequestInfo.integer",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"certificationRequestInfoVersion"},{name:"CertificationRequestInfo.subject",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfoSubject"},s,{name:"CertificationRequestInfo.attributes",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"certificationRequestInfoAttributes",value:[{name:"CertificationRequestInfo.attributes",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequestInfo.attributes.type",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1},{name:"CertificationRequestInfo.attributes.value",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0}]}]}]},f={name:"CertificationRequest",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"csr",value:[a,{name:"CertificationRequest.signatureAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequest.signatureAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"csrSignatureOid"},{name:"CertificationRequest.signatureAlgorithm.parameters",tagClass:t.Class.UNIVERSAL,optional:!0,captureAsn1:"csrSignatureParams"}]},{name:"CertificationRequest.signature",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"csrSignature"}]};n.RDNAttributesAsArray=function(e,n){var s=[],o,u,a;for(var f=0;f<e.value.length;++f){o=e.value[f];for(var l=0;l<o.value.length;++l)a={},u=o.value[l],a.type=t.derToOid(u.value[0].value),a.value=u.value[1].value,a.valueTagClass=u.value[1].type,a.type in r&&(a.name=r[a.type],a.name in i&&(a.shortName=i[a.name])),n&&(n.update(a.type),n.update(a.value)),s.push(a)}return s},n.CRIAttributesAsArray=function(e){var n=[];for(var s=0;s<e.length;++s){var o=e[s],u=t.derToOid(o.value[0].value),a=o.value[1].value;for(var f=0;f<a.length;++f){var l={};l.type=u,l.value=a[f].value,l.valueTagClass=a[f].type,l.type in r&&(l.name=r[l.type],l.name in i&&(l.shortName=i[l.name])),n.push(l)}}return n};var c=function(n){var i=[],s,o,u;for(var a=0;a<n.value.length;++a){u=n.value[a];for(var f=0;f<u.value.length;++f){o=u.value[f],s={},s.id=t.derToOid(o.value[0].value),s.critical=!1,o.value[1].type===t.Type.BOOLEAN?(s.critical=o.value[1].value.charCodeAt(0)!==0,s.value=o.value[2].value):s.value=o.value[1].value;if(s.id in r){s.name=r[s.id];if(s.name==="keyUsage"){var l=t.fromDer(s.value),c=0,h=0;l.value.length>1&&(c=l.value.charCodeAt(1),h=l.value.length>2?l.value.charCodeAt(2):0),s.digitalSignature=(c&128)===128,s.nonRepudiation=(c&64)===64,s.keyEncipherment=(c&32)===32,s.dataEncipherment=(c&16)===16,s.keyAgreement=(c&8)===8,s.keyCertSign=(c&4)===4,s.cRLSign=(c&2)===2,s.encipherOnly=(c&1)===1,s.decipherOnly=(h&128)===128}else if(s.name==="basicConstraints"){var l=t.fromDer(s.value);l.value.length>0&&l.value[0].type===t.Type.BOOLEAN?s.cA=l.value[0].value.charCodeAt(0)!==0:s.cA=!1;var p=null;l.value.length>0&&l.value[0].type===t.Type.INTEGER?p=l.value[0].value:l.value.length>1&&(p=l.value[1].value),p!==null&&(s.pathLenConstraint=t.derToInteger(p))}else if(s.name==="extKeyUsage"){var l=t.fromDer(s.value);for(var d=0;d<l.value.length;++d){var v=t.derToOid(l.value[d].value);v in r?s[r[v]]=!0:s[v]=!0}}else if(s.name==="nsCertType"){var l=t.fromDer(s.value),c=0;l.value.length>1&&(c=l.value.charCodeAt(1)),s.client=(c&128)===128,s.server=(c&64)===64,s.email=(c&32)===32,s.objsign=(c&16)===16,s.reserved=(c&8)===8,s.sslCA=(c&4)===4,s.emailCA=(c&2)===2,s.objCA=(c&1)===1}else if(s.name==="subjectAltName"||s.name==="issuerAltName"){s.altNames=[];var m,l=t.fromDer(s.value);for(var g=0;g<l.value.length;++g){m=l.value[g];var y={type:m.type,value:m.value};s.altNames.push(y);switch(m.type){case 1:case 2:case 6:break;case 7:y.ip=e.util.bytesToIP(m.value);break;case 8:y.oid=t.derToOid(m.value);break;default:}}}else if(s.name==="subjectKeyIdentifier"){var l=t.fromDer(s.value);s.subjectKeyIdentifier=e.util.bytesToHex(l.value)}}i.push(s)}}return i},h=function(e,n,i){var s={};if(e!==r["RSASSA-PSS"])return s;i&&(s={hash:{algorithmOid:r.sha1},mgf:{algorithmOid:r.mgf1,hash:{algorithmOid:r.sha1}},saltLength:20});var o={},a=[];if(!t.validate(n,u,o,a))throw{message:"Cannot read RSASSA-PSS parameter block.",errors:a};return o.hashOid!==undefined&&(s.hash=s.hash||{},s.hash.algorithmOid=t.derToOid(o.hashOid)),o.maskGenOid!==undefined&&(s.mgf=s.mgf||{},s.mgf.algorithmOid=t.derToOid(o.maskGenOid),s.mgf.hash=s.mgf.hash||{},s.mgf.hash.algorithmOid=t.derToOid(o.maskGenHashOid)),o.saltLength!==undefined&&(s.saltLength=o.saltLength.charCodeAt(0)),s};n.certificateFromPem=function(r,i,s){var o=e.pem.decode(r)[0];if(o.type!=="CERTIFICATE"&&o.type!=="X509 CERTIFICATE"&&o.type!=="TRUSTED CERTIFICATE")throw{message:'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',headerType:o.type};if(o.procType&&o.procType.type==="ENCRYPTED")throw{message:"Could not convert certificate from PEM; PEM is encrypted."};var u=t.fromDer(o.body,s);return n.certificateFromAsn1(u,i)},n.certificateToPem=function(r,i){var s={type:"CERTIFICATE",body:t.toDer(n.certificateToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.publicKeyFromPem=function(r){var i=e.pem.decode(r)[0];if(i.type!=="PUBLIC KEY"&&i.type!=="RSA PUBLIC KEY")throw{message:'Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".',headerType:i.type};if(i.procType&&i.procType.type==="ENCRYPTED")throw{message:"Could not convert public key from PEM; PEM is encrypted."};var s=t.fromDer(i.body);return n.publicKeyFromAsn1(s)},n.publicKeyToPem=function(r,i){var s={type:"PUBLIC KEY",body:t.toDer(n.publicKeyToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.publicKeyToRSAPublicKeyPem=function(r,i){var s={type:"RSA PUBLIC KEY",body:t.toDer(n.publicKeyToRSAPublicKey(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.certificationRequestFromPem=function(r,i,s){var o=e.pem.decode(r)[0];if(o.type!=="CERTIFICATE REQUEST")throw{message:'Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".',headerType:o.type};if(o.procType&&o.procType.type==="ENCRYPTED")throw{message:"Could not convert certification request from PEM; PEM is encrypted."};var u=t.fromDer(o.body,s);return n.certificationRequestFromAsn1(u,i)},n.certificationRequestToPem=function(r,i){var s={type:"CERTIFICATE REQUEST",body:t.toDer(n.certificationRequestToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.createCertificate=function(){var i={};return i.version=2,i.serialNumber="00",i.signatureOid=null,i.signature=null,i.siginfo={},i.siginfo.algorithmOid=null,i.validity={},i.validity.notBefore=new Date,i.validity.notAfter=new Date,i.issuer={},i.issuer.getField=function(e){return l(i.issuer,e)},i.issuer.addField=function(e){m([e]),i.issuer.attributes.push(e)},i.issuer.attributes=[],i.issuer.hash=null,i.subject={},i.subject.getField=function(e){return l(i.subject,e)},i.subject.addField=function(e){m([e]),i.subject.attributes.push(e)},i.subject.attributes=[],i.subject.hash=null,i.extensions=[],i.publicKey=null,i.md=null,i.setSubject=function(e,t){m(e),i.subject.attributes=e,delete i.subject.uniqueId,t&&(i.subject.uniqueId=t),i.subject.hash=null},i.setIssuer=function(e,t){m(e),i.issuer.attributes=e,delete i.issuer.uniqueId,t&&(i.issuer.uniqueId=t),i.issuer.hash=null},i.setExtensions=function(s){var o;for(var u=0;u<s.length;++u){o=s[u],typeof o.name=="undefined"&&o.id&&o.id in n.oids&&(o.name=n.oids[o.id]);if(typeof o.id=="undefined"){if(!(o.name&&o.name in n.oids))throw{message:"Extension ID not specified.",extension:o};o.id=n.oids[o.name]}if(typeof o.value=="undefined"){if(o.name==="keyUsage"){var a=0,f=0,l=0;o.digitalSignature&&(f|=128,a=7),o.nonRepudiation&&(f|=64,a=6),o.keyEncipherment&&(f|=32,a=5),o.dataEncipherment&&(f|=16,a=4),o.keyAgreement&&(f|=8,a=3),o.keyCertSign&&(f|=4,a=2),o.cRLSign&&(f|=2,a=1),o.encipherOnly&&(f|=1,a=0),o.decipherOnly&&(l|=128,a=7);var c=String.fromCharCode(a);l!==0?c+=String.fromCharCode(f)+String.fromCharCode(l):f!==0&&(c+=String.fromCharCode(f)),o.value=t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,c)}else if(o.name==="basicConstraints")o.value=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]),o.cA&&o.value.value.push(t.create(t.Class.UNIVERSAL,t.Type.BOOLEAN,!1,String.fromCharCode(255))),"pathLenConstraint"in o&&o.value.value.push(t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(o.pathLenConstraint).getBytes()));else if(o.name==="extKeyUsage"){o.value=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);var h=o.value.value;for(var p in o){if(o[p]!==!0)continue;p in r?h.push(t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r[p]).getBytes())):p.indexOf(".")!==-1&&h.push(t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(p).getBytes()))}}else if(o.name==="nsCertType"){var a=0,f=0;o.client&&(f|=128,a=7),o.server&&(f|=64,a=6),o.email&&(f|=32,a=5),o.objsign&&(f|=16,a=4),o.reserved&&(f|=8,a=3),o.sslCA&&(f|=4,a=2),o.emailCA&&(f|=2,a=1),o.objCA&&(f|=1,a=0);var c=String.fromCharCode(a);f!==0&&(c+=String.fromCharCode(f)),o.value=t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,c)}else if(o.name==="subjectAltName"||o.name==="issuerAltName"){o.value=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);var d;for(var v=0;v<o.altNames.length;++v){d=o.altNames[v];var c=d.value;if(d.type===7&&d.ip){c=e.util.bytesFromIP(d.ip);if(c===null)throw{message:'Extension "ip" value is not a valid IPv4 or IPv6 address.',extension:o}}else d.type===8&&(d.oid?c=t.oidToDer(t.oidToDer(d.oid)):c=t.oidToDer(c));o.value.value.push(t.create(t.Class.CONTEXT_SPECIFIC,d.type,!1,c))}}else if(o.name==="subjectKeyIdentifier"){var m=i.generateSubjectKeyIdentifier();o.subjectKeyIdentifier=m.toHex(),o.value=t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,m.getBytes())}if(typeof o.value=="undefined")throw{message:"Extension value not specified.",extension:o}}}i.extensions=s},i.getExtension=function(e){typeof e=="string"&&(e={name:e});var t=null,n;for(var r=0;t===null&&r<i.extensions.length;++r)n=i.extensions[r],e.id&&n.id===e.id?t=n:e.name&&n.name===e.name&&(t=n);return t},i.sign=function(s,o){i.md=o||e.md.sha1.create();var u=r[i.md.algorithm+"WithRSAEncryption"];if(!u)throw{message:"Could not compute certificate digest. Unknown message digest algorithm OID.",algorithm:i.md.algorithm};i.signatureOid=i.siginfo.algorithmOid=u,i.tbsCertificate=n.getTBSCertificate(i);var a=t.toDer(i.tbsCertificate);i.md.update(a.getBytes()),i.signature=s.sign(i.md)},i.verify=function(s){var o=!1;if(!i.issued(s)){var u=s.issuer,a=i.subject;throw{message:"The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.",expectedIssuer:u.attributes,actualIssuer:a.attributes}}var f=s.md;if(f===null){if(s.signatureOid in r){var l=r[s.signatureOid];switch(l){case"sha1WithRSAEncryption":f=e.md.sha1.create();break;case"md5WithRSAEncryption":f=e.md.md5.create();break;case"sha256WithRSAEncryption":f=e.md.sha256.create();break;case"RSASSA-PSS":f=e.md.sha256.create()}}if(f===null)throw{message:"Could not compute certificate digest. Unknown signature OID.",signatureOid:s.signatureOid};var c=s.tbsCertificate||n.getTBSCertificate(s),h=t.toDer(c);f.update(h.getBytes())}if(f!==null){var p=undefined;switch(s.signatureOid){case r.sha1WithRSAEncryption:p=undefined;break;case r["RSASSA-PSS"]:var d,v;d=r[s.signatureParameters.mgf.hash.algorithmOid];if(d===undefined||e.md[d]===undefined)throw{message:"Unsupported MGF hash function.",oid:s.signatureParameters.mgf.hash.algorithmOid,name:d};v=r[s.signatureParameters.mgf.algorithmOid];if(v===undefined||e.mgf[v]===undefined)throw{message:"Unsupported MGF function.",oid:s.signatureParameters.mgf.algorithmOid,name:v};v=e.mgf[v].create(e.md[d].create()),d=r[s.signatureParameters.hash.algorithmOid];if(d===undefined||e.md[d]===undefined)throw{message:"Unsupported RSASSA-PSS hash function.",oid:s.signatureParameters.hash.algorithmOid,name:d};p=e.pss.create(e.md[d].create(),v,s.signatureParameters.saltLength)}o=i.publicKey.verify(f.digest().getBytes(),s.signature,p)}return o},i.isIssuer=function(e){var t=!1,n=i.issuer,r=e.subject;if(n.hash&&r.hash)t=n.hash===r.hash;else if(n.attributes.length===r.attributes.length){t=!0;var s,o;for(var u=0;t&&u<n.attributes.length;++u){s=n.attributes[u],o=r.attributes[u];if(s.type!==o.type||s.value!==o.value)t=!1}}return t},i.issued=function(e){return e.isIssuer(i)},i.generateSubjectKeyIdentifier=function(){var r=t.toDer(n.publicKeyToRSAPublicKey(i.publicKey)),s=e.md.sha1.create();return s.update(r.getBytes()),s.digest()},i.verifySubjectKeyIdentifier=function(){var t=r.subjectKeyIdentifier;for(var n=0;n<i.extensions.length;++n){var s=i.extensions[n];if(s.id===t){var o=i.generateSubjectKeyIdentifier().getBytes();return e.util.hexToBytes(s.subjectKeyIdentifier)===o}}return!1},i},n.certificateFromAsn1=function(i,s){var u={},a=[];if(!t.validate(i,o,u,a))throw{message:"Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.",errors:a};if(typeof u.certSignature!="string"){var f="\0";for(var p=0;p<u.certSignature.length;++p)f+=t.toDer(u.certSignature[p]).getBytes();u.certSignature=f}var d=t.derToOid(u.publicKeyOid);if(d!==n.oids.rsaEncryption)throw{message:"Cannot read public key. OID is not RSA."};var v=n.createCertificate();v.version=u.certVersion?u.certVersion.charCodeAt(0):0;var g=e.util.createBuffer(u.certSerialNumber);v.serialNumber=g.toHex(),v.signatureOid=e.asn1.derToOid(u.certSignatureOid),v.signatureParameters=h(v.signatureOid,u.certSignatureParams,!0),v.siginfo.algorithmOid=e.asn1.derToOid(u.certinfoSignatureOid),v.siginfo.parameters=h(v.siginfo.algorithmOid,u.certinfoSignatureParams,!1);var y=e.util.createBuffer(u.certSignature);++y.read,v.signature=y.getBytes();var b=[];u.certValidity1UTCTime!==undefined&&b.push(t.utcTimeToDate(u.certValidity1UTCTime)),u.certValidity2GeneralizedTime!==undefined&&b.push(t.generalizedTimeToDate(u.certValidity2GeneralizedTime)),u.certValidity3UTCTime!==undefined&&b.push(t.utcTimeToDate(u.certValidity3UTCTime)),u.certValidity4GeneralizedTime!==undefined&&b.push(t.generalizedTimeToDate(u.certValidity4GeneralizedTime));if(b.length>2)throw{message:"Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate."};if(b.length<2)throw{message:"Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime."};v.validity.notBefore=b[0],v.validity.notAfter=b[1],v.tbsCertificate=u.tbsCertificate;if(s){v.md=null;if(v.signatureOid in r){var d=r[v.signatureOid];switch(d){case"sha1WithRSAEncryption":v.md=e.md.sha1.create();break;case"md5WithRSAEncryption":v.md=e.md.md5.create();break;case"sha256WithRSAEncryption":v.md=e.md.sha256.create();break;case"RSASSA-PSS":v.md=e.md.sha256.create()}}if(v.md===null)throw{message:"Could not compute certificate digest. Unknown signature OID.",signatureOid:v.signatureOid};var w=t.toDer(v.tbsCertificate);v.md.update(w.getBytes())}var E=e.md.sha1.create();v.issuer.getField=function(e){return l(v.issuer,e)},v.issuer.addField=function(e){m([e]),v.issuer.attributes.push(e)},v.issuer.attributes=n.RDNAttributesAsArray(u.certIssuer,E),u.certIssuerUniqueId&&(v.issuer.uniqueId=u.certIssuerUniqueId),v.issuer.hash=E.digest().toHex();var S=e.md.sha1.create();return v.subject.getField=function(e){return l(v.subject,e)},v.subject.addField=function(e){m([e]),v.subject.attributes.push(e)},v.subject.attributes=n.RDNAttributesAsArray(u.certSubject,S),u.certSubjectUniqueId&&(v.subject.uniqueId=u.certSubjectUniqueId),v.subject.hash=S.digest().toHex(),u.certExtensions?v.extensions=c(u.certExtensions):v.extensions=[],v.publicKey=n.publicKeyFromAsn1(u.subjectPublicKeyInfo),v},n.certificationRequestFromAsn1=function(i,s){var o={},u=[];if(!t.validate(i,f,o,u))throw{message:"Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.",errors:u};if(typeof o.csrSignature!="string"){var a="\0";for(var c=0;c<o.csrSignature.length;++c)a+=t.toDer(o.csrSignature[c]).getBytes();o.csrSignature=a}var p=t.derToOid(o.publicKeyOid);if(p!==n.oids.rsaEncryption)throw{message:"Cannot read public key. OID is not RSA."};var d=n.createCertificationRequest();d.version=o.csrVersion?o.csrVersion.charCodeAt(0):0,d.signatureOid=e.asn1.derToOid(o.csrSignatureOid),d.signatureParameters=h(d.signatureOid,o.csrSignatureParams,!0),d.siginfo.algorithmOid=e.asn1.derToOid(o.csrSignatureOid),d.siginfo.parameters=h(d.siginfo.algorithmOid,o.csrSignatureParams,!1);var v=e.util.createBuffer(o.csrSignature);++v.read,d.signature=v.getBytes(),d.certificationRequestInfo=o.certificationRequestInfo;if(s){d.md=null;if(d.signatureOid in r){var p=r[d.signatureOid];switch(p){case"sha1WithRSAEncryption":d.md=e.md.sha1.create();break;case"md5WithRSAEncryption":d.md=e.md.md5.create();break;case"sha256WithRSAEncryption":d.md=e.md.sha256.create();break;case"RSASSA-PSS":d.md=e.md.sha256.create()}}if(d.md===null)throw{message:"Could not compute certification request digest. Unknown signature OID.",signatureOid:d.signatureOid};var g=t.toDer(d.certificationRequestInfo);d.md.update(g.getBytes())}var y=e.md.sha1.create();return d.subject.getField=function(e){return l(d.subject,e)},d.subject.addField=function(e){m([e]),d.subject.attributes.push(e)},d.subject.attributes=n.RDNAttributesAsArray(o.certificationRequestInfoSubject,y),d.subject.hash=y.digest().toHex(),d.publicKey=n.publicKeyFromAsn1(o.subjectPublicKeyInfo),d.getAttribute=function(e){return l(d.attributes,e)},d.addAttribute=function(e){m([e]),d.attributes.push(e)},d.attributes=n.CRIAttributesAsArray(o.certificationRequestInfoAttributes),d},n.createCertificationRequest=function(){var i={};return i.version=0,i.signatureOid=null,i.signature=null,i.siginfo={},i.siginfo.algorithmOid=null,i.subject={},i.subject.getField=function(e){return l(i.subject,e)},i.subject.addField=function(e){m([e]),i.subject.attributes.push(e)},i.subject.attributes=[],i.subject.hash=null,i.publicKey=null,i.attributes=[],i.getAttribute=function(e){return l(i.attributes,e)},i.addAttribute=function(e){m([e]),i.attributes.push(e)},i.md=null,i.setSubject=function(e){m(e),i.subject.attributes=e,i.subject.hash=null},i.setAttributes=function(e){m(e),i.attributes=e},i.sign=function(s,o){i.md=o||e.md.sha1.create();var u=r[i.md.algorithm+"WithRSAEncryption"];if(!u)throw{message:"Could not compute certification request digest. Unknown message digest algorithm OID.",algorithm:i.md.algorithm};i.signatureOid=i.siginfo.algorithmOid=u,i.certificationRequestInfo=n.getCertificationRequestInfo(i);var a=t.toDer(i.certificationRequestInfo);i.md.update(a.getBytes()),i.signature=s.sign(i.md)},i.verify=function(){var s=!1,o=i.md;if(o===null){if(i.signatureOid in r){var u=r[i.signatureOid];switch(u){case"sha1WithRSAEncryption":o=e.md.sha1.create();break;case"md5WithRSAEncryption":o=e.md.md5.create();break;case"sha256WithRSAEncryption":o=e.md.sha256.create();break;case"RSASSA-PSS":o=e.md.sha256.create()}}if(o===null)throw{message:"Could not compute certification request digest. Unknown signature OID.",signatureOid:i.signatureOid};var a=i.certificationRequestInfo||n.getCertificationRequestInfo(i),f=t.toDer(a);o.update(f.getBytes())}if(o!==null){var l;switch(i.signatureOid){case r.sha1WithRSAEncryption:break;case r["RSASSA-PSS"]:var c,h;c=r[i.signatureParameters.mgf.hash.algorithmOid];if(c===undefined||e.md[c]===undefined)throw{message:"Unsupported MGF hash function.",oid:i.signatureParameters.mgf.hash.algorithmOid,name:c};h=r[i.signatureParameters.mgf.algorithmOid];if(h===undefined||e.mgf[h]===undefined)throw{message:"Unsupported MGF function.",oid:i.signatureParameters.mgf.algorithmOid,name:h};h=e.mgf[h].create(e.md[c].create()),c=r[i.signatureParameters.hash.algorithmOid];if(c===undefined||e.md[c]===undefined)throw{message:"Unsupported RSASSA-PSS hash function.",oid:i.signatureParameters.hash.algorithmOid,name:c};l=e.pss.create(e.md[c].create(),h,i.signatureParameters.saltLength)}s=i.publicKey.verify(o.digest().getBytes(),i.signature,l)}return s},i},n.getTBSCertificate=function(r){var i=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(r.version).getBytes())]),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,e.util.hexToBytes(r.serialNumber)),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r.siginfo.algorithmOid).getBytes()),g(r.siginfo.algorithmOid,r.siginfo.parameters)]),p(r.issuer),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.UTCTIME,!1,t.dateToUtcTime(r.validity.notBefore)),t.create(t.Class.UNIVERSAL,t.Type.UTCTIME,!1,t.dateToUtcTime(r.validity.notAfter))]),p(r.subject),n.publicKeyToAsn1(r.publicKey)]);return r.issuer.uniqueId&&i.value.push(t.create(t.Class.CONTEXT_SPECIFIC,1,!0,[t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+r.issuer.uniqueId)])),r.subject.uniqueId&&i.value.push(t.create(t.Class.CONTEXT_SPECIFIC,2,!0,[t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+r.subject.uniqueId)])),r.extensions.length>0&&i.value.push(d(r.extensions)),i},n.getCertificationRequestInfo=function(e){var r=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(e.version).getBytes()),p(e.subject),n.publicKeyToAsn1(e.publicKey),y(e)]);return r},n.distinguishedNameToAsn1=function(e){return p(e)},n.certificateToAsn1=function(e){var r=e.tbsCertificate||n.getTBSCertificate(e);return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[r,t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.signatureOid).getBytes()),g(e.signatureOid,e.signatureParameters)]),t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},n.certificationRequestToAsn1=function(e){var r=e.certificationRequestInfo||n.getCertificationRequestInfo(e);return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[r,t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.signatureOid).getBytes()),g(e.signatureOid,e.signatureParameters)]),t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},n.createCaStore=function(t){var r={certs:{}};r.getIssuer=function(t){var i=null;if(!t.issuer.hash){var s=e.md.sha1.create();t.issuer.attributes=n.RDNAttributesAsArray(p(t.issuer),s),t.issuer.hash=s.digest().toHex()}if(t.issuer.hash in r.certs){i=r.certs[t.issuer.hash];if(e.util.isArray(i))throw{message:"Resolving multiple issuer matches not implemented yet."}}return i},r.addCertificate=function(t){typeof t=="string"&&(t=e.pki.certificateFromPem(t));if(!t.subject.hash){var i=e.md.sha1.create();t.subject.attributes=n.RDNAttributesAsArray(p(t.subject),i),t.subject.hash=i.digest().toHex()}if(t.subject.hash in r.certs){var s=r.certs[t.subject.hash];e.util.isArray(s)||(s=[s]),s.push(t)}else r.certs[t.subject.hash]=t};if(t)for(var i=0;i<t.length;++i){var s=t[i];r.addCertificate(s)}return r},n.certificateError={bad_certificate:"forge.pki.BadCertificate",unsupported_certificate:"forge.pki.UnsupportedCertificate",certificate_revoked:"forge.pki.CertificateRevoked",certificate_expired:"forge.pki.CertificateExpired",certificate_unknown:"forge.pki.CertificateUnknown",unknown_ca:"forge.pki.UnknownCertificateAuthority"},n.verifyCertificateChain=function(t,r,i){r=r.slice(0);var s=r.slice(0),o=new Date,u=!0,a=null,f=0,l=null;do{var c=r.shift();if(o<c.validity.notBefore||o>c.validity.notAfter)a={message:"Certificate is not valid yet or has expired.",error:n.certificateError.certificate_expired,notBefore:c.validity.notBefore,notAfter:c.validity.notAfter,now:o};else{var h=!1;if(r.length>0){l=r[0];try{h=l.verify(c)}catch(p){}}else{var d=t.getIssuer(c);if(d===null)a={message:"Certificate is not trusted.",error:n.certificateError.unknown_ca};else{e.util.isArray(d)||(d=[d]);while(!h&&d.length>0){l=d.shift();try{h=l.verify(c)}catch(p){}}}}a===null&&!h&&(a={message:"Certificate signature is invalid.",error:n.certificateError.bad_certificate})}a===null&&!c.isIssuer(l)&&(a={message:"Certificate issuer is invalid.",error:n.certificateError.bad_certificate});if(a===null){var v={keyUsage:!0,basicConstraints:!0};for(var m=0;a===null&&m<c.extensions.length;++m){var g=c.extensions[m];g.critical&&!(g.name in v)&&(a={message:"Certificate has an unsupported critical extension.",error:n.certificateError.unsupported_certificate})}}if(!u||r.length===0&&!l){var y=c.getExtension("basicConstraints"),b=c.getExtension("keyUsage");b!==null&&(!b.keyCertSign||y===null)&&(a={message:"Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",error:n.certificateError.bad_certificate}),a===null&&y!==null&&!y.cA&&(a={message:"Certificate basicConstraints indicates the certificate is not a CA.",error:n.certificateError.bad_certificate});if(a===null&&b!==null&&"pathLenConstraint"in y){var w=0;for(var m=1;m<r.length-1;++m)r[m].isIssuer(r[m])&&++w;var E=y.pathLenConstraint+1;r.length-w>E&&(a={message:"Certificate basicConstraints pathLenConstraint violated.",error:n.certificateError.bad_certificate})}}var S=a===null?!0:a.error,x=i?i(S,f,s):S;if(x!==!0){S===!0&&(a={message:"The application rejected the certificate.",error:n.certificateError.bad_certificate});if(x||x===0)typeof x=="object"&&!e.util.isArray(x)?(x.message&&(a.message=x.message),x.error&&(a.error=x.error)):typeof x=="string"&&(a.error=x);throw a}a=null,u=!1,++f}while(r.length>0);return!0}}var r="x509";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n.pki}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/x509",["require","module","./aes","./asn1","./des","./md","./mgf","./oids","./pem","./pss","./rsa","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function f(e,t,n,r){var i=[];for(var s=0;s<e.length;s++)for(var o=0;o<e[s].safeBags.length;o++){var u=e[s].safeBags[o];if(r!==undefined&&u.type!==r)continue;u.attributes[t]!==undefined&&u.attributes[t].indexOf(n)>=0&&i.push(u)}return i}function l(e,r,s,o){r=t.fromDer(r,s);if(r.tagClass!==t.Class.UNIVERSAL||r.type!==t.Type.SEQUENCE||r.constructed!==!0)throw{message:"PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo"};for(var u=0;u<r.value.length;u++){var a=r.value[u],f={},l=[];if(!t.validate(a,i,f,l))throw{message:"Cannot read ContentInfo.",errors:l};var p={encrypted:!1},d=null,v=f.content.value[0];switch(t.derToOid(f.contentType)){case n.oids.data:if(v.tagClass!==t.Class.UNIVERSAL||v.type!==t.Type.OCTETSTRING)throw{message:"PKCS#12 SafeContents Data is not an OCTET STRING."};d=v.value;break;case n.oids.encryptedData:if(o===undefined)throw{message:"Found PKCS#12 Encrypted SafeContents Data but no password available."};d=c(v,o),p.encrypted=!0;break;default:throw{message:"Unsupported PKCS#12 contentType.",contentType:t.derToOid(f.contentType)}}p.safeBags=h(d,s,o),e.safeContents.push(p)}}function c(r,i){var s={},o=[];if(!t.validate(r,e.pkcs7.asn1.encryptedDataValidator,s,o))throw{message:"Cannot read EncryptedContentInfo. ",errors:o};var u=t.derToOid(s.contentType);if(u!==n.oids.data)throw{message:"PKCS#12 EncryptedContentInfo ContentType is not Data.",oid:u};u=t.derToOid(s.encAlgorithm);var a=n.pbe.getCipher(u,s.encParameter,i),f=e.util.createBuffer(s.encryptedContent);a.update(f);if(!a.finish())throw{message:"Failed to decrypt PKCS#12 SafeContents."};return a.output.getBytes()}function h(e,r,i){e=t.fromDer(e,r);if(e.tagClass!==t.Class.UNIVERSAL||e.type!==t.Type.SEQUENCE||e.constructed!==!0)throw{message:"PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag"};var s=[];for(var u=0;u<e.value.length;u++){var f=e.value[u],l={},c=[];if(!t.validate(f,o,l,c))throw{message:"Cannot read SafeBag.",errors:c};var h={type:t.derToOid(l.bagId),attributes:p(l.bagAttributes)};s.push(h);var d,v,m=l.bagValue.value[0];switch(h.type){case n.oids.pkcs8ShroudedKeyBag:if(i===undefined)throw{message:"Found PKCS#8 ShroudedKeyBag but no password available."};m=n.decryptPrivateKeyInfo(m,i);if(m===null)throw{message:"Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"};case n.oids.keyBag:h.key=n.privateKeyFromAsn1(m);continue;case n.oids.certBag:d=a,v=function(){if(t.derToOid(l.certId)!==n.oids.x509Certificate)throw{message:"Unsupported certificate type, only X.509 supported.",oid:t.derToOid(l.certId)};h.cert=n.certificateFromAsn1(t.fromDer(l.cert,r),!0)};break;default:throw{message:"Unsupported PKCS#12 SafeBag type.",oid:h.type}}if(d!==undefined&&!t.validate(m,d,l,c))throw{message:"Cannot read PKCS#12 "+d.name,errors:c};v()}return s}function p(e){var r={};if(e!==undefined)for(var i=0;i<e.length;++i){var s={},o=[];if(!t.validate(e[i],u,s,o))throw{message:"Cannot read PKCS#12 BagAttribute.",errors:o};var a=t.derToOid(s.oid);if(n.oids[a]===undefined)continue;r[n.oids[a]]=[];for(var f=0;f<s.values.length;++f)r[n.oids[a]].push(s.values[f].value)}return r}var t=e.asn1,n=e.pki,r=e.pkcs12=e.pkcs12||{},i={name:"ContentInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.contentType",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:t.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"content"}]},s={name:"PFX",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},i,{name:"PFX.macData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"mac",value:[{name:"PFX.macData.mac",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.macData.mac.digestAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.macData.mac.digestAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"macAlgorithm"},{name:"PFX.macData.mac.digestAlgorithm.parameters",tagClass:t.Class.UNIVERSAL,captureAsn1:"macAlgorithmParameters"}]},{name:"PFX.macData.mac.digest",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"macDigest"}]},{name:"PFX.macData.macSalt",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"macSalt"},{name:"PFX.macData.iterations",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,optional:!0,capture:"macIterations"}]}]},o={name:"SafeBag",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SafeBag.bagId",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"bagId"},{name:"SafeBag.bagValue",tagClass:t.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"bagValue"},{name:"SafeBag.bagAttributes",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,optional:!0,capture:"bagAttributes"}]},u={name:"Attribute",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Attribute.attrId",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"oid"},{name:"Attribute.attrValues",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,capture:"values"}]},a={name:"CertBag",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"CertBag.certId",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"certId"},{name:"CertBag.certValue",tagClass:t.Class.CONTEXT_SPECIFIC,constructed:!0,value:[{name:"CertBag.certValue[0]",tagClass:t.Class.UNIVERSAL,type:t.Class.OCTETSTRING,constructed:!1,capture:"cert"}]}]};r.pkcs12FromAsn1=function(i,o,u){typeof o=="string"?(u=o,o=!0):o===undefined&&(o=!0);var a={},c=[];if(!t.validate(i,s,a,c))throw{message:"Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.",errors:c};var h={version:a.version.charCodeAt(0),safeContents:[],getBags:function(t){var n={},r;return"localKeyId"in t?r=t.localKeyId:"localKeyIdHex"in t&&(r=e.util.hexToBytes(t.localKeyIdHex)),r!==undefined&&(n.localKeyId=f(h.safeContents,"localKeyId",r,t.bagType)),"friendlyName"in t&&(n.friendlyName=f(h.safeContents,"friendlyName",t.friendlyName,t.bagType)),n},getBagsByFriendlyName:function(e,t){return f(h.safeContents,"friendlyName",e,t)},getBagsByLocalKeyId:function(e,t){return f(h.safeContents,"localKeyId",e,t)}};if(a.version.charCodeAt(0)!==3)throw{message:"PKCS#12 PFX of version other than 3 not supported.",version:a.version.charCodeAt(0)};if(t.derToOid(a.contentType)!==n.oids.data)throw{message:"Only PKCS#12 PFX in password integrity mode supported.",oid:t.derToOid(a.contentType)};var p=a.content.value[0];if(p.tagClass!==t.Class.UNIVERSAL||p.type!==t.Type.OCTETSTRING)throw{message:"PKCS#12 authSafe content data is not an OCTET STRING."};if(a.mac){var d=null,v=0,m=t.derToOid(a.macAlgorithm);switch(m){case n.oids.sha1:d=e.md.sha1.create(),v=20;break;case n.oids.sha256:d=e.md.sha256.create(),v=32;break;case n.oids.sha384:d=e.md.sha384.create(),v=48;break;case n.oids.sha512:d=e.md.sha512.create(),v=64;break;case n.oids.md5:d=e.md.md5.create(),v=16}if(d===null)throw{message:"PKCS#12 uses unsupported MAC algorithm: "+m};var g=new e.util.ByteBuffer(a.macSalt),y="macIterations"in a?parseInt(e.util.bytesToHex(a.macIterations),16):1,b=r.generateKey(u||"",g,3,y,v,d),w=e.hmac.create();w.start(d,b),w.update(p.value);var E=w.getMac();if(E.getBytes()!==a.macDigest)throw{message:"PKCS#12 MAC could not be verified. Invalid password?"}}return l(h,p.value,o,u),h},r.toPkcs12Asn1=function(i,s,o,u){u=u||{},u.saltSize=u.saltSize||8,u.count=u.count||2048,u.algorithm=u.algorithm||u.encAlgorithm||"aes128","useMac"in u||(u.useMac=!0),"localKeyId"in u||(u.localKeyId=null),"generateLocalKeyId"in u||(u.generateLocalKeyId=!0);var a=u.localKeyId,f;if(a!==null)a=e.util.hexToBytes(a);else if(u.generateLocalKeyId)if(s){var l=e.util.isArray(s)?s[0]:s;typeof l=="string"&&(l=n.certificateFromPem(l));var c=e.md.sha1.create();c.update(t.toDer(n.certificateToAsn1(l)).getBytes()),a=c.digest().getBytes()}else a=e.random.getBytes(20);var h=[];a!==null&&h.push(t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.localKeyId).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,a)])])),"friendlyName"in u&&h.push(t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.friendlyName).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,t.Type.BMPSTRING,!1,u.friendlyName)])])),h.length>0&&(f=t.create(t.Class.UNIVERSAL,t.Type.SET,!0,h));var p=[],d=[];s!==null&&(e.util.isArray(s)?d=s:d=[s]);var v=[];for(var m=0;m<d.length;++m){s=d[m],typeof s=="string"&&(s=n.certificateFromPem(s));var g=m===0?f:undefined,y=n.certificateToAsn1(s),b=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.certBag).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.x509Certificate).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(y).getBytes())])])]),g]);v.push(b)}if(v.length>0){var w=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,v),E=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.data).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(w).getBytes())])]);p.push(E)}var S=null;if(i!==null){var x=n.wrapRsaPrivateKey(n.privateKeyToAsn1(i));o===null?S=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.keyBag).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[x]),f]):S=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.pkcs8ShroudedKeyBag).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[n.encryptPrivateKeyInfo(x,o,u)]),f]);var T=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[S]),N=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.data).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(T).getBytes())])]);p.push(N)}var C=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,p),k;if(u.useMac){var c=e.md.sha1.create(),L=new e.util.ByteBuffer(e.random.getBytes(u.saltSize)),A=u.count,i=r.generateKey(o||"",L,3,A,20),O=e.hmac.create();O.start(c,i),O.update(t.toDer(C).getBytes());var M=O.getMac();k=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.sha1).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")]),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,M.getBytes())]),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,L.getBytes()),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(A).getBytes())])}return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(3).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.data).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(C).getBytes())])]),k])},r.generateKey=e.pbe.generatePkcs12Key}var r="pkcs12";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs12",["require","module","./asn1","./hmac","./oids","./pkcs7asn1","./pbe","./random","./rsa","./sha1","./util","./x509"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1,n=e.pki=e.pki||{};n.pemToDer=function(t){var n=e.pem.decode(t)[0];if(n.procType&&n.procType.type==="ENCRYPTED")throw{message:"Could not convert PEM to DER; PEM is encrypted."};return e.util.createBuffer(n.body)},n.privateKeyFromPem=function(r){var i=e.pem.decode(r)[0];if(i.type!=="PRIVATE KEY"&&i.type!=="RSA PRIVATE KEY")throw{message:'Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".',headerType:i.type};if(i.procType&&i.procType.type==="ENCRYPTED")throw{message:"Could not convert private key from PEM; PEM is encrypted."};var s=t.fromDer(i.body);return n.privateKeyFromAsn1(s)},n.privateKeyToPem=function(r,i){var s={type:"RSA PRIVATE KEY",body:t.toDer(n.privateKeyToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})}}var r="pki";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pki",["require","module","./asn1","./oids","./pbe","./pem","./pbkdf2","./pkcs12","./pss","./rsa","./util","./x509"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=function(t,n,r,i){var s=e.util.createBuffer(),o=t.length>>1,u=o+(t.length&1),a=t.substr(0,u),f=t.substr(o,u),l=e.util.createBuffer(),c=e.hmac.create();r=n+r;var h=Math.ceil(i/16),p=Math.ceil(i/20);c.start("MD5",a);var d=e.util.createBuffer();l.putBytes(r);for(var v=0;v<h;++v)c.start(null,null),c.update(l.getBytes()),l.putBuffer(c.digest()),c.start(null,null),c.update(l.bytes()+r),d.putBuffer(c.digest());c.start("SHA1",f);var m=e.util.createBuffer();l.clear(),l.putBytes(r);for(var v=0;v<p;++v)c.start(null,null),c.update(l.getBytes()),l.putBuffer(c.digest()),c.start(null,null),c.update(l.bytes()+r),m.putBuffer(c.digest());return s.putBytes(e.util.xorBytes(d.getBytes(),m.getBytes(),i)),s},n=function(e,t,n,r){},r=function(t,n,r){var i=e.hmac.create();i.start("SHA1",t);var s=e.util.createBuffer();return s.putInt32(n[0]),s.putInt32(n[1]),s.putByte(r.type),s.putByte(r.version.major),s.putByte(r.version.minor),s.putInt16(r.length),s.putBytes(r.fragment.bytes()),i.update(s.getBytes()),i.digest().getBytes()},i=function(t,n,r){var i=!1;try{var s=t.deflate(n.fragment.getBytes());n.fragment=e.util.createBuffer(s),n.length=s.length,i=!0}catch(o){}return i},s=function(t,n,r){var i=!1;try{var s=t.inflate(n.fragment.getBytes());n.fragment=e.util.createBuffer(s),n.length=s.length,i=!0}catch(o){}return i},o=function(t,n){var r=0;switch(n){case 1:r=t.getByte();break;case 2:r=t.getInt16();break;case 3:r=t.getInt24();break;case 4:r=t.getInt32()}return e.util.createBuffer(t.getBytes(r))},u=function(e,t,n){e.putInt(n.length(),t<<3),e.putBuffer(n)},a={};a.Version={major:3,minor:1},a.MaxFragment=15360,a.ConnectionEnd={server:0,client:1},a.PRFAlgorithm={tls_prf_sha256:0},a.BulkCipherAlgorithm={none:null,rc4:0,des3:1,aes:2},a.CipherType={stream:0,block:1,aead:2},a.MACAlgorithm={none:null,hmac_md5:0,hmac_sha1:1,hmac_sha256:2,hmac_sha384:3,hmac_sha512:4},a.CompressionMethod={none:0,deflate:1},a.ContentType={change_cipher_spec:20,alert:21,handshake:22,application_data:23},a.HandshakeType={hello_request:0,client_hello:1,server_hello:2,certificate:11,server_key_exchange:12,certificate_request:13,server_hello_done:14,certificate_verify:15,client_key_exchange:16,finished:20},a.Alert={},a.Alert.Level={warning:1,fatal:2},a.Alert.Description={close_notify:0,unexpected_message:10,bad_record_mac:20,decryption_failed:21,record_overflow:22,decompression_failure:30,handshake_failure:40,bad_certificate:42,unsupported_certificate:43,certificate_revoked:44,certificate_expired:45,certificate_unknown:46,illegal_parameter:47,unknown_ca:48,access_denied:49,decode_error:50,decrypt_error:51,export_restriction:60,protocol_version:70,insufficient_security:71,internal_error:80,user_canceled:90,no_renegotiation:100},a.CipherSuites={},a.getCipherSuite=function(e){var t=null;for(var n in a.CipherSuites){var r=a.CipherSuites[n];if(r.id[0]===e.charCodeAt(0)&&r.id[1]===e.charCodeAt(1)){t=r;break}}return t},a.handleUnexpected=function(e,t){var n=!e.open&&e.entity===a.ConnectionEnd.client;n||e.error(e,{message:"Unexpected message. Received TLS record out of order.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unexpected_message}})},a.handleHelloRequest=function(e,t,n){!e.handshaking&&e.handshakes>0&&(a.queue(e,a.createAlert({level:a.Alert.Level.warning,description:a.Alert.Description.no_renegotiation})),a.flush(e)),e.process()},a.parseHelloMessage=function(t,n,r){var i=null,s=t.entity===a.ConnectionEnd.client;if(r<38)t.error(t,{message:s?"Invalid ServerHello message. Message too short.":"Invalid ClientHello message. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var u=n.fragment,f=u.length();i={version:{major:u.getByte(),minor:u.getByte()},random:e.util.createBuffer(u.getBytes(32)),session_id:o(u,1),extensions:[]},s?(i.cipher_suite=u.getBytes(2),i.compression_method=u.getByte()):(i.cipher_suites=o(u,2),i.compression_methods=o(u,1)),f=r-(f-u.length());if(f>0){var l=o(u,2);while(l.length()>0)i.extensions.push({type:[l.getByte(),l.getByte()],data:o(l,2)});if(!s)for(var c=0;c<i.extensions.length;++c){var h=i.extensions[c];if(h.type[0]===0&&h.type[1]===0){var p=o(h.data,2);while(p.length()>0){var d=p.getByte();if(d!==0)break;t.session.serverNameList.push(o(p,2).getBytes())}}}}(i.version.major!==a.Version.major||i.version.minor!==a.Version.minor)&&t.error(t,{message:"Incompatible TLS version.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.protocol_version}});if(s)t.session.cipherSuite=a.getCipherSuite(i.cipher_suite);else{var v=e.util.createBuffer(i.cipher_suites.bytes());while(v.length()>0){t.session.cipherSuite=a.getCipherSuite(v.getBytes(2));if(t.session.cipherSuite!==null)break}}if(t.session.cipherSuite===null)return t.error(t,{message:"No cipher suites in common.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.handshake_failure},cipherSuite:e.util.bytesToHex(i.cipher_suite)});s?t.session.compressionMethod=i.compression_method:t.session.compressionMethod=a.CompressionMethod.none}return i},a.createSecurityParameters=function(e,t){var n=e.entity===a.ConnectionEnd.client,r=t.random.bytes(),i=n?e.session.sp.client_random:r,s=n?r:a.createRandom().getBytes();e.session.sp={entity:e.entity,prf_algorithm:a.PRFAlgorithm.tls_prf_sha256,bulk_cipher_algorithm:null,cipher_type:null,enc_key_length:null,block_length:null,fixed_iv_length:null,record_iv_length:null,mac_algorithm:null,mac_length:null,mac_key_length:null,compression_algorithm:e.session.compressionMethod,pre_master_secret:null,master_secret:null,client_random:i,server_random:s}},a.handleServerHello=function(e,t,n){var r=a.parseHelloMessage(e,t,n);if(!e.fail){var i=r.session_id.bytes();i.length>0&&i===e.session.id?(e.expect=d,e.session.resuming=!0,e.session.sp.server_random=r.random.bytes()):(e.expect=l,e.session.resuming=!1,a.createSecurityParameters(e,r)),e.session.id=i,e.process()}},a.handleClientHello=function(t,n,r){var i=a.parseHelloMessage(t,n,r);if(!t.fail){var s=i.session_id.bytes(),o=null;t.sessionCache&&(o=t.sessionCache.getSession(s),o===null&&(s="")),s.length===0&&(s=e.random.getBytes(32)),t.session.id=s,t.session.clientHelloVersion=i.version,t.session.sp=o?o.sp:{},o!==null?(t.expect=S,t.session.resuming=!0,t.session.sp.client_random=i.random.bytes()):(t.expect=t.verifyClient!==!1?b:w,t.session.resuming=!1,a.createSecurityParameters(t,i)),t.open=!0,a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createServerHello(t)})),t.session.resuming?(a.queue(t,a.createRecord({type:a.ContentType.change_cipher_spec,data:a.createChangeCipherSpec()})),t.state.pending=a.createConnectionState(t),t.state.current.write=t.state.pending.write,a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createFinished(t)}))):(a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createCertificate(t)})),t.fail||(a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createServerKeyExchange(t)})),t.verifyClient!==!1&&a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createCertificateRequest(t)})),a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createServerHelloDone(t)})))),a.flush(t),t.process()}},a.handleCertificate=function(t,n,r){if(r<3)t.error(t,{message:"Invalid Certificate message. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var i=n.fragment,s={certificate_list:o(i,3)},u,f,l=[];try{while(s.certificate_list.length()>0)u=o(s.certificate_list,3),f=e.asn1.fromDer(u),u=e.pki.certificateFromAsn1(f,!0),l.push(u)}catch(h){t.error(t,{message:"Could not parse certificate list.",cause:h,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_certificate}})}if(!t.fail){var p=t.entity===a.ConnectionEnd.client;!p&&t.verifyClient!==!0||l.length!==0?l.length===0?t.expect=p?c:w:(p?t.session.serverCertificate=l[0]:t.session.clientCertificate=l[0],a.verifyCertificateChain(t,l)&&(t.expect=p?c:w)):t.error(t,{message:p?"No server certificate provided.":"No client certificate provided.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}}),t.process()}}},a.handleServerKeyExchange=function(e,t,n){n>0?e.error(e,{message:"Invalid key parameters. Only RSA is supported.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unsupported_certificate}}):(e.expect=h,e.process())},a.handleClientKeyExchange=function(t,n,r){if(r<48)t.error(t,{message:"Invalid key parameters. Only RSA is supported.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unsupported_certificate}});else{var i=n.fragment,s={enc_pre_master_secret:o(i,2).getBytes()},u=null;if(t.getPrivateKey)try{u=t.getPrivateKey(t,t.session.serverCertificate),u=e.pki.privateKeyFromPem(u)}catch(f){t.error(t,{message:"Could not get private key.",cause:f,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}})}if(u===null)t.error(t,{message:"No private key set.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}});else try{var l=t.session.sp;l.pre_master_secret=u.decrypt(s.enc_pre_master_secret);var c=t.session.clientHelloVersion;if(c.major!==l.pre_master_secret.charCodeAt(0)||c.minor!==l.pre_master_secret.charCodeAt(1))throw{message:"TLS version rollback attack detected."}}catch(f){l.pre_master_secret=e.random.getBytes(48)}}t.fail||(t.expect=S,t.session.clientCertificate!==null&&(t.expect=E),t.process())},a.handleCertificateRequest=function(e,t,n){if(n<3)e.error(e,{message:"Invalid CertificateRequest. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var r=t.fragment,i={certificate_types:o(r,1),certificate_authorities:o(r,2)};e.session.certificateRequest=i,e.expect=p,e.process()}},a.handleCertificateVerify=function(t,n,r){if(r<2)t.error(t,{message:"Invalid CertificateVerify. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var i=n.fragment;i.read-=4;var s=i.bytes();i.read+=4;var u={signature:o(i,2).getBytes()},f=e.util.createBuffer();f.putBuffer(t.session.md5.digest()),f.putBuffer(t.session.sha1.digest()),f=f.getBytes();try{var l=t.session.clientCertificate;if(!l.publicKey.verify(f,u.signature,"NONE"))throw{message:"CertificateVerify signature does not match."};t.session.md5.update(s),t.session.sha1.update(s)}catch(c){t.error(t,{message:"Bad signature in CertificateVerify.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.handshake_failure}})}t.fail||(t.expect=S,t.process())}},a.handleServerHelloDone=function(t,n,r){if(r>0)t.error(t,{message:"Invalid ServerHelloDone message. Invalid length.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.record_overflow}});else if(t.serverCertificate===null){var i={message:"No server certificate provided. Not enough security.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.insufficient_security}},s=t.verify(t,i.alert.description,depth,[]);if(s===!0)i=null;else{if(s||s===0)typeof s=="object"&&!e.util.isArray(s)?(s.message&&(i.message=s.message),s.alert&&(i.alert.description=s.alert)):typeof s=="number"&&(i.alert.description=s);t.error(t,i)}}!t.fail&&t.session.certificateRequest!==null&&(n=a.createRecord({type:a.ContentType.handshake,data:a.createCertificate(t)}),a.queue(t,n));if(!t.fail){n=a.createRecord({type:a.ContentType.handshake,data:a.createClientKeyExchange(t)}),a.queue(t,n),t.expect=g;var o=function(e,t){e.session.certificateRequest!==null&&e.session.clientCertificate!==null&&a.queue(e,a.createRecord({type:a.ContentType.handshake,data:a.createCertificateVerify(e,t)})),a.queue(e,a.createRecord({type:a.ContentType.change_cipher_spec,data:a.createChangeCipherSpec()})),e.state.pending=a.createConnectionState(e),e.state.current.write=e.state.pending.write,a.queue(e,a.createRecord({type:a.ContentType.handshake,data:a.createFinished(e)})),e.expect=d,a.flush(e),e.process()};t.session.certificateRequest===null||t.session.clientCertificate===null?o(t,null):a.getClientSignature(t,o)}},a.handleChangeCipherSpec=function(e,t){if(t.fragment.getByte()!==1)e.error(e,{message:"Invalid ChangeCipherSpec message received.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var n=e.entity===a.ConnectionEnd.client;if(e.session.resuming&&n||!e.session.resuming&&!n)e.state.pending=a.createConnectionState(e);e.state.current.read=e.state.pending.read;if(!e.session.resuming&&n||e.session.resuming&&!n)e.state.pending=null;e.expect=n?v:x,e.process()}},a.handleFinished=function(n,r,i){var s=r.fragment;s.read-=4;var o=s.bytes();s.read+=4;var u=r.fragment.getBytes();s=e.util.createBuffer(),s.putBuffer(n.session.md5.digest()),s.putBuffer(n.session.sha1.digest());var f=n.entity===a.ConnectionEnd.client,l=f?"server finished":"client finished",c=n.session.sp,h=12,p=t;s=p(c.master_secret,l,s.getBytes(),h);if(s.getBytes()!==u)n.error(n,{message:"Invalid verify_data in Finished message.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.decrypt_error}});else{n.session.md5.update(o),n.session.sha1.update(o);if(n.session.resuming&&f||!n.session.resuming&&!f)a.queue(n,a.createRecord({type:a.ContentType.change_cipher_spec,data:a.createChangeCipherSpec()})),n.state.current.write=n.state.pending.write,n.state.pending=null,a.queue(n,a.createRecord({type:a.ContentType.handshake,data:a.createFinished(n)}));n.expect=f?m:T,n.handshaking=!1,++n.handshakes,n.peerCertificate=f?n.session.serverCertificate:n.session.clientCertificate,n.sessionCache?(n.session={id:n.session.id,sp:n.session.sp},n.session.sp.keys=null):n.session=null,a.flush(n),n.isConnected=!0,n.connected(n),n.process()}},a.handleAlert=function(e,t){var n=t.fragment,r={level:n.getByte(),description:n.getByte()},i;switch(r.description){case a.Alert.Description.close_notify:i="Connection closed.";break;case a.Alert.Description.unexpected_message:i="Unexpected message.";break;case a.Alert.Description.bad_record_mac:i="Bad record MAC.";break;case a.Alert.Description.decryption_failed:i="Decryption failed.";break;case a.Alert.Description.record_overflow:i="Record overflow.";break;case a.Alert.Description.decompression_failure:i="Decompression failed.";break;case a.Alert.Description.handshake_failure:i="Handshake failure.";break;case a.Alert.Description.bad_certificate:i="Bad certificate.";break;case a.Alert.Description.unsupported_certificate:i="Unsupported certificate.";break;case a.Alert.Description.certificate_revoked:i="Certificate revoked.";break;case a.Alert.Description.certificate_expired:i="Certificate expired.";break;case a.Alert.Description.certificate_unknown:i="Certificate unknown.";break;case a.Alert.Description.illegal_parameter:i="Illegal parameter.";break;case a.Alert.Description.unknown_ca:i="Unknown certificate authority.";break;case a.Alert.Description.access_denied:i="Access denied.";break;case a.Alert.Description.decode_error:i="Decode error.";break;case a.Alert.Description.decrypt_error:i="Decrypt error.";break;case a.Alert.Description.export_restriction:i="Export restriction.";break;case a.Alert.Description.protocol_version:i="Unsupported protocol version.";break;case a.Alert.Description.insufficient_security:i="Insufficient security.";break;case a.Alert.Description.internal_error:i="Internal error.";break;case a.Alert.Description.user_canceled:i="User canceled.";break;case a.Alert.Description.no_renegotiation:i="Renegotiation not supported.";break;default:i="Unknown error."}r.description===a.Alert.Description.close_notify?e.close():(e.error(e,{message:i,send:!1,origin:e.entity===a.ConnectionEnd.client?"server":"client",alert:r}),e.process())},a.handleHandshake=function(t,n){var r=n.fragment,i=r.getByte(),s=r.getInt24();if(s>r.length())t.fragmented=n,n.fragment=e.util.createBuffer(),r.read-=4,t.process();else{t.fragmented=null,r.read-=4;var o=r.bytes(s+4);r.read+=4,i in I[t.entity][t.expect]?(t.entity===a.ConnectionEnd.server&&!t.open&&!t.fail&&(t.handshaking=!0,t.session={serverNameList:[],cipherSuite:null,compressionMethod:null,serverCertificate:null,clientCertificate:null,md5:e.md.md5.create(),sha1:e.md.sha1.create()}),i!==a.HandshakeType.hello_request&&i!==a.HandshakeType.certificate_verify&&i!==a.HandshakeType.finished&&(t.session.md5.update(o),t.session.sha1.update(o)),I[t.entity][t.expect][i](t,n,s)):a.handleUnexpected(t,n)}},a.handleApplicationData=function(e,t){e.data.putBuffer(t.fragment),e.dataReady(e),e.process()};var f=0,l=1,c=2,h=3,p=4,d=5,v=6,m=7,g=8,y=0,b=1,w=2,E=3,S=4,x=5,T=6,N=7,C=a.handleUnexpected,k=a.handleChangeCipherSpec,L=a.handleAlert,A=a.handleHandshake,O=a.handleApplicationData,M=[];M[a.ConnectionEnd.client]=[[C,L,A,C],[C,L,A,C],[C,L,A,C],[C,L,A,C],[C,L,A,C],[k,L,C,C],[C,L,A,C],[C,L,A,O],[C,L,A,C]],M[a.ConnectionEnd.server]=[[C,L,A,C],[C,L,A,C],[C,L,A,C],[C,L,A,C],[k,L,C,C],[C,L,A,C],[C,L,A,O],[C,L,A,C]];var _=a.handleHelloRequest,D=a.handleServerHello,P=a.handleCertificate,H=a.handleServerKeyExchange,B=a.handleCertificateRequest,j=a.handleServerHelloDone,F=a.handleFinished,I=[];I[a.ConnectionEnd.client]=[[C,C,D,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,P,H,B,j,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,H,B,j,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,B,j,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,j,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,F],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C]];var q=a.handleClientHello,R=a.handleClientKeyExchange,U=a.handleCertificateVerify;I[a.ConnectionEnd.server]=[[C,q,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,P,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,R,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,U,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,F],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C]],a.generateKeys=function(e,n){var r=t,i=n.client_random+n.server_random;e.session.resuming||(n.master_secret=r(n.pre_master_secret,"master secret",i,48).bytes(),n.pre_master_secret=null),i=n.server_random+n.client_random;var s=2*n.mac_key_length+2*n.enc_key_length+2*n.fixed_iv_length,o=r(n.master_secret,"key expansion",i,s);return{client_write_MAC_key:o.getBytes(n.mac_key_length),server_write_MAC_key:o.getBytes(n.mac_key_length),client_write_key:o.getBytes(n.enc_key_length),server_write_key:o.getBytes(n.enc_key_length),client_write_IV:o.getBytes(n.fixed_iv_length),server_write_IV:o.getBytes(n.fixed_iv_length)}},a.createConnectionState=function(e){var t=e.entity===a.ConnectionEnd.client,n=function(){var e={sequenceNumber:[0,0],macKey:null,macLength:0,macFunction:null,cipherState:null,cipherFunction:function(e){return!0},compressionState:null,compressFunction:function(e){return!0},updateSequenceNumber:function(){e.sequenceNumber[1]===4294967295?(e.sequenceNumber[1]=0,++e.sequenceNumber[0]):++e.sequenceNumber[1]}};return e},r={read:n(),write:n()};r.read.update=function(e,t){return r.read.cipherFunction(t,r.read)?r.read.compressFunction(e,t,r.read)||e.error(e,{message:"Could not decompress record.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.decompression_failure}}):e.error(e,{message:"Could not decrypt record or bad MAC.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_record_mac}}),!e.fail},r.write.update=function(e,t){return r.write.compressFunction(e,t,r.write)?r.write.cipherFunction(t,r.write)||e.error(e,{message:"Could not encrypt record.",send:!1,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}}):e.error(e,{message:"Could not compress record.",send:!1,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}}),!e.fail};if(e.session){var o=e.session.sp;e.session.cipherSuite.initSecurityParameters(o),o.keys=a.generateKeys(e,o),r.read.macKey=t?o.keys.server_write_MAC_key:o.keys.client_write_MAC_key,r.write.macKey=t?o.keys.client_write_MAC_key:o.keys.server_write_MAC_key,e.session.cipherSuite.initConnectionState(r,e,o);switch(o.compression_algorithm){case a.CompressionMethod.none:break;case a.CompressionMethod.deflate:r.read.compressFunction=s,r.write.compressFunction=i;break;default:throw{message:"Unsupported compression algorithm."}}}return r},a.createRandom=function(){var t=new Date,n=+t+t.getTimezoneOffset()*6e4,r=e.util.createBuffer();return r.putInt32(n),r.putBytes(e.random.getBytes(28)),r},a.createRecord=function(e){if(!e.data)return null;var t={type:e.type,version:{major:a.Version.major,minor:a.Version.minor},length:e.data.length(),fragment:e.data};return t},a.createAlert=function(t){var n=e.util.createBuffer();return n.putByte(t.level),n.putByte(t.description),a.createRecord({type:a.ContentType.alert,data:n})},a.createClientHello=function(t){var n=e.util.createBuffer();for(var r=0;r<t.cipherSuites.length;++r){var i=t.cipherSuites[r];n.putByte(i.id[0]),n.putByte(i.id[1])}var s=n.length(),o=e.util.createBuffer();o.putByte(a.CompressionMethod.none);var f=o.length(),l=e.util.createBuffer();if(t.virtualHost){var c=e.util.createBuffer();c.putByte(0),c.putByte(0);var h=e.util.createBuffer();h.putByte(0),u(h,2,e.util.createBuffer(t.virtualHost));var p=e.util.createBuffer();u(p,2,h),u(c,2,p),l.putBuffer(c)}var d=l.length();d>0&&(d+=2);var v=t.session.id,m=v.length+1+2+4+28+2+s+1+f+d,g=e.util.createBuffer();return g.putByte(a.HandshakeType.client_hello),g.putInt24(m),g.putByte(a.Version.major),g.putByte(a.Version.minor),g.putBytes(t.session.sp.client_random),u(g,1,e.util.createBuffer(v)),u(g,2,n),u(g,1,o),d>0&&u(g,2,l),g},a.createServerHello=function(t){var n=t.session.id,r=n.length+1+2+4+28+2+1,i=e.util.createBuffer();return i.putByte(a.HandshakeType.server_hello),i.putInt24(r),i.putByte(a.Version.major),i.putByte(a.Version.minor),i.putBytes(t.session.sp.server_random),u(i,1,e.util.createBuffer(n)),i.putByte(t.session.cipherSuite.id[0]),i.putByte(t.session.cipherSuite.id[1]),i.putByte(t.session.compressionMethod),i},a.createCertificate=function(t){var n=t.entity===a.ConnectionEnd.client,r=null;t.getCertificate&&(r=t.getCertificate(t,n?t.session.certificateRequest:t.session.serverNameList));var i=e.util.createBuffer();if(r!==null)try{e.util.isArray(r)||(r=[r]);var s=null;for(var o=0;o<r.length;++o){var f=e.pem.decode(r[o])[0];if(f.type!=="CERTIFICATE"&&f.type!=="X509 CERTIFICATE"&&f.type!=="TRUSTED CERTIFICATE")throw{message:'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',headerType:f.type};if(f.procType&&f.procType.type==="ENCRYPTED")throw{message:"Could not convert certificate from PEM; PEM is encrypted."};var l=e.util.createBuffer(f.body);s===null&&(s=e.asn1.fromDer(l.bytes(),!1));var c=e.util.createBuffer();u(c,3,l),i.putBuffer(c)}r=e.pki.certificateFromAsn1(s),n?t.session.clientCertificate=r:t.session.serverCertificate=r}catch(h){return t.error(t,{message:"Could not send certificate list.",cause:h,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_certificate}})}var p=3+i.length(),d=e.util.createBuffer();return d.putByte(a.HandshakeType.certificate),d.putInt24(p),u(d,3,i),d},a.createClientKeyExchange=function(t){var n=e.util.createBuffer();n.putByte(a.Version.major),n.putByte(a.Version.minor),n.putBytes(e.random.getBytes(46));var r=t.session.sp;r.pre_master_secret=n.getBytes();var i=t.session.serverCertificate.publicKey;n=i.encrypt(r.pre_master_secret);var s=n.length+2,o=e.util.createBuffer();return o.putByte(a.HandshakeType.client_key_exchange),o.putInt24(s),o.putInt16(n.length),o.putBytes(n),o},a.createServerKeyExchange=function(t){var n=0,r=e.util.createBuffer();return n>0&&(r.putByte(a.HandshakeType.server_key_exchange),r.putInt24(n)),r},a.getClientSignature=function(t,n){var r=e.util.createBuffer();r.putBuffer(t.session.md5.digest()),r.putBuffer(t.session.sha1.digest()),r=r.getBytes(),t.getSignature=t.getSignature||function(t,n,r){var i=null;if(t.getPrivateKey)try{i=t.getPrivateKey(t,t.session.clientCertificate),i=e.pki.privateKeyFromPem(i)}catch(s){t.error(t,{message:"Could not get private key.",cause:s,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}})}i===null?t.error(t,{message:"No private key set.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}}):n=i.sign(n,null),r(t,n)},t.getSignature(t,r,n)},a.createCertificateVerify=function(t,n){var r=n.length+2,i=e.util.createBuffer();return i.putByte(a.HandshakeType.certificate_verify),i.putInt24(r),i.putInt16(n.length),i.putBytes(n),i},a.createCertificateRequest=function(t){var n=e.util.createBuffer();n.putByte(1);var r=e.util.createBuffer();for(var i in t.caStore.certs){var s=t.caStore.certs[i],o=e.pki.distinguishedNameToAsn1(s.subject);r.putBuffer(e.asn1.toDer(o))}var f=1+n.length()+2+r.length(),l=e.util.createBuffer();return l.putByte(a.HandshakeType.certificate_request),l.putInt24(f),u(l,1,n),u(l,2,r),l},a.createServerHelloDone=function(t){var n=e.util.createBuffer();return n.putByte(a.HandshakeType.server_hello_done),n.putInt24(0),n},a.createChangeCipherSpec=function(){var t=e.util.createBuffer();return t.putByte(1),t},a.createFinished=function(n){var r=e.util.createBuffer();r.putBuffer(n.session.md5.digest()),r.putBuffer(n.session.sha1.digest());var i=n.entity===a.ConnectionEnd.client,s=n.session.sp,o=12,u=t,f=i?"client finished":"server finished";r=u(s.master_secret,f,r.getBytes(),o);var l=e.util.createBuffer();return l.putByte(a.HandshakeType.finished),l.putInt24(r.length()),l.putBuffer(r),l},a.queue=function(t,n){if(!n)return;if(n.type===a.ContentType.handshake){var r=n.fragment.bytes();t.session.md5.update(r),t.session.sha1.update(r),r=null}var i;if(n.fragment.length()<=a.MaxFragment)i=[n];else{i=[];var s=n.fragment.bytes();while(s.length>a.MaxFragment)i.push(a.createRecord({type:n.type,data:e.util.createBuffer(s.slice(0,a.MaxFragment))})),s=s.slice(a.MaxFragment);s.length>0&&i.push(a.createRecord({type:n.type,data:e.util.createBuffer(s)}))}for(var o=0;o<i.length&&!t.fail;++o){var u=i[o],f=t.state.current.write;f.update(t,u)&&t.records.push(u)}},a.flush=function(e){for(var t=0;t<e.records.length;++t){var n=e.records[t];e.tlsData.putByte(n.type),e.tlsData.putByte(n.version.major),e.tlsData.putByte(n.version.minor),e.tlsData.putInt16(n.fragment.length()),e.tlsData.putBuffer(e.records[t].fragment)}return e.records=[],e.tlsDataReady(e)};var z=function(t){switch(t){case!0:return!0;case e.pki.certificateError.bad_certificate:return a.Alert.Description.bad_certificate;case e.pki.certificateError.unsupported_certificate:return a.Alert.Description.unsupported_certificate;case e.pki.certificateError.certificate_revoked:return a.Alert.Description.certificate_revoked;case e.pki.certificateError.certificate_expired:return a.Alert.Description.certificate_expired;case e.pki.certificateError.certificate_unknown:return a.Alert.Description.certificate_unknown;case e.pki.certificateError.unknown_ca:return a.Alert.Description.unknown_ca;default:return a.Alert.Description.bad_certificate}},W=function(t){switch(t){case!0:return!0;case a.Alert.Description.bad_certificate:return e.pki.certificateError.bad_certificate;case a.Alert.Description.unsupported_certificate:return e.pki.certificateError.unsupported_certificate;case a.Alert.Description.certificate_revoked:return e.pki.certificateError.certificate_revoked;case a.Alert.Description.certificate_expired:return e.pki.certificateError.certificate_expired;case a.Alert.Description.certificate_unknown:return e.pki.certificateError.certificate_unknown;case a.Alert.Description.unknown_ca:return e.pki.certificateError.unknown_ca;default:return e.pki.certificateError.bad_certificate}};a.verifyCertificateChain=function(t,n){try{e.pki.verifyCertificateChain(t.caStore,n,function(r,i,s){var o=z(r),u=t.verify(t,r,i,s);if(u!==!0){if(typeof u=="object"&&!e.util.isArray(u)){var f={message:"The application rejected the certificate.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_certificate}};throw u.message&&(f.message=u.message),u.alert&&(f.alert.description=u.alert),f}u!==r&&(u=W(u))}return u})}catch(r){if(typeof r!="object"||e.util.isArray(r))r={send:!0,alert:{level:a.Alert.Level.fatal,description:z(r)}};"send"in r||(r.send=!0),"alert"in r||(r.alert={level:a.Alert.Level.fatal,description:z(r.error)}),t.error(t,r)}return!t.fail},a.createSessionCache=function(t,n){var r=null;if(t&&t.getSession&&t.setSession&&t.order)r=t;else{r={},r.cache=t||{},r.capacity=Math.max(n||100,1),r.order=[];for(var i in t)r.order.length<=n?r.order.push(i):delete t[i];r.getSession=function(t){var n=null,i=null;t?i=e.util.bytesToHex(t):r.order.length>0&&(i=r.order[0]);if(i!==null&&i in r.cache){n=r.cache[i],delete r.cache[i];for(var s in r.order)if(r.order[s]===i){r.order.splice(s,1);break}}return n},r.setSession=function(t,n){if(r.order.length===r.capacity){var i=r.order.shift();delete r.cache[i]}var i=e.util.bytesToHex(t);r.order.push(i),r.cache[i]=n}}return r},a.createConnection=function(t){var n=null;t.caStore?e.util.isArray(t.caStore)?n=e.pki.createCaStore(t.caStore):n=t.caStore:n=e.pki.createCaStore();var r=t.cipherSuites||null;if(r===null){r=[];for(var i in a.CipherSuites)r.push(a.CipherSuites[i])}var s=t.server||!1?a.ConnectionEnd.server:a.ConnectionEnd.client,o=t.sessionCache?a.createSessionCache(t.sessionCache):null,u={entity:s,sessionId:t.sessionId,caStore:n,sessionCache:o,cipherSuites:r,connected:t.connected,virtualHost:t.virtualHost||null,verifyClient:t.verifyClient||!1,verify:t.verify||function(e,t,n,r){return t},getCertificate:t.getCertificate||null,getPrivateKey:t.getPrivateKey||null,getSignature:t.getSignature||null,input:e.util.createBuffer(),tlsData:e.util.createBuffer(),data:e.util.createBuffer(),tlsDataReady:t.tlsDataReady,dataReady:t.dataReady,closed:t.closed,error:function(e,n){n.origin=n.origin||(e.entity===a.ConnectionEnd.client?"client":"server"),n.send&&(a.queue(e,a.createAlert(n.alert)),a.flush(e));var r=n.fatal!==!1;r&&(e.fail=!0),t.error(e,n),r&&e.close(!1)},deflate:t.deflate||null,inflate:t.inflate||null};u.reset=function(e){u.record=null,u.session=null,u.peerCertificate=null,u.state={pending:null,current:null},u.expect=u.entity===a.ConnectionEnd.client?f:y,u.fragmented=null,u.records=[],u.open=!1,u.handshakes=0,u.handshaking=!1,u.isConnected=!1,u.fail=!e&&typeof e!="undefined",u.input.clear(),u.tlsData.clear(),u.data.clear(),u.state.current=a.createConnectionState(u)},u.reset();var l=function(e,t){var n=t.type-a.ContentType.change_cipher_spec,r=M[e.entity][e.expect];n in r?r[n](e,t):a.handleUnexpected(e,t)},c=function(t){var n=0,r=t.input,i=r.length();return i<5?n=5-i:(t.record={type:r.getByte(),version:{major:r.getByte(),minor:r.getByte()},length:r.getInt16(),fragment:e.util.createBuffer(),ready:!1},(t.record.version.major!==a.Version.major||t.record.version.minor!==a.Version.minor)&&t.error(t,{message:"Incompatible TLS version.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.protocol_version}})),n},h=function(e){var t=0,n=e.input,r=n.length();if(r<e.record.length)t=e.record.length-r;else{e.record.fragment.putBytes(n.getBytes(e.record.length)),n.compact();var i=e.state.current.read;i.update(e,e.record)&&(e.fragmented!==null&&(e.fragmented.type===e.record.type?(e.fragmented.fragment.putBuffer(e.record.fragment),e.record=e.fragmented):e.error(e,{message:"Invalid fragmented record.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unexpected_message}})),e.record.ready=!0)}return t};return u.handshake=function(t){if(u.entity!==a.ConnectionEnd.client)u.error(u,{message:"Cannot initiate handshake as a server.",fatal:!1});else if(u.handshaking)u.error(u,{message:"Handshake already in progress.",fatal:!1});else{u.fail&&!u.open&&u.handshakes===0&&(u.fail=!1),u.handshaking=!0,t=t||"";var n=null;t.length>0&&(u.sessionCache&&(n=u.sessionCache.getSession(t)),n===null&&(t="")),t.length===0&&u.sessionCache&&(n=u.sessionCache.getSession(),n!==null&&(t=n.id)),u.session={id:t,cipherSuite:null,compressionMethod:null,serverCertificate:null,certificateRequest:null,clientCertificate:null,sp:n?n.sp:{},md5:e.md.md5.create(),sha1:e.md.sha1.create()},u.session.sp.client_random=a.createRandom().getBytes(),u.open=!0,a.queue(u,a.createRecord({type:a.ContentType.handshake,data:a.createClientHello(u)})),a.flush(u)}},u.process=function(e){var t=0;return e&&u.input.putBytes(e),u.fail||(u.record!==null&&u.record.ready&&u.record.fragment.isEmpty()&&(u.record=null),u.record===null&&(t=c(u)),!u.fail&&u.record!==null&&!u.record.ready&&(t=h(u)),!u.fail&&u.record!==null&&u.record.ready&&l(u,u.record)),t},u.prepare=function(t){return a.queue(u,a.createRecord({type:a.ContentType.application_data,data:e.util.createBuffer(t)})),a.flush(u)},u.close=function(e){!u.fail&&u.sessionCache&&u.session&&u.sessionCache.setSession(u.session.id,u.session);if(u.open){u.open=!1,u.input.clear();if(u.isConnected||u.handshaking)u.isConnected=u.handshaking=!1,a.queue(u,a.createAlert({level:a.Alert.Level.warning,description:a.Alert.Description.close_notify})),a.flush(u);u.closed(u)}u.reset(e)},u},e.tls=e.tls||{};for(var X in a)typeof a[X]!="function"&&(e.tls[X]=a[X]);e.tls.prf_tls1=t,e.tls.hmac_sha1=r,e.tls.createSessionCache=a.createSessionCache,e.tls.createConnection=a.createConnection}var r="tls";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/tls",["require","module","./asn1","./hmac","./md","./pem","./pki","./random","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(n,i,s){var u=i.entity===e.tls.ConnectionEnd.client;n.read.cipherState={init:!1,cipher:e.aes.createDecryptionCipher(u?s.keys.server_write_key:s.keys.client_write_key),iv:u?s.keys.server_write_IV:s.keys.client_write_IV},n.write.cipherState={init:!1,cipher:e.aes.createEncryptionCipher(u?s.keys.client_write_key:s.keys.server_write_key),iv:u?s.keys.client_write_IV:s.keys.server_write_IV},n.read.cipherFunction=o,n.write.cipherFunction=r,n.read.macLength=n.write.macLength=s.mac_length,n.read.macFunction=n.write.macFunction=t.hmac_sha1}function r(t,n){var r=!1,s=n.macFunction(n.macKey,n.sequenceNumber,t);t.fragment.putBytes(s),n.updateSequenceNumber();var o;t.version.minor>1?o=e.random.getBytes(16):o=n.cipherState.init?null:n.cipherState.iv,n.cipherState.init=!0;var u=n.cipherState.cipher;return u.start(o),t.version.minor>1&&u.output.putBytes(o),u.update(t.fragment),u.finish(i)&&(t.fragment=u.output,t.length=t.fragment.length(),r=!0),r}function i(e,t,n){if(!n){var r=e-t.length()%e;t.fillWithByte(r-1,r)}return!0}function s(e,t,n){var r=!0;if(n){var i=t.length(),s=t.last();for(var o=i-1-s;o<i-1;++o)r=r&&t.at(o)==s;r&&t.truncate(s+1)}return r}function o(t,n){var r=!1,i=n.cipherState.init?null:n.cipherState.iv;n.cipherState.init=!0;var o=n.cipherState.cipher;o.start(i),o.update(t.fragment),r=o.finish(s);var u=n.macLength,a="";for(var f=0;f<u;++f)a+=String.fromCharCode(0);var l=o.output.length();l>=u?(t.fragment=o.output.getBytes(l-u),a=o.output.getBytes(u)):t.fragment=o.output.getBytes(),t.fragment=e.util.createBuffer(t.fragment),t.length=t.fragment.length();var c=n.macFunction(n.macKey,n.sequenceNumber,t);return n.updateSequenceNumber(),r=c===a&&r,r}var t=e.tls;t.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA={id:[0,47],name:"TLS_RSA_WITH_AES_128_CBC_SHA",initSecurityParameters:function(e){e.bulk_cipher_algorithm=t.BulkCipherAlgorithm.aes,e.cipher_type=t.CipherType.block,e.enc_key_length=16,e.block_length=16,e.fixed_iv_length=16,e.record_iv_length=16,e.mac_algorithm=t.MACAlgorithm.hmac_sha1,e.mac_length=20,e.mac_key_length=20},initConnectionState:n},t.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA={id:[0,53],name:"TLS_RSA_WITH_AES_256_CBC_SHA",initSecurityParameters:function(e){e.bulk_cipher_algorithm=t.BulkCipherAlgorithm.aes,e.cipher_type=t.CipherType.block,e.enc_key_length=32,e.block_length=16,e.fixed_iv_length=16,e.record_iv_length=16,e.mac_algorithm=t.MACAlgorithm.hmac_sha1,e.mac_length=20,e.mac_key_length=20},initConnectionState:n}}var r="aesCipherSuites";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/aesCipherSuites",["require","module","./aes","./tls"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.debug=e.debug||{},e.debug.storage={},e.debug.get=function(t,n){var r;return typeof t=="undefined"?r=e.debug.storage:t in e.debug.storage&&(typeof n=="undefined"?r=e.debug.storage[t]:r=e.debug.storage[t][n]),r},e.debug.set=function(t,n,r){t in e.debug.storage||(e.debug.storage[t]={}),e.debug.storage[t][n]=r},e.debug.clear=function(t,n){typeof t=="undefined"?e.debug.storage={}:t in e.debug.storage&&(typeof n=="undefined"?delete e.debug.storage[t]:delete e.debug.storage[t][n])}}var r="debug";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/debug",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.log=e.log||{},e.log.levels=["none","error","warning","info","debug","verbose","max"];var t={},n=[],r=null;e.log.LEVEL_LOCKED=2,e.log.NO_LEVEL_CHECK=4,e.log.INTERPOLATE=8;for(var i=0;i<e.log.levels.length;++i){var s=e.log.levels[i];t[s]={index:i,name:s.toUpperCase()}}e.log.logMessage=function(r){var i=t[r.level].index;for(var s=0;s<n.length;++s){var o=n[s];if(o.flags&e.log.NO_LEVEL_CHECK)o.f(r);else{var u=t[o.level].index;i<=u&&o.f(o,r)}}},e.log.prepareStandard=function(e){"standard"in e||(e.standard=t[e.level].name+" ["+e.category+"] "+e.message)},e.log.prepareFull=function(t){if(!("full"in t)){var n=[t.message];n=n.concat([]||t.arguments),t.full=e.util.format.apply(this,n)}},e.log.prepareStandardFull=function(t){"standardFull"in t||(e.log.prepareStandard(t),t.standardFull=t.standard)};var o=["error","warning","info","debug","verbose"];for(var i=0;i<o.length;++i)(function(t){e.log[t]=function(n,r){var i=Array.prototype.slice.call(arguments).slice(2),s={timestamp:new Date,level:t,category:n,message:r,arguments:i};e.log.logMessage(s)}})(o[i]);e.log.makeLogger=function(t){var n={flags:0,f:t};return e.log.setLevel(n,"none"),n},e.log.setLevel=function(t,n){var r=!1;if(t&&!(t.flags&e.log.LEVEL_LOCKED))for(var i=0;i<e.log.levels.length;++i){var s=e.log.levels[i];if(n==s){t.level=n,r=!0;break}}return r},e.log.lock=function(t,n){typeof n=="undefined"||n?t.flags|=e.log.LEVEL_LOCKED:t.flags&=~e.log.LEVEL_LOCKED},e.log.addLogger=function(e){n.push(e)};if(typeof console!="undefined"&&"log"in console){var u;if(console.error&&console.warn&&console.info&&console.debug){var a={error:console.error,warning:console.warn,info:console.info,debug:console.debug,verbose:console.debug},f=function(t,n){e.log.prepareStandard(n);var r=a[n.level],i=[n.standard];i=i.concat(n.arguments.slice()),r.apply(console,i)};u=e.log.makeLogger(f)}else{var f=function(t,n){e.log.prepareStandardFull(n),console.log(n.standardFull)};u=e.log.makeLogger(f)}e.log.setLevel(u,"debug"),e.log.addLogger(u),r=u}else console={log:function(){}};if(r!==null){var l=e.util.getQueryVariables();"console.level"in l&&e.log.setLevel(r,l["console.level"].slice(-1)[0]);if("console.lock"in l){var c=l["console.lock"].slice(-1)[0];c=="true"&&e.log.lock(r)}}e.log.consoleLogger=r}var r="log";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/log",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1,n=e.pkcs7=e.pkcs7||{};n.messageFromPem=function(r){var i=e.pem.decode(r)[0];if(i.type!=="PKCS7")throw{message:'Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".',headerType:i.type};if(i.procType&&i.procType.type==="ENCRYPTED")throw{message:"Could not convert PKCS#7 message from PEM; PEM is encrypted."};var s=t.fromDer(i.body);return n.messageFromAsn1(s)},n.messageToPem=function(n,r){var i={type:"PKCS7",body:t.toDer(n.toAsn1()).getBytes()};return e.pem.encode(i,{maxline:r})},n.messageFromAsn1=function(r){var i={},s=[];if(!t.validate(r,n.asn1.contentInfoValidator,i,s))throw{message:"Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.",errors:s};var o=t.derToOid(i.contentType),u;switch(o){case e.pki.oids.envelopedData:u=n.createEnvelopedData();break;case e.pki.oids.encryptedData:u=n.createEncryptedData();break;case e.pki.oids.signedData:u=n.createSignedData();break;default:throw{message:"Cannot read PKCS#7 message. ContentType with OID "+o+" is not (yet) supported."}}return u.fromAsn1(i.content.value[0]),u};var r=function(r){var i={},s=[];if(!t.validate(r,n.asn1.recipientInfoValidator,i,s))throw{message:"Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 EnvelopedData.",errors:s};return{version:i.version.charCodeAt(0),issuer:e.pki.RDNAttributesAsArray(i.issuer),serialNumber:e.util.createBuffer(i.serial).toHex(),encryptedContent:{algorithm:t.derToOid(i.encAlgorithm),parameter:i.encParameter.value,content:i.encKey}}},i=function(n){return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(n.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[e.pki.distinguishedNameToAsn1({attributes:n.issuer}),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,e.util.hexToBytes(n.serialNumber))]),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.encryptedContent.algorithm).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")]),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.encryptedContent.content)])},s=function(e){var t=[];for(var n=0;n<e.length;n++)t.push(r(e[n]));return t},o=function(e){var t=[];for(var n=0;n<e.length;n++)t.push(i(e[n]));return t},u=function(n){return[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.pki.oids.data).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.algorithm).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.parameter.getBytes())]),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.content.getBytes())])]},a=function(n,r,i){var s={},o=[];if(!t.validate(r,i,s,o))throw{message:"Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.",errors:o};var u=t.derToOid(s.contentType);if(u!==e.pki.oids.data)throw{message:"Unsupported PKCS#7 message. Only wrapped ContentType Data supported."};if(s.encryptedContent){var a="";if(e.util.isArray(s.encryptedContent))for(var f=0;f<s.encryptedContent.length;++f){if(s.encryptedContent[f].type!==t.Type.OCTETSTRING)throw{message:"Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects."};a+=s.encryptedContent[f].value}else a=s.encryptedContent;n.encryptedContent={algorithm:t.derToOid(s.encAlgorithm),parameter:e.util.createBuffer(s.encParameter.value),content:e.util.createBuffer(a)}}if(s.content){var a="";if(e.util.isArray(s.content))for(var f=0;f<s.content.length;++f){if(s.content[f].type!==t.Type.OCTETSTRING)throw{message:"Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects."};a+=s.content[f].value}else a=s.content;n.content=e.util.createBuffer(a)}return n.version=s.version.charCodeAt(0),n.rawCapture=s,s},f=function(t){if(t.encryptedContent.key===undefined)throw{message:"Symmetric key not available."};if(t.content===undefined){var n;switch(t.encryptedContent.algorithm){case e.pki.oids["aes128-CBC"]:case e.pki.oids["aes192-CBC"]:case e.pki.oids["aes256-CBC"]:n=e.aes.createDecryptionCipher(t.encryptedContent.key);break;case e.pki.oids.desCBC:case e.pki.oids["des-EDE3-CBC"]:n=e.des.createDecryptionCipher(t.encryptedContent.key);break;default:throw{message:"Unsupported symmetric cipher, OID "+t.encryptedContent.algorithm}}n.start(t.encryptedContent.parameter),n.update(t.encryptedContent.content);if(!n.finish())throw{message:"Symmetric decryption failed."};t.content=n.output}};n.createSignedData=function(){var r=null;return r={type:e.pki.oids.signedData,version:1,certificates:[],crls:[],digestAlgorithmIdentifiers:[],contentInfo:null,signerInfos:[],fromAsn1:function(t){a(r,t,n.asn1.signedDataValidator),r.certificates=[],r.crls=[],r.digestAlgorithmIdentifiers=[],r.contentInfo=null,r.signerInfos=[];var i=r.rawCapture.certificates.value;for(var s=0;s<i.length;++s)r.certificates.push(e.pki.certificateFromAsn1(i[s]))},toAsn1:function(){if("content"in r)throw"Signing PKCS#7 content not yet implemented.";r.contentInfo||r.sign();var n=[];for(var i=0;i<r.certificates.length;++i)n.push(e.pki.certificateToAsn1(r.certificates[0]));var s=[];return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r.type).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(r.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,r.digestAlgorithmIdentifiers),r.contentInfo,t.create(t.Class.CONTEXT_SPECIFIC,0,!0,n),t.create(t.Class.CONTEXT_SPECIFIC,1,!0,s),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,r.signerInfos)])])])},sign:function(n){if("content"in r)throw"PKCS#7 signing not yet implemented.";typeof r.content!="object"&&(r.contentInfo=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.pki.oids.data).getBytes())]),"content"in r&&r.contentInfo.value.push(t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,r.content)])))},verify:function(){throw"PKCS#7 signature verification not yet implemented."},addCertificate:function(t){typeof t=="string"&&(t=e.pki.certificateFromPem(t)),r.certificates.push(t)},addCertificateRevokationList:function(e){throw"PKCS#7 CRL support not yet implemented."}},r},n.createEncryptedData=function(){var t=null;return t={type:e.pki.oids.encryptedData,version:0,encryptedContent:{algorithm:e.pki.oids["aes256-CBC"]},fromAsn1:function(e){a(t,e,n.asn1.encryptedDataValidator)},decrypt:function(e){e!==undefined&&(t.encryptedContent.key=e),f(t)}},t},n.createEnvelopedData=function(){var r=null;return r={type:e.pki.oids.envelopedData,version:0,recipients:[],encryptedContent:{algorithm:e.pki.oids["aes256-CBC"]},fromAsn1:function(e){var t=a(r,e,n.asn1.envelopedDataValidator);r.recipients=s(t.recipientInfos.value)},toAsn1:function(){return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r.type).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(r.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,o(r.recipients)),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,u(r.encryptedContent))])])])},findRecipient:function(e){var t=e.issuer.attributes;for(var n=0;n<r.recipients.length;++n){var i=r.recipients[n],s=i.issuer;if(i.serialNumber!==e.serialNumber)continue;if(s.length!==t.length)continue;var o=!0;for(var u=0;u<t.length;++u)if(s[u].type!==t[u].type||s[u].value!==t[u].value){o=!1;break}if(o)return i}return null},decrypt:function(t,n){if(r.encryptedContent.key===undefined&&t!==undefined&&n!==undefined)switch(t.encryptedContent.algorithm){case e.pki.oids.rsaEncryption:case e.pki.oids.desCBC:var i=n.decrypt(t.encryptedContent.content);r.encryptedContent.key=e.util.createBuffer(i);break;default:throw{message:"Unsupported asymmetric cipher, OID "+t.encryptedContent.algorithm}}f(r)},addRecipient:function(t){r.recipients.push({version:0,issuer:t.subject.attributes,serialNumber:t.serialNumber,encryptedContent:{algorithm:e.pki.oids.rsaEncryption,key:t.publicKey}})},encrypt:function(t,n){if(r.encryptedContent.content===undefined){n=n||r.encryptedContent.algorithm,t=t||r.encryptedContent.key;var i,s,o;switch(n){case e.pki.oids["aes128-CBC"]:i=16,s=16,o=e.aes.createEncryptionCipher;break;case e.pki.oids["aes192-CBC"]:i=24,s=16,o=e.aes.createEncryptionCipher;break;case e.pki.oids["aes256-CBC"]:i=32,s=16,o=e.aes.createEncryptionCipher;break;case e.pki.oids["des-EDE3-CBC"]:i=24,s=8,o=e.des.createEncryptionCipher;break;default:throw{message:"Unsupported symmetric cipher, OID "+n}}if(t===undefined)t=e.util.createBuffer(e.random.getBytes(i));else if(t.length()!=i)throw{message:"Symmetric key has wrong length, got "+t.length()+" bytes, expected "+i};r.encryptedContent.algorithm=n,r.encryptedContent.key=t,r.encryptedContent.parameter=e.util.createBuffer(e.random.getBytes(s));var u=o(t);u.start(r.encryptedContent.parameter.copy()),u.update(r.content);if(!u.finish())throw{message:"Symmetric encryption failed."};r.encryptedContent.content=u.output}for(var a=0;a<r.recipients.length;a++){var f=r.recipients[a];if(f.encryptedContent.content!==undefined)continue;switch(f.encryptedContent.algorithm){case e.pki.oids.rsaEncryption:f.encryptedContent.content=f.encryptedContent.key.encrypt(r.encryptedContent.key.data);break;default:throw{message:"Unsupported asymmetric cipher, OID "+f.encryptedContent.algorithm}}}}},r}}var r="pkcs7";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs7",["require","module","./aes","./asn1","./des","./oids","./pem","./pkcs7asn1","./random","./util","./x509"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t="forge.task",n=0,r={},i=0;e.debug.set(t,"tasks",r);var s={};e.debug.set(t,"queues",s);var o="?",u=30,a=20,f="ready",l="running",c="blocked",h="sleeping",p="done",d="error",v="stop",m="start",g="block",y="unblock",b="sleep",w="wakeup",E="cancel",S="fail",x={};x[f]={},x[f][v]=f,x[f][m]=l,x[f][E]=p,x[f][S]=d,x[l]={},x[l][v]=f,x[l][m]=l,x[l][g]=c,x[l][y]=l,x[l][b]=h,x[l][w]=l,x[l][E]=p,x[l][S]=d,x[c]={},x[c][v]=c,x[c][m]=c,x[c][g]=c,x[c][y]=c,x[c][b]=c,x[c][w]=c,x[c][E]=p,x[c][S]=d,x[h]={},x[h][v]=h,x[h][m]=h,x[h][g]=h,x[h][y]=h,x[h][b]=h,x[h][w]=h,x[h][E]=p,x[h][S]=d,x[p]={},x[p][v]=p,x[p][m]=p,x[p][g]=p,x[p][y]=p,x[p][b]=p,x[p][w]=p,x[p][E]=p,x[p][S]=d,x[d]={},x[d][v]=d,x[d][m]=d,x[d][g]=d,x[d][y]=d,x[d][b]=d,x[d][w]=d,x[d][E]=d,x[d][S]=d;var T=function(s){this.id=-1,this.name=s.name||o,this.parent=s.parent||null,this.run=s.run,this.subtasks=[],this.error=!1,this.state=f,this.blocks=0,this.timeoutId=null,this.swapTime=null,this.userData=null,this.id=i++,r[this.id]=this,n>=1&&e.log.verbose(t,"[%s][%s] init",this.id,this.name,this)};T.prototype.debug=function(n){n=n||"",e.log.debug(t,n,"[%s][%s] task:",this.id,this.name,this,"subtasks:",this.subtasks.length,"queue:",s)},T.prototype.next=function(e,t){typeof e=="function"&&(t=e,e=this.name);var n=new T({run:t,name:e,parent:this});return n.state=l,n.type=this.type,n.successCallback=this.successCallback||null,n.failureCallback=this.failureCallback||null,this.subtasks.push(n),this},T.prototype.parallel=function(t,n){return e.util.isArray(t)&&(n=t,t=this.name),this.next(t,function(r){var i=r;i.block(n.length);var s=function(t,r){e.task.start({type:t,run:function(e){n[r](e)},success:function(e){i.unblock()},failure:function(e){i.unblock()}})};for(var o=0;o<n.length;o++){var u=t+"__parallel-"+r.id+"-"+o,a=o;s(u,a)}})},T.prototype.stop=function(){this.state=x[this.state][v]},T.prototype.start=function(){this.error=!1,this.state=x[this.state][m],this.state===l&&(this.start=new Date,this.run(this),C(this,0))},T.prototype.block=function(e){e=typeof e=="undefined"?1:e,this.blocks+=e,this.blocks>0&&(this.state=x[this.state][g])},T.prototype.unblock=function(e){return e=typeof e=="undefined"?1:e,this.blocks-=e,this.blocks===0&&this.state!==p&&(this.state=l,C(this,0)),this.blocks},T.prototype.sleep=function(e){e=typeof e=="undefined"?0:e,this.state=x[this.state][b];var t=this;this.timeoutId=setTimeout(function(){t.timeoutId=null,t.state=l,C(t,0)},e)},T.prototype.wait=function(e){e.wait(this)},T.prototype.wakeup=function(){this.state===h&&(cancelTimeout(this.timeoutId),this.timeoutId=null,this.state=l,C(this,0))},T.prototype.cancel=function(){this.state=x[this.state][E],this.permitsNeeded=0,this.timeoutId!==null&&(cancelTimeout(this.timeoutId),this.timeoutId=null),this.subtasks=[]},T.prototype.fail=function(e){this.error=!0,k(this,!0);if(e)e.error=this.error,e.swapTime=this.swapTime,e.userData=this.userData,C(e,0);else{if(this.parent!==null){var t=this.parent;while(t.parent!==null)t.error=this.error,t.swapTime=this.swapTime,t.userData=this.userData,t=t.parent;k(t,!0)}this.failureCallback&&this.failureCallback(this)}};var N=function(e){e.error=!1,e.state=x[e.state][m],setTimeout(function(){e.state===l&&(e.swapTime=+(new Date),e.run(e),C(e,0))},0)},C=function(e,t){var n=t>u||+(new Date)-e.swapTime>a,r=function(t){t++;if(e.state===l){n&&(e.swapTime=+(new Date));if(e.subtasks.length>0){var r=e.subtasks.shift();r.error=e.error,r.swapTime=e.swapTime,r.userData=e.userData,r.run(r),r.error||C(r,t)}else k(e),e.error||e.parent!==null&&(e.parent.error=e.error,e.parent.swapTime=e.swapTime,e.parent.userData=e.userData,C(e.parent,t))}};n?setTimeout(r,0):r(t)},k=function(i,o){i.state=p,delete r[i.id],n>=1&&e.log.verbose(t,"[%s][%s] finish",i.id,i.name,i),i.parent===null&&(i.type in s?s[i.type].length===0?e.log.error(t,"[%s][%s] task queue empty [%s]",i.id,i.name,i.type):s[i.type][0]!==i?e.log.error(t,"[%s][%s] task not first in queue [%s]",i.id,i.name,i.type):(s[i.type].shift(),s[i.type].length===0?(n>=1&&e.log.verbose(t,"[%s][%s] delete queue [%s]",i.id,i.name,i.type),delete s[i.type]):(n>=1&&e.log.verbose(t,"[%s][%s] queue start next [%s] remain:%s",i.id,i.name,i.type,s[i.type].length),s[i.type][0].start())):e.log.error(t,"[%s][%s] task queue missing [%s]",i.id,i.name,i.type),o||(i.error&&i.failureCallback?i.failureCallback(i):!i.error&&i.successCallback&&i.successCallback(i)))};e.task=e.task||{},e.task.start=function(r){var i=new T({run:r.run,name:r.name||o});i.type=r.type,i.successCallback=r.success||null,i.failureCallback=r.failure||null,i.type in s?s[r.type].push(i):(n>=1&&e.log.verbose(t,"[%s][%s] create queue [%s]",i.id,i.name,i.type),s[i.type]=[i],N(i))},e.task.cancel=function(e){e in s&&(s[e]=[s[e][0]])},e.task.createCondition=function(){var e={tasks:{}};return e.wait=function(t){t.id in e.tasks||(t.block(),e.tasks[t.id]=t)},e.notify=function(){var t=e.tasks;e.tasks={};for(var n in t)t[n].unblock()},e}}var r="task";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/task",["require","module","./debug","./log","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){var e="forge";if(typeof n!="function"){if(typeof module!="object"||!module.exports){typeof forge=="undefined"&&(forge={disableNativeCode:!1});return}var r=!0;n=function(e,n){n(t,module)}}var i,s=function(t,n){n.exports=function(n){var r=i.map(function(e){return t(e)});n=n||{},n.defined=n.defined||{};if(n.defined[e])return n[e];n.defined[e]=!0;for(var s=0;s<r.length;++s)r[s](n);return n},n.exports.disableNativeCode=!1,n.exports(n.exports)},o=n;n=function(e,t){return i=typeof e=="string"?t.slice(2):e.slice(2),r?(delete n,o.apply(null,Array.prototype.slice.call(arguments,0))):(n=o,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/forge",["require","module","./aes","./aesCipherSuites","./asn1","./debug","./des","./hmac","./log","./pbkdf2","./pem","./pkcs7","./pkcs1","./pkcs12","./pki","./prng","./pss","./random","./rc2","./task","./tls","./util","./md","./mgf1"],function(){s.apply(null,Array.prototype.slice.call(arguments,0))})}(),window.forge=t("js/forge")})();
}).call(this,require("/home/ryan/.local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/home/ryan/.local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":16}],199:[function(require,module,exports){
(function (Buffer){
var crypto = require("crypto");
var BigInteger = require("jsbn");
var ECPointFp = require("./lib/ec.js").ECPointFp;
exports.ECCurves = require("./lib/sec.js");

// zero prepad
function unstupid(hex,len)
{
	return (hex.length >= len) ? hex : unstupid("0"+hex,len);
}

exports.ECKey = function(curve, key, isPublic)
{
  var priv;
	var c = curve();
	var n = c.getN();
  var bytes = Math.floor(n.bitLength()/8);

  if(key)
  {
    if(isPublic)
    {
      if(key.length != bytes*2+1) return false;
      var curve = c.getCurve();
      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format
      var y = key.slice(bytes+1);
      this.P = new ECPointFp(curve,
        curve.fromBigInteger(new BigInteger(x.toString("hex"), 16)),
        curve.fromBigInteger(new BigInteger(y.toString("hex"), 16)));      
    }else{
      if(key.length != bytes) return false;
      priv = new BigInteger(key.toString("hex"), 16);      
    }
  }else{
    var n1 = n.subtract(BigInteger.ONE);
    var r = new BigInteger(crypto.randomBytes(n.bitLength()));
    priv = r.mod(n1).add(BigInteger.ONE);
    this.P = c.getG().multiply(priv);
  }
  if(this.P)
  {
  	var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);
  	this.PublicKey = new Buffer("04"+pubhex,"hex");    
  }
  if(priv)
  {
    this.PrivateKey = new Buffer(unstupid(priv.toString(16),bytes*2),"hex");
    this.deriveSharedSecret = function(key)
    {
      if(!key || !key.P) return false;
      var S = key.P.multiply(priv);
      return new Buffer(unstupid(S.getX().toBigInteger().toString(16),bytes*2),"hex");
   }     
  }
}


}).call(this,require("buffer").Buffer)
},{"./lib/ec.js":200,"./lib/sec.js":201,"buffer":1,"crypto":5,"jsbn":202}],200:[function(require,module,exports){
// Basic Javascript Elliptic Curve implementation
// Ported loosely from BouncyCastle's Java EC code
// Only Fp curves implemented for now

// Requires jsbn.js and jsbn2.js
var BigInteger = require('jsbn')
var Barrett = BigInteger.prototype.Barrett

// ----------------
// ECFieldElementFp

// constructor
function ECFieldElementFp(q,x) {
    this.x = x;
    // TODO if(x.compareTo(q) >= 0) error
    this.q = q;
}

function feFpEquals(other) {
    if(other == this) return true;
    return (this.q.equals(other.q) && this.x.equals(other.x));
}

function feFpToBigInteger() {
    return this.x;
}

function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
}

function feFpAdd(b) {
    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
}

function feFpSubtract(b) {
    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
}

function feFpMultiply(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
}

function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
}

function feFpDivide(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
}

ECFieldElementFp.prototype.equals = feFpEquals;
ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
ECFieldElementFp.prototype.negate = feFpNegate;
ECFieldElementFp.prototype.add = feFpAdd;
ECFieldElementFp.prototype.subtract = feFpSubtract;
ECFieldElementFp.prototype.multiply = feFpMultiply;
ECFieldElementFp.prototype.square = feFpSquare;
ECFieldElementFp.prototype.divide = feFpDivide;

// ----------------
// ECPointFp

// constructor
function ECPointFp(curve,x,y,z) {
    this.curve = curve;
    this.x = x;
    this.y = y;
    // Projective coordinates: either zinv == null or z * zinv == 1
    // z and zinv are just BigIntegers, not fieldElements
    if(z == null) {
      this.z = BigInteger.ONE;
    }
    else {
      this.z = z;
    }
    this.zinv = null;
    //TODO: compression flag
}

function pointFpGetX() {
    if(this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.x.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
}

function pointFpGetY() {
    if(this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.y.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
}

function pointFpEquals(other) {
    if(other == this) return true;
    if(this.isInfinity()) return other.isInfinity();
    if(other.isInfinity()) return this.isInfinity();
    var u, v;
    // u = Y2 * Z1 - Y1 * Z2
    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
    if(!u.equals(BigInteger.ZERO)) return false;
    // v = X2 * Z1 - X1 * Z2
    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
    return v.equals(BigInteger.ZERO);
}

function pointFpIsInfinity() {
    if((this.x == null) && (this.y == null)) return true;
    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
}

function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
}

function pointFpAdd(b) {
    if(this.isInfinity()) return b;
    if(b.isInfinity()) return this;

    // u = Y2 * Z1 - Y1 * Z2
    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
    // v = X2 * Z1 - X1 * Z2
    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);

    if(BigInteger.ZERO.equals(v)) {
        if(BigInteger.ZERO.equals(u)) {
            return this.twice(); // this == b, so double
        }
	return this.curve.getInfinity(); // this = -b, so infinity
    }

    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var x2 = b.x.toBigInteger();
    var y2 = b.y.toBigInteger();

    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);

    // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
    // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
    // z3 = v^3 * z1 * z2
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

function pointFpTwice() {
    if(this.isInfinity()) return this;
    if(this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

    // TODO: optimized handling of constants
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();

    var y1z1 = y1.multiply(this.z);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
    var a = this.curve.a.toBigInteger();

    // w = 3 * x1^2 + a * z1^2
    var w = x1.square().multiply(THREE);
    if(!BigInteger.ZERO.equals(a)) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.q);
    //this.curve.reduce(w);
    // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
    // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
    // z3 = 8 * (y1 * z1)^3
    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

// Simple NAF (Non-Adjacent Form) multiplication algorithm
// TODO: modularize the multiplication algorithm
function pointFpMultiply(k) {
    if(this.isInfinity()) return this;
    if(k.signum() == 0) return this.curve.getInfinity();

    var e = k;
    var h = e.multiply(new BigInteger("3"));

    var neg = this.negate();
    var R = this;

    var i;
    for(i = h.bitLength() - 2; i > 0; --i) {
	R = R.twice();

	var hBit = h.testBit(i);
	var eBit = e.testBit(i);

	if (hBit != eBit) {
	    R = R.add(hBit ? this : neg);
	}
    }

    return R;
}

// Compute this*j + x*k (simultaneous multiplication)
function pointFpMultiplyTwo(j,x,k) {
  var i;
  if(j.bitLength() > k.bitLength())
    i = j.bitLength() - 1;
  else
    i = k.bitLength() - 1;

  var R = this.curve.getInfinity();
  var both = this.add(x);
  while(i >= 0) {
    R = R.twice();
    if(j.testBit(i)) {
      if(k.testBit(i)) {
        R = R.add(both);
      }
      else {
        R = R.add(this);
      }
    }
    else {
      if(k.testBit(i)) {
        R = R.add(x);
      }
    }
    --i;
  }

  return R;
}

ECPointFp.prototype.getX = pointFpGetX;
ECPointFp.prototype.getY = pointFpGetY;
ECPointFp.prototype.equals = pointFpEquals;
ECPointFp.prototype.isInfinity = pointFpIsInfinity;
ECPointFp.prototype.negate = pointFpNegate;
ECPointFp.prototype.add = pointFpAdd;
ECPointFp.prototype.twice = pointFpTwice;
ECPointFp.prototype.multiply = pointFpMultiply;
ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;

// ----------------
// ECCurveFp

// constructor
function ECCurveFp(q,a,b) {
    this.q = q;
    this.a = this.fromBigInteger(a);
    this.b = this.fromBigInteger(b);
    this.infinity = new ECPointFp(this, null, null);
    this.reducer = new Barrett(this.q);
}

function curveFpGetQ() {
    return this.q;
}

function curveFpGetA() {
    return this.a;
}

function curveFpGetB() {
    return this.b;
}

function curveFpEquals(other) {
    if(other == this) return true;
    return(this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
}

function curveFpGetInfinity() {
    return this.infinity;
}

function curveFpFromBigInteger(x) {
    return new ECFieldElementFp(this.q, x);
}

function curveReduce(x) {
    this.reducer.reduce(x);
}

// for now, work with hex strings because they're easier in JS
function curveFpDecodePointHex(s) {
    switch(parseInt(s.substr(0,2), 16)) { // first byte
    case 0:
	return this.infinity;
    case 2:
    case 3:
	// point compression not supported yet
	return null;
    case 4:
    case 6:
    case 7:
	var len = (s.length - 2) / 2;
	var xHex = s.substr(2, len);
	var yHex = s.substr(len+2, len);

	return new ECPointFp(this,
			     this.fromBigInteger(new BigInteger(xHex, 16)),
			     this.fromBigInteger(new BigInteger(yHex, 16)));

    default: // unsupported
	return null;
    }
}

function curveFpEncodePointHex(p) {
	if (p.isInfinity()) return "00";
	var xHex = p.getX().toBigInteger().toString(16);
	var yHex = p.getY().toBigInteger().toString(16);
	var oLen = this.getQ().toString(16).length;
	if ((oLen % 2) != 0) oLen++;
	while (xHex.length < oLen) {
		xHex = "0" + xHex;
	}
	while (yHex.length < oLen) {
		yHex = "0" + yHex;
	}
	return "04" + xHex + yHex;
}

ECCurveFp.prototype.getQ = curveFpGetQ;
ECCurveFp.prototype.getA = curveFpGetA;
ECCurveFp.prototype.getB = curveFpGetB;
ECCurveFp.prototype.equals = curveFpEquals;
ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
ECCurveFp.prototype.reduce = curveReduce;
ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;

var exports = {
  ECCurveFp: ECCurveFp,
  ECPointFp: ECPointFp,
  ECFieldElementFp: ECFieldElementFp
}

module.exports = exports

},{"jsbn":202}],201:[function(require,module,exports){
// Named EC curves

// Requires ec.js, jsbn.js, and jsbn2.js
var BigInteger = require('jsbn')
var ECCurveFp = require('./ec.js').ECCurveFp


// ----------------
// X9ECParameters

// constructor
function X9ECParameters(curve,g,n,h) {
    this.curve = curve;
    this.g = g;
    this.n = n;
    this.h = h;
}

function x9getCurve() {
    return this.curve;
}

function x9getG() {
    return this.g;
}

function x9getN() {
    return this.n;
}

function x9getH() {
    return this.h;
}

X9ECParameters.prototype.getCurve = x9getCurve;
X9ECParameters.prototype.getG = x9getG;
X9ECParameters.prototype.getN = x9getN;
X9ECParameters.prototype.getH = x9getH;

// ----------------
// SECNamedCurves

function fromHex(s) { return new BigInteger(s, 16); }

function secp128r1() {
    // p = 2^128 - 2^97 - 1
    var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
    //byte[] S = Hex.decode("000E0D4D696E6768756151750CC03A4473D03679");
    var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "161FF7528B899B2D0C28607CA52C5B86"
		+ "CF5AC8395BAFEB13C02DA292DDED7A83");
    return new X9ECParameters(curve, G, n, h);
}

function secp160k1() {
    // p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
    var a = BigInteger.ZERO;
    var b = fromHex("7");
    //byte[] S = null;
    var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"
                + "938CF935318FDCED6BC28286531733C3F03C4FEE");
    return new X9ECParameters(curve, G, n, h);
}

function secp160r1() {
    // p = 2^160 - 2^31 - 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
    var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
    //byte[] S = Hex.decode("1053CDE42C14D696E67687561517533BF3F83345");
    var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
		+ "4A96B5688EF573284664698968C38BB913CBFC82"
		+ "23A628553168947D59DCC912042351377AC5FB32");
    return new X9ECParameters(curve, G, n, h);
}

function secp192k1() {
    // p = 2^192 - 2^32 - 2^12 - 2^8 - 2^7 - 2^6 - 2^3 - 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
    var a = BigInteger.ZERO;
    var b = fromHex("3");
    //byte[] S = null;
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"
                + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
    return new X9ECParameters(curve, G, n, h);
}

function secp192r1() {
    // p = 2^192 - 2^64 - 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
    var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
    //byte[] S = Hex.decode("3045AE6FC8422F64ED579528D38120EAE12196D5");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"
                + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
    return new X9ECParameters(curve, G, n, h);
}

function secp224r1() {
    // p = 2^224 - 2^96 + 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
    var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
    //byte[] S = Hex.decode("BD71344799D5C7FCDC45B59FA3B9AB8F6A948BC5");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"
                + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
    return new X9ECParameters(curve, G, n, h);
}

function secp256r1() {
    // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1
    var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
    //byte[] S = Hex.decode("C49D360886E704936A6678E1139D26B7819F7E90");
    var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"
		+ "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
    return new X9ECParameters(curve, G, n, h);
}

// TODO: make this into a proper hashtable
function getSECCurveByName(name) {
    if(name == "secp128r1") return secp128r1();
    if(name == "secp160k1") return secp160k1();
    if(name == "secp160r1") return secp160r1();
    if(name == "secp192k1") return secp192k1();
    if(name == "secp192r1") return secp192r1();
    if(name == "secp224r1") return secp224r1();
    if(name == "secp256r1") return secp256r1();
    return null;
}

module.exports = {
  "secp128r1":secp128r1,
  "secp160k1":secp160k1,
  "secp160r1":secp160r1,
  "secp192k1":secp192k1,
  "secp192r1":secp192r1,
  "secp224r1":secp224r1,
  "secp256r1":secp256r1
}

},{"./ec.js":200,"jsbn":202}],202:[function(require,module,exports){
(function(){

    // Copyright (c) 2005  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Basic JavaScript BN library - subset useful for RSA encryption.

    // Bits per digit
    var dbits;

    // JavaScript engine analysis
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary&0xffffff)==0xefcafe);

    // (public) Constructor
    function BigInteger(a,b,c) {
      if(a != null)
        if("number" == typeof a) this.fromNumber(a,b,c);
        else if(b == null && "string" != typeof a) this.fromString(a,256);
        else this.fromString(a,b);
    }

    // return new, unset BigInteger
    function nbi() { return new BigInteger(null); }

    // am: Compute w_j += (x*this_i), propagate carries,
    // c is initial carry, returns final carry.
    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
    // We need to select the fastest one that works in this environment.

    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    function am1(i,x,w,j,c,n) {
      while(--n >= 0) {
        var v = x*this[i++]+w[j]+c;
        c = Math.floor(v/0x4000000);
        w[j++] = v&0x3ffffff;
      }
      return c;
    }
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    function am2(i,x,w,j,c,n) {
      var xl = x&0x7fff, xh = x>>15;
      while(--n >= 0) {
        var l = this[i]&0x7fff;
        var h = this[i++]>>15;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
        w[j++] = l&0x3fffffff;
      }
      return c;
    }
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    function am3(i,x,w,j,c,n) {
      var xl = x&0x3fff, xh = x>>14;
      while(--n >= 0) {
        var l = this[i]&0x3fff;
        var h = this[i++]>>14;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
        c = (l>>28)+(m>>14)+xh*h;
        w[j++] = l&0xfffffff;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    }
    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
      BigInteger.prototype.am = am1;
      dbits = 26;
    }
    else { // Mozilla/Netscape seems to prefer am3
      BigInteger.prototype.am = am3;
      dbits = 28;
    }

    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1<<dbits)-1);
    BigInteger.prototype.DV = (1<<dbits);

    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2,BI_FP);
    BigInteger.prototype.F1 = BI_FP-dbits;
    BigInteger.prototype.F2 = 2*dbits-BI_FP;

    // Digit conversions
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr,vv;
    rr = "0".charCodeAt(0);
    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

    function int2char(n) { return BI_RM.charAt(n); }
    function intAt(s,i) {
      var c = BI_RC[s.charCodeAt(i)];
      return (c==null)?-1:c;
    }

    // (protected) copy this to r
    function bnpCopyTo(r) {
      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }

    // (protected) set from integer value x, -DV <= x < DV
    function bnpFromInt(x) {
      this.t = 1;
      this.s = (x<0)?-1:0;
      if(x > 0) this[0] = x;
      else if(x < -1) this[0] = x+DV;
      else this.t = 0;
    }

    // return bigint initialized to value
    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

    // (protected) set from string and radix
    function bnpFromString(s,b) {
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 256) k = 8; // byte array
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else { this.fromRadix(s,b); return; }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while(--i >= 0) {
        var x = (k==8)?s[i]&0xff:intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-") mi = true;
          continue;
        }
        mi = false;
        if(sh == 0)
          this[this.t++] = x;
        else if(sh+k > this.DB) {
          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
          this[this.t++] = (x>>(this.DB-sh));
        }
        else
          this[this.t-1] |= x<<sh;
        sh += k;
        if(sh >= this.DB) sh -= this.DB;
      }
      if(k == 8 && (s[0]&0x80) != 0) {
        this.s = -1;
        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
      }
      this.clamp();
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) clamp off excess high words
    function bnpClamp() {
      var c = this.s&this.DM;
      while(this.t > 0 && this[this.t-1] == c) --this.t;
    }

    // (public) return string representation in given radix
    function bnToString(b) {
      if(this.s < 0) return "-"+this.negate().toString(b);
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1<<k)-1, d, m = false, r = "", i = this.t;
      var p = this.DB-(i*this.DB)%k;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
        while(i >= 0) {
          if(p < k) {
            d = (this[i]&((1<<p)-1))<<(k-p);
            d |= this[--i]>>(p+=this.DB-k);
          }
          else {
            d = (this[i]>>(p-=k))&km;
            if(p <= 0) { p += this.DB; --i; }
          }
          if(d > 0) m = true;
          if(m) r += int2char(d);
        }
      }
      return m?r:"0";
    }

    // (public) -this
    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

    // (public) |this|
    function bnAbs() { return (this.s<0)?this.negate():this; }

    // (public) return + if this > a, - if this < a, 0 if equal
    function bnCompareTo(a) {
      var r = this.s-a.s;
      if(r != 0) return r;
      var i = this.t;
      r = i-a.t;
      if(r != 0) return (this.s<0)?-r:r;
      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
      return 0;
    }

    // returns bit length of the integer x
    function nbits(x) {
      var r = 1, t;
      if((t=x>>>16) != 0) { x = t; r += 16; }
      if((t=x>>8) != 0) { x = t; r += 8; }
      if((t=x>>4) != 0) { x = t; r += 4; }
      if((t=x>>2) != 0) { x = t; r += 2; }
      if((t=x>>1) != 0) { x = t; r += 1; }
      return r;
    }

    // (public) return the number of bits in "this"
    function bnBitLength() {
      if(this.t <= 0) return 0;
      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
    }

    // (protected) r = this << n*DB
    function bnpDLShiftTo(n,r) {
      var i;
      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
      for(i = n-1; i >= 0; --i) r[i] = 0;
      r.t = this.t+n;
      r.s = this.s;
    }

    // (protected) r = this >> n*DB
    function bnpDRShiftTo(n,r) {
      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
      r.t = Math.max(this.t-n,0);
      r.s = this.s;
    }

    // (protected) r = this << n
    function bnpLShiftTo(n,r) {
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<cbs)-1;
      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
      for(i = this.t-1; i >= 0; --i) {
        r[i+ds+1] = (this[i]>>cbs)|c;
        c = (this[i]&bm)<<bs;
      }
      for(i = ds-1; i >= 0; --i) r[i] = 0;
      r[ds] = c;
      r.t = this.t+ds+1;
      r.s = this.s;
      r.clamp();
    }

    // (protected) r = this >> n
    function bnpRShiftTo(n,r) {
      r.s = this.s;
      var ds = Math.floor(n/this.DB);
      if(ds >= this.t) { r.t = 0; return; }
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<bs)-1;
      r[0] = this[ds]>>bs;
      for(var i = ds+1; i < this.t; ++i) {
        r[i-ds-1] |= (this[i]&bm)<<cbs;
        r[i-ds] = this[i]>>bs;
      }
      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
      r.t = this.t-ds;
      r.clamp();
    }

    // (protected) r = this - a
    function bnpSubTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]-a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c -= a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c -= a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = (c<0)?-1:0;
      if(c < -1) r[i++] = this.DV+c;
      else if(c > 0) r[i++] = c;
      r.t = i;
      r.clamp();
    }

    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    function bnpMultiplyTo(a,r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i+y.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
      r.s = 0;
      r.clamp();
      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
    }

    // (protected) r = this^2, r != this (HAC 14.16)
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2*x.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < x.t-1; ++i) {
        var c = x.am(i,x[i],r,2*i,0,1);
        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
          r[i+x.t] -= x.DV;
          r[i+x.t+1] = 1;
        }
      }
      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
      r.s = 0;
      r.clamp();
    }

    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    function bnpDivRemTo(m,q,r) {
      var pm = m.abs();
      if(pm.t <= 0) return;
      var pt = this.abs();
      if(pt.t < pm.t) {
        if(q != null) q.fromInt(0);
        if(r != null) this.copyTo(r);
        return;
      }
      if(r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
      else { pm.copyTo(y); pt.copyTo(r); }
      var ys = y.t;
      var y0 = y[ys-1];
      if(y0 == 0) return;
      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
      y.dlShiftTo(j,t);
      if(r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t,r);
      }
      BigInteger.ONE.dlShiftTo(ys,t);
      t.subTo(y,y);  // "negative" y so we can replace sub with am later
      while(y.t < ys) y[y.t++] = 0;
      while(--j >= 0) {
        // Estimate quotient digit
        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
          y.dlShiftTo(j,t);
          r.subTo(t,r);
          while(r[i] < --qd) r.subTo(t,r);
        }
      }
      if(q != null) {
        r.drShiftTo(ys,q);
        if(ts != ms) BigInteger.ZERO.subTo(q,q);
      }
      r.t = ys;
      r.clamp();
      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
      if(ts < 0) BigInteger.ZERO.subTo(r,r);
    }

    // (public) this mod a
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a,null,r);
      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
      return r;
    }

    // Modular reduction using "classic" algorithm
    function Classic(m) { this.m = m; }
    function cConvert(x) {
      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) { return x; }
    function cReduce(x) { x.divRemTo(this.m,null,x); }
    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;

    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    function bnpInvDigit() {
      if(this.t < 1) return 0;
      var x = this[0];
      if((x&1) == 0) return 0;
      var y = x&3;       // y == 1/x mod 2^2
      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
      // last step - calculate inverse mod DV directly;
      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
      // we really want the negative inverse, and -DV < y < DV
      return (y>0)?this.DV-y:-y;
    }

    // Montgomery reduction
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp&0x7fff;
      this.mph = this.mp>>15;
      this.um = (1<<(m.DB-15))-1;
      this.mt2 = 2*m.t;
    }

    // xR mod m
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t,r);
      r.divRemTo(this.m,null,r);
      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
      return r;
    }

    // x/R mod m
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }

    // x = x/R mod m (HAC 14.32)
    function montReduce(x) {
      while(x.t <= this.mt2) // pad x so am has enough room later
        x[x.t++] = 0;
      for(var i = 0; i < this.m.t; ++i) {
        // faster way of calculating u0 = x[i]*mp mod DV
        var j = x[i]&0x7fff;
        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
        // use am to combine the multiply-shift-add into one call
        j = i+this.m.t;
        x[j] += this.m.am(0,u0,x,i,0,this.m.t);
        // propagate carry
        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
      }
      x.clamp();
      x.drShiftTo(this.m.t,x);
      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = "x^2/R mod m"; x != r
    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = "xy/R mod m"; x,y != r
    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;

    // (protected) true iff this is even
    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    function bnpExp(e,z) {
      if(e > 0xffffffff || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
      g.copyTo(r);
      while(--i >= 0) {
        z.sqrTo(r,r2);
        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
        else { var t = r; r = r2; r2 = t; }
      }
      return z.revert(r);
    }

    // (public) this^e % m, 0 <= e < 2^32
    function bnModPowInt(e,m) {
      var z;
      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
      return this.exp(e,z);
    }

    // protected
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;

    // public
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;

    // "constants"
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);

    // Copyright (c) 2005-2009  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Extended JavaScript BN functions, required for RSA private ops.

    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
    // Version 1.2: square() API, isProbablePrime fix

    // (public)
    function bnClone() { var r = nbi(); this.copyTo(r); return r; }

    // (public) return value as integer
    function bnIntValue() {
      if(this.s < 0) {
        if(this.t == 1) return this[0]-this.DV;
        else if(this.t == 0) return -1;
      }
      else if(this.t == 1) return this[0];
      else if(this.t == 0) return 0;
      // assumes 16 < DB < 32
      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
    }

    // (public) return value as byte
    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

    // (public) return value as short (assumes DB>=16)
    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

    // (protected) return x s.t. r^x < DV
    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

    // (public) 0 if this == 0, 1 if this > 0
    function bnSigNum() {
      if(this.s < 0) return -1;
      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
      else return 1;
    }

    // (protected) convert to radix string
    function bnpToRadix(b) {
      if(b == null) b = 10;
      if(this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b,cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d,y,z);
      while(y.signum() > 0) {
        r = (a+z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d,y,z);
      }
      return z.intValue().toString(b) + r;
    }

    // (protected) convert from radix string
    function bnpFromRadix(s,b) {
      this.fromInt(0);
      if(b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
      for(var i = 0; i < s.length; ++i) {
        var x = intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w = b*w+x;
        if(++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w,0);
          j = 0;
          w = 0;
        }
      }
      if(j > 0) {
        this.dMultiply(Math.pow(b,j));
        this.dAddOffset(w,0);
      }
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) alternate constructor
    function bnpFromNumber(a,b,c) {
      if("number" == typeof b) {
        // new BigInteger(int,int,RNG)
        if(a < 2) this.fromInt(1);
        else {
          this.fromNumber(a,c);
          if(!this.testBit(a-1))	// force MSB set
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
          if(this.isEven()) this.dAddOffset(1,0); // force odd
          while(!this.isProbablePrime(b)) {
            this.dAddOffset(2,0);
            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
          }
        }
      }
      else {
        // new BigInteger(int,RNG)
        var x = new Array(), t = a&7;
        x.length = (a>>3)+1;
        b.nextBytes(x);
        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
        this.fromString(x,256);
      }
    }

    // (public) convert to bigendian byte array
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB-(i*this.DB)%8, d, k = 0;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
          r[k++] = d|(this.s<<(this.DB-p));
        while(i >= 0) {
          if(p < 8) {
            d = (this[i]&((1<<p)-1))<<(8-p);
            d |= this[--i]>>(p+=this.DB-8);
          }
          else {
            d = (this[i]>>(p-=8))&0xff;
            if(p <= 0) { p += this.DB; --i; }
          }
          if((d&0x80) != 0) d |= -256;
          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
          if(k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }

    function bnEquals(a) { return(this.compareTo(a)==0); }
    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

    // (protected) r = this op a (bitwise)
    function bnpBitwiseTo(a,op,r) {
      var i, f, m = Math.min(a.t,this.t);
      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
      if(a.t < this.t) {
        f = a.s&this.DM;
        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
        r.t = this.t;
      }
      else {
        f = this.s&this.DM;
        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
        r.t = a.t;
      }
      r.s = op(this.s,a.s);
      r.clamp();
    }

    // (public) this & a
    function op_and(x,y) { return x&y; }
    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

    // (public) this | a
    function op_or(x,y) { return x|y; }
    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

    // (public) this ^ a
    function op_xor(x,y) { return x^y; }
    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

    // (public) this & ~a
    function op_andnot(x,y) { return x&~y; }
    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

    // (public) ~this
    function bnNot() {
      var r = nbi();
      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }

    // (public) this << n
    function bnShiftLeft(n) {
      var r = nbi();
      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
      return r;
    }

    // (public) this >> n
    function bnShiftRight(n) {
      var r = nbi();
      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
      return r;
    }

    // return index of lowest 1-bit in x, x < 2^31
    function lbit(x) {
      if(x == 0) return -1;
      var r = 0;
      if((x&0xffff) == 0) { x >>= 16; r += 16; }
      if((x&0xff) == 0) { x >>= 8; r += 8; }
      if((x&0xf) == 0) { x >>= 4; r += 4; }
      if((x&3) == 0) { x >>= 2; r += 2; }
      if((x&1) == 0) ++r;
      return r;
    }

    // (public) returns index of lowest 1-bit (or -1 if none)
    function bnGetLowestSetBit() {
      for(var i = 0; i < this.t; ++i)
        if(this[i] != 0) return i*this.DB+lbit(this[i]);
      if(this.s < 0) return this.t*this.DB;
      return -1;
    }

    // return number of 1 bits in x
    function cbit(x) {
      var r = 0;
      while(x != 0) { x &= x-1; ++r; }
      return r;
    }

    // (public) return number of set bits
    function bnBitCount() {
      var r = 0, x = this.s&this.DM;
      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
      return r;
    }

    // (public) true iff nth bit is set
    function bnTestBit(n) {
      var j = Math.floor(n/this.DB);
      if(j >= this.t) return(this.s!=0);
      return((this[j]&(1<<(n%this.DB)))!=0);
    }

    // (protected) this op (1<<n)
    function bnpChangeBit(n,op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r,op,r);
      return r;
    }

    // (public) this | (1<<n)
    function bnSetBit(n) { return this.changeBit(n,op_or); }

    // (public) this & ~(1<<n)
    function bnClearBit(n) { return this.changeBit(n,op_andnot); }

    // (public) this ^ (1<<n)
    function bnFlipBit(n) { return this.changeBit(n,op_xor); }

    // (protected) r = this + a
    function bnpAddTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]+a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c += a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c += a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = (c<0)?-1:0;
      if(c > 0) r[i++] = c;
      else if(c < -1) r[i++] = this.DV+c;
      r.t = i;
      r.clamp();
    }

    // (public) this + a
    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

    // (public) this - a
    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

    // (public) this * a
    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

    // (public) this^2
    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

    // (public) this / a
    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

    // (public) this % a
    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

    // (public) [this/a,this%a]
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a,q,r);
      return new Array(q,r);
    }

    // (protected) this *= n, this >= 0, 1 < n < DV
    function bnpDMultiply(n) {
      this[this.t] = this.am(0,n-1,this,0,0,this.t);
      ++this.t;
      this.clamp();
    }

    // (protected) this += n << w words, this >= 0
    function bnpDAddOffset(n,w) {
      if(n == 0) return;
      while(this.t <= w) this[this.t++] = 0;
      this[w] += n;
      while(this[w] >= this.DV) {
        this[w] -= this.DV;
        if(++w >= this.t) this[this.t++] = 0;
        ++this[w];
      }
    }

    // A "null" reducer
    function NullExp() {}
    function nNop(x) { return x; }
    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
    function nSqrTo(x,r) { x.squareTo(r); }

    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;

    // (public) this^e
    function bnPow(e) { return this.exp(e,new NullExp()); }

    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    function bnpMultiplyLowerTo(a,n,r) {
      var i = Math.min(this.t+a.t,n);
      r.s = 0; // assumes a,this >= 0
      r.t = i;
      while(i > 0) r[--i] = 0;
      var j;
      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
      r.clamp();
    }

    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    function bnpMultiplyUpperTo(a,n,r) {
      --n;
      var i = r.t = this.t+a.t-n;
      r.s = 0; // assumes a,this >= 0
      while(--i >= 0) r[i] = 0;
      for(i = Math.max(n-this.t,0); i < a.t; ++i)
        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
      r.clamp();
      r.drShiftTo(1,r);
    }

    // Barrett modular reduction
    function Barrett(m) {
      // setup Barrett
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }

    function barrettConvert(x) {
      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
      else if(x.compareTo(this.m) < 0) return x;
      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
    }

    function barrettRevert(x) { return x; }

    // x = x mod m (HAC 14.42)
    function barrettReduce(x) {
      x.drShiftTo(this.m.t-1,this.r2);
      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
      x.subTo(this.r2,x);
      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = x^2 mod m; x != r
    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = x*y mod m; x,y != r
    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;

    // (public) this^e % m (HAC 14.85)
    function bnModPow(e,m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if(i <= 0) return r;
      else if(i < 18) k = 1;
      else if(i < 48) k = 3;
      else if(i < 144) k = 4;
      else if(i < 768) k = 5;
      else k = 6;
      if(i < 8)
        z = new Classic(m);
      else if(m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);

      // precomputation
      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
      g[1] = z.convert(this);
      if(k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1],g2);
        while(n <= km) {
          g[n] = nbi();
          z.mulTo(g2,g[n-2],g[n]);
          n += 2;
        }
      }

      var j = e.t-1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e[j])-1;
      while(j >= 0) {
        if(i >= k1) w = (e[j]>>(i-k1))&km;
        else {
          w = (e[j]&((1<<(i+1))-1))<<(k1-i);
          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
        }

        n = k;
        while((w&1) == 0) { w >>= 1; --n; }
        if((i -= n) < 0) { i += this.DB; --j; }
        if(is1) {	// ret == 1, don't bother squaring or multiplying it
          g[w].copyTo(r);
          is1 = false;
        }
        else {
          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
          z.mulTo(r2,g[w],r);
        }

        while(j >= 0 && (e[j]&(1<<i)) == 0) {
          z.sqrTo(r,r2); t = r; r = r2; r2 = t;
          if(--i < 0) { i = this.DB-1; --j; }
        }
      }
      return z.revert(r);
    }

    // (public) gcd(this,a) (HAC 14.54)
    function bnGCD(a) {
      var x = (this.s<0)?this.negate():this.clone();
      var y = (a.s<0)?a.negate():a.clone();
      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if(g < 0) return x;
      if(i < g) g = i;
      if(g > 0) {
        x.rShiftTo(g,x);
        y.rShiftTo(g,y);
      }
      while(x.signum() > 0) {
        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
        if(x.compareTo(y) >= 0) {
          x.subTo(y,x);
          x.rShiftTo(1,x);
        }
        else {
          y.subTo(x,y);
          y.rShiftTo(1,y);
        }
      }
      if(g > 0) y.lShiftTo(g,y);
      return y;
    }

    // (protected) this % n, n < 2^26
    function bnpModInt(n) {
      if(n <= 0) return 0;
      var d = this.DV%n, r = (this.s<0)?n-1:0;
      if(this.t > 0)
        if(d == 0) r = this[0]%n;
        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
      return r;
    }

    // (public) 1/this % m (HAC 14.61)
    function bnModInverse(m) {
      var ac = m.isEven();
      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while(u.signum() != 0) {
        while(u.isEven()) {
          u.rShiftTo(1,u);
          if(ac) {
            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
            a.rShiftTo(1,a);
          }
          else if(!b.isEven()) b.subTo(m,b);
          b.rShiftTo(1,b);
        }
        while(v.isEven()) {
          v.rShiftTo(1,v);
          if(ac) {
            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
            c.rShiftTo(1,c);
          }
          else if(!d.isEven()) d.subTo(m,d);
          d.rShiftTo(1,d);
        }
        if(u.compareTo(v) >= 0) {
          u.subTo(v,u);
          if(ac) a.subTo(c,a);
          b.subTo(d,b);
        }
        else {
          v.subTo(u,v);
          if(ac) c.subTo(a,c);
          d.subTo(b,d);
        }
      }
      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if(d.compareTo(m) >= 0) return d.subtract(m);
      if(d.signum() < 0) d.addTo(m,d); else return d;
      if(d.signum() < 0) return d.add(m); else return d;
    }

    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
    var lplim = (1<<26)/lowprimes[lowprimes.length-1];

    // (public) test primality with certainty >= 1-.5^t
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
        for(i = 0; i < lowprimes.length; ++i)
          if(x[0] == lowprimes[i]) return true;
        return false;
      }
      if(x.isEven()) return false;
      i = 1;
      while(i < lowprimes.length) {
        var m = lowprimes[i], j = i+1;
        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while(i < j) if(m%lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t);
    }

    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if(k <= 0) return false;
      var r = n1.shiftRight(k);
      t = (t+1)>>1;
      if(t > lowprimes.length) t = lowprimes.length;
      var a = nbi();
      for(var i = 0; i < t; ++i) {
        //Pick bases at random, instead of starting at 2
        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
        var y = a.modPow(r,this);
        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while(j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2,this);
            if(y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if(y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }

    // protected
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;

    // public
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

    // JSBN-specific extension
    BigInteger.prototype.square = bnSquare;

    // Expose the Barrett function
    BigInteger.prototype.Barrett = Barrett

    // BigInteger interfaces not implemented in jsbn:

    // BigInteger(int signum, byte[] magnitude)
    // double doubleValue()
    // float floatValue()
    // int hashCode()
    // long longValue()
    // static BigInteger valueOf(long val)
    if (typeof exports !== 'undefined') {
        exports = module.exports = BigInteger;
    } else {
        this.BigInteger = BigInteger;
    }

}).call(this);

},{}],203:[function(require,module,exports){
var cs2a = require("./cs2a.js");
var ecc = require("ecc-jsbn");
require("./forge.min.js"); // PITA not browserify compat
cs2a.crypt(ecc,forge);

Object.keys(cs2a).forEach(function(f){ exports[f] = cs2a[f]; });


},{"./cs2a.js":204,"./forge.min.js":205,"ecc-jsbn":206}],204:[function(require,module,exports){
(function (Buffer){
var crypto = require("crypto");
var sjcl = require("sjcl");

var self;
exports.install = function(telehash)
{
  self = telehash;
  telehash.CSets["2a"] = exports;
}

var forge;
exports.crypt = function(ecc,f)
{
  crypto.ecc = ecc;
  forge = f;
}

exports.genkey = function(ret,cbDone,cbStep)
{
	var state = forge.rsa.createKeyPairGenerationState(2048, 0x10001);
	var step = function() {
	  // run for 100 ms
	  if(!forge.rsa.stepKeyPairGenerationState(state, 100)) {
      if(cbStep) cbStep();
	    setTimeout(step, 10);
	  } else {
      var key = forge.asn1.toDer(forge.pki.publicKeyToAsn1(state.keys.publicKey)).bytes();
      ret["2a"] = forge.util.encode64(key);
      ret["2a_secret"] = forge.util.encode64(forge.asn1.toDer(forge.pki.privateKeyToAsn1(state.keys.privateKey)).bytes());
      cbDone();
	  }
	}
	setTimeout(step);  
}

exports.loadkey = function(id, pub, priv)
{
  // take pki or ber format
  if(pub.length > 300)
  {
    if(pub.substr(0,1) == "-") pub = forge.asn1.toDer(forge.pki.publicKeyToAsn1(forge.pki.publicKeyFromPem(key))).bytes();
    else pub = forge.util.decode64(pub);
  }
  id.key = pub;
  var pk = forge.pki.publicKeyFromAsn1(forge.asn1.fromDer(pub));    
  id.encrypt = function(buf){
    return new Buffer(pk.encrypt(buf.toString("binary"), "RSA-OAEP"), "binary");
  };
  id.verify = function(a,b){
    return pk.verify(a.toString("binary"), b.toString("binary"));
  };
  if(priv)
  {
    var sk = (priv.substr(0,1) == "-") ? forge.pki.privateKeyFromPem(priv) :  forge.pki.privateKeyFromAsn1(forge.asn1.fromDer(forge.util.decode64(priv)));
    id.sign = function(buf){
    	var md = forge.md.sha256.create();
    	md.update(buf.toString("binary"));
      return new Buffer(sk.sign(md),"binary");
    };
    id.decrypt = function(buf){
      return new Buffer(sk.decrypt(buf.toString("binary"), "RSA-OAEP"),"binary");
    };
  }
  return false;
}

exports.openize = function(id, to, inner)
{
	if(!to.ecc) to.ecc = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp256r1);
  var eccpub = to.ecc.PublicKey.slice(1);

	// encrypt the body
  var ibody = (!Buffer.isBuffer(inner)) ? self.pencode(inner,id.cs["2a"].key) : inner;
  var keyhex = crypto.createHash("sha256").update(eccpub).digest("hex");
  var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
  var iv = sjcl.codec.hex.toBits("00000000000000000000000000000001");
  var cipher = sjcl.mode.gcm.encrypt(key, sjcl.codec.hex.toBits(ibody.toString("hex")), iv, [], 128);
  var cbody = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");

	// sign & encrypt the sig
  var sig = id.cs["2a"].sign(cbody);
  if(!to.lineOut) to.lineOut = ""; // no lines for tickets
  var keyhex = crypto.createHash("sha256").update(Buffer.concat([eccpub,new Buffer(to.lineOut,"hex")])).digest("hex");
  var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
  var cipher = sjcl.mode.gcm.encrypt(key, sjcl.codec.hex.toBits(sig.toString("hex")), iv, [], 32);
  var csig = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");

	// encrypt the ecc key
  var ekey = to.encrypt(eccpub);

  var body = Buffer.concat([ekey,csig,cbody]);    
  //	console.log(open, body.length);
	var packet = self.pencode(0x2a, body);
	return packet;
}

exports.deopenize = function(id, open)
{
  var ret = {verify:false};
  // grab the chunks
  var ekey = open.body.slice(0,256);
  var csig = open.body.slice(256,256+260);
  var cbody = open.body.slice(256+260);

  // decrypt the ecc public key and verify/load it
  var eccpub = id.cs["2a"].decrypt(ekey);
  if(!eccpub) return ret;
  try {
    ret.linepub = new crypto.ecc.ECKey(crypto.ecc.ECCurves.secp256r1, Buffer.concat([new Buffer("04","hex"),eccpub]), true);
  }catch(E){};
  if(!ret.linepub) return ret;

  // decipher the body as a packet so we can examine it
  var keyhex = crypto.createHash("sha256").update(eccpub).digest("hex");
  var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
  var iv = sjcl.codec.hex.toBits("00000000000000000000000000000001");
  var cipher = sjcl.mode.gcm.decrypt(key, sjcl.codec.hex.toBits(cbody.toString("hex")), iv, [], 128);
  var ibody = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");
  var deciphered = self.pdecode(ibody);
  if(!deciphered || !deciphered.body) return ret;
  ret.js = deciphered.js;
  ret.inner = deciphered;
  
  var from = {};
  var lineIn;
  if(!open.from)
  {
    // extract attached public key
    ret.key = deciphered.body;
    if(exports.loadkey(from,deciphered.body)) return ret;
    lineIn = deciphered.js.line;
  }else{
    from = open.from;
    lineIn = "";
  }

  // decrypt signature
  var keyhex = crypto.createHash("sha256").update(Buffer.concat([eccpub,new Buffer(lineIn,"hex")])).digest("hex");
  var key = new sjcl.cipher.aes(sjcl.codec.hex.toBits(keyhex));
  var cipher = sjcl.mode.gcm.decrypt(key, sjcl.codec.hex.toBits(csig.toString("hex")), iv, [], 32);
  var sig = new Buffer(sjcl.codec.hex.fromBits(cipher), "hex");

  // verify signature
  ret.verify = from.verify(cbody,sig);
  return ret;
}

// set up the line enc/dec keys
exports.openline = function(from, open)
{
  var ecdhe = from.ecc.deriveSharedSecret(open.linepub);
  from.lineInB = new Buffer(from.lineIn, "hex");
  var hex = crypto.createHash("sha256")
    .update(ecdhe)
    .update(new Buffer(from.lineOut, "hex"))
    .update(new Buffer(from.lineIn, "hex"))
    .digest("hex");
  from.encKey = new sjcl.cipher.aes(sjcl.codec.hex.toBits(hex));
  var hex = crypto.createHash("sha256")
    .update(ecdhe)
    .update(new Buffer(from.lineIn, "hex"))
    .update(new Buffer(from.lineOut, "hex"))
    .digest("hex");
  from.decKey = new sjcl.cipher.aes(sjcl.codec.hex.toBits(hex));
  return true;
}

exports.lineize = function(to, packet)
{
  var iv = crypto.randomBytes(16);
  var buf = self.pencode(packet.js,packet.body);

	// now encrypt the packet
  var cipher = sjcl.mode.gcm.encrypt(to.encKey, sjcl.codec.hex.toBits(buf.toString("hex")), sjcl.codec.hex.toBits(iv.toString("hex")), [], 128);
  var cbody = new Buffer(sjcl.codec.hex.fromBits(cipher),"hex");

  var body = Buffer.concat([to.lineInB,iv,cbody]);
	return self.pencode(null,body);
},

exports.delineize = function(from, packet)
{
  if(!packet.body) return "missing body";
  // remove lineid
  packet.body = packet.body.slice(16);
  var iv = sjcl.codec.hex.toBits(packet.body.slice(0,16).toString("hex"));

  try{
    var cipher = sjcl.mode.gcm.decrypt(from.decKey, sjcl.codec.hex.toBits(packet.body.slice(16).toString("hex")), iv, [], 128);    
  }catch(E){
    return E;
  }
  if(!cipher) return "no cipher output";
  var deciphered = self.pdecode(new Buffer(sjcl.codec.hex.fromBits(cipher),"hex"));
	if(!deciphered) return "invalid decrypted packet";

  packet.js = deciphered.js;
  packet.body = deciphered.body;
  return false;
}


}).call(this,require("buffer").Buffer)
},{"buffer":1,"crypto":5,"sjcl":210}],205:[function(require,module,exports){
module.exports=require(198)
},{"/home/ryan/.local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":16}],206:[function(require,module,exports){
arguments[4][199][0].apply(exports,arguments)
},{"./lib/ec.js":207,"./lib/sec.js":208,"buffer":1,"crypto":5,"jsbn":209}],207:[function(require,module,exports){
module.exports=require(200)
},{"jsbn":209}],208:[function(require,module,exports){
arguments[4][201][0].apply(exports,arguments)
},{"./ec.js":207,"jsbn":209}],209:[function(require,module,exports){
module.exports=require(202)
},{}],210:[function(require,module,exports){
"use strict";function q(a){throw a;}var t=void 0,u=!1;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return"CORRUPT: "+this.message};this.message=a},invalid:function(a){this.toString=function(){return"INVALID: "+this.message};this.message=a},bug:function(a){this.toString=function(){return"BUG: "+this.message};this.message=a},notReady:function(a){this.toString=function(){return"NOT READY: "+this.message};this.message=a}}};
"undefined"!==typeof module&&module.exports&&(module.exports=sjcl);
sjcl.cipher.aes=function(a){this.k[0][0][0]||this.D();var b,c,d,e,f=this.k[0][4],g=this.k[1];b=a.length;var h=1;4!==b&&(6!==b&&8!==b)&&q(new sjcl.exception.invalid("invalid aes key size"));this.b=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(0===a%b||8===b&&4===a%b)c=f[c>>>24]<<24^f[c>>16&255]<<16^f[c>>8&255]<<8^f[c&255],0===a%b&&(c=c<<8^c>>>24^h<<24,h=h<<1^283*(h>>7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&3?a:a-4],e[b]=4>=a||4>b?c:g[0][f[c>>>24]]^g[1][f[c>>16&255]]^g[2][f[c>>8&255]]^g[3][f[c&
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return y(this,a,0)},decrypt:function(a){return y(this,a,1)},k:[[[],[],[],[],[]],[[],[],[],[],[]]],D:function(){var a=this.k[0],b=this.k[1],c=a[4],d=b[4],e,f,g,h=[],l=[],k,n,m,p;for(e=0;0x100>e;e++)l[(h[e]=e<<1^283*(e>>7))^e]=e;for(f=g=0;!c[f];f^=k||1,g=l[g]||1){m=g^g<<1^g<<2^g<<3^g<<4;m=m>>8^m&255^99;c[f]=m;d[m]=f;n=h[e=h[k=h[f]]];p=0x1010101*n^0x10001*e^0x101*k^0x1010100*f;n=0x101*h[m]^0x1010100*m;for(e=0;4>e;e++)a[e][f]=n=n<<24^n>>>8,b[e][m]=p=p<<24^p>>>8}for(e=
0;5>e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function y(a,b,c){4!==b.length&&q(new sjcl.exception.invalid("invalid aes block size"));var d=a.b[c],e=b[0]^d[0],f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,l,k,n=d.length/4-2,m,p=4,s=[0,0,0,0];h=a.k[c];a=h[0];var r=h[1],v=h[2],w=h[3],x=h[4];for(m=0;m<n;m++)h=a[e>>>24]^r[f>>16&255]^v[g>>8&255]^w[b&255]^d[p],l=a[f>>>24]^r[g>>16&255]^v[b>>8&255]^w[e&255]^d[p+1],k=a[g>>>24]^r[b>>16&255]^v[e>>8&255]^w[f&255]^d[p+2],b=a[b>>>24]^r[e>>16&255]^v[f>>8&255]^w[g&255]^d[p+3],p+=4,e=h,f=l,g=k;for(m=0;4>
m;m++)s[c?3&-m:m]=x[e>>>24]<<24^x[f>>16&255]<<16^x[g>>8&255]<<8^x[b&255]^d[p++],h=e,e=f,f=g,g=b,b=h;return s}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.P(a.slice(b/32),32-(b&31)).slice(1);return c===t?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.P(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b&=31;0<c&&b&&(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b<<32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return u;var c=0,d;for(d=0;d<a.length;d++)c|=a[d]^b[d];return 0===
c},P:function(a,b,c,d){var e;e=0;for(d===t&&(d=[]);32<=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0;e<a.length;e++)d.push(c|a[e]>>>b),c=a[e]<<32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,32<b+a?c:d.pop(),1));return d},l:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]}};
sjcl.codec.utf8String={fromBits:function(a){var b="",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b+=String.fromCharCode(e>>>24),e<<=8;return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a.charCodeAt(c),3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b="",c;for(c=0;c<a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,"");d=a.length;a+="00000000";for(b=0;b<a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base64={J:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",fromBits:function(a,b,c){var d="",e=0,f=sjcl.codec.base64.J,g=0,h=sjcl.bitArray.bitLength(a);c&&(f=f.substr(0,62)+"-_");for(c=0;6*d.length<h;)d+=f.charAt((g^a[c]>>>e)>>>26),6>e?(g=a[c]<<6-e,e+=26,c++):(g<<=6,e-=6);for(;d.length&3&&!b;)d+="=";return d},toBits:function(a,b){a=a.replace(/\s|=/g,"");var c=[],d,e=0,f=sjcl.codec.base64.J,g=0,h;b&&(f=f.substr(0,62)+"-_");for(d=0;d<a.length;d++)h=f.indexOf(a.charAt(d)),
0>h&&q(new sjcl.exception.invalid("this isn't base64!")),26<e?(e-=26,c.push(g^h>>>e),g=h<<32-e):(e+=6,g^=h<<32-e);e&56&&c.push(sjcl.bitArray.partial(e&56,g,1));return c}};sjcl.codec.base64url={fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash.sha256=function(a){this.b[0]||this.D();a?(this.r=a.r.slice(0),this.o=a.o.slice(0),this.h=a.h):this.reset()};sjcl.hash.sha256.hash=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.r=this.N.slice(0);this.o=[];this.h=0;return this},update:function(a){"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.o=sjcl.bitArray.concat(this.o,a);b=this.h;a=this.h=b+sjcl.bitArray.bitLength(a);for(b=512+b&-512;b<=a;b+=512)z(this,c.splice(0,16));return this},finalize:function(){var a,b=this.o,c=this.r,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.h/
4294967296));for(b.push(this.h|0);b.length;)z(this,b.splice(0,16));this.reset();return c},N:[],b:[],D:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}var b=0,c=2,d;a:for(;64>b;c++){for(d=2;d*d<=c;d++)if(0===c%d)continue a;8>b&&(this.N[b]=a(Math.pow(c,0.5)));this.b[b]=a(Math.pow(c,1/3));b++}}};
function z(a,b){var c,d,e,f=b.slice(0),g=a.r,h=a.b,l=g[0],k=g[1],n=g[2],m=g[3],p=g[4],s=g[5],r=g[6],v=g[7];for(c=0;64>c;c++)16>c?d=f[c]:(d=f[c+1&15],e=f[c+14&15],d=f[c&15]=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+f[c&15]+f[c+9&15]|0),d=d+v+(p>>>6^p>>>11^p>>>25^p<<26^p<<21^p<<7)+(r^p&(s^r))+h[c],v=r,r=s,s=p,p=m+d|0,m=n,n=k,k=l,l=d+(k&n^m&(k^n))+(k>>>2^k>>>13^k>>>22^k<<30^k<<19^k<<10)|0;g[0]=g[0]+l|0;g[1]=g[1]+k|0;g[2]=g[2]+n|0;g[3]=g[3]+m|0;g[4]=g[4]+p|0;g[5]=g[5]+s|0;g[6]=
g[6]+r|0;g[7]=g[7]+v|0}
sjcl.mode.ccm={name:"ccm",encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,l=h.bitLength(c)/8,k=h.bitLength(g)/8;e=e||64;d=d||[];7>l&&q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes"));for(f=2;4>f&&k>>>8*f;f++);f<15-l&&(f=15-l);c=h.clamp(c,8*(15-f));b=sjcl.mode.ccm.L(a,b,c,d,e,f);g=sjcl.mode.ccm.p(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),l=f.clamp(b,h-e),k=f.bitSlice(b,
h-e),h=(h-e)/8;7>g&&q(new sjcl.exception.invalid("ccm: iv must be at least 7 bytes"));for(b=2;4>b&&h>>>8*b;b++);b<15-g&&(b=15-g);c=f.clamp(c,8*(15-b));l=sjcl.mode.ccm.p(a,l,c,k,e,b);a=sjcl.mode.ccm.L(a,l.data,c,d,e,b);f.equal(l.tag,a)||q(new sjcl.exception.corrupt("ccm: tag doesn't match"));return l.data},L:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,l=h.l;e/=8;(e%2||4>e||16<e)&&q(new sjcl.exception.invalid("ccm: invalid tag length"));(0xffffffff<d.length||0xffffffff<b.length)&&q(new sjcl.exception.bug("ccm: can't deal with 4GiB or more data"));
f=[h.partial(8,(d.length?64:0)|e-2<<2|f-1)];f=h.concat(f,c);f[3]|=h.bitLength(b)/8;f=a.encrypt(f);if(d.length){c=h.bitLength(d)/8;65279>=c?g=[h.partial(16,c)]:0xffffffff>=c&&(g=h.concat([h.partial(16,65534)],[c]));g=h.concat(g,d);for(d=0;d<g.length;d+=4)f=a.encrypt(l(f,g.slice(d,d+4).concat([0,0,0])))}for(d=0;d<b.length;d+=4)f=a.encrypt(l(f,b.slice(d,d+4).concat([0,0,0])));return h.clamp(f,8*e)},p:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.l;var l=b.length,k=h.bitLength(b);c=h.concat([h.partial(8,
f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!l)return{tag:d,data:[]};for(g=0;g<l;g+=4)c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,k)}}};
sjcl.mode.ocb2={name:"ocb2",encrypt:function(a,b,c,d,e,f){128!==sjcl.bitArray.bitLength(c)&&q(new sjcl.exception.invalid("ocb iv must be 128 bits"));var g,h=sjcl.mode.ocb2.H,l=sjcl.bitArray,k=l.l,n=[0,0,0,0];c=h(a.encrypt(c));var m,p=[];d=d||[];e=e||64;for(g=0;g+4<b.length;g+=4)m=b.slice(g,g+4),n=k(n,m),p=p.concat(k(c,a.encrypt(k(c,m)))),c=h(c);m=b.slice(g);b=l.bitLength(m);g=a.encrypt(k(c,[0,0,0,b]));m=l.clamp(k(m.concat([0,0,0]),g),b);n=k(n,k(m.concat([0,0,0]),g));n=a.encrypt(k(n,k(c,h(c))));d.length&&
(n=k(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(l.concat(m,l.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){128!==sjcl.bitArray.bitLength(c)&&q(new sjcl.exception.invalid("ocb iv must be 128 bits"));e=e||64;var g=sjcl.mode.ocb2.H,h=sjcl.bitArray,l=h.l,k=[0,0,0,0],n=g(a.encrypt(c)),m,p,s=sjcl.bitArray.bitLength(b)-e,r=[];d=d||[];for(c=0;c+4<s/32;c+=4)m=l(n,a.decrypt(l(n,b.slice(c,c+4)))),k=l(k,m),r=r.concat(m),n=g(n);p=s-32*c;m=a.encrypt(l(n,[0,0,0,p]));m=l(m,h.clamp(b.slice(c),p).concat([0,0,0]));
k=l(k,m);k=a.encrypt(l(k,l(n,g(n))));d.length&&(k=l(k,f?d:sjcl.mode.ocb2.pmac(a,d)));h.equal(h.clamp(k,e),h.bitSlice(b,s))||q(new sjcl.exception.corrupt("ocb: tag doesn't match"));return r.concat(h.clamp(m,p))},pmac:function(a,b){var c,d=sjcl.mode.ocb2.H,e=sjcl.bitArray,f=e.l,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4<b.length;c+=4)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128>e.bitLength(c)&&(h=f(h,d(h)),c=e.concat(c,[-2147483648,0,0,0]));g=f(g,c);return a.encrypt(f(d(f(h,
d(h))),g))},H:function(a){return[a[0]<<1^a[1]>>>31,a[1]<<1^a[2]>>>31,a[2]<<1^a[3]>>>31,a[3]<<1^135*(a[0]>>>31)]}};
sjcl.mode.gcm={name:"gcm",encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.p(!0,a,f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||128;d=d||[];e<=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.p(u,a,f,d,c,e);g.equal(a.tag,b)||q(new sjcl.exception.corrupt("gcm: tag doesn't match"));return a.data},Z:function(a,b){var c,d,e,f,g,h=sjcl.bitArray.l;e=[0,0,0,0];f=b.slice(0);
for(c=0;128>c;c++){(d=0!==(a[Math.floor(c/32)]&1<<31-c%32))&&(e=h(e,f));g=0!==(f[3]&1);for(d=3;0<d;d--)f[d]=f[d]>>>1|(f[d-1]&1)<<31;f[0]>>>=1;g&&(f[0]^=-0x1f000000)}return e},g:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d<e;d+=4)b[0]^=0xffffffff&c[d],b[1]^=0xffffffff&c[d+1],b[2]^=0xffffffff&c[d+2],b[3]^=0xffffffff&c[d+3],b=sjcl.mode.gcm.Z(b,a);return b},p:function(a,b,c,d,e,f){var g,h,l,k,n,m,p,s,r=sjcl.bitArray;m=c.length;p=r.bitLength(c);s=r.bitLength(d);h=r.bitLength(e);g=b.encrypt([0,
0,0,0]);96===h?(e=e.slice(0),e=r.concat(e,[1])):(e=sjcl.mode.gcm.g(g,[0,0,0,0],e),e=sjcl.mode.gcm.g(g,e,[0,0,Math.floor(h/0x100000000),h&0xffffffff]));h=sjcl.mode.gcm.g(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.g(g,h,c));for(k=0;k<m;k+=4)n[3]++,l=b.encrypt(n),c[k]^=l[0],c[k+1]^=l[1],c[k+2]^=l[2],c[k+3]^=l[3];c=r.clamp(c,p);a&&(d=sjcl.mode.gcm.g(g,h,c));a=[Math.floor(s/0x100000000),s&0xffffffff,Math.floor(p/0x100000000),p&0xffffffff];d=sjcl.mode.gcm.g(g,d,a);l=b.encrypt(e);d[0]^=l[0];
d[1]^=l[1];d[2]^=l[2];d[3]^=l[3];return{tag:r.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.M=b=b||sjcl.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.n=[new b,new b];a.length>e&&(a=b.hash(a));for(d=0;d<e;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.n[0].update(c[0]);this.n[1].update(c[1]);this.G=new b(this.n[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){this.Q&&q(new sjcl.exception.invalid("encrypt on already updated hmac called!"));this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.G=new this.M(this.n[0]);this.Q=u};sjcl.misc.hmac.prototype.update=function(a){this.Q=!0;this.G.update(a)};sjcl.misc.hmac.prototype.digest=function(){var a=this.G.finalize(),a=(new this.M(this.n[1])).update(a).finalize();this.reset();return a};
sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E3;(0>d||0>c)&&q(sjcl.exception.invalid("invalid params to pbkdf2"));"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,l,k=[],n=sjcl.bitArray;for(l=1;32*k.length<(d||1);l++){e=f=a.encrypt(n.concat(b,[l]));for(g=1;g<c;g++){f=a.encrypt(f);for(h=0;h<f.length;h++)e[h]^=f[h]}k=k.concat(e)}d&&(k=n.clamp(k,d));return k};
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.i=[0];this.F=0;this.s={};this.C=0;this.K={};this.O=this.d=this.j=this.W=0;this.b=[0,0,0,0,0,0,0,0];this.f=[0,0,0,0];this.A=t;this.B=a;this.q=u;this.w={progress:{},seeded:{}};this.m=this.V=0;this.t=1;this.u=2;this.S=0x10000;this.I=[0,48,64,96,128,192,0x100,384,512,768,1024];this.T=3E4;this.R=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;d===this.m&&q(new sjcl.exception.notReady("generator isn't seeded"));if(d&this.u){d=!(d&this.t);e=[];var f=0,g;this.O=e[0]=(new Date).valueOf()+this.T;for(g=0;16>g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g<this.c.length&&!(e=e.concat(this.c[g].finalize()),f+=this.i[g],this.i[g]=0,!d&&this.F&1<<g);g++);this.F>=1<<this.c.length&&(this.c.push(new sjcl.hash.sha256),this.i.push(0));this.d-=f;f>this.j&&(this.j=f);this.F++;
this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.A=new sjcl.cipher.aes(this.b);for(d=0;4>d&&!(this.f[d]=this.f[d]+1|0,this.f[d]);d++);}for(d=0;d<a;d+=4)0===(d+1)%this.S&&A(this),e=B(this),c.push(e[0],e[1],e[2],e[3]);A(this);return c.slice(0,a)},setDefaultParanoia:function(a,b){0===a&&"Setting paranoia=0 will ruin your security; use it only for testing"!==b&&q("Setting paranoia=0 will ruin your security; use it only for testing");this.B=a},addEntropy:function(a,b,c){c=c||"user";var d,e,f=(new Date).valueOf(),
g=this.s[c],h=this.isReady(),l=0;d=this.K[c];d===t&&(d=this.K[c]=this.W++);g===t&&(g=this.s[c]=0);this.s[c]=(this.s[c]+1)%this.c.length;switch(typeof a){case "number":b===t&&(b=1);this.c[g].update([d,this.C++,1,b,f,1,a|0]);break;case "object":c=Object.prototype.toString.call(a);if("[object Uint32Array]"===c){e=[];for(c=0;c<a.length;c++)e.push(a[c]);a=e}else{"[object Array]"!==c&&(l=1);for(c=0;c<a.length&&!l;c++)"number"!==typeof a[c]&&(l=1)}if(!l){if(b===t)for(c=b=0;c<a.length;c++)for(e=a[c];0<e;)b++,
e>>>=1;this.c[g].update([d,this.C++,2,b,f,a.length].concat(a))}break;case "string":b===t&&(b=a.length);this.c[g].update([d,this.C++,3,b,f,a.length]);this.c[g].update(a);break;default:l=1}l&&q(new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string"));this.i[g]+=b;this.d+=b;h===this.m&&(this.isReady()!==this.m&&C("seeded",Math.max(this.j,this.d)),C("progress",this.getProgress()))},isReady:function(a){a=this.I[a!==t?a:this.B];return this.j&&this.j>=a?this.i[0]>this.R&&
(new Date).valueOf()>this.O?this.u|this.t:this.t:this.d>=a?this.u|this.m:this.m},getProgress:function(a){a=this.I[a?a:this.B];return this.j>=a?1:this.d>a?1:this.d/a},startCollectors:function(){this.q||(this.a={loadTimeCollector:D(this,this.aa),mouseCollector:D(this,this.ba),keyboardCollector:D(this,this.$),accelerometerCollector:D(this,this.U)},window.addEventListener?(window.addEventListener("load",this.a.loadTimeCollector,u),window.addEventListener("mousemove",this.a.mouseCollector,u),window.addEventListener("keypress",
this.a.keyboardCollector,u),window.addEventListener("devicemotion",this.a.accelerometerCollector,u)):document.attachEvent?(document.attachEvent("onload",this.a.loadTimeCollector),document.attachEvent("onmousemove",this.a.mouseCollector),document.attachEvent("keypress",this.a.keyboardCollector)):q(new sjcl.exception.bug("can't attach event")),this.q=!0)},stopCollectors:function(){this.q&&(window.removeEventListener?(window.removeEventListener("load",this.a.loadTimeCollector,u),window.removeEventListener("mousemove",
this.a.mouseCollector,u),window.removeEventListener("keypress",this.a.keyboardCollector,u),window.removeEventListener("devicemotion",this.a.accelerometerCollector,u)):document.detachEvent&&(document.detachEvent("onload",this.a.loadTimeCollector),document.detachEvent("onmousemove",this.a.mouseCollector),document.detachEvent("keypress",this.a.keyboardCollector)),this.q=u)},addEventListener:function(a,b){this.w[a][this.V++]=b},removeEventListener:function(a,b){var c,d,e=this.w[a],f=[];for(d in e)e.hasOwnProperty(d)&&
e[d]===b&&f.push(d);for(c=0;c<f.length;c++)d=f[c],delete e[d]},$:function(){E(1)},ba:function(a){sjcl.random.addEntropy([a.x||a.clientX||a.offsetX||0,a.y||a.clientY||a.offsetY||0],2,"mouse");E(0)},aa:function(){E(2)},U:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity.z;if(window.orientation){var b=window.orientation;"number"===typeof b&&sjcl.random.addEntropy(b,1,"accelerometer")}a&&sjcl.random.addEntropy(a,2,"accelerometer");E(0)}};
function C(a,b){var c,d=sjcl.random.w[a],e=[];for(c in d)d.hasOwnProperty(c)&&e.push(d[c]);for(c=0;c<e.length;c++)e[c](b)}function E(a){window&&window.performance&&"function"===typeof window.performance.now?sjcl.random.addEntropy(window.performance.now(),a,"loadtime"):sjcl.random.addEntropy((new Date).valueOf(),a,"loadtime")}function A(a){a.b=B(a).concat(B(a));a.A=new sjcl.cipher.aes(a.b)}function B(a){for(var b=0;4>b&&!(a.f[b]=a.f[b]+1|0,a.f[b]);b++);return a.A.encrypt(a.f)}
function D(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var F,G,H,I;if(I="undefined"!==typeof module){var J;if(J=module.exports){var K;try{K=require("crypto")}catch(L){K=null}J=(G=K)&&G.randomBytes}I=J}if(I)F=G.randomBytes(128),F=new Uint32Array((new Uint8Array(F)).buffer),sjcl.random.addEntropy(F,1024,"crypto['randomBytes']");else if(window&&Uint32Array){H=new Uint32Array(32);if(window.crypto&&window.crypto.getRandomValues)window.crypto.getRandomValues(H);else if(window.msCrypto&&window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(H);
else break a;sjcl.random.addEntropy(H,1024,"crypto['getRandomValues']")}}catch(M){"undefined"!==typeof window&&window.console&&(console.log("There was an error collecting entropy from the browser:"),console.log(M))}
sjcl.json={defaults:{v:1,iter:1E3,ks:128,ts:64,mode:"ccm",adata:"",cipher:"aes"},Y:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json,f=e.e({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.e(f,c);c=f.adata;"string"===typeof f.salt&&(f.salt=sjcl.codec.base64.toBits(f.salt));"string"===typeof f.iv&&(f.iv=sjcl.codec.base64.toBits(f.iv));(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||"string"===typeof a&&100>=f.iter||64!==f.ts&&96!==f.ts&&128!==f.ts||128!==f.ks&&192!==f.ks&&0x100!==f.ks||2>f.iv.length||4<
f.iv.length)&&q(new sjcl.exception.invalid("json encrypt: invalid parameters"));"string"===typeof a?(g=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.publicKey&&(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));"string"===typeof c&&(c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.e(d,f);d.key=a;f.ct=sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt:function(a,
b,c,d){var e=sjcl.json,f=e.Y.apply(e,arguments);return e.encode(f)},X:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json;b=e.e(e.e(e.e({},e.defaults),b),c,!0);var f;c=b.adata;"string"===typeof b.salt&&(b.salt=sjcl.codec.base64.toBits(b.salt));"string"===typeof b.iv&&(b.iv=sjcl.codec.base64.toBits(b.iv));(!sjcl.mode[b.mode]||!sjcl.cipher[b.cipher]||"string"===typeof a&&100>=b.iter||64!==b.ts&&96!==b.ts&&128!==b.ts||128!==b.ks&&192!==b.ks&&0x100!==b.ks||!b.iv||2>b.iv.length||4<b.iv.length)&&q(new sjcl.exception.invalid("json decrypt: invalid parameters"));
"string"===typeof a?(f=sjcl.misc.cachedPbkdf2(a,b),a=f.key.slice(0,b.ks/32),b.salt=f.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.secretKey&&(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));"string"===typeof c&&(c=sjcl.codec.utf8String.toBits(c));f=new sjcl.cipher[b.cipher](a);c=sjcl.mode[b.mode].decrypt(f,b.ct,b.iv,c,b.ts);e.e(d,b);d.key=a;return sjcl.codec.utf8String.fromBits(c)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.X(a,e.decode(b),c,d)},encode:function(a){var b,c=
"{",d="";for(b in a)if(a.hasOwnProperty(b))switch(b.match(/^[a-z0-9]+$/i)||q(new sjcl.exception.invalid("json encode: invalid property name")),c+=d+'"'+b+'":',d=",",typeof a[b]){case "number":case "boolean":c+=a[b];break;case "string":c+='"'+escape(a[b])+'"';break;case "object":c+='"'+sjcl.codec.base64.fromBits(a[b],0)+'"';break;default:q(new sjcl.exception.bug("json encode: unsupported type"))}return c+"}"},decode:function(a){a=a.replace(/\s/g,"");a.match(/^\{.*\}$/)||q(new sjcl.exception.invalid("json decode: this isn't json!"));
a=a.replace(/^\{|\}$/g,"").split(/,/);var b={},c,d;for(c=0;c<a.length;c++)(d=a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i))||q(new sjcl.exception.invalid("json decode: this isn't json!")),b[d[2]]=d[3]?parseInt(d[3],10):d[2].match(/^(ct|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape(d[4]);return b},e:function(a,b,c){a===t&&(a={});if(b===t)return a;for(var d in b)b.hasOwnProperty(d)&&(c&&(a[d]!==t&&a[d]!==b[d])&&q(new sjcl.exception.invalid("required parameter overridden")),
a[d]=b[d]);return a},ea:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&&a[d]!==b[d]&&(c[d]=a[d]);return c},da:function(a,b){var c={},d;for(d=0;d<b.length;d++)a[b[d]]!==t&&(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl.decrypt=sjcl.json.decrypt;sjcl.misc.ca={};
sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.ca,d;b=b||{};d=b.iter||1E3;c=c[a]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&&b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=b.salt===t?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};

},{"crypto":5}],211:[function(require,module,exports){
(function (Buffer){
var io = require("socket.io-client");

exports.install = function(self)
{
  var sockets = {};
  self.deliver("http", function(path, msg, to) {
    if(!sockets[path.http]){
      sockets[path.http] = io.connect(path.http);
      sockets[path.http].on("packet", function(packet){
        self.receive((new Buffer(packet.data, "base64")).toString("binary"), path);
      });
    }
    sockets[path.http].emit("packet", {data: msg.toString("base64")});
  });  
}


}).call(this,require("buffer").Buffer)
},{"buffer":1,"socket.io-client":212}],212:[function(require,module,exports){
/*! Socket.IO.js build:0.9.16, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */

var io = ('undefined' === typeof module ? {} : module.exports);
(function() {

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, global) {

  /**
   * IO namespace.
   *
   * @namespace
   */

  var io = exports;

  /**
   * Socket.IO version
   *
   * @api public
   */

  io.version = '0.9.16';

  /**
   * Protocol implemented.
   *
   * @api public
   */

  io.protocol = 1;

  /**
   * Available transports, these will be populated with the available transports
   *
   * @api public
   */

  io.transports = [];

  /**
   * Keep track of jsonp callbacks.
   *
   * @api private
   */

  io.j = [];

  /**
   * Keep track of our io.Sockets
   *
   * @api private
   */
  io.sockets = {};


  /**
   * Manages connections to hosts.
   *
   * @param {String} uri
   * @Param {Boolean} force creation of new socket (defaults to false)
   * @api public
   */

  io.connect = function (host, details) {
    var uri = io.util.parseUri(host)
      , uuri
      , socket;

    if (global && global.location) {
      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);
      uri.host = uri.host || (global.document
        ? global.document.domain : global.location.hostname);
      uri.port = uri.port || global.location.port;
    }

    uuri = io.util.uniqueUri(uri);

    var options = {
        host: uri.host
      , secure: 'https' == uri.protocol
      , port: uri.port || ('https' == uri.protocol ? 443 : 80)
      , query: uri.query || ''
    };

    io.util.merge(options, details);

    if (options['force new connection'] || !io.sockets[uuri]) {
      socket = new io.Socket(options);
    }

    if (!options['force new connection'] && socket) {
      io.sockets[uuri] = socket;
    }

    socket = socket || io.sockets[uuri];

    // if path is different from '' or /
    return socket.of(uri.path.length > 1 ? uri.path : '');
  };

})('object' === typeof module ? module.exports : (this.io = {}), this);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, global) {

  /**
   * Utilities namespace.
   *
   * @namespace
   */

  var util = exports.util = {};

  /**
   * Parses an URI
   *
   * @author Steven Levithan <stevenlevithan.com> (MIT license)
   * @api public
   */

  var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',
               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',
               'anchor'];

  util.parseUri = function (str) {
    var m = re.exec(str || '')
      , uri = {}
      , i = 14;

    while (i--) {
      uri[parts[i]] = m[i] || '';
    }

    return uri;
  };

  /**
   * Produces a unique url that identifies a Socket.IO connection.
   *
   * @param {Object} uri
   * @api public
   */

  util.uniqueUri = function (uri) {
    var protocol = uri.protocol
      , host = uri.host
      , port = uri.port;

    if ('document' in global) {
      host = host || document.domain;
      port = port || (protocol == 'https'
        && document.location.protocol !== 'https:' ? 443 : document.location.port);
    } else {
      host = host || 'localhost';

      if (!port && protocol == 'https') {
        port = 443;
      }
    }

    return (protocol || 'http') + '://' + host + ':' + (port || 80);
  };

  /**
   * Mergest 2 query strings in to once unique query string
   *
   * @param {String} base
   * @param {String} addition
   * @api public
   */

  util.query = function (base, addition) {
    var query = util.chunkQuery(base || '')
      , components = [];

    util.merge(query, util.chunkQuery(addition || ''));
    for (var part in query) {
      if (query.hasOwnProperty(part)) {
        components.push(part + '=' + query[part]);
      }
    }

    return components.length ? '?' + components.join('&') : '';
  };

  /**
   * Transforms a querystring in to an object
   *
   * @param {String} qs
   * @api public
   */

  util.chunkQuery = function (qs) {
    var query = {}
      , params = qs.split('&')
      , i = 0
      , l = params.length
      , kv;

    for (; i < l; ++i) {
      kv = params[i].split('=');
      if (kv[0]) {
        query[kv[0]] = kv[1];
      }
    }

    return query;
  };

  /**
   * Executes the given function when the page is loaded.
   *
   *     io.util.load(function () { console.log('page loaded'); });
   *
   * @param {Function} fn
   * @api public
   */

  var pageLoaded = false;

  util.load = function (fn) {
    if ('document' in global && document.readyState === 'complete' || pageLoaded) {
      return fn();
    }

    util.on(global, 'load', fn, false);
  };

  /**
   * Adds an event.
   *
   * @api private
   */

  util.on = function (element, event, fn, capture) {
    if (element.attachEvent) {
      element.attachEvent('on' + event, fn);
    } else if (element.addEventListener) {
      element.addEventListener(event, fn, capture);
    }
  };

  /**
   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.
   *
   * @param {Boolean} [xdomain] Create a request that can be used cross domain.
   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.
   * @api private
   */

  util.request = function (xdomain) {

    if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {
      return new XDomainRequest();
    }

    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {
      return new XMLHttpRequest();
    }

    if (!xdomain) {
      try {
        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');
      } catch(e) { }
    }

    return null;
  };

  /**
   * XHR based transport constructor.
   *
   * @constructor
   * @api public
   */

  /**
   * Change the internal pageLoaded value.
   */

  if ('undefined' != typeof window) {
    util.load(function () {
      pageLoaded = true;
    });
  }

  /**
   * Defers a function to ensure a spinner is not displayed by the browser
   *
   * @param {Function} fn
   * @api public
   */

  util.defer = function (fn) {
    if (!util.ua.webkit || 'undefined' != typeof importScripts) {
      return fn();
    }

    util.load(function () {
      setTimeout(fn, 100);
    });
  };

  /**
   * Merges two objects.
   *
   * @api public
   */

  util.merge = function merge (target, additional, deep, lastseen) {
    var seen = lastseen || []
      , depth = typeof deep == 'undefined' ? 2 : deep
      , prop;

    for (prop in additional) {
      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {
        if (typeof target[prop] !== 'object' || !depth) {
          target[prop] = additional[prop];
          seen.push(additional[prop]);
        } else {
          util.merge(target[prop], additional[prop], depth - 1, seen);
        }
      }
    }

    return target;
  };

  /**
   * Merges prototypes from objects
   *
   * @api public
   */

  util.mixin = function (ctor, ctor2) {
    util.merge(ctor.prototype, ctor2.prototype);
  };

  /**
   * Shortcut for prototypical and static inheritance.
   *
   * @api private
   */

  util.inherit = function (ctor, ctor2) {
    function f() {};
    f.prototype = ctor2.prototype;
    ctor.prototype = new f;
  };

  /**
   * Checks if the given object is an Array.
   *
   *     io.util.isArray([]); // true
   *     io.util.isArray({}); // false
   *
   * @param Object obj
   * @api public
   */

  util.isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  /**
   * Intersects values of two arrays into a third
   *
   * @api public
   */

  util.intersect = function (arr, arr2) {
    var ret = []
      , longest = arr.length > arr2.length ? arr : arr2
      , shortest = arr.length > arr2.length ? arr2 : arr;

    for (var i = 0, l = shortest.length; i < l; i++) {
      if (~util.indexOf(longest, shortest[i]))
        ret.push(shortest[i]);
    }

    return ret;
  };

  /**
   * Array indexOf compatibility.
   *
   * @see bit.ly/a5Dxa2
   * @api public
   */

  util.indexOf = function (arr, o, i) {

    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;
         i < j && arr[i] !== o; i++) {}

    return j <= i ? -1 : i;
  };

  /**
   * Converts enumerables to array.
   *
   * @api public
   */

  util.toArray = function (enu) {
    var arr = [];

    for (var i = 0, l = enu.length; i < l; i++)
      arr.push(enu[i]);

    return arr;
  };

  /**
   * UA / engines detection namespace.
   *
   * @namespace
   */

  util.ua = {};

  /**
   * Whether the UA supports CORS for XHR.
   *
   * @api public
   */

  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {
    try {
      var a = new XMLHttpRequest();
    } catch (e) {
      return false;
    }

    return a.withCredentials != undefined;
  })();

  /**
   * Detect webkit.
   *
   * @api public
   */

  util.ua.webkit = 'undefined' != typeof navigator
    && /webkit/i.test(navigator.userAgent);

   /**
   * Detect iPad/iPhone/iPod.
   *
   * @api public
   */

  util.ua.iDevice = 'undefined' != typeof navigator
      && /iPad|iPhone|iPod/i.test(navigator.userAgent);

})('undefined' != typeof io ? io : module.exports, this);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.EventEmitter = EventEmitter;

  /**
   * Event emitter constructor.
   *
   * @api public.
   */

  function EventEmitter () {};

  /**
   * Adds a listener
   *
   * @api public
   */

  EventEmitter.prototype.on = function (name, fn) {
    if (!this.$events) {
      this.$events = {};
    }

    if (!this.$events[name]) {
      this.$events[name] = fn;
    } else if (io.util.isArray(this.$events[name])) {
      this.$events[name].push(fn);
    } else {
      this.$events[name] = [this.$events[name], fn];
    }

    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  /**
   * Adds a volatile listener.
   *
   * @api public
   */

  EventEmitter.prototype.once = function (name, fn) {
    var self = this;

    function on () {
      self.removeListener(name, on);
      fn.apply(this, arguments);
    };

    on.listener = fn;
    this.on(name, on);

    return this;
  };

  /**
   * Removes a listener.
   *
   * @api public
   */

  EventEmitter.prototype.removeListener = function (name, fn) {
    if (this.$events && this.$events[name]) {
      var list = this.$events[name];

      if (io.util.isArray(list)) {
        var pos = -1;

        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {
            pos = i;
            break;
          }
        }

        if (pos < 0) {
          return this;
        }

        list.splice(pos, 1);

        if (!list.length) {
          delete this.$events[name];
        }
      } else if (list === fn || (list.listener && list.listener === fn)) {
        delete this.$events[name];
      }
    }

    return this;
  };

  /**
   * Removes all listeners for an event.
   *
   * @api public
   */

  EventEmitter.prototype.removeAllListeners = function (name) {
    if (name === undefined) {
      this.$events = {};
      return this;
    }

    if (this.$events && this.$events[name]) {
      this.$events[name] = null;
    }

    return this;
  };

  /**
   * Gets all listeners for a certain event.
   *
   * @api publci
   */

  EventEmitter.prototype.listeners = function (name) {
    if (!this.$events) {
      this.$events = {};
    }

    if (!this.$events[name]) {
      this.$events[name] = [];
    }

    if (!io.util.isArray(this.$events[name])) {
      this.$events[name] = [this.$events[name]];
    }

    return this.$events[name];
  };

  /**
   * Emits an event.
   *
   * @api public
   */

  EventEmitter.prototype.emit = function (name) {
    if (!this.$events) {
      return false;
    }

    var handler = this.$events[name];

    if (!handler) {
      return false;
    }

    var args = Array.prototype.slice.call(arguments, 1);

    if ('function' == typeof handler) {
      handler.apply(this, args);
    } else if (io.util.isArray(handler)) {
      var listeners = handler.slice();

      for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i].apply(this, args);
      }
    } else {
      return false;
    }

    return true;
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Based on JSON2 (http://www.JSON.org/js.html).
 */

(function (exports, nativeJSON) {
  "use strict";

  // use native JSON if it's available
  if (nativeJSON && nativeJSON.parse){
    return exports.JSON = {
      parse: nativeJSON.parse
    , stringify: nativeJSON.stringify
    };
  }

  var JSON = exports.JSON = {};

  function f(n) {
      // Format integers to have at least two digits.
      return n < 10 ? '0' + n : n;
  }

  function date(d, key) {
    return isFinite(d.valueOf()) ?
        d.getUTCFullYear()     + '-' +
        f(d.getUTCMonth() + 1) + '-' +
        f(d.getUTCDate())      + 'T' +
        f(d.getUTCHours())     + ':' +
        f(d.getUTCMinutes())   + ':' +
        f(d.getUTCSeconds())   + 'Z' : null;
  };

  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      gap,
      indent,
      meta = {    // table of character substitutions
          '\b': '\\b',
          '\t': '\\t',
          '\n': '\\n',
          '\f': '\\f',
          '\r': '\\r',
          '"' : '\\"',
          '\\': '\\\\'
      },
      rep;


  function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
          var c = meta[a];
          return typeof c === 'string' ? c :
              '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
  }


  function str(key, holder) {

// Produce a string from holder[key].

      var i,          // The loop counter.
          k,          // The member key.
          v,          // The member value.
          length,
          mind = gap,
          partial,
          value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

      if (value instanceof Date) {
          value = date(key);
      }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

      if (typeof rep === 'function') {
          value = rep.call(holder, key, value);
      }

// What happens next depends on the value's type.

      switch (typeof value) {
      case 'string':
          return quote(value);

      case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

          return isFinite(value) ? String(value) : 'null';

      case 'boolean':
      case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

          return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

      case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

          if (!value) {
              return 'null';
          }

// Make an array to hold the partial results of stringifying this object value.

          gap += indent;
          partial = [];

// Is the value an array?

          if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

              length = value.length;
              for (i = 0; i < length; i += 1) {
                  partial[i] = str(i, value) || 'null';
              }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

              v = partial.length === 0 ? '[]' : gap ?
                  '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                  '[' + partial.join(',') + ']';
              gap = mind;
              return v;
          }

// If the replacer is an array, use it to select the members to be stringified.

          if (rep && typeof rep === 'object') {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                  if (typeof rep[i] === 'string') {
                      k = rep[i];
                      v = str(k, value);
                      if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          } else {

// Otherwise, iterate through all of the keys in the object.

              for (k in value) {
                  if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = str(k, value);
                      if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

          v = partial.length === 0 ? '{}' : gap ?
              '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
              '{' + partial.join(',') + '}';
          gap = mind;
          return v;
      }
  }

// If the JSON object does not yet have a stringify method, give it one.

  JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

      var i;
      gap = '';
      indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

      if (typeof space === 'number') {
          for (i = 0; i < space; i += 1) {
              indent += ' ';
          }

// If the space parameter is a string, it will be used as the indent string.

      } else if (typeof space === 'string') {
          indent = space;
      }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

      rep = replacer;
      if (replacer && typeof replacer !== 'function' &&
              (typeof replacer !== 'object' ||
              typeof replacer.length !== 'number')) {
          throw new Error('JSON.stringify');
      }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

      return str('', {'': value});
  };

// If the JSON object does not yet have a parse method, give it one.

  JSON.parse = function (text, reviver) {
  // The parse method takes a text and an optional reviver function, and returns
  // a JavaScript value if the text is a valid JSON text.

      var j;

      function walk(holder, key) {

  // The walk method is used to recursively walk the resulting structure so
  // that modifications can be made.

          var k, v, value = holder[key];
          if (value && typeof value === 'object') {
              for (k in value) {
                  if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = walk(value, k);
                      if (v !== undefined) {
                          value[k] = v;
                      } else {
                          delete value[k];
                      }
                  }
              }
          }
          return reviver.call(holder, key, value);
      }


  // Parsing happens in four stages. In the first stage, we replace certain
  // Unicode characters with escape sequences. JavaScript handles many characters
  // incorrectly, either silently deleting them, or treating them as line endings.

      text = String(text);
      cx.lastIndex = 0;
      if (cx.test(text)) {
          text = text.replace(cx, function (a) {
              return '\\u' +
                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
          });
      }

  // In the second stage, we run the text against regular expressions that look
  // for non-JSON patterns. We are especially concerned with '()' and 'new'
  // because they can cause invocation, and '=' because it can cause mutation.
  // But just to be safe, we want to reject all unexpected forms.

  // We split the second stage into 4 regexp operations in order to work around
  // crippling inefficiencies in IE's and Safari's regexp engines. First we
  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
  // replace all simple value tokens with ']' characters. Third, we delete all
  // open brackets that follow a colon or comma or that begin the text. Finally,
  // we look to see that the remaining characters are only whitespace or ']' or
  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (/^[\],:{}\s]*$/
              .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                  .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                  .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

  // In the third stage we use the eval function to compile the text into a
  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
  // in JavaScript: it can begin a block or an object literal. We wrap the text
  // in parens to eliminate the ambiguity.

          j = eval('(' + text + ')');

  // In the optional fourth stage, we recursively walk the new structure, passing
  // each name/value pair to a reviver function for possible transformation.

          return typeof reviver === 'function' ?
              walk({'': j}, '') : j;
      }

  // If the text is not JSON parseable, then a SyntaxError is thrown.

      throw new SyntaxError('JSON.parse');
  };

})(
    'undefined' != typeof io ? io : module.exports
  , typeof JSON !== 'undefined' ? JSON : undefined
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Parser namespace.
   *
   * @namespace
   */

  var parser = exports.parser = {};

  /**
   * Packet types.
   */

  var packets = parser.packets = [
      'disconnect'
    , 'connect'
    , 'heartbeat'
    , 'message'
    , 'json'
    , 'event'
    , 'ack'
    , 'error'
    , 'noop'
  ];

  /**
   * Errors reasons.
   */

  var reasons = parser.reasons = [
      'transport not supported'
    , 'client not handshaken'
    , 'unauthorized'
  ];

  /**
   * Errors advice.
   */

  var advice = parser.advice = [
      'reconnect'
  ];

  /**
   * Shortcuts.
   */

  var JSON = io.JSON
    , indexOf = io.util.indexOf;

  /**
   * Encodes a packet.
   *
   * @api private
   */

  parser.encodePacket = function (packet) {
    var type = indexOf(packets, packet.type)
      , id = packet.id || ''
      , endpoint = packet.endpoint || ''
      , ack = packet.ack
      , data = null;

    switch (packet.type) {
      case 'error':
        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''
          , adv = packet.advice ? indexOf(advice, packet.advice) : '';

        if (reason !== '' || adv !== '')
          data = reason + (adv !== '' ? ('+' + adv) : '');

        break;

      case 'message':
        if (packet.data !== '')
          data = packet.data;
        break;

      case 'event':
        var ev = { name: packet.name };

        if (packet.args && packet.args.length) {
          ev.args = packet.args;
        }

        data = JSON.stringify(ev);
        break;

      case 'json':
        data = JSON.stringify(packet.data);
        break;

      case 'connect':
        if (packet.qs)
          data = packet.qs;
        break;

      case 'ack':
        data = packet.ackId
          + (packet.args && packet.args.length
              ? '+' + JSON.stringify(packet.args) : '');
        break;
    }

    // construct packet with required fragments
    var encoded = [
        type
      , id + (ack == 'data' ? '+' : '')
      , endpoint
    ];

    // data fragment is optional
    if (data !== null && data !== undefined)
      encoded.push(data);

    return encoded.join(':');
  };

  /**
   * Encodes multiple messages (payload).
   *
   * @param {Array} messages
   * @api private
   */

  parser.encodePayload = function (packets) {
    var decoded = '';

    if (packets.length == 1)
      return packets[0];

    for (var i = 0, l = packets.length; i < l; i++) {
      var packet = packets[i];
      decoded += '\ufffd' + packet.length + '\ufffd' + packets[i];
    }

    return decoded;
  };

  /**
   * Decodes a packet
   *
   * @api private
   */

  var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;

  parser.decodePacket = function (data) {
    var pieces = data.match(regexp);

    if (!pieces) return {};

    var id = pieces[2] || ''
      , data = pieces[5] || ''
      , packet = {
            type: packets[pieces[1]]
          , endpoint: pieces[4] || ''
        };

    // whether we need to acknowledge the packet
    if (id) {
      packet.id = id;
      if (pieces[3])
        packet.ack = 'data';
      else
        packet.ack = true;
    }

    // handle different packet types
    switch (packet.type) {
      case 'error':
        var pieces = data.split('+');
        packet.reason = reasons[pieces[0]] || '';
        packet.advice = advice[pieces[1]] || '';
        break;

      case 'message':
        packet.data = data || '';
        break;

      case 'event':
        try {
          var opts = JSON.parse(data);
          packet.name = opts.name;
          packet.args = opts.args;
        } catch (e) { }

        packet.args = packet.args || [];
        break;

      case 'json':
        try {
          packet.data = JSON.parse(data);
        } catch (e) { }
        break;

      case 'connect':
        packet.qs = data || '';
        break;

      case 'ack':
        var pieces = data.match(/^([0-9]+)(\+)?(.*)/);
        if (pieces) {
          packet.ackId = pieces[1];
          packet.args = [];

          if (pieces[3]) {
            try {
              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];
            } catch (e) { }
          }
        }
        break;

      case 'disconnect':
      case 'heartbeat':
        break;
    };

    return packet;
  };

  /**
   * Decodes data payload. Detects multiple messages
   *
   * @return {Array} messages
   * @api public
   */

  parser.decodePayload = function (data) {
    // IE doesn't like data[i] for unicode chars, charAt works fine
    if (data.charAt(0) == '\ufffd') {
      var ret = [];

      for (var i = 1, length = ''; i < data.length; i++) {
        if (data.charAt(i) == '\ufffd') {
          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));
          i += Number(length) + 1;
          length = '';
        } else {
          length += data.charAt(i);
        }
      }

      return ret;
    } else {
      return [parser.decodePacket(data)];
    }
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.Transport = Transport;

  /**
   * This is the transport template for all supported transport methods.
   *
   * @constructor
   * @api public
   */

  function Transport (socket, sessid) {
    this.socket = socket;
    this.sessid = sessid;
  };

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(Transport, io.EventEmitter);


  /**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */

  Transport.prototype.heartbeats = function () {
    return true;
  };

  /**
   * Handles the response from the server. When a new response is received
   * it will automatically update the timeout, decode the message and
   * forwards the response to the onMessage function for further processing.
   *
   * @param {String} data Response from the server.
   * @api private
   */

  Transport.prototype.onData = function (data) {
    this.clearCloseTimeout();

    // If the connection in currently open (or in a reopening state) reset the close
    // timeout since we have just received data. This check is necessary so
    // that we don't reset the timeout on an explicitly disconnected connection.
    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {
      this.setCloseTimeout();
    }

    if (data !== '') {
      // todo: we should only do decodePayload for xhr transports
      var msgs = io.parser.decodePayload(data);

      if (msgs && msgs.length) {
        for (var i = 0, l = msgs.length; i < l; i++) {
          this.onPacket(msgs[i]);
        }
      }
    }

    return this;
  };

  /**
   * Handles packets.
   *
   * @api private
   */

  Transport.prototype.onPacket = function (packet) {
    this.socket.setHeartbeatTimeout();

    if (packet.type == 'heartbeat') {
      return this.onHeartbeat();
    }

    if (packet.type == 'connect' && packet.endpoint == '') {
      this.onConnect();
    }

    if (packet.type == 'error' && packet.advice == 'reconnect') {
      this.isOpen = false;
    }

    this.socket.onPacket(packet);

    return this;
  };

  /**
   * Sets close timeout
   *
   * @api private
   */

  Transport.prototype.setCloseTimeout = function () {
    if (!this.closeTimeout) {
      var self = this;

      this.closeTimeout = setTimeout(function () {
        self.onDisconnect();
      }, this.socket.closeTimeout);
    }
  };

  /**
   * Called when transport disconnects.
   *
   * @api private
   */

  Transport.prototype.onDisconnect = function () {
    if (this.isOpen) this.close();
    this.clearTimeouts();
    this.socket.onDisconnect();
    return this;
  };

  /**
   * Called when transport connects
   *
   * @api private
   */

  Transport.prototype.onConnect = function () {
    this.socket.onConnect();
    return this;
  };

  /**
   * Clears close timeout
   *
   * @api private
   */

  Transport.prototype.clearCloseTimeout = function () {
    if (this.closeTimeout) {
      clearTimeout(this.closeTimeout);
      this.closeTimeout = null;
    }
  };

  /**
   * Clear timeouts
   *
   * @api private
   */

  Transport.prototype.clearTimeouts = function () {
    this.clearCloseTimeout();

    if (this.reopenTimeout) {
      clearTimeout(this.reopenTimeout);
    }
  };

  /**
   * Sends a packet
   *
   * @param {Object} packet object.
   * @api private
   */

  Transport.prototype.packet = function (packet) {
    this.send(io.parser.encodePacket(packet));
  };

  /**
   * Send the received heartbeat message back to server. So the server
   * knows we are still connected.
   *
   * @param {String} heartbeat Heartbeat response from the server.
   * @api private
   */

  Transport.prototype.onHeartbeat = function (heartbeat) {
    this.packet({ type: 'heartbeat' });
  };

  /**
   * Called when the transport opens.
   *
   * @api private
   */

  Transport.prototype.onOpen = function () {
    this.isOpen = true;
    this.clearCloseTimeout();
    this.socket.onOpen();
  };

  /**
   * Notifies the base when the connection with the Socket.IO server
   * has been disconnected.
   *
   * @api private
   */

  Transport.prototype.onClose = function () {
    var self = this;

    /* FIXME: reopen delay causing a infinit loop
    this.reopenTimeout = setTimeout(function () {
      self.open();
    }, this.socket.options['reopen delay']);*/

    this.isOpen = false;
    this.socket.onClose();
    this.onDisconnect();
  };

  /**
   * Generates a connection url based on the Socket.IO URL Protocol.
   * See <https://github.com/learnboost/socket.io-node/> for more details.
   *
   * @returns {String} Connection url
   * @api private
   */

  Transport.prototype.prepareUrl = function () {
    var options = this.socket.options;

    return this.scheme() + '://'
      + options.host + ':' + options.port + '/'
      + options.resource + '/' + io.protocol
      + '/' + this.name + '/' + this.sessid;
  };

  /**
   * Checks if the transport is ready to start a connection.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  Transport.prototype.ready = function (socket, fn) {
    fn.call(this);
  };
})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports.Socket = Socket;

  /**
   * Create a new `Socket.IO client` which can establish a persistent
   * connection with a Socket.IO enabled server.
   *
   * @api public
   */

  function Socket (options) {
    this.options = {
        port: 80
      , secure: false
      , document: 'document' in global ? document : false
      , resource: 'socket.io'
      , transports: io.transports
      , 'connect timeout': 10000
      , 'try multiple transports': true
      , 'reconnect': true
      , 'reconnection delay': 500
      , 'reconnection limit': Infinity
      , 'reopen delay': 3000
      , 'max reconnection attempts': 10
      , 'sync disconnect on unload': false
      , 'auto connect': true
      , 'flash policy port': 10843
      , 'manualFlush': false
    };

    io.util.merge(this.options, options);

    this.connected = false;
    this.open = false;
    this.connecting = false;
    this.reconnecting = false;
    this.namespaces = {};
    this.buffer = [];
    this.doBuffer = false;

    if (this.options['sync disconnect on unload'] &&
        (!this.isXDomain() || io.util.ua.hasCORS)) {
      var self = this;
      io.util.on(global, 'beforeunload', function () {
        self.disconnectSync();
      }, false);
    }

    if (this.options['auto connect']) {
      this.connect();
    }
};

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(Socket, io.EventEmitter);

  /**
   * Returns a namespace listener/emitter for this socket
   *
   * @api public
   */

  Socket.prototype.of = function (name) {
    if (!this.namespaces[name]) {
      this.namespaces[name] = new io.SocketNamespace(this, name);

      if (name !== '') {
        this.namespaces[name].packet({ type: 'connect' });
      }
    }

    return this.namespaces[name];
  };

  /**
   * Emits the given event to the Socket and all namespaces
   *
   * @api private
   */

  Socket.prototype.publish = function () {
    this.emit.apply(this, arguments);

    var nsp;

    for (var i in this.namespaces) {
      if (this.namespaces.hasOwnProperty(i)) {
        nsp = this.of(i);
        nsp.$emit.apply(nsp, arguments);
      }
    }
  };

  /**
   * Performs the handshake
   *
   * @api private
   */

  function empty () { };

  Socket.prototype.handshake = function (fn) {
    var self = this
      , options = this.options;

    function complete (data) {
      if (data instanceof Error) {
        self.connecting = false;
        self.onError(data.message);
      } else {
        fn.apply(null, data.split(':'));
      }
    };

    var url = [
          'http' + (options.secure ? 's' : '') + ':/'
        , options.host + ':' + options.port
        , options.resource
        , io.protocol
        , io.util.query(this.options.query, 't=' + +new Date)
      ].join('/');

    if (this.isXDomain() && !io.util.ua.hasCORS) {
      var insertAt = document.getElementsByTagName('script')[0]
        , script = document.createElement('script');

      script.src = url + '&jsonp=' + io.j.length;
      insertAt.parentNode.insertBefore(script, insertAt);

      io.j.push(function (data) {
        complete(data);
        script.parentNode.removeChild(script);
      });
    } else {
      var xhr = io.util.request();

      xhr.open('GET', url, true);
      if (this.isXDomain()) {
        xhr.withCredentials = true;
      }
      xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
          xhr.onreadystatechange = empty;

          if (xhr.status == 200) {
            complete(xhr.responseText);
          } else if (xhr.status == 403) {
            self.onError(xhr.responseText);
          } else {
            self.connecting = false;            
            !self.reconnecting && self.onError(xhr.responseText);
          }
        }
      };
      xhr.send(null);
    }
  };

  /**
   * Find an available transport based on the options supplied in the constructor.
   *
   * @api private
   */

  Socket.prototype.getTransport = function (override) {
    var transports = override || this.transports, match;

    for (var i = 0, transport; transport = transports[i]; i++) {
      if (io.Transport[transport]
        && io.Transport[transport].check(this)
        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {
        return new io.Transport[transport](this, this.sessionid);
      }
    }

    return null;
  };

  /**
   * Connects to the server.
   *
   * @param {Function} [fn] Callback.
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.connect = function (fn) {
    if (this.connecting) {
      return this;
    }

    var self = this;
    self.connecting = true;
    
    this.handshake(function (sid, heartbeat, close, transports) {
      self.sessionid = sid;
      self.closeTimeout = close * 1000;
      self.heartbeatTimeout = heartbeat * 1000;
      if(!self.transports)
          self.transports = self.origTransports = (transports ? io.util.intersect(
              transports.split(',')
            , self.options.transports
          ) : self.options.transports);

      self.setHeartbeatTimeout();

      function connect (transports){
        if (self.transport) self.transport.clearTimeouts();

        self.transport = self.getTransport(transports);
        if (!self.transport) return self.publish('connect_failed');

        // once the transport is ready
        self.transport.ready(self, function () {
          self.connecting = true;
          self.publish('connecting', self.transport.name);
          self.transport.open();

          if (self.options['connect timeout']) {
            self.connectTimeoutTimer = setTimeout(function () {
              if (!self.connected) {
                self.connecting = false;

                if (self.options['try multiple transports']) {
                  var remaining = self.transports;

                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=
                         self.transport.name) {}

                    if (remaining.length){
                      connect(remaining);
                    } else {
                      self.publish('connect_failed');
                    }
                }
              }
            }, self.options['connect timeout']);
          }
        });
      }

      connect(self.transports);

      self.once('connect', function (){
        clearTimeout(self.connectTimeoutTimer);

        fn && typeof fn == 'function' && fn();
      });
    });

    return this;
  };

  /**
   * Clears and sets a new heartbeat timeout using the value given by the
   * server during the handshake.
   *
   * @api private
   */

  Socket.prototype.setHeartbeatTimeout = function () {
    clearTimeout(this.heartbeatTimeoutTimer);
    if(this.transport && !this.transport.heartbeats()) return;

    var self = this;
    this.heartbeatTimeoutTimer = setTimeout(function () {
      self.transport.onClose();
    }, this.heartbeatTimeout);
  };

  /**
   * Sends a message.
   *
   * @param {Object} data packet.
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.packet = function (data) {
    if (this.connected && !this.doBuffer) {
      this.transport.packet(data);
    } else {
      this.buffer.push(data);
    }

    return this;
  };

  /**
   * Sets buffer state
   *
   * @api private
   */

  Socket.prototype.setBuffer = function (v) {
    this.doBuffer = v;

    if (!v && this.connected && this.buffer.length) {
      if (!this.options['manualFlush']) {
        this.flushBuffer();
      }
    }
  };

  /**
   * Flushes the buffer data over the wire.
   * To be invoked manually when 'manualFlush' is set to true.
   *
   * @api public
   */

  Socket.prototype.flushBuffer = function() {
    this.transport.payload(this.buffer);
    this.buffer = [];
  };
  

  /**
   * Disconnect the established connect.
   *
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.disconnect = function () {
    if (this.connected || this.connecting) {
      if (this.open) {
        this.of('').packet({ type: 'disconnect' });
      }

      // handle disconnection immediately
      this.onDisconnect('booted');
    }

    return this;
  };

  /**
   * Disconnects the socket with a sync XHR.
   *
   * @api private
   */

  Socket.prototype.disconnectSync = function () {
    // ensure disconnection
    var xhr = io.util.request();
    var uri = [
        'http' + (this.options.secure ? 's' : '') + ':/'
      , this.options.host + ':' + this.options.port
      , this.options.resource
      , io.protocol
      , ''
      , this.sessionid
    ].join('/') + '/?disconnect=1';

    xhr.open('GET', uri, false);
    xhr.send(null);

    // handle disconnection immediately
    this.onDisconnect('booted');
  };

  /**
   * Check if we need to use cross domain enabled transports. Cross domain would
   * be a different port or different domain name.
   *
   * @returns {Boolean}
   * @api private
   */

  Socket.prototype.isXDomain = function () {

    var port = global.location.port ||
      ('https:' == global.location.protocol ? 443 : 80);

    return this.options.host !== global.location.hostname 
      || this.options.port != port;
  };

  /**
   * Called upon handshake.
   *
   * @api private
   */

  Socket.prototype.onConnect = function () {
    if (!this.connected) {
      this.connected = true;
      this.connecting = false;
      if (!this.doBuffer) {
        // make sure to flush the buffer
        this.setBuffer(false);
      }
      this.emit('connect');
    }
  };

  /**
   * Called when the transport opens
   *
   * @api private
   */

  Socket.prototype.onOpen = function () {
    this.open = true;
  };

  /**
   * Called when the transport closes.
   *
   * @api private
   */

  Socket.prototype.onClose = function () {
    this.open = false;
    clearTimeout(this.heartbeatTimeoutTimer);
  };

  /**
   * Called when the transport first opens a connection
   *
   * @param text
   */

  Socket.prototype.onPacket = function (packet) {
    this.of(packet.endpoint).onPacket(packet);
  };

  /**
   * Handles an error.
   *
   * @api private
   */

  Socket.prototype.onError = function (err) {
    if (err && err.advice) {
      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {
        this.disconnect();
        if (this.options.reconnect) {
          this.reconnect();
        }
      }
    }

    this.publish('error', err && err.reason ? err.reason : err);
  };

  /**
   * Called when the transport disconnects.
   *
   * @api private
   */

  Socket.prototype.onDisconnect = function (reason) {
    var wasConnected = this.connected
      , wasConnecting = this.connecting;

    this.connected = false;
    this.connecting = false;
    this.open = false;

    if (wasConnected || wasConnecting) {
      this.transport.close();
      this.transport.clearTimeouts();
      if (wasConnected) {
        this.publish('disconnect', reason);

        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {
          this.reconnect();
        }
      }
    }
  };

  /**
   * Called upon reconnection.
   *
   * @api private
   */

  Socket.prototype.reconnect = function () {
    this.reconnecting = true;
    this.reconnectionAttempts = 0;
    this.reconnectionDelay = this.options['reconnection delay'];

    var self = this
      , maxAttempts = this.options['max reconnection attempts']
      , tryMultiple = this.options['try multiple transports']
      , limit = this.options['reconnection limit'];

    function reset () {
      if (self.connected) {
        for (var i in self.namespaces) {
          if (self.namespaces.hasOwnProperty(i) && '' !== i) {
              self.namespaces[i].packet({ type: 'connect' });
          }
        }
        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);
      }

      clearTimeout(self.reconnectionTimer);

      self.removeListener('connect_failed', maybeReconnect);
      self.removeListener('connect', maybeReconnect);

      self.reconnecting = false;

      delete self.reconnectionAttempts;
      delete self.reconnectionDelay;
      delete self.reconnectionTimer;
      delete self.redoTransports;

      self.options['try multiple transports'] = tryMultiple;
    };

    function maybeReconnect () {
      if (!self.reconnecting) {
        return;
      }

      if (self.connected) {
        return reset();
      };

      if (self.connecting && self.reconnecting) {
        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);
      }

      if (self.reconnectionAttempts++ >= maxAttempts) {
        if (!self.redoTransports) {
          self.on('connect_failed', maybeReconnect);
          self.options['try multiple transports'] = true;
          self.transports = self.origTransports;
          self.transport = self.getTransport();
          self.redoTransports = true;
          self.connect();
        } else {
          self.publish('reconnect_failed');
          reset();
        }
      } else {
        if (self.reconnectionDelay < limit) {
          self.reconnectionDelay *= 2; // exponential back off
        }

        self.connect();
        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);
        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);
      }
    };

    this.options['try multiple transports'] = false;
    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);

    this.on('connect', maybeReconnect);
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.SocketNamespace = SocketNamespace;

  /**
   * Socket namespace constructor.
   *
   * @constructor
   * @api public
   */

  function SocketNamespace (socket, name) {
    this.socket = socket;
    this.name = name || '';
    this.flags = {};
    this.json = new Flag(this, 'json');
    this.ackPackets = 0;
    this.acks = {};
  };

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(SocketNamespace, io.EventEmitter);

  /**
   * Copies emit since we override it
   *
   * @api private
   */

  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;

  /**
   * Creates a new namespace, by proxying the request to the socket. This
   * allows us to use the synax as we do on the server.
   *
   * @api public
   */

  SocketNamespace.prototype.of = function () {
    return this.socket.of.apply(this.socket, arguments);
  };

  /**
   * Sends a packet.
   *
   * @api private
   */

  SocketNamespace.prototype.packet = function (packet) {
    packet.endpoint = this.name;
    this.socket.packet(packet);
    this.flags = {};
    return this;
  };

  /**
   * Sends a message
   *
   * @api public
   */

  SocketNamespace.prototype.send = function (data, fn) {
    var packet = {
        type: this.flags.json ? 'json' : 'message'
      , data: data
    };

    if ('function' == typeof fn) {
      packet.id = ++this.ackPackets;
      packet.ack = true;
      this.acks[packet.id] = fn;
    }

    return this.packet(packet);
  };

  /**
   * Emits an event
   *
   * @api public
   */
  
  SocketNamespace.prototype.emit = function (name) {
    var args = Array.prototype.slice.call(arguments, 1)
      , lastArg = args[args.length - 1]
      , packet = {
            type: 'event'
          , name: name
        };

    if ('function' == typeof lastArg) {
      packet.id = ++this.ackPackets;
      packet.ack = 'data';
      this.acks[packet.id] = lastArg;
      args = args.slice(0, args.length - 1);
    }

    packet.args = args;

    return this.packet(packet);
  };

  /**
   * Disconnects the namespace
   *
   * @api private
   */

  SocketNamespace.prototype.disconnect = function () {
    if (this.name === '') {
      this.socket.disconnect();
    } else {
      this.packet({ type: 'disconnect' });
      this.$emit('disconnect');
    }

    return this;
  };

  /**
   * Handles a packet
   *
   * @api private
   */

  SocketNamespace.prototype.onPacket = function (packet) {
    var self = this;

    function ack () {
      self.packet({
          type: 'ack'
        , args: io.util.toArray(arguments)
        , ackId: packet.id
      });
    };

    switch (packet.type) {
      case 'connect':
        this.$emit('connect');
        break;

      case 'disconnect':
        if (this.name === '') {
          this.socket.onDisconnect(packet.reason || 'booted');
        } else {
          this.$emit('disconnect', packet.reason);
        }
        break;

      case 'message':
      case 'json':
        var params = ['message', packet.data];

        if (packet.ack == 'data') {
          params.push(ack);
        } else if (packet.ack) {
          this.packet({ type: 'ack', ackId: packet.id });
        }

        this.$emit.apply(this, params);
        break;

      case 'event':
        var params = [packet.name].concat(packet.args);

        if (packet.ack == 'data')
          params.push(ack);

        this.$emit.apply(this, params);
        break;

      case 'ack':
        if (this.acks[packet.ackId]) {
          this.acks[packet.ackId].apply(this, packet.args);
          delete this.acks[packet.ackId];
        }
        break;

      case 'error':
        if (packet.advice){
          this.socket.onError(packet);
        } else {
          if (packet.reason == 'unauthorized') {
            this.$emit('connect_failed', packet.reason);
          } else {
            this.$emit('error', packet.reason);
          }
        }
        break;
    }
  };

  /**
   * Flag interface.
   *
   * @api private
   */

  function Flag (nsp, name) {
    this.namespace = nsp;
    this.name = name;
  };

  /**
   * Send a message
   *
   * @api public
   */

  Flag.prototype.send = function () {
    this.namespace.flags[this.name] = true;
    this.namespace.send.apply(this.namespace, arguments);
  };

  /**
   * Emit an event
   *
   * @api public
   */

  Flag.prototype.emit = function () {
    this.namespace.flags[this.name] = true;
    this.namespace.emit.apply(this.namespace, arguments);
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports.websocket = WS;

  /**
   * The WebSocket transport uses the HTML5 WebSocket API to establish an
   * persistent connection with the Socket.IO server. This transport will also
   * be inherited by the FlashSocket fallback as it provides a API compatible
   * polyfill for the WebSockets.
   *
   * @constructor
   * @extends {io.Transport}
   * @api public
   */

  function WS (socket) {
    io.Transport.apply(this, arguments);
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(WS, io.Transport);

  /**
   * Transport name
   *
   * @api public
   */

  WS.prototype.name = 'websocket';

  /**
   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach
   * all the appropriate listeners to handle the responses from the server.
   *
   * @returns {Transport}
   * @api public
   */

  WS.prototype.open = function () {
    var query = io.util.query(this.socket.options.query)
      , self = this
      , Socket


    if (!Socket) {
      Socket = global.MozWebSocket || global.WebSocket;
    }

    this.websocket = new Socket(this.prepareUrl() + query);

    this.websocket.onopen = function () {
      self.onOpen();
      self.socket.setBuffer(false);
    };
    this.websocket.onmessage = function (ev) {
      self.onData(ev.data);
    };
    this.websocket.onclose = function () {
      self.onClose();
      self.socket.setBuffer(true);
    };
    this.websocket.onerror = function (e) {
      self.onError(e);
    };

    return this;
  };

  /**
   * Send a message to the Socket.IO server. The message will automatically be
   * encoded in the correct message format.
   *
   * @returns {Transport}
   * @api public
   */

  // Do to a bug in the current IDevices browser, we need to wrap the send in a 
  // setTimeout, when they resume from sleeping the browser will crash if 
  // we don't allow the browser time to detect the socket has been closed
  if (io.util.ua.iDevice) {
    WS.prototype.send = function (data) {
      var self = this;
      setTimeout(function() {
         self.websocket.send(data);
      },0);
      return this;
    };
  } else {
    WS.prototype.send = function (data) {
      this.websocket.send(data);
      return this;
    };
  }

  /**
   * Payload
   *
   * @api private
   */

  WS.prototype.payload = function (arr) {
    for (var i = 0, l = arr.length; i < l; i++) {
      this.packet(arr[i]);
    }
    return this;
  };

  /**
   * Disconnect the established `WebSocket` connection.
   *
   * @returns {Transport}
   * @api public
   */

  WS.prototype.close = function () {
    this.websocket.close();
    return this;
  };

  /**
   * Handle the errors that `WebSocket` might be giving when we
   * are attempting to connect or send messages.
   *
   * @param {Error} e The error.
   * @api private
   */

  WS.prototype.onError = function (e) {
    this.socket.onError(e);
  };

  /**
   * Returns the appropriate scheme for the URI generation.
   *
   * @api private
   */
  WS.prototype.scheme = function () {
    return this.socket.options.secure ? 'wss' : 'ws';
  };

  /**
   * Checks if the browser has support for native `WebSockets` and that
   * it's not the polyfill created for the FlashSocket transport.
   *
   * @return {Boolean}
   * @api public
   */

  WS.check = function () {
    return ('WebSocket' in global && !('__addTask' in WebSocket))
          || 'MozWebSocket' in global;
  };

  /**
   * Check if the `WebSocket` transport support cross domain communications.
   *
   * @returns {Boolean}
   * @api public
   */

  WS.xdomainCheck = function () {
    return true;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('websocket');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.flashsocket = Flashsocket;

  /**
   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket
   * specification. It uses a .swf file to communicate with the server. If you want
   * to serve the .swf file from a other server than where the Socket.IO script is
   * coming from you need to use the insecure version of the .swf. More information
   * about this can be found on the github page.
   *
   * @constructor
   * @extends {io.Transport.websocket}
   * @api public
   */

  function Flashsocket () {
    io.Transport.websocket.apply(this, arguments);
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(Flashsocket, io.Transport.websocket);

  /**
   * Transport name
   *
   * @api public
   */

  Flashsocket.prototype.name = 'flashsocket';

  /**
   * Disconnect the established `FlashSocket` connection. This is done by adding a 
   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` 
   * transport.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.open = function () {
    var self = this
      , args = arguments;

    WebSocket.__addTask(function () {
      io.Transport.websocket.prototype.open.apply(self, args);
    });
    return this;
  };
  
  /**
   * Sends a message to the Socket.IO server. This is done by adding a new
   * task to the FlashSocket. The rest will be handled off by the `WebSocket` 
   * transport.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.send = function () {
    var self = this, args = arguments;
    WebSocket.__addTask(function () {
      io.Transport.websocket.prototype.send.apply(self, args);
    });
    return this;
  };

  /**
   * Disconnects the established `FlashSocket` connection.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.close = function () {
    WebSocket.__tasks.length = 0;
    io.Transport.websocket.prototype.close.call(this);
    return this;
  };

  /**
   * The WebSocket fall back needs to append the flash container to the body
   * element, so we need to make sure we have access to it. Or defer the call
   * until we are sure there is a body element.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  Flashsocket.prototype.ready = function (socket, fn) {
    function init () {
      var options = socket.options
        , port = options['flash policy port']
        , path = [
              'http' + (options.secure ? 's' : '') + ':/'
            , options.host + ':' + options.port
            , options.resource
            , 'static/flashsocket'
            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'
          ];

      // Only start downloading the swf file when the checked that this browser
      // actually supports it
      if (!Flashsocket.loaded) {
        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {
          // Set the correct file based on the XDomain settings
          WEB_SOCKET_SWF_LOCATION = path.join('/');
        }

        if (port !== 843) {
          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);
        }

        WebSocket.__initialize();
        Flashsocket.loaded = true;
      }

      fn.call(self);
    }

    var self = this;
    if (document.body) return init();

    io.util.load(init);
  };

  /**
   * Check if the FlashSocket transport is supported as it requires that the Adobe
   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if
   * the polyfill is correctly loaded.
   *
   * @returns {Boolean}
   * @api public
   */

  Flashsocket.check = function () {
    if (
        typeof WebSocket == 'undefined'
      || !('__initialize' in WebSocket) || !swfobject
    ) return false;

    return swfobject.getFlashPlayerVersion().major >= 10;
  };

  /**
   * Check if the FlashSocket transport can be used as cross domain / cross origin 
   * transport. Because we can't see which type (secure or insecure) of .swf is used
   * we will just return true.
   *
   * @returns {Boolean}
   * @api public
   */

  Flashsocket.xdomainCheck = function () {
    return true;
  };

  /**
   * Disable AUTO_INITIALIZATION
   */

  if (typeof window != 'undefined') {
    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;
  }

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('flashsocket');
})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
if ('undefined' != typeof window) {
var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();
}
// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>
// License: New BSD License
// Reference: http://dev.w3.org/html5/websockets/
// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol

(function() {
  
  if ('undefined' == typeof window || window.WebSocket) return;

  var console = window.console;
  if (!console || !console.log || !console.error) {
    console = {log: function(){ }, error: function(){ }};
  }
  
  if (!swfobject.hasFlashPlayerVersion("10.0.0")) {
    console.error("Flash Player >= 10.0.0 is required.");
    return;
  }
  if (location.protocol == "file:") {
    console.error(
      "WARNING: web-socket-js doesn't work in file:///... URL " +
      "unless you set Flash Security Settings properly. " +
      "Open the page via Web server i.e. http://...");
  }

  /**
   * This class represents a faux web socket.
   * @param {string} url
   * @param {array or string} protocols
   * @param {string} proxyHost
   * @param {int} proxyPort
   * @param {string} headers
   */
  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
    var self = this;
    self.__id = WebSocket.__nextId++;
    WebSocket.__instances[self.__id] = self;
    self.readyState = WebSocket.CONNECTING;
    self.bufferedAmount = 0;
    self.__events = {};
    if (!protocols) {
      protocols = [];
    } else if (typeof protocols == "string") {
      protocols = [protocols];
    }
    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.
    // Otherwise, when onopen fires immediately, onopen is called before it is set.
    setTimeout(function() {
      WebSocket.__addTask(function() {
        WebSocket.__flash.create(
            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
      });
    }, 0);
  };

  /**
   * Send data to the web socket.
   * @param {string} data  The data to send to the socket.
   * @return {boolean}  True for success, false for failure.
   */
  WebSocket.prototype.send = function(data) {
    if (this.readyState == WebSocket.CONNECTING) {
      throw "INVALID_STATE_ERR: Web Socket connection has not been established";
    }
    // We use encodeURIComponent() here, because FABridge doesn't work if
    // the argument includes some characters. We don't use escape() here
    // because of this:
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions
    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't
    // preserve all Unicode characters either e.g. "\uffff" in Firefox.
    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require
    // additional testing.
    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
    if (result < 0) { // success
      return true;
    } else {
      this.bufferedAmount += result;
      return false;
    }
  };

  /**
   * Close this web socket gracefully.
   */
  WebSocket.prototype.close = function() {
    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {
      return;
    }
    this.readyState = WebSocket.CLOSING;
    WebSocket.__flash.close(this.__id);
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {string} type
   * @param {function} listener
   * @param {boolean} useCapture
   * @return void
   */
  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
    if (!(type in this.__events)) {
      this.__events[type] = [];
    }
    this.__events[type].push(listener);
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {string} type
   * @param {function} listener
   * @param {boolean} useCapture
   * @return void
   */
  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
    if (!(type in this.__events)) return;
    var events = this.__events[type];
    for (var i = events.length - 1; i >= 0; --i) {
      if (events[i] === listener) {
        events.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {Event} event
   * @return void
   */
  WebSocket.prototype.dispatchEvent = function(event) {
    var events = this.__events[event.type] || [];
    for (var i = 0; i < events.length; ++i) {
      events[i](event);
    }
    var handler = this["on" + event.type];
    if (handler) handler(event);
  };

  /**
   * Handles an event from Flash.
   * @param {Object} flashEvent
   */
  WebSocket.prototype.__handleEvent = function(flashEvent) {
    if ("readyState" in flashEvent) {
      this.readyState = flashEvent.readyState;
    }
    if ("protocol" in flashEvent) {
      this.protocol = flashEvent.protocol;
    }
    
    var jsEvent;
    if (flashEvent.type == "open" || flashEvent.type == "error") {
      jsEvent = this.__createSimpleEvent(flashEvent.type);
    } else if (flashEvent.type == "close") {
      // TODO implement jsEvent.wasClean
      jsEvent = this.__createSimpleEvent("close");
    } else if (flashEvent.type == "message") {
      var data = decodeURIComponent(flashEvent.message);
      jsEvent = this.__createMessageEvent("message", data);
    } else {
      throw "unknown event type: " + flashEvent.type;
    }
    
    this.dispatchEvent(jsEvent);
  };
  
  WebSocket.prototype.__createSimpleEvent = function(type) {
    if (document.createEvent && window.Event) {
      var event = document.createEvent("Event");
      event.initEvent(type, false, false);
      return event;
    } else {
      return {type: type, bubbles: false, cancelable: false};
    }
  };
  
  WebSocket.prototype.__createMessageEvent = function(type, data) {
    if (document.createEvent && window.MessageEvent && !window.opera) {
      var event = document.createEvent("MessageEvent");
      event.initMessageEvent("message", false, false, data, null, null, window, null);
      return event;
    } else {
      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.
      return {type: type, data: data, bubbles: false, cancelable: false};
    }
  };
  
  /**
   * Define the WebSocket readyState enumeration.
   */
  WebSocket.CONNECTING = 0;
  WebSocket.OPEN = 1;
  WebSocket.CLOSING = 2;
  WebSocket.CLOSED = 3;

  WebSocket.__flash = null;
  WebSocket.__instances = {};
  WebSocket.__tasks = [];
  WebSocket.__nextId = 0;
  
  /**
   * Load a new flash security policy file.
   * @param {string} url
   */
  WebSocket.loadFlashPolicyFile = function(url){
    WebSocket.__addTask(function() {
      WebSocket.__flash.loadManualPolicyFile(url);
    });
  };

  /**
   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.
   */
  WebSocket.__initialize = function() {
    if (WebSocket.__flash) return;
    
    if (WebSocket.__swfLocation) {
      // For backword compatibility.
      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;
    }
    if (!window.WEB_SOCKET_SWF_LOCATION) {
      console.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
      return;
    }
    var container = document.createElement("div");
    container.id = "webSocketContainer";
    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents
    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).
    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash
    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is
    // the best we can do as far as we know now.
    container.style.position = "absolute";
    if (WebSocket.__isFlashLite()) {
      container.style.left = "0px";
      container.style.top = "0px";
    } else {
      container.style.left = "-100px";
      container.style.top = "-100px";
    }
    var holder = document.createElement("div");
    holder.id = "webSocketFlash";
    container.appendChild(holder);
    document.body.appendChild(container);
    // See this article for hasPriority:
    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html
    swfobject.embedSWF(
      WEB_SOCKET_SWF_LOCATION,
      "webSocketFlash",
      "1" /* width */,
      "1" /* height */,
      "10.0.0" /* SWF version */,
      null,
      null,
      {hasPriority: true, swliveconnect : true, allowScriptAccess: "always"},
      null,
      function(e) {
        if (!e.success) {
          console.error("[WebSocket] swfobject.embedSWF failed");
        }
      });
  };
  
  /**
   * Called by Flash to notify JS that it's fully loaded and ready
   * for communication.
   */
  WebSocket.__onFlashInitialized = function() {
    // We need to set a timeout here to avoid round-trip calls
    // to flash during the initialization process.
    setTimeout(function() {
      WebSocket.__flash = document.getElementById("webSocketFlash");
      WebSocket.__flash.setCallerUrl(location.href);
      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
      for (var i = 0; i < WebSocket.__tasks.length; ++i) {
        WebSocket.__tasks[i]();
      }
      WebSocket.__tasks = [];
    }, 0);
  };
  
  /**
   * Called by Flash to notify WebSockets events are fired.
   */
  WebSocket.__onFlashEvent = function() {
    setTimeout(function() {
      try {
        // Gets events using receiveEvents() instead of getting it from event object
        // of Flash event. This is to make sure to keep message order.
        // It seems sometimes Flash events don't arrive in the same order as they are sent.
        var events = WebSocket.__flash.receiveEvents();
        for (var i = 0; i < events.length; ++i) {
          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
        }
      } catch (e) {
        console.error(e);
      }
    }, 0);
    return true;
  };
  
  // Called by Flash.
  WebSocket.__log = function(message) {
    console.log(decodeURIComponent(message));
  };
  
  // Called by Flash.
  WebSocket.__error = function(message) {
    console.error(decodeURIComponent(message));
  };
  
  WebSocket.__addTask = function(task) {
    if (WebSocket.__flash) {
      task();
    } else {
      WebSocket.__tasks.push(task);
    }
  };
  
  /**
   * Test if the browser is running flash lite.
   * @return {boolean} True if flash lite is running, false otherwise.
   */
  WebSocket.__isFlashLite = function() {
    if (!window.navigator || !window.navigator.mimeTypes) {
      return false;
    }
    var mimeType = window.navigator.mimeTypes["application/x-shockwave-flash"];
    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {
      return false;
    }
    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;
  };
  
  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {
    if (window.addEventListener) {
      window.addEventListener("load", function(){
        WebSocket.__initialize();
      }, false);
    } else {
      window.attachEvent("onload", function(){
        WebSocket.__initialize();
      });
    }
  }
  
})();

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   *
   * @api public
   */

  exports.XHR = XHR;

  /**
   * XHR constructor
   *
   * @costructor
   * @api public
   */

  function XHR (socket) {
    if (!socket) return;

    io.Transport.apply(this, arguments);
    this.sendBuffer = [];
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(XHR, io.Transport);

  /**
   * Establish a connection
   *
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.open = function () {
    this.socket.setBuffer(false);
    this.onOpen();
    this.get();

    // we need to make sure the request succeeds since we have no indication
    // whether the request opened or not until it succeeded.
    this.setCloseTimeout();

    return this;
  };

  /**
   * Check if we need to send data to the Socket.IO server, if we have data in our
   * buffer we encode it and forward it to the `post` method.
   *
   * @api private
   */

  XHR.prototype.payload = function (payload) {
    var msgs = [];

    for (var i = 0, l = payload.length; i < l; i++) {
      msgs.push(io.parser.encodePacket(payload[i]));
    }

    this.send(io.parser.encodePayload(msgs));
  };

  /**
   * Send data to the Socket.IO server.
   *
   * @param data The message
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.send = function (data) {
    this.post(data);
    return this;
  };

  /**
   * Posts a encoded message to the Socket.IO server.
   *
   * @param {String} data A encoded message.
   * @api private
   */

  function empty () { };

  XHR.prototype.post = function (data) {
    var self = this;
    this.socket.setBuffer(true);

    function stateChange () {
      if (this.readyState == 4) {
        this.onreadystatechange = empty;
        self.posting = false;

        if (this.status == 200){
          self.socket.setBuffer(false);
        } else {
          self.onClose();
        }
      }
    }

    function onload () {
      this.onload = empty;
      self.socket.setBuffer(false);
    };

    this.sendXHR = this.request('POST');

    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {
      this.sendXHR.onload = this.sendXHR.onerror = onload;
    } else {
      this.sendXHR.onreadystatechange = stateChange;
    }

    this.sendXHR.send(data);
  };

  /**
   * Disconnects the established `XHR` connection.
   *
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.close = function () {
    this.onClose();
    return this;
  };

  /**
   * Generates a configured XHR request
   *
   * @param {String} url The url that needs to be requested.
   * @param {String} method The method the request should use.
   * @returns {XMLHttpRequest}
   * @api private
   */

  XHR.prototype.request = function (method) {
    var req = io.util.request(this.socket.isXDomain())
      , query = io.util.query(this.socket.options.query, 't=' + +new Date);

    req.open(method || 'GET', this.prepareUrl() + query, true);

    if (method == 'POST') {
      try {
        if (req.setRequestHeader) {
          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        } else {
          // XDomainRequest
          req.contentType = 'text/plain';
        }
      } catch (e) {}
    }

    return req;
  };

  /**
   * Returns the scheme to use for the transport URLs.
   *
   * @api private
   */

  XHR.prototype.scheme = function () {
    return this.socket.options.secure ? 'https' : 'http';
  };

  /**
   * Check if the XHR transports are supported
   *
   * @param {Boolean} xdomain Check if we support cross domain requests.
   * @returns {Boolean}
   * @api public
   */

  XHR.check = function (socket, xdomain) {
    try {
      var request = io.util.request(xdomain),
          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),
          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),
          isXProtocol = (global.location && socketProtocol != global.location.protocol);
      if (request && !(usesXDomReq && isXProtocol)) {
        return true;
      }
    } catch(e) {}

    return false;
  };

  /**
   * Check if the XHR transport supports cross domain requests.
   *
   * @returns {Boolean}
   * @api public
   */

  XHR.xdomainCheck = function (socket) {
    return XHR.check(socket, true);
  };

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.htmlfile = HTMLFile;

  /**
   * The HTMLFile transport creates a `forever iframe` based transport
   * for Internet Explorer. Regular forever iframe implementations will 
   * continuously trigger the browsers buzy indicators. If the forever iframe
   * is created inside a `htmlfile` these indicators will not be trigged.
   *
   * @constructor
   * @extends {io.Transport.XHR}
   * @api public
   */

  function HTMLFile (socket) {
    io.Transport.XHR.apply(this, arguments);
  };

  /**
   * Inherits from XHR transport.
   */

  io.util.inherit(HTMLFile, io.Transport.XHR);

  /**
   * Transport name
   *
   * @api public
   */

  HTMLFile.prototype.name = 'htmlfile';

  /**
   * Creates a new Ac...eX `htmlfile` with a forever loading iframe
   * that can be used to listen to messages. Inside the generated
   * `htmlfile` a reference will be made to the HTMLFile transport.
   *
   * @api private
   */

  HTMLFile.prototype.get = function () {
    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
    this.doc.open();
    this.doc.write('<html></html>');
    this.doc.close();
    this.doc.parentWindow.s = this;

    var iframeC = this.doc.createElement('div');
    iframeC.className = 'socketio';

    this.doc.body.appendChild(iframeC);
    this.iframe = this.doc.createElement('iframe');

    iframeC.appendChild(this.iframe);

    var self = this
      , query = io.util.query(this.socket.options.query, 't='+ +new Date);

    this.iframe.src = this.prepareUrl() + query;

    io.util.on(window, 'unload', function () {
      self.destroy();
    });
  };

  /**
   * The Socket.IO server will write script tags inside the forever
   * iframe, this function will be used as callback for the incoming
   * information.
   *
   * @param {String} data The message
   * @param {document} doc Reference to the context
   * @api private
   */

  HTMLFile.prototype._ = function (data, doc) {
    // unescape all forward slashes. see GH-1251
    data = data.replace(/\\\//g, '/');
    this.onData(data);
    try {
      var script = doc.getElementsByTagName('script')[0];
      script.parentNode.removeChild(script);
    } catch (e) { }
  };

  /**
   * Destroy the established connection, iframe and `htmlfile`.
   * And calls the `CollectGarbage` function of Internet Explorer
   * to release the memory.
   *
   * @api private
   */

  HTMLFile.prototype.destroy = function () {
    if (this.iframe){
      try {
        this.iframe.src = 'about:blank';
      } catch(e){}

      this.doc = null;
      this.iframe.parentNode.removeChild(this.iframe);
      this.iframe = null;

      CollectGarbage();
    }
  };

  /**
   * Disconnects the established connection.
   *
   * @returns {Transport} Chaining.
   * @api public
   */

  HTMLFile.prototype.close = function () {
    this.destroy();
    return io.Transport.XHR.prototype.close.call(this);
  };

  /**
   * Checks if the browser supports this transport. The browser
   * must have an `Ac...eXObject` implementation.
   *
   * @return {Boolean}
   * @api public
   */

  HTMLFile.check = function (socket) {
    if (typeof window != "undefined" && (['Active'].concat('Object').join('X')) in window){
      try {
        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
        return a && io.Transport.XHR.check(socket);
      } catch(e){}
    }
    return false;
  };

  /**
   * Check if cross domain requests are supported.
   *
   * @returns {Boolean}
   * @api public
   */

  HTMLFile.xdomainCheck = function () {
    // we can probably do handling for sub-domains, we should
    // test that it's cross domain but a subdomain here
    return false;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('htmlfile');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports['xhr-polling'] = XHRPolling;

  /**
   * The XHR-polling transport uses long polling XHR requests to create a
   * "persistent" connection with the server.
   *
   * @constructor
   * @api public
   */

  function XHRPolling () {
    io.Transport.XHR.apply(this, arguments);
  };

  /**
   * Inherits from XHR transport.
   */

  io.util.inherit(XHRPolling, io.Transport.XHR);

  /**
   * Merge the properties from XHR transport
   */

  io.util.merge(XHRPolling, io.Transport.XHR);

  /**
   * Transport name
   *
   * @api public
   */

  XHRPolling.prototype.name = 'xhr-polling';

  /**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */

  XHRPolling.prototype.heartbeats = function () {
    return false;
  };

  /** 
   * Establish a connection, for iPhone and Android this will be done once the page
   * is loaded.
   *
   * @returns {Transport} Chaining.
   * @api public
   */

  XHRPolling.prototype.open = function () {
    var self = this;

    io.Transport.XHR.prototype.open.call(self);
    return false;
  };

  /**
   * Starts a XHR request to wait for incoming messages.
   *
   * @api private
   */

  function empty () {};

  XHRPolling.prototype.get = function () {
    if (!this.isOpen) return;

    var self = this;

    function stateChange () {
      if (this.readyState == 4) {
        this.onreadystatechange = empty;

        if (this.status == 200) {
          self.onData(this.responseText);
          self.get();
        } else {
          self.onClose();
        }
      }
    };

    function onload () {
      this.onload = empty;
      this.onerror = empty;
      self.retryCounter = 1;
      self.onData(this.responseText);
      self.get();
    };

    function onerror () {
      self.retryCounter ++;
      if(!self.retryCounter || self.retryCounter > 3) {
        self.onClose();  
      } else {
        self.get();
      }
    };

    this.xhr = this.request();

    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {
      this.xhr.onload = onload;
      this.xhr.onerror = onerror;
    } else {
      this.xhr.onreadystatechange = stateChange;
    }

    this.xhr.send(null);
  };

  /**
   * Handle the unclean close behavior.
   *
   * @api private
   */

  XHRPolling.prototype.onClose = function () {
    io.Transport.XHR.prototype.onClose.call(this);

    if (this.xhr) {
      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;
      try {
        this.xhr.abort();
      } catch(e){}
      this.xhr = null;
    }
  };

  /**
   * Webkit based browsers show a infinit spinner when you start a XHR request
   * before the browsers onload event is called so we need to defer opening of
   * the transport until the onload event is called. Wrapping the cb in our
   * defer method solve this.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  XHRPolling.prototype.ready = function (socket, fn) {
    var self = this;

    io.util.defer(function () {
      fn.call(self);
    });
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('xhr-polling');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {
  /**
   * There is a way to hide the loading indicator in Firefox. If you create and
   * remove a iframe it will stop showing the current loading indicator.
   * Unfortunately we can't feature detect that and UA sniffing is evil.
   *
   * @api private
   */

  var indicator = global.document && "MozAppearance" in
    global.document.documentElement.style;

  /**
   * Expose constructor.
   */

  exports['jsonp-polling'] = JSONPPolling;

  /**
   * The JSONP transport creates an persistent connection by dynamically
   * inserting a script tag in the page. This script tag will receive the
   * information of the Socket.IO server. When new information is received
   * it creates a new script tag for the new data stream.
   *
   * @constructor
   * @extends {io.Transport.xhr-polling}
   * @api public
   */

  function JSONPPolling (socket) {
    io.Transport['xhr-polling'].apply(this, arguments);

    this.index = io.j.length;

    var self = this;

    io.j.push(function (msg) {
      self._(msg);
    });
  };

  /**
   * Inherits from XHR polling transport.
   */

  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);

  /**
   * Transport name
   *
   * @api public
   */

  JSONPPolling.prototype.name = 'jsonp-polling';

  /**
   * Posts a encoded message to the Socket.IO server using an iframe.
   * The iframe is used because script tags can create POST based requests.
   * The iframe is positioned outside of the view so the user does not
   * notice it's existence.
   *
   * @param {String} data A encoded message.
   * @api private
   */

  JSONPPolling.prototype.post = function (data) {
    var self = this
      , query = io.util.query(
             this.socket.options.query
          , 't='+ (+new Date) + '&i=' + this.index
        );

    if (!this.form) {
      var form = document.createElement('form')
        , area = document.createElement('textarea')
        , id = this.iframeId = 'socketio_iframe_' + this.index
        , iframe;

      form.className = 'socketio';
      form.style.position = 'absolute';
      form.style.top = '0px';
      form.style.left = '0px';
      form.style.display = 'none';
      form.target = id;
      form.method = 'POST';
      form.setAttribute('accept-charset', 'utf-8');
      area.name = 'd';
      form.appendChild(area);
      document.body.appendChild(form);

      this.form = form;
      this.area = area;
    }

    this.form.action = this.prepareUrl() + query;

    function complete () {
      initIframe();
      self.socket.setBuffer(false);
    };

    function initIframe () {
      if (self.iframe) {
        self.form.removeChild(self.iframe);
      }

      try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = document.createElement('<iframe name="'+ self.iframeId +'">');
      } catch (e) {
        iframe = document.createElement('iframe');
        iframe.name = self.iframeId;
      }

      iframe.id = self.iframeId;

      self.form.appendChild(iframe);
      self.iframe = iframe;
    };

    initIframe();

    // we temporarily stringify until we figure out how to prevent
    // browsers from turning `\n` into `\r\n` in form inputs
    this.area.value = io.JSON.stringify(data);

    try {
      this.form.submit();
    } catch(e) {}

    if (this.iframe.attachEvent) {
      iframe.onreadystatechange = function () {
        if (self.iframe.readyState == 'complete') {
          complete();
        }
      };
    } else {
      this.iframe.onload = complete;
    }

    this.socket.setBuffer(true);
  };

  /**
   * Creates a new JSONP poll that can be used to listen
   * for messages from the Socket.IO server.
   *
   * @api private
   */

  JSONPPolling.prototype.get = function () {
    var self = this
      , script = document.createElement('script')
      , query = io.util.query(
             this.socket.options.query
          , 't='+ (+new Date) + '&i=' + this.index
        );

    if (this.script) {
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }

    script.async = true;
    script.src = this.prepareUrl() + query;
    script.onerror = function () {
      self.onClose();
    };

    var insertAt = document.getElementsByTagName('script')[0];
    insertAt.parentNode.insertBefore(script, insertAt);
    this.script = script;

    if (indicator) {
      setTimeout(function () {
        var iframe = document.createElement('iframe');
        document.body.appendChild(iframe);
        document.body.removeChild(iframe);
      }, 100);
    }
  };

  /**
   * Callback function for the incoming message stream from the Socket.IO server.
   *
   * @param {String} data The message
   * @api private
   */

  JSONPPolling.prototype._ = function (msg) {
    this.onData(msg);
    if (this.isOpen) {
      this.get();
    }
    return this;
  };

  /**
   * The indicator hack only works after onload
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  JSONPPolling.prototype.ready = function (socket, fn) {
    var self = this;
    if (!indicator) return fn.call(this);

    io.util.load(function () {
      fn.call(self);
    });
  };

  /**
   * Checks if browser supports this transport.
   *
   * @return {Boolean}
   * @api public
   */

  JSONPPolling.check = function () {
    return 'document' in global;
  };

  /**
   * Check if cross domain requests are supported
   *
   * @returns {Boolean}
   * @api public
   */

  JSONPPolling.xdomainCheck = function () {
    return true;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('jsonp-polling');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

if (typeof define === "function" && define.amd) {
  define([], function () { return io; });
}
})();
},{}],213:[function(require,module,exports){
(function (Buffer){
var crypto = require("crypto");

var warn = function(){console.log.apply(console,arguments); return undefined; };
var debug = function(){};
//var debug = function(){console.log.apply(console,arguments)};
exports.debug = function(cb){ debug = cb; };
var info = function(){};
//var debug = function(){console.log.apply(console,arguments)};
exports.info = function(cb){ info = cb; };

var defaults = exports.defaults = {};
defaults.chan_timeout = 10000; // how long before for ending durable channels w/ no acks
defaults.seek_timeout = 3000; // shorter tolerance for seeks, is far more lossy
defaults.chan_autoack = 1000; // is how often we auto ack if the app isn't generating responses in a durable channel
defaults.chan_resend = 2000; // resend the last packet after this long if it wasn't acked in a durable channel
defaults.chan_outbuf = 100; // max size of outgoing buffer before applying backpressure
defaults.chan_inbuf = 50; // how many incoming packets to cache during processing/misses
defaults.nat_timeout = 60*1000; // nat timeout for inactivity
defaults.idle_timeout = 5*defaults.nat_timeout; // overall inactivity timeout
defaults.link_timer = defaults.nat_timeout - (5*1000); // how often the DHT link maintenance runs
defaults.link_max = 256; // maximum number of links to maintain overall (minimum one packet per link timer)
defaults.link_k = 8; // maximum number of links to maintain per bucket

// network preference order for paths
var pathShareOrder = ["bluetooth","webrtc","ipv6","ipv4","http"];

exports.switch = function()
{
  var self = {seeds:[], locals:[], lines:{}, bridges:{}, bridgeLine:{}, all:{}, buckets:[], capacity:[], rels:{}, raws:{}, paths:[], bridgeCache:{}, networks:{}, CSets:{}};

  self.load = function(id)
  {
    if(typeof id != "object") return "bad keys";
    self.id = id;
    var err = loadkeys(self);
    if(err) return err;
    if(Object.keys(self.cs).length == 0) return "missing cipher sets";
    self.hashname = parts2hn(self.parts);
    return false;
  }
  self.make = keysgen;

  // configure defaults
  self.seed = true;

  // udp socket stuff
  self.pcounter = 1;
  self.receive = receive;
  // outgoing packets to the network
  self.deliver = function(type, callback){ self.networks[type] = callback};
  self.networks["relay"] = function(path,msg){
    if(path.relay.ended) return debug("dropping dead relay");
    path.relay.send({body:msg});
  };
  self.send = function(path, msg, to){
    if(!msg) return debug("send called w/ no packet, dropping");
    if(to) path = to.pathOut(path);
    if(!path) return debug("send called w/ no valid network, dropping");
    debug("<<<<",Date(),msg.length,[path.type,path.ip,path.port,path.id].join(","),to&&to.hashname);

    // try to send it via a supported network
    if(self.networks[path.type]) self.networks[path.type](path,msg,to);

    // if the path has been active in or out recently, we're done
    if(Date.now() - path.lastIn < defaults.nat_timeout || Date.now() - path.lastOut < (defaults.chan_timeout / 2)) return;

    // no network support or unresponsive path, try a bridge
    self.bridge(path,msg,to);
  };
  self.pathSet = function(path, del)
  {
    var existing;
    if(!path) return;
    if((existing = pathMatch(path,self.paths)))
    {
      if(del) self.paths.splice(self.paths.indexOf(existing),1);
      return;
    }
    debug("local path add",JSON.stringify(path));
    info("self",path.type,JSON.stringify(path));
    self.paths.push(path);
    // trigger pings if we're online
    if(self.isOnline)
    {
      linkMaint(self);
    }
  }

  // need some seeds to connect to, addSeed({ip:"1.2.3.4", port:5678, public:"PEM"})
  self.addSeed = addSeed;

  // map a hashname to an object, whois(hashname)
  self.whois = whois;
  self.whokey = whokey;
  self.start = function(hashname,type,arg,cb)
  {
    var hn = self.whois(hashname);
    if(!hn) return cb("invalid hashname");
    return hn.start(type,arg,cb);
  }

  // connect to the network, online(callback(err))
  self.online = online;

  // handle new reliable channels coming in from anyone
  self.listen = function(type, callback){
    if(typeof type != "string" || typeof callback != "function") return warn("invalid arguments to listen");
    if(type.substr(0,1) !== "_") type = "_"+type;
    self.rels[type] = callback;
  };
  // advanced usage only
  self.raw = function(type, callback){
    if(typeof type != "string" || typeof callback != "function") return warn("invalid arguments to raw");
    self.raws[type] = callback;
  };

  // internal listening unreliable channels
  self.raws["peer"] = inPeer;
  self.raws["connect"] = inConnect;
  self.raws["seek"] = inSeek;
  self.raws["path"] = inPath;
  self.raws["bridge"] = inBridge;
  self.raws["link"] = inLink;

  // primarily internal, to seek/connect to a hashname
  self.seek = seek;
  self.bridge = bridge;

  // for modules
  self.pencode = pencode;
  self.pdecode = pdecode;
  self.isLocalIP = isLocalIP;
  self.randomHEX = randomHEX;
  self.uriparse = uriparse;
  self.pathMatch = pathMatch;
  self.isHashname = function(hex){return isHEX(hex, 64)};
  self.isBridge = isBridge;
  self.wraps = channelWraps;
  self.waits = [];
  self.waiting = false
  self.wait = function(bool){
    if(bool) return self.waits.push(true);
    self.waits.pop();
    if(self.waiting && self.waits.length == 0) self.waiting();
  }
  self.ping = function(){
    if(!self.tracer) self.tracer = randomHEX(16);
    var js = {type:"ping",trace:self.tracer};
    Object.keys(self.parts).forEach(function(csid){js[csid] = true;});
    return js;
  }

  linkLoop(self);
  return self;
}

/* CHANNELS API
hn.channel(type, arg, callback)
  - used by app to create a reliable channel of given type
  - arg contains .js and .body for the first packet
  - callback(err, arg, chan, cbDone)
    - called when any packet is received (or error/fail)
    - given the response .js .body in arg
    - cbDone when arg is processed
    - chan.send() to send packets
    - chan.wrap(bulk|stream) to modify interface, replaces this callback handler
      - chan.bulk(str, cbDone) / onBulk(cbDone(err, str))
      - chan.read/write
hn.raw(type, arg, callback)
  - arg contains .js and .body to create an unreliable channel
  - callback(err, arg, chan)
    - called on any packet or error
    - given the response .js .body in arg
    - chan.send() to send packets

self.channel(type, callback)
  - used to listen for incoming reliable channel starts
  - callback(err, arg, chan, cbDone)
    - called for any answer or subsequent packets
    - chan.wrap() to modify
self.raw(type, callback)
  - used to listen for incoming unreliable channel starts
  - callback(err, arg, chan)
    - called for any incoming packets
*/

// these are called once a reliable channel is started both ways to add custom functions for the app
var channelWraps = {
  "bulk":function(chan){
    // handle any incoming bulk flow
    var bulkIn = "";
    chan.callback = function(end, packet, chan, cb)
    {
      cb();
      if(packet.body) bulkIn += packet.body;
      if(!chan.onBulk) return;
      if(end) chan.onBulk(end!==true?end:false, bulkIn);
    }
    // handle (optional) outgoing bulk flow
    chan.bulk = function(data, callback)
    {
      // break data into chunks and send out, no backpressure yet
      while(data)
      {
        var chunk = data.substr(0,1000);
        data = data.substr(1000);
        var packet = {body:chunk};
        if(!data) packet.callback = callback; // last packet gets confirmed
        chan.send(packet);
      }
      chan.end();
    }
  }
}

// do the maintenance work for links
function linkLoop(self)
{
  self.bridgeCache = {}; // reset cache for any bridging
//  hnReap(self); // remove any dead ones, temporarily disabled due to node crypto compiled cleanup bug
  linkMaint(self); // ping all of them
  setTimeout(function(){linkLoop(self)}, defaults.link_timer);
}

// delete any defunct hashnames!
function hnReap(self)
{
  var hn;
  function del(why)
  {
    if(hn.lineOut) delete self.lines[hn.lineOut];
    delete self.all[hn.hashname];
    debug("reaping ", hn.hashname, why);
  }
  Object.keys(self.all).forEach(function(h){
    hn = self.all[h];
    debug("reap check",hn.hashname,Date.now()-hn.sentAt,Date.now()-hn.recvAt,Object.keys(hn.chans).length);
    if(hn.isSeed) return;
    if(Object.keys(hn.chans).length > 0) return; // let channels clean themselves up
    if(Date.now() - hn.at < hn.timeout()) return; // always leave n00bs around for a while
    if(!hn.sentAt) return del("never sent anything, gc");
    if(!hn.recvAt) return del("sent open, never received");
    if(Date.now() - hn.sentAt > hn.timeout()) return del("we stopped sending to them");
    if(Date.now() - hn.recvAt > hn.timeout()) return del("they stopped responding to us");
  });
}

// every link that needs to be maintained, ping them
function linkMaint(self)
{
  // process every bucket
  Object.keys(self.buckets).forEach(function(bucket){
    // sort by age and send maintenance to only k links
    var sorted = self.buckets[bucket].sort(function(a,b){ return a.age - b.age });
    if(sorted.length) debug("link maintenance on bucket",bucket,sorted.length);
    sorted.slice(0,defaults.link_k).forEach(function(hn){
      if(!hn.linked || !hn.alive) return;
      if((Date.now() - hn.linked.sentAt) < Math.ceil(defaults.link_timer/2)) return; // we sent to them recently
      hn.linked.send({js:{seed:self.seed}});
    });
  });
}

// try finding a bridge
function bridge(path, msg, to)
{
  var self = this;
  var packet = pdecode(msg);
  if(packet.head.length) return; // only bridge line packets
  if(!to) return; // require to for line info

  // check for existing bridge
  var existing = pathMatch(path,to.bridges);
  if(existing)
  {
    if(existing.bridged) return self.send(existing.bridged,msg); // leave off to to prevent loops
    existing.bridgeq = msg; // queue most recent packet;
    return;
  }

  if(!self.bridges[path.type]) return;
  debug("bridging",JSON.stringify(path.json),to.hashname);

  // TODO, better selection of a bridge?
  var via;
  Object.keys(self.bridges[path.type]).forEach(function(id){
    if(id == to.hashname) return; // lolz
    var hn = self.whois(id);
    if(hn.alive) via = hn;
  });

  if(!via) return debug("couldn't find a bridge host");

  // stash this so that any more bridge's don't spam
  if(!to.bridges) to.bridges = [];
  path.bridgeq = msg;
  to.bridges.push(path);

  // create the bridge
  via.raw("bridge", {js:{to:to.lineIn,from:to.lineOut,path:path}}, function(end, packet){
    // TODO we can try another one if failed?
    if(end !== true) return debug("failed to create bridge",end,via.hashname);
    // create our mapping!
    path.bridged = packet.sender;
    self.send(packet.sender,path.bridgeq);
    delete path.bridgeq;
  });
}

// configures or checks
function isBridge(arg)
{
  var self = this;
  if(arg === true) self.bridging = true;
  if(self.bridging) return true;
  if(!arg) return self.bridging;

  var check = (typeof arg == "string")?self.whois(arg):arg;
  if(check && check.bridging) return true;
  return false;
}

function addSeed(arg) {
  var self = this;
  if(!arg.parts) return warn("invalid args to addSeed",arg);
  var seed = self.whokey(arg.parts,false,arg.keys);
  if(!seed) return warn("invalid seed info",arg);
  if(Array.isArray(arg.paths)) arg.paths.forEach(function(path){
    path = seed.pathGet(path);
    path.seed = true;
  });
  seed.isSeed = true;
  self.seeds.push(seed);
}

function online(callback)
{
  var self = this;
  if(self.waits.length > 0) return self.waiting = function(){self.online(callback)};
  self.isOnline = true;
  // ping lan
  self.send({type:"lan"}, pencode(self.ping()));

  var dones = self.seeds.length;
  if(!dones) {
    warn("no seeds");
    return callback(null,0);
  }

  // safely callback only once or when all seeds return
  function done()
  {
    if(!dones) return; // already called back
    var alive = self.seeds.filter(function(seed){return seed.alive}).length;
    if(alive)
    {
      callback(null,alive);
      dones = 0;
      return;
    }
    dones--;
    // failed
    if(!dones) callback("offline",0);
  }

  self.seeds.forEach(function(seed){
    seed.link(function(){
      if(seed.alive) seed.pathSync();
      done();
    });
  });
}

// self.receive, raw incoming udp data
function receive(msg, path)
{
  var self = this;
  var packet = pdecode(msg);
  if(!packet) return warn("failed to decode a packet from", path, (new Buffer(msg)).toString("hex"));
  if(packet.length == 2) return; // empty packets are NAT pings

  packet.sender = path;
  packet.id = self.pcounter++;
  packet.at = Date.now();
  debug(">>>>",Date(),msg.length, packet.head.length, [path.type,path.ip,path.port,path.id].join(","));

  // handle any discovery requests
  if(packet.js.type == "ping") return inPing(self, packet);
  if(packet.js.type == "pong") return inPong(self, packet);

  // either it's an open
  if(packet.head.length == 1)
  {
    var open = deopenize(self, packet);
    if (!open || !open.verify) return warn("couldn't decode open (possibly using the wrong public key?)",open&&open.err);
    if (!isHEX(open.js.line, 32)) return warn("invalid line id enclosed",open.js.line);
    if(open.js.to !== self.hashname) return warn("open for wrong hashname",open.js.to);
    var csid = partsMatch(self.parts,open.js.from);
    if(csid != open.csid) return warn("open with mismatch CSID",csid,open.csid);

    var from = self.whokey(open.js.from,open.key);
    if (!from) return warn("invalid hashname", open.js.from);

    // make sure this open is legit
    if (typeof open.js.at != "number") return warn("invalid at", open.js.at);

    // duplicate open and there's newer line packets, ignore it
    if(from.openAt && open.js.at <= from.openAt && from.lineAt == from.openAt) return;

    // open is legit!
    from.recvAt = Date.now();

    // add this path in and sync paths
    path = from.pathIn(path);
    debug("inOpen verified", from.hashname,JSON.stringify(path.json));
    setTimeout(from.pathSync,1); // in background

    // if new line id, reset incoming channels
    if(open.js.line != from.lineIn)
    {
      debug("new line");
      Object.keys(from.chans).forEach(function(id){
        if(id % 2 == from.chanOut % 2) return; // our ids
        if(from.chans[id]) from.chans[id].fail({js:{err:"reset"}});
        delete from.chans[id];
      });
    }

    // update values
    var line = {};
    from.openAt = open.js.at;
    from.lineIn = open.js.line;

    // send an open back
    self.send(path,from.open(),from);

    // line is open now!
    from.csid = open.csid;
    self.CSets[open.csid].openline(from, open);
    debug("line open",from.hashname,from.lineOut,from.lineIn);
    self.lines[from.lineOut] = from;

    // resend the last sent packet again
    if (from.lastPacket) {
      var packet = from.lastPacket;
      delete from.lastPacket;
      from.send(packet)
    }

    // if it was a lan seed, add them
    if(from.local && self.locals.indexOf(from) == -1) self.locals.push(from);

    return;
  }

  // or it's a line
  if(packet.head.length == 0)
  {
    var lineID = packet.body.slice(0,16).toString("hex");
    var line = packet.from = self.lines[lineID];

    // a matching line is required to decode the packet
    if(!line) {
      if(!self.bridgeLine[lineID]) return debug("unknown line received", lineID, JSON.stringify(packet.sender));
      debug("BRIDGE",JSON.stringify(self.bridgeLine[lineID]),lineID);
      var id = crypto.createHash("sha256").update(packet.body).digest("hex")
      if(self.bridgeCache[id]) return; // drop duplicates
      self.bridgeCache[id] = true;
      // flat out raw retransmit any bridge packets
      return self.send(self.bridgeLine[lineID],msg);
    }

    // decrypt and process
    var err;
    if((err = self.CSets[line.csid].delineize(line, packet))) return debug("couldn't decrypt line",err,packet.sender);
    line.lineAt = line.openAt;
    line.receive(packet);
    return;
  }

  if(Object.keys(packet.js).length > 0) warn("dropping incoming packet of unknown type", packet.js, packet.sender);
}

function whokey(parts, key, keys)
{
  var self = this;
  if(typeof parts != "object") return false;
  var csid = partsMatch(self.parts,parts);
  if(!csid) return false;
  hn = self.whois(parts2hn(parts));
  if(!hn) return false;
  if(keys) key = keys[csid]; // convenience for addSeed
  var err = loadkey(self,hn,csid,key);
  if(err)
  {
    warn("whokey err",hn.hashname,err);
    return false;
  }
  if(crypto.createHash("sha256").update(hn.key).digest("hex") != parts[csid])
  {
    warn("whokey part mismatch",hn.hashname,csid,parts[csid],crypto.createHash("sha256").update(hn.key).digest("hex"));
    delete hn.key;
    return false;
  }
  hn.parts = parts;

  return hn;
}

// this creates a hashname identity object (or returns existing)
function whois(hashname)
{
  var self = this;
  // validations
  if(!hashname) { warn("whois called without a hashname", hashname, new Error().stack); return false; }
  if(typeof hashname != "string") { warn("wrong type, should be string", typeof hashname,hashname); return false; }
  hashname = hashname.split(",")[0]; // convenience if an address is passed in
  if(!isHEX(hashname, 64)) { warn("whois called without a valid hashname", hashname); return false; }

  // never return ourselves
  if(hashname === self.hashname) { debug("whois called for self"); return false; }

  var hn = self.all[hashname];
  if(hn) return hn;

  // make a new one
  hn = self.all[hashname] = {hashname:hashname, chans:{}, self:self, paths:[], isAlive:0};
  hn.at = Date.now();
  hn.bucket = dhash(self.hashname, hashname);
  if(!self.buckets[hn.bucket]) self.buckets[hn.bucket] = [];

  // to create a new channels to this hashname
  var sort = [self.hashname,hashname].sort();
  hn.chanOut = (sort[0] == self.hashname) ? 2 : 1;
  hn.start = channel;
  hn.raw = raw;

  hn.pathGet = function(path)
  {
    if(typeof path != "object" || typeof path.type != "string") return false;

    var match = pathMatch(path, hn.paths);
    if(match) return match;

    // preserve original
    if(!path.json) path.json = JSON.parse(JSON.stringify(path));

    debug("adding new path",hn.paths.length,JSON.stringify(path.json));
    info(hn.hashname,path.type,JSON.stringify(path.json));
    hn.paths.push(path);

    // track overall if they have a public IP network
    if(!isLocalPath(path)) hn.isPublic = true;

    return path;
  }

  hn.pathOut = function(path)
  {
    if(!path) return false;
    path = hn.pathGet(path);
    if(path.type == "relay" && path.relay.ended) return hn.pathEnd(path);
    path.lastOut = Date.now();
    if(!pathValid(hn.to) && pathValid(path)) hn.to = path;
    return path;
  }

  hn.pathEnd = function(path)
  {
    if(path.seed) return false; // never remove a seed-path
    if(hn.to == path) hn.to = false;
    path.gone = true;
    var index = hn.paths.indexOf(path);
    if(index >= 0) hn.paths.splice(index,1);
    debug("PATH END",JSON.stringify(path.json));
    return false;
  }

  // manage network information consistently, called on all validated incoming packets
  hn.pathIn = function(path)
  {
    path = hn.pathGet(path);

    // first time we've seen em
    if(!path.lastIn && !path.lastOut)
    {
      debug("PATH INNEW",isLocalPath(path)?"local":"public",JSON.stringify(path.json),hn.paths.map(function(p){return JSON.stringify(p.json)}));

      // update public ipv4 info
      if(path.type == "ipv4" && !isLocalIP(path.ip))
      {
        hn.ip = path.ip;
        hn.port = path.port;
      }

      // cull any invalid paths of the same type
      hn.paths.forEach(function(other){
        if(other == path) return;
        if(other.type != path.type) return;
        if(!pathValid(other)) return hn.pathEnd(other);
        // remove any previous path on the same IP
        if(path.ip && other.ip == path.ip) return hn.pathEnd(other);
        // remove any previous http path entirely
        if(path.type == "http") return hn.pathEnd(other);
      });

      // any custom non-public paths, we must bridge for
      if(pathShareOrder.indexOf(path.type) == -1 && path.type != "relay") hn.bridging = true;

      // track overall if we trust them as local
      if(isLocalPath(path)) hn.isLocal = true;
    }

    path.lastIn = Date.now();
    self.recvAt = Date.now();

    // always update default to newest
    hn.to = path;
    hn.alive = pathValid(hn.to);

    return path;
  }

  // try to send a packet to a hashname, doing whatever is possible/necessary
  hn.send = function(packet){
    // if there's a line, try sending it via a valid network path!
    if(hn.lineIn)
    {
      debug("line sending",hn.hashname,hn.lineIn);
      var lined = packet.msg || self.CSets[hn.csid].lineize(hn, packet);
      hn.sentAt = Date.now();

      // directed packets are preferred, just dump and done
      if(packet.to) return self.send(packet.to, lined, hn);

      // send to the default best path
      if(hn.to) self.send(hn.to, lined, hn);

      // if it was good, we're done, if not fall through
      if(pathValid(hn.to)) return;
    }

    // we've fallen through, either no line, or no valid paths
    debug("alive failthrough",hn.sendSeek,Object.keys(hn.vias||{}));
    hn.alive = hn.openAt = false;
    hn.lastPacket = packet; // will be resent if/when an open is received

    // always send to all known paths, increase resiliency
    hn.paths.forEach(function(path){
      self.send(path, hn.open(), hn);
    });

    // also try using any via informtion to create a new line
    function vias()
    {
      if(!hn.vias) return;
      hn.sentOpen = false; // whenever we send a peer, we'll always need to resend any open regardless
      // try to connect vias
      var todo = hn.vias;
      delete hn.vias; // never use more than once
      Object.keys(todo).forEach(function(via){
        var address = todo[via].split(",");
        if(address.length <= 1) return;
        if(address.length == 4 && address[2].split(".").length == 4 && parseInt(address[3]) > 0)
        {
          // NAT hole punching
          var path = {type:"ipv4",ip:address[2],port:parseInt(address[3])};
          self.send(path,pencode());
          // if possibly behind the same NAT (same public ip), set flag to allow/ask to share local paths
          self.paths.forEach(function(path2){
            if(path2.type == "ipv4" && path2.ip == path.ip) hn.isLocal = true;
          })
        }
        // send the peer request
        self.whois(via).peer(hn.hashname, address[1]);
      });
    }

    // if there's via information, just try that
    if(hn.vias) return vias();


    // never too fast, worst case is to try to seek again
    if(!hn.sendSeek || (Date.now() - hn.sendSeek) > 5000)
    {
      hn.sendSeek = Date.now();
      self.seek(hn, function(err){
        if(!hn.lastPacket) return; // packet was already sent elsewise
        vias(); // process any new vias
      });
    }

  }

  // handle all incoming line packets
  hn.receive = function(packet)
  {
//    if((Math.floor(Math.random()*10) == 4)) return warn("testing dropping randomly!");
    if(!packet.js || typeof packet.js.c != "number") return warn("dropping invalid channel packet",packet.js);

    debug("LINEIN",JSON.stringify(packet.js));
    hn.recvAt = Date.now();
    // normalize/track sender network path
    packet.sender = hn.pathIn(packet.sender);

    // find any existing channel
    var chan = hn.chans[packet.js.c];
    if(chan === false) return; // drop packet for a closed channel
    if(chan) return chan.receive(packet);

    // start a channel if one doesn't exist, check either reliable or unreliable types
    var listening = {};
    if(typeof packet.js.seq == "undefined") listening = self.raws;
    if(packet.js.seq === 0) listening = self.rels;
    if(!listening[packet.js.type])
    {
      // bounce error
      if(!packet.js.end && !packet.js.err)
      {
        warn("bouncing unknown channel/type",packet.js);
        var err = (packet.js.type) ? "unknown type" : "unknown channel"
        hn.send({js:{err:err,c:packet.js.c}});
      }
      return;
    }

    // verify incoming new chan id
    if(packet.js.c % 2 == hn.chanOut % 2) return warn("channel id incorrect",packet.js.c,hn.chanOut)

    // make the correct kind of channel;
    var kind = (listening == self.raws) ? "raw" : "start";
    var chan = hn[kind](packet.js.type, {bare:true,id:packet.js.c}, listening[packet.js.type]);
    chan.receive(packet);
  }

  hn.chanDone = function(id)
  {
    hn.chans[id] = false;
  }

  // track who told us about this hn
  hn.via = function(from, address)
  {
    if(typeof address != "string") return warn("invalid see address",address);
    if(!hn.vias) hn.vias = {};
    if(hn.vias[from.hashname]) return;
    hn.vias[from.hashname] = address;
  }

  // just make a seek request conveniently
  hn.seek = function(hashname, callback)
  {
    var bucket = dhash(hn.hashname, hashname);
    var prefix = hashname.substr(0, Math.ceil((255-bucket)/4)+2);
    hn.raw("seek", {timeout:defaults.seek_timeout, retry:3, js:{"seek":prefix}}, function(err, packet, chan){
      callback(packet.js.err,Array.isArray(packet.js.see)?packet.js.see:[]);
    });
  }

  // return our address to them
  hn.address = function(to)
  {
    if(!to) return "";
    var csid = partsMatch(hn.parts,to.parts);
    if(!csid) return "";
    if(!hn.ip) return [hn.hashname,csid].join(",");
    return [hn.hashname,csid,hn.ip,hn.port].join(",");
  }

  // request a new link to them
  hn.link = function(callback)
  {
    if(!callback) callback = function(){}

    var js = {seed:self.seed};
    js.see = self.buckets[hn.bucket].sort(function(a,b){ return a.age - b.age }).filter(function(a){ return a.seed }).map(function(seed){ return seed.address(hn) }).slice(0,8);
    // add some distant ones if none
    if(js.see.length < 8) Object.keys(self.buckets).forEach(function(bucket){
      if(js.see.length >= 8) return;
      self.buckets[bucket].sort(function(a,b){ return a.age - b.age }).forEach(function(seed){
        if(js.see.length >= 8 || !seed.seed || js.see.indexOf(seed.address(hn)) != -1) return;
        js.see.push(seed.address(hn));
      });
    });

    if(self.isBridge(hn)) js.bridges = Object.keys(self.networks).filter(function(type){return (pathShareOrder.indexOf(type) >= 0)?true:false});

    if(hn.linked)
    {
      hn.linked.send({js:js});
      return callback();
    }

    hn.raw("link", {retry:3, js:js}, function(err, packet, chan){
      inLink(err, packet, chan);
      callback(packet.js.err);
    });
  }

  // send a simple lossy peer request, don't care about answer
  hn.peer = function(hashname, csid)
  {
    if(!csid || !self.parts[csid]) return;
    var js = {"peer":hashname};
    js.paths = hn.pathsOut();
    hn.raw("peer",{js:js, body:getkey(self,csid)}, function(err, packet, chan){
      if(err) return;
      if(!chan.relay) chan.relay = self.whois(hashname);
      inRelay(self, chan, packet);
    });
  }

  // return the current open packet
  hn.open = function()
  {
    if(!hn.parts) return false; // can't open if no key
    if(hn.opened) return hn.opened;
    hn.opened = openize(self,hn);
    return hn.opened;
  }

  // generate current paths array to them, for peer and paths requests
  hn.pathsOut = function()
  {
    var paths = [];
    self.paths.forEach(function(path){
      if(isLocalPath(path) && !hn.isLocal) return;
      paths.push(path);
    });
    return paths;
  }

  // send a path sync
  hn.pathSync = function()
  {
    if(hn.pathSyncing) return;
    hn.pathSyncing = true;
    debug("pathSync",hn.hashname);
    var js = {};
    var paths = hn.pathsOut();
    if(paths.length > 0) js.paths = paths;
    var alive = [];
    hn.raw("path",{js:js, timeout:10*1000}, function(err, packet){
      if(err)
      {
        hn.pathSyncing = false;
        return;
      }

      // if path answer is from a seed, update our public ip/port in case we're behind a NAT
      if(packet.from.isSeed && typeof packet.js.path == "object" && packet.js.path.type == "ipv4" && !isLocalIP(packet.js.path.ip))
      {
        debug("updating public ipv4",JSON.stringify(self.pub4),JSON.stringify(packet.js.path));
        self.pathSet(self.pub4,true);
        self.pub4 = {type:"ipv4", ip:packet.js.path.ip, port:parseInt(packet.js.path.port)};
        self.pathSet(self.pub4);
      }

      // add to all answers and update best default from active ones
      alive.push(packet.sender);
      var best = packet.sender;
      alive.forEach(function(path){
        if(pathShareOrder.indexOf(path.type) > pathShareOrder.indexOf(path.type)) return;
        if(isLocalPath(best)) return; // always prefer (the first) local paths
        best = path;
      });
      debug("pathSync best",hn.hashname,JSON.stringify(best.json));
      hn.to = best;
    });
  }

  // create a ticket buffer to this hn w/ this packet
  hn.ticket = function(packet)
  {
    if(self.pencode(packet).length > 1024) return false;
    return ticketize(self, hn, packet);
  }

  // decode a ticket buffer from them
  hn.ticketed = function(ticket)
  {
    packet = pdecode(ticket);
    if(!packet) return false;
    return deticketize(self, hn, packet);
  }

  return hn;
}

// seek the dht for this hashname
function seek(hn, callback)
{
  var self = this;
  if(typeof hn == "string") hn = self.whois(hn);
  if(!callback) callback = function(){};
  if(!hn) return callback("invalid hashname");

  var did = {};
  var doing = {};
  var queue = [];
  var wise = {};
  var closest = 255;

  // load all seeds and sort to get the top 3
  var seeds = []
  Object.keys(self.buckets).forEach(function(bucket){
    self.buckets[bucket].forEach(function(link){
      if(link.hashname == hn) return; // ignore the one we're (re)seeking
      if(link.seed && link.alive) seeds.push(link);
    });
  });
  seeds.sort(function(a,b){ return dhash(hn.hashname,a.hashname) - dhash(hn.hashname,b.hashname) }).slice(0,3).forEach(function(seed){
    wise[seed.hashname] = true;
    queue.push(seed.hashname);
  });

  debug("seek starting with",queue,seeds.length);

  // always process potentials in order
  function sort()
  {
    queue = queue.sort(function(a,b){
      return dhash(hn.hashname,a) - dhash(hn.hashname,b)
    });
  }

  // track when we finish
  function done(err)
  {
    // get all the hashnames we used/found and do final sort to return
    Object.keys(did).forEach(function(k){ if(queue.indexOf(k) == -1) queue.push(k); });
    Object.keys(doing).forEach(function(k){ if(queue.indexOf(k) == -1) queue.push(k); });
    sort();
    while(cb = hn.seeking.shift()) cb(err, queue.slice());
  }

  // track callback(s);
  if(!hn.seeking) hn.seeking = [];
  hn.seeking.push(callback);
  if(hn.seeking.length > 1) return;

  // main loop, multiples of these running at the same time
  function loop(onetime){
    if(!hn.seeking.length) return; // already returned
    debug("SEEK LOOP",queue);
    // if nothing left to do and nobody's doing anything, failed :(
    if(Object.keys(doing).length == 0 && queue.length == 0) return done("failed to find the hashname");

    // get the next one to ask
    var mine = onetime||queue.shift();
    if(!mine) return; // another loop() is still running

    // if we found it, yay! :)
    if(mine == hn.hashname) return done();
    // skip dups
    if(did[mine] || doing[mine]) return onetime||loop();
    var distance = dhash(hn.hashname, mine);
    if(distance > closest) return onetime||loop(); // don't "back up" further away
    if(wise[mine]) closest = distance; // update distance if trusted
    doing[mine] = true;
    var to = self.whois(mine);
    to.seek(hn.hashname, function(err, see){
      see.forEach(function(item){
        var sug = self.whois(item);
        if(!sug) return;
        // if this is the first entry and from a wise one, give them wisdom too
        if(wise[to.hashname] && see.indexOf(item) == 0) wise[sug.hashname] = true;
        sug.via(to, item);
        queue.push(sug.hashname);
      });
      sort();
      did[mine] = true;
      delete doing[mine];
      onetime||loop();
    });
  }

  // start three of them
  loop();loop();loop();

  // also force query any locals
  self.locals.forEach(function(local){loop(local.hashname)});
}

// create an unreliable channel
function raw(type, arg, callback)
{
  var hn = this;
  var chan = {type:type, callback:callback};
  chan.id = arg.id;
  if(!chan.id)
  {
    chan.id = hn.chanOut;
    hn.chanOut += 2;
  }
  chan.isOut = (chan.id % 2 == hn.chanOut % 2);
  hn.chans[chan.id] = chan;

  // raw channels always timeout/expire after the last sent/received packet
  if(!arg.timeout) arg.timeout = defaults.chan_timeout;
  function timer()
  {
    if(chan.timer) clearTimeout(chan.timer);
    chan.timer = setTimeout(function(){
      chan.fail({js:{err:"timeout"}});
    }, arg.timeout);
  }
  chan.timeout = function(timeout)
  {
    arg.timeout = timeout;
    timer();
  }

  chan.hashname = hn.hashname; // for convenience

  debug("new unreliable channel",hn.hashname,chan.type,chan.id);

  // process packets at a raw level, very little to do
  chan.receive = function(packet)
  {
    if(!hn.chans[chan.id]) return debug("dropping receive packet to dead channel",chan.id,packet.js)
    // if err'd or ended, delete ourselves
    if(packet.js.err || packet.js.end) chan.fail();
    chan.last = packet.sender; // cache last received network
    chan.recvAt = Date.now();
    chan.callback(packet.js.err||packet.js.end, packet, chan);
    timer();
  }

  // minimal wrapper to send raw packets
  chan.send = function(packet)
  {
    if(!hn.chans[chan.id]) return debug("dropping send packet to dead channel",chan.id,packet.js);
    if(!packet.js) packet.js = {};
    packet.js.c = chan.id;
    debug("SEND",chan.type,JSON.stringify(packet.js));
    chan.sentAt = Date.now();
    hn.send(packet);
    // if err'd or ended, delete ourselves
    if(packet.js.err || packet.js.end) chan.fail();
    timer();
  }

  chan.fail = function(packet){
    if(chan.ended) return; // prevent multiple calls
    hn.chanDone(chan.id);
    chan.ended = true;
    if(packet)
    {
      packet.from = hn;
      chan.callback(packet.js.err, packet, chan, function(){});
    }
  }

  // send optional initial packet with type set
  if(arg.js)
  {
    arg.js.type = type;
    chan.send(arg);
    // retry if asked to, TODO use timeout for better time
    if(arg.retry)
    {
      var at = 1000;
      function retry(){
        if(chan.ended || chan.recvAt) return; // means we're gone or received a packet
        chan.send(arg);
        if(at < 4000) at *= 2;
        arg.retry--;
        if(arg.retry) setTimeout(retry, at);
      };
      setTimeout(retry, at);
    }
  }

  return chan;
}

// create a reliable channel with a friendlier interface
function channel(type, arg, callback)
{
  var hn = this;
  var chan = {inq:[], outq:[], outSeq:0, inDone:-1, outConfirmed:-1, lastAck:-1, callback:callback};
  chan.id = arg.id;
  if(!chan.id)
  {
    chan.id = hn.chanOut;
    hn.chanOut += 2;
  }
  chan.isOut = (chan.id % 2 == hn.chanOut % 2);
  hn.chans[chan.id] = chan;
  chan.timeout = arg.timeout || defaults.chan_timeout;
  // app originating if not bare, be friendly w/ the type, don't double-underscore if they did already
  if(!arg.bare && type.substr(0,1) !== "_") type = "_"+type;
  chan.type = type; // save for debug
  if(chan.type.substr(0,1) != "_") chan.safe = true; // means don't _ escape the json
  chan.hashname = hn.hashname; // for convenience

  debug("new channel",hn.hashname,chan.type,chan.id);

  // used by app to change how it interfaces with the channel
  chan.wrap = function(wrap)
  {
    if(!channelWraps[wrap]) return false;
    return channelWraps[wrap](chan);
  }

  // called to do eventual cleanup
  chan.done = function(){
    if(chan.ended) return; // prevent multiple calls
    chan.ended = true;
    debug("channel done",chan.id);
    hn.chanDone(chan.id);
  };

  // used to internally fail a channel, timeout or connection failure
  chan.fail = function(packet){
    if(chan.errored) return; // prevent multiple calls
    chan.errored = packet;
    packet.from = hn;
    chan.callback(packet.js.err, packet, chan, function(){});
    chan.done();
  }

  // simple convenience wrapper to end the channel
  chan.end = function(){
    chan.send({end:true});
    chan.done();
  };

  // errors are hard-send-end
  chan.err = function(err){
    if(chan.errored) return;
    chan.errored = {js:{err:err,c:chan.id}};
    hn.send(chan.errored);
    chan.done();
  };

  // process packets at a raw level, handle all miss/ack tracking and ordering
  chan.receive = function(packet)
  {
    // if it's an incoming error, bail hard/fast
    if(packet.js.err) return chan.fail(packet);

    // in errored state, only/always reply with the error and drop
    if(chan.errored) return chan.send(chan.errored);
    chan.lastIn = Date.now();

    // process any valid newer incoming ack/miss
    var ack = parseInt(packet.js.ack);
    if(ack > chan.outSeq) return warn("bad ack, dropping entirely",chan.outSeq,ack);
    var miss = Array.isArray(packet.js.miss) ? packet.js.miss : [];
    if(miss.length > 100) {
      warn("too many misses", miss.length, chan.id, packet.from.hashname);
      miss = miss.slice(0,100);
    }
    if(miss.length > 0 || ack > chan.lastAck)
    {
      debug("miss processing",ack,chan.lastAck,miss,chan.outq.length);
      chan.lastAck = ack;
      // rebuild outq, only keeping newer packets, resending any misses
      var outq = chan.outq;
      chan.outq = [];
      outq.forEach(function(pold){
        // packet acknowleged!
        if(pold.js.seq <= ack) {
          if(pold.callback) pold.callback();
          return;
        }
        chan.outq.push(pold);
        if(miss.indexOf(pold.js.seq) == -1) return;
        // resend misses but not too frequently
        if(Date.now() - pold.resentAt < 1000) return;
        pold.resentAt = Date.now();
        chan.ack(pold);
      });
    }

    // don't process packets w/o a seq, no batteries included
    var seq = packet.js.seq;
    if(!(seq >= 0)) return;

    // auto trigger an ack in case none were sent
    if(!chan.acker) chan.acker = setTimeout(function(){ delete chan.acker; chan.ack();}, defaults.chan_autoack);

    // drop duplicate packets, always force an ack
    if(seq <= chan.inDone || chan.inq[seq-(chan.inDone+1)]) return chan.forceAck = true;

    // drop if too far ahead, must ack
    if(seq-chan.inDone > defaults.chan_inbuf)
    {
      warn("chan too far behind, dropping", seq, chan.inDone, chan.id, packet.from.hashname);
      return chan.forceAck = true;
    }

    // stash this seq and process any in sequence, adjust for yacht-based array indicies
    chan.inq[seq-(chan.inDone+1)] = packet;
    debug("INQ",Object.keys(chan.inq),chan.inDone,chan.handling);
    chan.handler();
  }

  // wrapper to deliver packets in series
  chan.handler = function()
  {
    if(chan.handling) return;
    var packet = chan.inq[0];
    // always force an ack when there's misses yet
    if(!packet && chan.inq.length > 0) chan.forceAck = true;
    if(!packet) return;
    chan.handling = true;
    if(!chan.safe) packet.js = packet.js._ || {}; // unescape all content json
    chan.callback(packet.js.end, packet, chan, function(ack){
      // catch whenever it was ended to start cleanup
      if(packet.js.end) chan.endIn = true;
      if(chan.endOut && chan.endIn) chan.done();
      chan.inq.shift();
      chan.inDone++;
      chan.handling = false;
      if(ack) chan.ack(); // auto-ack functionality
      chan.handler();
    });
  }

  // resend the last sent packet if it wasn't acked
  chan.resend = function()
  {
    if(chan.ended) return;
    if(!chan.outq.length) return;
    var lastpacket = chan.outq[chan.outq.length-1];
    // timeout force-end the channel
    if(Date.now() - lastpacket.sentAt > chan.timeout)
    {
      chan.fail({js:{err:"timeout"}});
      return;
    }
    debug("channel resending");
    chan.ack(lastpacket);
    setTimeout(chan.resend, defaults.chan_resend); // recurse until chan_timeout
  }

  // add/create ack/miss values and send
  chan.ack = function(packet)
  {
    if(!packet) debug("ACK CHECK",chan.id,chan.outConfirmed,chan.inDone);

    // these are just empty "ack" requests
    if(!packet)
    {
      // drop if no reason to ack so calling .ack() harmless when already ack'd
      if(!chan.forceAck && chan.outConfirmed == chan.inDone) return;
      packet = {js:{}};
    }
    chan.forceAck = false;

    // confirm only what's been processed
    if(chan.inDone >= 0) chan.outConfirmed = packet.js.ack = chan.inDone;

    // calculate misses, if any
    delete packet.js.miss; // when resending packets, make sure no old info slips through
    if(chan.inq.length > 0)
    {
      packet.js.miss = [];
      for(var i = 0; i < chan.inq.length; i++)
      {
        if(!chan.inq[i]) packet.js.miss.push(chan.inDone+i+1);
      }
    }

    // now validate and send the packet
    packet.js.c = chan.id;
    debug("SEND",chan.type,JSON.stringify(packet.js));
    hn.send(packet);

    // catch whenever it was ended to start cleanup
    if(packet.js.end) chan.endOut = true;
    if(chan.endOut && chan.endIn) chan.done();
  }

  // send content reliably
  chan.send = function(arg)
  {
    if(chan.ended) return warn("can't send to an ended channel");

    // create a new packet from the arg
    if(!arg) arg = {};
    var packet = {};
    packet.js = chan.safe ? arg.js : {_:arg.js};
    if(arg.type) packet.js.type = arg.type;
    if(arg.end) packet.js.end = arg.end;
    packet.body = arg.body;
    packet.callback = arg.callback;

    // do durable stuff
    packet.js.seq = chan.outSeq++;

    // reset/update tracking stats
    packet.sentAt = Date.now();
    chan.outq.push(packet);

    // add optional ack/miss and send
    chan.ack(packet);

    // to auto-resend if it isn't acked
    if(chan.resender) clearTimeout(chan.resender);
    chan.resender = setTimeout(chan.resend, defaults.chan_resend);
    return chan;
  }

  // send optional initial packet with type set
  if(arg.js)
  {
    arg.type = type;
    chan.send(arg);
  }

  return chan;
}

function inRelay(self, chan, packet)
{
  if(!packet.body) return warn("relay in w/ no body",packet.js,packet.from.hashname);

  // create a virtual network path that maps back to this channel
  var path = {type:"relay",relay:chan,json:{type:"relay",relay:chan.hashname}};
  if(packet.js.bridge) path = packet.sender; // sender is offering to bridge, use them!
  if(packet.js.warn) info("relay warning",packet.js.warn);
  self.receive(packet.body, path);

  // always try a path sync to upgrade the relay
  chan.relay.pathSync();
}

// someone's trying to connect to us, send an open to them
function inConnect(err, packet, chan)
{
  if(err || !packet.body) return;
  var self = packet.from.self;

  // if this channel is acting as a relay
  if(chan.relay) return inRelay(self, chan, packet);

  var to = chan.relay = self.whokey(packet.js.from,packet.body);
  if(!chan.relay) return warn("invalid connect request from",packet.from.hashname,packet.js);

  // try the suggested paths
  if(Array.isArray(packet.js.paths)) packet.js.paths.forEach(function(path){
    if(typeof path.type != "string") return debug("bad path",JSON.stringify(path));
    self.send(path,to.open(),to);
  });

  // send back an open through the connect too
  chan.send({body:to.open()});
}

function relay(self, from, to, packet)
{
  if(from.ended && !to.ended) return to.fail({js:{err:"disconnected"}});
  if(to.ended && !from.ended) return from.fail({js:{err:"disconnected"}});

  // check to see if we should set the bridge flag for line packets
  var js = {};
  if(self.isBridge(from.hashname) || self.isBridge(to.hashname))
  {
    var bp = pdecode(packet.body);
    if(bp && bp.head.length == 0 && !to.bridged)
    {
      to.bridged = true;
      self.bridgeLine[bp.body.slice(0,16).toString("hex")] = to.last;
    }
  }
  // have to seen both directions to bridge
  if(from.bridged && to.bridged) js = {"bridge":true};

  // throttle
  if(!from.relayed || Date.now() - from.relayed > 1000)
  {
    from.relayed = Date.now();
    from.relays = 0;
  }
  from.relays++;
  if(from.relays > 5)
  {
    debug("relay too fast, dropping",from.relays);
    js.warn = "dropped";
    from.send({js:js});
    return;
  }

  from.relayed = Date.now();
  to.send({js:js, body:packet.body});
}

// be the middleman to help NAT hole punch
function inPeer(err, packet, chan)
{
  if(err) return;
  var self = packet.from.self;
  if(chan.relay) return relay(self, chan, chan.relay, packet);

  if(!isHEX(packet.js.peer, 64)) return;
  var peer = self.whois(packet.js.peer);
  if(!peer || !peer.lineIn) return; // these happen often as lines come/go, ignore dead peer requests
  var js = {from:packet.from.parts};

  // sanity on incoming paths array
  if(!Array.isArray(packet.js.paths)) packet.js.paths = [];

  // insert all usable/safe sender paths
  packet.from.paths.forEach(function(path){
    if(pathShareOrder.indexOf(path.type) == -1) return;
    if(isLocalPath(path) && !peer.isLocal) return;
    packet.js.paths.push(path.json);
  });

  // load/cleanse all paths
  js.paths = [];
  packet.js.paths.forEach(function(path){
    if(typeof path.type != "string") return;
    if(pathMatch(js.paths,path)) return; // duplicate
    js.paths.push(path);
  });

  // must bundle the senders key so the recipient can open them
  chan.relay = peer.raw("connect",{js:js, body:packet.body},function(err, packet, chan2){
    if(err) return;
    relay(self, chan2, chan, packet);
  });
}

// return a see to anyone closer
function inSeek(err, packet, chan)
{
  if(err) return;
  if(!isHEX(packet.js.seek)) return warn("invalid seek of ", packet.js.seek, "from:", packet.from.hashname);
  var self = packet.from.self;
  var seek = packet.js.seek;

  var see = [];
  var seen = {};

  // see if we have any seeds to add
  var bucket = dhash(self.hashname, packet.js.seek);
  var links = self.buckets[bucket] ? self.buckets[bucket] : [];

  // first, sort by age and add the most wise one
  links.sort(function(a,b){ return a.age - b.age}).forEach(function(seed){
    if(see.length) return;
    if(!seed.seed) return;
    see.push(seed.address(packet.from));
    seen[seed.hashname] = true;
  });

  // sort by distance for more
  links.sort(function(a,b){ return dhash(seek,a.hashname) - dhash(seek,b.hashname)}).forEach(function(link){
    if(seen[link.hashname]) return;
    if(link.seed || link.hashname.substr(0,seek.length) == seek)
    {
      see.push(link.address(packet.from));
      seen[link.hashname] = true;
    }
  });

  var answer = {end:true, see:see.filter(function(x){return x}).slice(0,8)};
  chan.send({js:answer});
}

// accept a dht link
function inLink(err, packet, chan)
{
  if(err) return;
  var self = packet.from.self;
  chan.timeout(defaults.nat_timeout*2); // two NAT windows to be safe

  // add in this link
  if(!packet.from.age) packet.from.age = Date.now();
  packet.from.linked = chan;
  packet.from.seed = packet.js.seed;
  if(self.buckets[packet.from.bucket].indexOf(packet.from) == -1) self.buckets[packet.from.bucket].push(packet.from);

  // send a response if this is a new incoming
  if(!chan.sentAt) packet.from.link();

  // look for any see and check to see if we should create a link
  if(Array.isArray(packet.js.see)) packet.js.see.forEach(function(address){
    if(!address) return; // garbage
    var hn = self.whois(address);
    if(!hn || hn.linked) return;
    if(self.buckets[hn.bucket].length < defaults.link_k) hn.link();
  });

  // check for bridges
  if(Array.isArray(packet.js.bridges)) packet.js.bridges.forEach(function(type){
    if(!self.bridges[type]) self.bridges[type] = {};
    self.bridges[type][packet.from.hashname] = Date.now();
  });

  // let mainteanance handle
  chan.callback = inMaintenance;
}

function inMaintenance(err, packet, chan)
{
  // ignore if this isn't the main link
  if(!packet.from || !packet.from.linked || packet.from.linked != chan) return;
  var self = packet.from.self;
  if(err)
  {
    delete packet.from.linked;
    var index = self.buckets[packet.from.bucket].indexOf(packet.from);
    if(index > -1) self.buckets[packet.from.bucket].splice(index,1);
    return;
  }

  // update seed status
  packet.from.seed = packet.js.seed;

  // only send a response if we've not sent one in a while
  if((Date.now() - chan.sentAt) > Math.ceil(defaults.link_timer/2)) chan.send({js:{seed:self.seed}});
}

// update/respond to network state
function inPath(err, packet, chan)
{
  if(err) return;
  var self = packet.from.self;

  // add any/all suggested paths
  if(Array.isArray(packet.js.paths)) packet.js.paths.forEach(hn.pathGet);

  // send back on all paths
  packet.from.paths.forEach(function(path){
    var js = {};
    if(pathShareOrder.indexOf(path.type) >= 0) js.path = path.json;
    chan.send({js:js, to:path});
  });
}

// handle any bridge requests, if allowed
function inBridge(err, packet, chan)
{
  if(err) return;
  var self = packet.from.self;

  // ensure valid request
  if(!isHEX(packet.js.to,32) || !isHEX(packet.js.from,32) || typeof packet.js.path != "object") return warn("invalid bridge request",JSON.stringify(packet.js),packet.from.hashname);

  // must be allowed either globally or per hashname
  if(!self.isBridge(packet.from)) return chan.send({js:{err:"not allowed"}});

  // don't bridge for types we don't know
  if(!self.networks[packet.js.path.type]) return chan.send({js:{err:"bad path"}});

  // ignore fool line ids
  if(self.lines[packet.js.to] || self.lines[packet.js.from]) return chan.send({js:{err:"bad line"}});

  // set up the actual bridge paths
  debug("BRIDGEUP",JSON.stringify(packet.js));
  self.bridgeLine[packet.js.to] = packet.js.path;
  self.bridgeLine[packet.js.from] = packet.sender;

  chan.send({js:{end:true}});
}

// someone's looking for a local seed
function inPing(self, packet)
{
  if(packet.js.trace == self.tracer) return; // ignore ourselves
  if(self.locals.length > 0) return; // someone locally is announcing already
  if(self.lanSkip && self.lanSkip == packet.js.trace) return; // often immediate duplicates, skip them
  debug("PING-PONG",packet.js,packet.sender);
  self.lanSkip = packet.js.trace;
  // announce ourself as the seed back
  var csid = partsMatch(self.parts,packet.js);
  if(!csid) return;
  var js = {type:"pong",from:self.parts,trace:packet.js.trace};
  self.send(packet.sender, pencode(js, getkey(self,csid)));
}

// answers from any LAN broadcast notice we sent
function inPong(self, packet)
{
  debug("PONG",JSON.stringify(packet.js),JSON.stringify(packet.sender));
  if(packet.js.trace != self.tracer) return;
  if(self.locals.length >= 5) return warn("locals full");
  if(!packet.body || packet.body.length == 0) return;
  var to = self.whokey(packet.js.from,packet.body);
  if(!to) return warn("invalid lan request from",packet.js.from,packet.sender);
  to.local = true;
  debug("local seed open",to.hashname,JSON.stringify(packet.sender));
  self.send(packet.sender,to.open(),to);
  to.link();
}

// utility functions

// just return true/false if it's at least the format of a sha1
function isHEX(str, len)
{
  if(typeof str !== "string") return false;
  if(len && str.length !== len) return false;
  if(str.replace(/[a-f0-9]+/i, "").length !== 0) return false;
  return true;
}

// XOR distance between two hex strings, high is furthest bit, 0 is closest bit, -1 is error
function dhash(h1, h2) {
  // convert to nibbles, easier to understand
  var n1 = hex2nib(h1);
  var n2 = hex2nib(h2);
  if(!n1.length || !n2.length) return -1;
  // compare nibbles
  var sbtab = [-1,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3];
  var ret = 252;
  for (var i = 0; i < n1.length; i++) {
    if(!n2[i]) return ret;
    var diff = n1[i] ^ n2[i];
    if (diff) return ret + sbtab[diff];
    ret -= 4;
  }
  return ret;
}

// convert hex string to nibble array
function hex2nib(hex)
{
  var ret = [];
  for (var i = 0; i < hex.length / 2; i ++) {
      var bite = parseInt(hex.substr(i * 2, 2), 16);
      if (isNaN(bite)) return [];
      ret[ret.length] = bite >> 4;
      ret[ret.length] = bite & 0xf;
  }
  return ret;
}

function pathMatch(path1, paths)
{
  var match;
  if(!path1 || !Array.isArray(paths)) return match;
  paths.forEach(function(path2){
    if(!path2 || path2.type != path1.type) return;
    switch(path1.type)
    {
    case "relay":
      if(path1.relay == path2.relay) match = path2;
      break;
    case "ipv4":
    case "ipv6":
      if(path1.ip == path2.ip && path1.port == path2.port) match = path2;
      break;
    case "http":
      if(path1.http == path2.http) match = path2;
      break;
    default:
      // all other paths match based on id, local, webrtc, etc
      if(path1.id === path2.id) match = path2;
    }
    if(match) return;
  });
  return match;
}

// validate if a network path is acceptable to stop at
function pathValid(path)
{
  if(!path || path.gone) return false;
  if(path.type == "relay" && !path.relay.ended) return true; // active relays are always valid
  if(!path.lastIn) return false; // all else must receive to be valid
  if(Date.now() - path.lastIn < defaults.nat_timeout) return true; // received anything recently is good
  return false;
}

function partsMatch(parts1, parts2)
{
  if(typeof parts1 != "object" || typeof parts2 != "object") return false;
  var ids = Object.keys(parts1).sort();
  var csid;
  while(csid = ids.pop()) if(parts2[csid]) return csid;
  return false;
}

function isLocalPath(path)
{
  if(!path || !path.type) return false;
  if(path.type == "bluetooth") return true;
  if(path.type == "http" && typeof path.http == "string") return isLocalIP(require("url").parse(path.http).hostname);
  if(["ipv4","ipv6"].indexOf(path.type) >= 0) return isLocalIP(path.ip);
  // http?
  return false;
}

// return if an IP is local or public
function isLocalIP(ip)
{
  // ipv6 ones
  if(ip.indexOf(":") >= 0)
  {
    if(ip.indexOf("::") == 0) return true; // localhost
    if(ip.indexOf("fc00") == 0) return true;
    if(ip.indexOf("fe80") == 0) return true;
    return false;
  }

  var parts = ip.split(".");
  if(parts[0] == "0") return true;
  if(parts[0] == "127") return true; // localhost
  if(parts[0] == "10") return true;
  if(parts[0] == "192" && parts[1] == "168") return true;
  if(parts[0] == "172" && parts[1] >= 16 && parts[1] <= 31) return true;
  if(parts[0] == "169" && parts[1] == "254") return true; // link local
  return false;
}

// return random bytes, in hex
function randomHEX(len)
{
  return crypto.randomBytes(len).toString("hex");
}

function parts2hn(parts)
{
  var rollup = new Buffer(0);
  Object.keys(parts).sort().forEach(function(id){
    rollup = crypto.createHash("sha256").update(Buffer.concat([rollup,new Buffer(id)])).digest();
    rollup = crypto.createHash("sha256").update(Buffer.concat([rollup,new Buffer(parts[id])])).digest();
  });
  return rollup.toString("hex");
}

// encode a packet
function pencode(js, body)
{
  // be flexible, take {js:{},body:...} as first arg
  if(!body && js && js.js)
  {
    body = js.body;
    js = js.js;
  }
  var head = (typeof js == "number") ? new Buffer(String.fromCharCode(js)) : new Buffer(js?JSON.stringify(js):"", "utf8");
  if(typeof body == "string") body = new Buffer(body, "binary");
  body = body || new Buffer(0);
  var len = new Buffer(2);
  len.writeInt16BE(head.length, 0);
  return Buffer.concat([len, head, body]);
}

// packet decoding
function pdecode(packet)
{
  if(!packet) return undefined;
  var buf = (typeof packet == "string") ? new Buffer(packet, "binary") : packet;
  if(packet.length < 2) return undefined;

  // read and validate the json length
  var len = buf.readUInt16BE(0);
  if(len > (buf.length - 2)) return undefined;
  var head = buf.slice(2, len+2);
  var body = buf.slice(len + 2);

  // parse out the json
  var js = {};
  if(len > 1)
  {
    try {
      js = JSON.parse(head.toString("utf8"));
    } catch(E) {
      console.log("couldn't parse JS",buf.toString("hex"),E);
      return undefined;
    }
  }
  return {js:js, length:buf.length, head:head.toString("binary"), body:body};
}

function getkey(id, csid)
{
  return id.cs && id.cs[csid] && id.cs[csid].key;
}

function loadkeys(self)
{
  self.cs = {};
  self.keys = {};
  self.parts = {};
  var err = false;
  Object.keys(self.id).forEach(function(csid){
    if(csid.length != 2) return; // only csid keys
    self.cs[csid] = {};
    if(!self.CSets[csid]) err = csid+" not supported";
    err = err||self.CSets[csid].loadkey(self.cs[csid], self.id[csid], self.id[csid+"_secret"]);
    self.keys[csid] = self.id[csid];
    self.parts[csid] = crypto.createHash("sha256").update(self.cs[csid].key).digest("hex");
  });
  return err;
}

function loadkey(self, id, csid, key)
{
  id.csid = csid;
  return self.CSets[csid].loadkey(id, key);
}

function keysgen(cbDone,cbStep)
{
  var self = this;
  var ret = {};
  var todo = Object.keys(self.CSets);
  if(todo.length == 0) return cbDone("no sets supported");
  function pop(err)
  {
    if(err) return cbDone(err);
    var csid = todo.pop();
    if(!csid){
      self.load(ret);
      return cbDone(null, ret);
    }
    self.CSets[csid].genkey(ret,pop,cbStep);
  }
  pop();
}

function ticketize(self, to, inner)
{
  if(!to.csid)
  {
    console.log("can't ticket w/ no key");
    return false;
  }
  // clone the recipient CS stuff to gen new ephemeral line state
  var tcs = {};
  self.CSets[to.csid].loadkey(tcs,to.key);
  return self.CSets[to.csid].openize(self, tcs, pencode(inner));
}

function deticketize(self, from, open)
{
  var ret;
  var csid = open.head.charCodeAt().toString(16);
  if(!self.CSets[csid] || csid != from.csid) ret = {err:"invalid CSID of "+csid};
  else{
    open.from = from;
    try{ret = self.CSets[csid].deopenize(self, open);}catch(E){ret = {err:E};}
  }
  if(ret.err || !ret.inner)
  {
    debug("deticketize failed",ret.err);
    return false;
  }
  return ret.inner;
}

function openize(self, to)
{
  if(!to.csid)
  {
    console.log("can't open w/ no key");
    return undefined;
  }
  if(!to.lineOut) to.lineOut = randomHEX(16);
  if(!to.lineAt) to.lineAt = Date.now();
  var inner = {}
  inner.at = to.lineAt; // always the same for the generated line id/key
  inner.to = to.hashname;
  inner.from = self.parts;
  inner.line = to.lineOut;
  return self.CSets[to.csid].openize(self, to, inner);
}

function deopenize(self, open)
{
//  console.log("DEOPEN",open.body.length);
  var ret;
  var csid = open.head.charCodeAt().toString(16);
  if(!self.CSets[csid]) return {err:"unknown CSID of "+csid};
  try{ret = self.CSets[csid].deopenize(self, open);}catch(E){return {err:E};}
  ret.csid = csid;
  return ret;
}

var urllib = require("url");
function uriparse(uri)
{
  // node's uri parser enforces dns max 63 chars per label, grr!
  if(typeof uri !== "string") uri = "";
  var hashname = uri.match(/[0-9A-Fa-f]{64}/);
  if(!hashname) return urllib.parse(uri);
  var full = hashname[0];
  var part = full.substr(0,32);
  var u = urllib.parse(uri.replace(full,part));
  if(u.hostname != part) return urllib.parse(uri); // hashname was not the hostname
  Object.keys(u).forEach(function(k){
    if(typeof u[k] != "string") return;
    u[k] = u[k].replace(part,full);
  });
  return u;
}

}).call(this,require("buffer").Buffer)
},{"buffer":1,"crypto":5,"url":29}],214:[function(require,module,exports){
(function (Buffer){
exports.install = function(self)
{
  self.wraps["stream"] = function(chan)
  {
    chan.duplex = new require("stream").Duplex();

    // allow for manually injected json
    duplex.bufJS = {};
    duplex.js = function(js){
      Object.keys(js).forEach(function(key){ duplex.bufJS[key] = js[key]; });
      setTimeout(doChunk, 10);
    };
  
    // buffer writes and chunk them out
    duplex.bufBody = new Buffer(0);
    duplex.cbWrite;

    function doChunk(){
      debug("CHUNKING", duplex.bufJS, duplex.bufBody.length)
      if(duplex.bufBody.length === 0 && Object.keys(duplex.bufJS).length === 0) return;      
      var bodyout;
      var jsout = duplex.bufJS;
      duplex.bufJS = {};
      if(duplex.bufBody.length > 0)
      {
        var len = 1024 - JSON.stringify(jsout).length; // max body size for a packet
        if(duplex.bufBody.length < len) len = duplex.bufBody.length;
        bodyout = duplex.bufBody.slice(0, len);
        duplex.bufBody = duplex.bufBody.slice(len);
      }
      // send it!
      chan.send({js:jsout, body:bodyout, done:function(){
        // we might be backed up, let more in
        if(duplex.cbWrite)
        {
          // am I being paranoid that a cbWrite() could have set another duplex.cbWrite?
          var cb = duplex.cbWrite;
          delete duplex.cbWrite;
          cb();
        }
      }});
      // recurse nicely
      setTimeout(doChunk, 10);
    
    };

    duplex.end = function(){
      duplex.bufJS.end = true;
      if(stream.errMsg) duplex.bufJS.err = stream.errMsg;
      doChunk();
    }

    duplex._write = function(buf, enc, cbWrite){
      duplex.bufBody = Buffer.concat([duplex.bufBody, buf]);

      // if there's 50 packets waiting to be confirmed, hold up here, otherwise buffer up
      var cbPacket = doChunk;
      if(stream.outq.length > 50)
      {
        duplex.cbWrite = cbWrite;
      }else{
        cbWrite();
      }
    
      // try sending a chunk;
      doChunk();
    }  
  
    duplex._read = function(size){
      // TODO handle backpressure
      // perform duplex.push(body)'s if any waiting, if not .push('')
      // handle return value logic properly
    };

    stream.handler = function(self, packet, cbHandler) {
      // TODO migrate to _read backpressure stuff above
      debug("HANDLER", packet.js)
      if(cbExtra) cbExtra(packet);
      if(packet.body) duplex.push(packet.body);
      if(packet.js.end) duplex.push(null);
      cbHandler();
    }
    return duplex;  
  }
}
}).call(this,require("buffer").Buffer)
},{"buffer":1}],215:[function(require,module,exports){
exports.install = function(self)
{
  self.TSockets = {};
  self.socket = function(uri, callback)
  {
    if(typeof uri != "string") return warn("invalid TS uri")&&false;
    // detect connecting socket
    if(uri.indexOf("ts://") == 0)
    {
      var parts = uri.substr(5).split("/");
      var to = self.whois(parts.shift());
      if(!to) return warn("invalid TS hashname")&&false;
      var pathname = parts.join("/");
      if(!pathname) pathname = "/";
      var chan = to.start("ts",{bare:true,js:{path:pathname}});
      chan.wrap("TS");
      return chan.socket;
    }
    if(uri.indexOf("/") != 0) return warn("invalid TS listening uri")&&false;
    self.TSockets[uri] = callback;
  }
	self.rels["ts"] = function(err, packet, chan, callback)
  {
    if(err) return;
    var self = packet.from.self;
    callback();

    // ensure valid request
    if(typeof packet.js.path != "string" || !self.TSockets[packet.js.path]) return chan.err("unknown path");
  
    // create the socket and hand back to app
    chan.wrap("TS");
    self.TSockets[packet.js.path](chan.socket);
    chan.send({js:{open:true}});
  }

  
  self.wraps["TS"] = function(chan){
    chan.socket = {data:"", hashname:chan.hashname, id:chan.id};
    chan.callback = function(err, packet, chan, callback){
      chan.socket.readyState = 1;
      if(chan.socket.onopen)
      {
        chan.socket.onopen();
        delete chan.socket.onopen;
      }
      if(packet.body) chan.socket.data += packet.body;
      if(packet.js.done)
      {
        // allow ack-able onmessage handler instead
        if(chan.socket.onmessageack) chan.socket.onmessageack(chan.socket, callback);
        else{
          if(chan.socket.onmessage) chan.socket.onmessage(chan.socket);
          chan.socket.data = "";
          callback();
        }
      }else{
        callback();
      }
      if(err)
      {
        chan.socket.readyState = 2;
        if(err != true && chan.socket.onerror) chan.socket.onerror(err);
        if(chan.socket.onclose) chan.socket.onclose();
      }
    }
    // set up TS object for external use
    chan.socket.readyState = chan.lastIn ? 1 : 0; // if channel was already active, set state 1
    chan.socket.send = function(data, callback){
      if(chan.socket.readyState != 1) return console.log("sending fail to TS readyState",chan.socket.readyState)&&false;
      // chunk it
      while(data)
      {
        var chunk = data.substr(0,1000);
        data = data.substr(1000);
        var packet = {js:{},body:chunk};
        // last packet gets confirmed/flag
        if(!data)
        {
          packet.callback = callback;
          packet.js.done = true;
        }
        chan.send(packet);
      }
    }
    chan.socket.close = function(){
      chan.socket.readyState = 2;
      chan.done();
    }
    return chan.socket;
  }
}
},{}],216:[function(require,module,exports){
(function (Buffer){
var stream = require("stream");
var urllib = require("url");
var httplib = require("http");

exports.install = function(self)
{
  self.thtp = {};
  self.thtp.request = function(args, cbRequest)
  {
    if(!cbRequest) cbRequest = function(){};
    if(typeof args == "string") args = {uri:args}; // convenience
    if(typeof args != "object" || !(args.uri || args.url || args.hashname)) return errored("invalid args",cbRequest);

    if(args.hashname) args.uri = "thtp://"+args.hashname+args.path;
    var uri = self.uriparse(args.uri||args.url);

    if(uri.protocol != "thtp:") return errored("invalid protocol "+uri.protocol,cbRequest);
    if(uri.hostname == self.hashname) return errored("can't request self",cbRequest);
    var to;
    if(!(to = self.whois(uri.hostname))) return errored("invalid hashname",cbRequest);

    var js = {};
    if(typeof args.headers == "object") Object.keys(args.headers).forEach(function(header){
      js[header.toLowerCase()] = args.headers[header].toString();
    });
    if(args.body) js["content-length"] = args.body.length.toString();
    js.method = args.method || "get";
    js.path = uri.path;

    var body = self.pencode(js,args.body);
    js = {};

    // single-shot requests
    if(body.length <= 1000) js.end = true;

    var pin = new Buffer(0);
//    console.log("REQ",js,body);
    var pipe = streamer(to.start("thtp",{bare:true,js:js,body:body.slice(0,1000)},function(err,packet,chan,cbChan){
      cbChan(true);
//      console.log("PACKET",packet.js,packet.body.length)
      if(pipe.headers)
      {
        pipe.push(packet.body);
        if(err) pipe.emit("end");
        return;
      }

      if(packet.body) pin = Buffer.concat([pin,packet.body]);
      var http;
      if(!(http = self.pdecode(pin)))
      {
        // no packet (yet)
        if(err) cbRequest(500,pipe);
        return;
      }

      pipe.status = parseInt(http.js.status) || 500;
      pipe.headers = http.js;
      cbRequest(pipe.status >= 300?pipe.status.toString():false,pipe); // flag error for status too
      if(http.body) pipe.push(http.body);
      if(err) pipe.emit("end");
    }));

    // any remainder
    if(body.length > 1000) pipe.end(body.slice(1000));

    return pipe;
  }

  self.thtp.listen = function(cbListen)
  {
    self.rels["thtp"] = function(err, packet, chan, cbStart)
    {

      var pipe;
      var pin = new Buffer(0);
      chan.callback = function(err, packet, chan, cbChan)
      {
        cbChan(true);
        // just streaming the body
        if(pipe)
        {
          if(packet.body) pipe.push(packet.body);
          if(err) pipe.emit("end");
          return;          
        }
        
        // if parsing the request yet
        pin = Buffer.concat([pin,packet.body]);
        if(!(http = self.pdecode(pin)))
        {
          if(err) chan.end();
          return;
        }

//        console.log("REQ",http,http.js);
        // new thtp request
        if(typeof http.js.method != "string" || typeof http.js.path != "string") return chan.err("invalid");

        pipe = streamer(chan);
        pipe.method = http.js.method;
        pipe.path = http.js.path;
        delete http.js.method;
        delete http.js.path;
        pipe.headers = http.js;
        cbListen(pipe,function(args){
          if(!args) args = {};
          if(args.err) return errored(err,chan.err);

          var js = {}
          if(typeof args.headers == "object") Object.keys(args.headers).forEach(function(header){
            js[header.toLowerCase()] = args.headers[header].toString();
          });
          js.status = args.status || 200;
          if(args.json) args.body = JSON.stringify(args.json);
          if(args.body) js["content-length"] = args.body.length.toString();
          var phttp = self.pencode(js,args.body);

          var js = {};
          if(args.body && phttp.length <= 1000) js.end = true;
          chan.send({js:js,body:phttp.slice(0,1000)});
          if(phttp.length >1000) pipe.write(phttp.slice(1000));
          return pipe;
        });
        if(http.body) pipe.push(http.body);
        if(err) pipe.emit("end");
      }
      chan.callback(err,packet,chan,cbStart);
    }
  }
  
  var mPaths = {};
  self.thtp.match = function(uri, cbMatch)
  {
    var path = self.uriparse(uri).pathname;
    mPaths[path] = cbMatch;
    if(Object.keys(mPaths).length > 1) return;
    self.thtp.listen(function(req,cbRes){
      var match;
      Object.keys(mPaths).forEach(function(path){
        if(req.path.indexOf(path) != 0) return;
        if(match && match.length > path) return; // prefer longest match
        match = path;
      })
//      console.log("CHECKING",req.path,match);
      if(match) return mPaths[match](req,cbRes);
      cbRes({status:404,body:"not found"});
    });
  }
  
  // this is super simplistic, it'll need a lot of edge case fixes
  self.thtp.proxy = function(args)
  {
    if(args.address == "0.0.0.0") args.address = "127.0.0.1";
    self.thtp.listen(function(req,cbRes){
      var opt = {host:args.address,port:args.port,headers:req.headers,method:req.method,path:req.path};
      req.pipe(httplib.request(opt, function(res){
        res.pipe(cbRes({status:res.statusCode,headers:res.headers}));
      }));
    });
  }
}

// convenience wrapper
function errored(err, cb)
{
  cb(err);
  var pipe = stream.Readable();
  pipe._read = function(){}; // TODO
  pipe.emit("end");
  return pipe;
}

function streamer(chan)
{
  var pipe = stream.Duplex();
  pipe._read = function(){}; // TODO
  pipe.on("finish",function(){
    chan.send({js:{end:true}});
  });
  pipe._write = function(data,enc,cbWrite)
  {
    // chunk it
    while(data.length)
    {
      var chunk = data.slice(0,1000);
      data = data.slice(1000);
      var packet = {js:{},body:chunk};
      // last packet gets confirmed/flag
      if(!data.length)
      {
        packet.callback = cbWrite;
        if(pipe.ended) packet.js.end = true;
      }
      chan.send(packet);
    }
  }
  pipe.end = function(data)
  {
    pipe.ended = true;
    if(!data) data = new Buffer(0);
    pipe.write(data);
  }
  return pipe;
}
}).call(this,require("buffer").Buffer)
},{"buffer":1,"http":11,"stream":22,"url":29}],217:[function(require,module,exports){
(function (Buffer){
var crypto = require("crypto");

exports.install = function(self)
{
  var tokens = {};
  self.token = function(token, callback)
  {
    if(typeof token == "function")
    {
      callback = token;
      token = false;
    }
    if(!token)
    {
      var bytes = new Buffer(self.hashname,"hex");
      var rand = new Buffer(self.randomHEX(8),"hex");
      var hash = crypto.createHash("sha256").update(Buffer.concat([bytes,rand])).digest();
      token = Buffer.concat([bytes.slice(0,16),rand,hash.slice(0,8)]).toString("hex");
    }
    if(callback) tokens[token] = callback;
    return token;
  }

  self.raws["token"] = function(err, packet, chan)
  {
    if(err) return;
    var self = packet.from.self;

    // ensure valid request
    if(!self.isHashname(packet.js.token)) return chan.err("invalid");
  
    if(tokens[packet.js.token])
    {
      tokens[packet.js.token](packet.from);
      return chan.send({js:{end:true}});
    }
    
    if(!self.tokens) return chan.err("unknown");

    self.tokens(packet.js.token, packet.from, function(err){
      if(err) chan.err(err);
      can.send({js:{end:true}});
    });
  }

  self.dispense = function(token, callback)
  {
    self.seek(token, function(err, see){
      if(!Array.isArray(see)) return callback(err||"not found");
      var match;
      see.forEach(function(hn){
        if(hn.substr(0,32) != token.substr(0,32)) return;
        var bytes = new Buffer(hn,"hex");
        var rand = new Buffer(token.substr(32,16),"hex");
        var hash = crypto.createHash("sha256").update(Buffer.concat([bytes,rand])).digest();
        token2 = Buffer.concat([bytes.slice(0,16),rand,hash.slice(0,8)]).toString("hex");
        if(token == token2) match = hn;
      });
      if(!match || !(match = self.whois(match))) return callback("not found");
      match.raw("token",{js:{token:token},retries:3}, function(err){
        callback((err !== true)?err:false, match);
      });
    });
  }
}
}).call(this,require("buffer").Buffer)
},{"buffer":1,"crypto":5}],218:[function(require,module,exports){
(function (Buffer){
var rtc = require("webrtc-peer");

exports.install = function(self)
{
  if(!rtc.hasWebRTC) return false;
  self.pathSet({type:"webrtc"});

  var conns = {};
  var peers = {};

  function init(initiate,chan,to)
  {
    chan.wrap("TS"); // takes over channel callbacks, creates chan.socket
    peers[to] = chan;

    var pch;
    chan.socket.onopen = function()
    {
      pch = new rtc.peer({initiate:initiate, _self:"self", _peer:to});
      pch.DEBUG = true;
      pch.onsignal = function(signal) {
        console.log("RTC OUT", signal);
        chan.socket.send(JSON.stringify(signal));
      }
      pch.onconnection = function() {
        console.log("RTC CONNECTED");
        conns[to] = pch;
        if(chan.cached) pch.send(chan.cached);
      }
      pch.onmessage = function(safe) {
        self.receive(new Buffer(safe, "base64"),{type:"webrtc"});
      }
    }
    chan.socket.onmessage = function(data) {
      console.log("RTC IN", data);
      try {
        data = JSON.parse(data.data)
      } catch (E) {
        return console.log("rtc parse error", E, data.data)
      }
      pch.signal(data);
    }
  }
  
  self.deliver("webrtc", function(path, msg, to) {
    var safe = msg.toString("base64");
    // have a conn already
    if(conns[to.hashname]) return conns[to.hashname].send(safe);
    // if signalling, just cache the most recent
    if(peers[to.hashname]) return peers[to.hashname].cached = safe;
    // start a new signal path
    var chan = to.start("webrtc", {bare:true});
    // it may be possible for chan send to immediately recurse back here before peers[to] is set, hack around it
    setTimeout(function(){ chan.send({type:"webrtc",js:{open:true}}); },10);
    // initialize signalling
    init(true,chan,to.hashname);
  });

  self.rels["webrtc"] = function(err, packet, chan, cb) {
    cb();
    if(err) return;
    var from = packet.from.hashname;
    // detect simultaneous and prefer the highest
    if(peers[from] && chan.id < peers[from].id) return chan.fail("duplicate");
    chan.send({js:{open:true}});
    init(false,chan,from);
  }
}


}).call(this,require("buffer").Buffer)
},{"buffer":1,"webrtc-peer":219}],219:[function(require,module,exports){
// everything that's exported
exports.peer = PeerConnectionHandler;
exports.iceServers = [{
  "url": "stun:23.21.150.121"
}];

// PeerConnectionHandler extracted from code in https://github.com/natevw/PeerPouch
var RTCPeerConnection = window.mozRTCPeerConnection || window.RTCPeerConnection || window.webkitRTCPeerConnection,
  RTCSessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription || window.webkitRTCSessionDescription,
  RTCIceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate || window.webkitRTCIceCandidate;

exports.hasWebRTC = RTCPeerConnection ? true : false;

function PeerConnectionHandler(opts) {
  if(!opts) opts = {};
  opts.reliable = true;
  var cfg = {
    "iceServers": exports.iceServers
  },
    con = (opts.reliable) ? {} : {
      'optional': [{
        'RtpDataChannels': true
      }]
    };

  this._rtc = new RTCPeerConnection(cfg, con);

  this.LOG_SELF = opts._self;
  this.LOG_PEER = opts._peer;
  this._channel = null;

  this.onsignal = null; // caller MUST provide this
  this.onmessage = null; // caller SHOULD provide this
  this.onconnection = null; // and maybe this

  var handler = this,
    rtc = this._rtc;
  if (opts.initiate) this._setupChannel();
  else rtc.ondatachannel = this._setupChannel.bind(this);
  rtc.onnegotiationneeded = function(evt) {
    if (handler.DEBUG) console.log(handler.LOG_SELF, "saw negotiation trigger and will create an offer");
    rtc.createOffer(function(offerDesc) {
      if (handler.DEBUG) console.log(handler.LOG_SELF, "created offer, sending to", handler.LOG_PEER);
      rtc.setLocalDescription(offerDesc, function() {
        console.log("DONE")
      });
      handler._sendSignal(offerDesc);
    }, function(e) {
      console.warn(handler.LOG_SELF, "failed to create offer", e);
    });
  };
  rtc.onicecandidate = function(evt) {
    if (evt.candidate) handler._sendSignal({
      candidate: evt.candidate
    });
  };
  // debugging
  rtc.onicechange = function(evt) {
    if (handler.DEBUG) console.log(handler.LOG_SELF, "ICE change", rtc.iceGatheringState, rtc.iceConnectionState);
  };
  rtc.onstatechange = function(evt) {
    if (handler.DEBUG) console.log(handler.LOG_SELF, "State change", rtc.signalingState, rtc.readyState)
  };
}

PeerConnectionHandler.prototype._sendSignal = function(data) {
  if (!this.onsignal) throw Error("Need to send message but `onsignal` handler is not set.");
  this.onsignal(data);
};

PeerConnectionHandler.prototype.signal = function(data) {
  var handler = this,
    rtc = this._rtc;
  if (handler.DEBUG) console.log(this.LOG_SELF, "got data", data, "from", this.LOG_PEER);
  if (data.sdp) rtc.setRemoteDescription(new RTCSessionDescription(data), function() {
    var needsAnswer = (rtc.remoteDescription.type == 'offer');
    if (handler.DEBUG) console.log(handler.LOG_SELF, "set offer, now creating answer:", needsAnswer);
    if (needsAnswer) rtc.createAnswer(function(answerDesc) {
      if (handler.DEBUG) console.log(handler.LOG_SELF, "got anwer, sending back to", handler.LOG_PEER);
      rtc.setLocalDescription(answerDesc);
      handler._sendSignal(answerDesc);
    }, function(e) {
      console.warn(handler.LOG_SELF, "couldn't create answer", e);
    });
  }, function(e) {
    console.warn(handler.LOG_SELF, "couldn't set remote description", e)
  });
  else if (data.candidate) try {
    rtc.addIceCandidate(new RTCIceCandidate(data.candidate));
  } catch (e) {
    console.error("Couldn't add candidate", e);
  }
};

PeerConnectionHandler.prototype.send = function(data) {
  if (!this._channel || this._channel.readyState !== 'open') return handler.DEBUG && console.log("dropping data, no open channel");
  this._channel.send(data);
};

PeerConnectionHandler.prototype._setupChannel = function(evt) {
  var handler = this,
    rtc = this._rtc;
  if (evt)
    if (handler.DEBUG) console.log(this.LOG_SELF, "received data channel", evt.channel.readyState);
  this._channel = (evt) ? evt.channel : rtc.createDataChannel('telehash');
  // NOTE: in Chrome (M32) `this._channel.binaryType === 'arraybuffer'` instead of blob
  this._channel.onopen = function(evt) {
    if (handler.DEBUG) console.log(handler.LOG_SELF, "DATA CHANNEL IS OPEN", handler._channel);
    if (handler.onconnection) handler.onconnection(handler._channel); // BOOM!
  };
  this._channel.onmessage = function(evt) {
    if (handler.DEBUG) console.log(handler.LOG_SELF, "received message!", evt);
    if (handler.onmessage) handler.onmessage(evt.data);
  };
  if (window.mozRTCPeerConnection) setTimeout(function() {
    rtc.onnegotiationneeded(); // FF doesn't trigger this for us like Chrome does
  }, 0);
  window.dbgChannel = this._channel;
};


},{}],220:[function(require,module,exports){
module.exports=require(34)
},{"jsbn":271}],221:[function(require,module,exports){
module.exports=require(35)
},{}],222:[function(require,module,exports){
module.exports=require(36)
},{}],223:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./sha256.js":228,"jsbn":271}],224:[function(require,module,exports){
module.exports=require(38)
},{"jsbn":271}],225:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./rsa.js":224,"jsbn":271}],226:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./asn1hex-1.1.js":220,"./base64.js":221,"./rsa2.js":225}],227:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"./rsapem-1.1.js":226,"jsbn":271}],228:[function(require,module,exports){
module.exports=require(42)
},{"./core.js":222}],229:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"./js/browserify.js":231,"./js/closure.js":232,"./js/data.js":233,"./js/encoding/binary-xml-wire-format.js":237,"./js/encoding/data-utils.js":238,"./js/encoding/element-reader.js":240,"./js/encoding/encoding-utils.js":241,"./js/encoding/tlv-wire-format.js":243,"./js/encoding/tlv/tlv-decoder.js":244,"./js/encoding/tlv/tlv.js":247,"./js/encoding/wire-format.js":248,"./js/exclude.js":249,"./js/face.js":251,"./js/forwarding-flags.js":253,"./js/interest.js":254,"./js/key-locator.js":255,"./js/key.js":256,"./js/meta-info.js":258,"./js/name.js":259,"./js/publisher-public-key-digest.js":261,"./js/security/key-manager.js":262,"./js/util/blob.js":265,"./js/util/name-enumeration.js":267,"./js/util/ndn-time.js":269}],230:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"./transport/web-socket-transport.js":264}],231:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../contrib/securityLib/asn1hex-1.1.js":220,"../contrib/securityLib/base64.js":221,"../contrib/securityLib/crypto-1.0.js":223,"../contrib/securityLib/rsasign-1.2.js":227}],232:[function(require,module,exports){
module.exports=require(46)
},{}],233:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./buffer.js":231,"./crypto.js":231,"./encoding/binary-xml-encoder.js":235,"./encoding/binary-xml-wire-format.js":237,"./encoding/data-utils.js":238,"./encoding/wire-format.js":248,"./key-locator.js":255,"./meta-info.js":258,"./name.js":259,"./security/key-manager.js":262,"./signature.js":263,"./util/blob.js":265,"./util/ndn-protoco-id-tags.js":268,"./util/signed-blob.js":270,"buffer":1,"crypto":5}],234:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"../buffer.js":231,"../log.js":257,"../util/ndn-protoco-id-tags.js":268,"../util/ndn-time.js":269,"./data-utils.js":238,"./decoding-exception.js":239}],235:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"../buffer.js":231,"../log.js":257,"../util/dynamic-buffer.js":266,"../util/ndn-protoco-id-tags.js":268,"./data-utils.js":238}],236:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"../util/dynamic-buffer.js":266,"./binary-xml-decoder.js":234}],237:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"../exclude.js":249,"../key-locator.js":255,"../meta-info.js":258,"../name.js":259,"../publisher-public-key-digest.js":261,"../signature.js":263,"../util/blob.js":265,"../util/ndn-protoco-id-tags.js":268,"./binary-xml-decoder.js":234,"./binary-xml-encoder.js":235,"./data-utils.js":238,"./wire-format.js":248}],238:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"../buffer.js":231}],239:[function(require,module,exports){
module.exports=require(53)
},{}],240:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"../buffer.js":231,"../log.js":257,"./binary-xml-structure-decoder.js":236,"./data-utils.js":238,"./tlv/tlv-structure-decoder.js":246,"./tlv/tlv.js":247}],241:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"../data.js":233,"../face-instance.js":250,"../forwarding-entry.js":252,"../interest.js":254,"../key-locator.js":255,"../key.js":256,"../log.js":257,"./binary-xml-decoder.js":234,"./binary-xml-encoder.js":235,"./data-utils.js":238,"./wire-format.js":248}],242:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"../crypto.js":231,"../exclude.js":249,"../key-locator.js":255,"../meta-info.js":258,"../signature.js":263,"../util/blob.js":265,"./decoding-exception.js":239,"./tlv/tlv-decoder.js":244,"./tlv/tlv-encoder.js":245,"./tlv/tlv.js":247,"./wire-format.js":248,"crypto":5}],243:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"./tlv-0_1a2-wire-format.js":242,"./wire-format.js":248}],244:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"../../buffer.js":231,"../decoding-exception.js":239}],245:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"../../buffer.js":231,"../../util/dynamic-buffer.js":266}],246:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"../../buffer.js":231,"./tlv-decoder.js":244}],247:[function(require,module,exports){
module.exports=require(61)
},{}],248:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"../buffer.js":231,"./tlv-wire-format.js":243}],249:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./buffer.js":231,"./encoding/binary-xml-decoder.js":234,"./encoding/binary-xml-encoder.js":235,"./encoding/data-utils.js":238,"./name.js":259,"./util/ndn-protoco-id-tags.js":268}],250:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"./publisher-public-key-digest.js":261,"./util/ndn-protoco-id-tags.js":268}],251:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"./buffer.js":231,"./closure.js":232,"./crypto.js":231,"./data.js":233,"./encoding/binary-xml-decoder.js":234,"./encoding/binary-xml-encoder.js":235,"./encoding/binary-xml-wire-format.js":237,"./encoding/data-utils.js":238,"./encoding/tlv-wire-format.js":243,"./encoding/tlv/tlv-decoder.js":244,"./encoding/tlv/tlv.js":247,"./forwarding-entry.js":252,"./forwarding-flags.js":253,"./interest.js":254,"./key-locator.js":255,"./key.js":256,"./log.js":257,"./meta-info.js":258,"./name.js":259,"./transport/tcp-transport.js":230,"./util/ndn-protoco-id-tags.js":268,"crypto":5}],252:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"./name.js":259,"./publisher-public-key-digest.js":261,"./util/ndn-protoco-id-tags.js":268}],253:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"./forwarding-entry.js":252}],254:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"./buffer.js":231,"./encoding/binary-xml-wire-format.js":237,"./encoding/wire-format.js":248,"./exclude.js":249,"./key-locator.js":255,"./log.js":257,"./name.js":259,"./publisher-public-key-digest.js":261,"./util/blob.js":265}],255:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"./buffer.js":231,"./log.js":257,"./name.js":259,"./publisher-id.js":260,"./util/ndn-protoco-id-tags.js":268}],256:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"./buffer.js":231,"./crypto.js":231,"./encoding/data-utils.js":238,"./log.js":257}],257:[function(require,module,exports){
module.exports=require(71)
},{}],258:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"./buffer.js":231,"./encoding/binary-xml-decoder.js":234,"./encoding/binary-xml-encoder.js":235,"./key-locator.js":255,"./log.js":257,"./name.js":259,"./publisher-public-key-digest.js":261,"./security/key-manager.js":262,"./util/blob.js":265,"./util/ndn-protoco-id-tags.js":268,"./util/ndn-time.js":269}],259:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"./buffer.js":231,"./encoding/binary-xml-decoder.js":234,"./encoding/binary-xml-encoder.js":235,"./encoding/data-utils.js":238,"./log.js":257,"./util/blob.js":265,"./util/ndn-protoco-id-tags.js":268}],260:[function(require,module,exports){
module.exports=require(74)
},{"./encoding/decoding-exception.js":239,"./util/ndn-protoco-id-tags.js":268}],261:[function(require,module,exports){
module.exports=require(75)
},{"./log.js":257,"./util/ndn-protoco-id-tags.js":268}],262:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"../key.js":256}],263:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./buffer.js":231,"./encoding/binary-xml-decoder.js":234,"./encoding/binary-xml-encoder.js":235,"./key-locator.js":255,"./log.js":257,"./util/blob.js":265,"./util/ndn-protoco-id-tags.js":268}],264:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"../buffer.js":231,"../encoding/data-utils.js":238,"../encoding/element-reader.js":240,"../log.js":257}],265:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../buffer.js":231}],266:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../buffer.js":231}],267:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../buffer.js":231,"../encoding/binary-xml-decoder.js":234,"../encoding/data-utils.js":238,"../name.js":259,"./ndn-protoco-id-tags.js":268,"buffer":1}],268:[function(require,module,exports){
module.exports=require(82)
},{}],269:[function(require,module,exports){
module.exports=require(83)
},{"../log.js":257}],270:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"../buffer.js":231,"./blob.js":265}],271:[function(require,module,exports){
module.exports=require(85)
},{}],272:[function(require,module,exports){
var utils = {}
  , ndn = require('ndn-lib')
var Data = ndn.Data
var Name = ndn.Name
var SignedInfo = ndn.SignedInfo
var ndnbuf = ndn.customBuffer
var DataUtils = ndn.DataUtils

utils.chunkArbitraryData = function(opts) {
  var ndnArray = [];
  //console.log(name)
  if (opts.type == 'object') {
    var string = JSON.stringify(opts.thing);
  }
  var name = new ndn.Name(opts.uri)
  if (opts.version != false) {
    utils.appendVersion(name, opts.version)
  }
  var stringArray = string.match(/.{1,1300}/g);
  var segmentNames = [];
  for (i = 0; i < stringArray.length; i++) {
    segmentNames[i] = new Name(name).appendSegment(i)
    var co = new Data(segmentNames[i], new SignedInfo(), stringArray[i]);
    co.signedInfo.setFields()
    co.signedInfo.finalBlockID = utils.initSegment(stringArray.length - 1)

    if (opts.freshness != undefined) {
      co.signedInfo.setFreshnessPeriod(opts.freshness)
    }
    co.sign()
    ndnArray[i] = co.wireEncode()
  };

  return {array:ndnArray, name: name};

};

utils.initSegment = function(seg) {
    if (seg == null || seg == 0)
	  return (new ndnbuf('00', 'hex'));

    var segStr = seg.toString(16);

    if (segStr.length % 2 == 1)
	segStr = '0' + segStr;

    segStr = '00' + segStr;
    return (new ndnbuf(segStr, 'hex'));
};

utils.getAllPrefixes = function(name) {
  var uriArray = [];
  for (i = 0 ; i < name.components.length + 1 ; i++) {
    var uri = name.getPrefix(i).toUri()
    uriArray.push(uri);
  };
  return uriArray;
};

utils.isFirstSegment = function(name) {
    return name.components != null && name.components.length >= 1 &&
        name.components[name.components.length - 1].value.length == 1 &&
        name.components[name.components.length - 1].value[0] == 0;
};

utils.isLastSegment = function(name, co) {

    return DataUtils.arraysEqual(name.components[name.components.length - 1].value, co.signedInfo.finalBlockID);
}

utils.normalizeUri = function(name) {
  //console.log(name)
  if (!endsWithSegmentNumber(name)) {
    normalizedName = name;
    requestedSegment = 0
  } else if (!isFirstSegment(name)) {
    normalizedName = name.getPrefix(name.components.length - 1);
    requestedSegment = DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value);
  } else {
    normalizedName = name.getPrefix(name.components.length - 1) ;
    requestedSegment = 0;
  };
  var returns = [normalizedName, requestedSegment];
  return returns;
};

utils.getSegmentInteger = function(name) {
  if (name.components != null && name.components.length >= 1 &&
  name.components[name.components.length - 1].value.length >= 1 &&
  name.components[name.components.length - 1].value[0] == 0) {
    return DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value)
  } else {
    return 0;
  }
};

utils.normalizeNameToObjectStore = function(name) {
  var throwaway = utils.getNameWithoutCommandMarker(name);

  if (!utils.endsWithSegmentNumber(throwaway)) {
    return throwaway.appendSegment(0).toUri();
  } else if (!utils.isFirstSegment(throwaway)) {
    return throwaway.getPrefix(name.components.length - 1).appendSegment(0).toUri();
  } else {
    return throwaway.toUri();
  };
};

utils.endsWithSegmentNumber = function(name) {
    return name.components != null && name.components.length >= 1 &&
        name.components[name.components.length - 1].value.length >= 1 &&
        name.components[name.components.length - 1].value[0] == 0;
}

utils.nameHasCommandMarker = function(name) {
  for (var i = name.size() - 1; i >= 0; --i) {
    var component = name.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] == 0xC1) {
      return true
    };
  }

  return false;
};

utils.getCommandMarker = function(name) {
  //console.log(name)
  for (var i = name.size() - 1; i >= 0; --i) {
    var component = name.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] == 0xC1 && component[2] != 0x4E) {
      return name.components[i].toEscapedString()
    };
  }
};

utils.getNameWithoutCommandMarker = function(name) {
  var strippedName = new Name('');

  for (var i = 0 ; i < name.size(); i++) {
    var component = name.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] != 0xC1) {
      strippedName.append(name.components[i]);
    };
  };
  return strippedName;
};


utils.getSuffix = function(name, p) {
    return new Name(name.components.slice(p));
};

utils.appendVersion = function(name, date) {
    console.log(date)
    if (date) {
      if (date instanceof Date) {
        var d = date.getTime()

      } else if (typeof date == "number")
        var d = new Date().setTime(date)
    } else {
      var d = new Date().getTime();
    };

    var time = d.toString(16);
    if (time.length % 2 == 1) {
	    time = '0' + time;
    };
    time = 'fd' + time;
    var binTime = new ndnbuf(time, 'hex');
    //console.log(binTime)
    return name.append(binTime);
};

utils.timeToVersion = function(date) {
  if (date instanceof Date) {
    var d = date.getTime
  } else {
    var d = date;
  };
  var time = d.toString(16);
  if (time.length % 2 == 1) {
    time = '0' + time;
  };
  time = 'fd' + time;
  var binTime = new ndnbuf(time, 'hex');
  return (new Name.Component(binTime).toEscapedString())

};

utils.versionToTime = function(version) {
  time = 0
  array = DataUtils.toNumbers(DataUtils.toHex(version))
  //console.log(array)
  for (i = 1; i < array.length ; i++) {
    time = time + (array[i] * Math.pow(2, (7 - i)));
    //console.log(time)
  };
  return time
};



utils.setNonce = function(interest) {
  var bytes = [0xc1, 0x2e, 0x4e, 0x00];
  for (var n = 8; n > 0; n--) {
	  bytes.push(Math.floor(Math.random() * 256));
	  //console.log(bytes)
  }
  var buf = new ndnbuf(bytes);
  interest.nonce = buf;
}

module.exports = utils;

},{"ndn-lib":229}]},{},[33])